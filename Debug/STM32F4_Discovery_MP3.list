
STM32F4_Discovery_MP3.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .isr_vector   00000188  08000000  08000000  00010000  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .text         000174b8  08000190  08000190  00010190  2**4
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .rodata       00054640  08017648  08017648  00027648  2**3
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 .init_array   00000004  0806bc88  0806bc88  0007bc88  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  4 .fini_array   00000004  0806bc8c  0806bc8c  0007bc8c  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  5 .data         00000098  20000000  0806bc90  00080000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  6 .ccmram       00000000  10000000  10000000  00080098  2**0
                  CONTENTS
  7 .bss          00009dd8  20000098  20000098  00080098  2**2
                  ALLOC
  8 ._user_heap_stack 00000400  20009e70  20009e70  00080098  2**0
                  ALLOC
  9 .ARM.attributes 00000030  00000000  00000000  00080098  2**0
                  CONTENTS, READONLY
 10 .debug_info   0001da66  00000000  00000000  000800c8  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_abbrev 000055b0  00000000  00000000  0009db2e  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_aranges 000006a8  00000000  00000000  000a30e0  2**3
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_line   00009a66  00000000  00000000  000a3788  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_str    00007d8d  00000000  00000000  000ad1ee  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .comment      0000007c  00000000  00000000  000b4f7b  2**0
                  CONTENTS, READONLY
 16 .debug_frame  00007370  00000000  00000000  000b4ff8  2**2
                  CONTENTS, READONLY, DEBUGGING
 17 .debug_ranges 00000020  00000000  00000000  000bc368  2**3
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

08000190 <__do_global_dtors_aux>:
 8000190:	b510      	push	{r4, lr}
 8000192:	4c05      	ldr	r4, [pc, #20]	; (80001a8 <__do_global_dtors_aux+0x18>)
 8000194:	7823      	ldrb	r3, [r4, #0]
 8000196:	b933      	cbnz	r3, 80001a6 <__do_global_dtors_aux+0x16>
 8000198:	4b04      	ldr	r3, [pc, #16]	; (80001ac <__do_global_dtors_aux+0x1c>)
 800019a:	b113      	cbz	r3, 80001a2 <__do_global_dtors_aux+0x12>
 800019c:	4804      	ldr	r0, [pc, #16]	; (80001b0 <__do_global_dtors_aux+0x20>)
 800019e:	f3af 8000 	nop.w
 80001a2:	2301      	movs	r3, #1
 80001a4:	7023      	strb	r3, [r4, #0]
 80001a6:	bd10      	pop	{r4, pc}
 80001a8:	20000098 	.word	0x20000098
 80001ac:	00000000 	.word	0x00000000
 80001b0:	08017624 	.word	0x08017624

080001b4 <frame_dummy>:
 80001b4:	b508      	push	{r3, lr}
 80001b6:	4b03      	ldr	r3, [pc, #12]	; (80001c4 <frame_dummy+0x10>)
 80001b8:	b11b      	cbz	r3, 80001c2 <frame_dummy+0xe>
 80001ba:	4903      	ldr	r1, [pc, #12]	; (80001c8 <frame_dummy+0x14>)
 80001bc:	4803      	ldr	r0, [pc, #12]	; (80001cc <frame_dummy+0x18>)
 80001be:	f3af 8000 	nop.w
 80001c2:	bd08      	pop	{r3, pc}
 80001c4:	00000000 	.word	0x00000000
 80001c8:	2000009c 	.word	0x2000009c
 80001cc:	08017624 	.word	0x08017624

080001d0 <MP3InitDecoder>:
 * Outputs:     none
 *
 * Return:      handle to mp3 decoder instance, 0 if malloc fails
 **************************************************************************************/
HMP3Decoder MP3InitDecoder(void)
{
 80001d0:	b580      	push	{r7, lr}
 80001d2:	b082      	sub	sp, #8
 80001d4:	af00      	add	r7, sp, #0
	MP3DecInfo *mp3DecInfo;

	mp3DecInfo = AllocateBuffers();
 80001d6:	f000 ffa1 	bl	800111c <xmp3fixpt_AllocateBuffers>
 80001da:	6078      	str	r0, [r7, #4]

	return (HMP3Decoder)mp3DecInfo;
 80001dc:	687b      	ldr	r3, [r7, #4]
}
 80001de:	4618      	mov	r0, r3
 80001e0:	3708      	adds	r7, #8
 80001e2:	46bd      	mov	sp, r7
 80001e4:	bd80      	pop	{r7, pc}

080001e6 <MP3FreeDecoder>:
 * Outputs:     none
 *
 * Return:      none
 **************************************************************************************/
void MP3FreeDecoder(HMP3Decoder hMP3Decoder)
{
 80001e6:	b580      	push	{r7, lr}
 80001e8:	b084      	sub	sp, #16
 80001ea:	af00      	add	r7, sp, #0
 80001ec:	6078      	str	r0, [r7, #4]
	MP3DecInfo *mp3DecInfo = (MP3DecInfo *)hMP3Decoder;
 80001ee:	687b      	ldr	r3, [r7, #4]
 80001f0:	60fb      	str	r3, [r7, #12]

	if (!mp3DecInfo)
 80001f2:	68fb      	ldr	r3, [r7, #12]
 80001f4:	2b00      	cmp	r3, #0
 80001f6:	d003      	beq.n	8000200 <MP3FreeDecoder+0x1a>
		return;

	FreeBuffers(mp3DecInfo);
 80001f8:	68f8      	ldr	r0, [r7, #12]
 80001fa:	f001 f809 	bl	8001210 <xmp3fixpt_FreeBuffers>
 80001fe:	e000      	b.n	8000202 <MP3FreeDecoder+0x1c>
		return;
 8000200:	bf00      	nop
}
 8000202:	3710      	adds	r7, #16
 8000204:	46bd      	mov	sp, r7
 8000206:	bd80      	pop	{r7, pc}

08000208 <MP3FindSyncWord>:
 *
 * Return:      offset to first sync word (bytes from start of buf)
 *              -1 if sync not found after searching nBytes
 **************************************************************************************/
int MP3FindSyncWord(unsigned char *buf, int nBytes)
{
 8000208:	b480      	push	{r7}
 800020a:	b085      	sub	sp, #20
 800020c:	af00      	add	r7, sp, #0
 800020e:	6078      	str	r0, [r7, #4]
 8000210:	6039      	str	r1, [r7, #0]
	int i;

	/* find byte-aligned syncword - need 12 (MPEG 1,2) or 11 (MPEG 2.5) matching bits */
	for (i = 0; i < nBytes - 1; i++) {
 8000212:	2300      	movs	r3, #0
 8000214:	60fb      	str	r3, [r7, #12]
 8000216:	e013      	b.n	8000240 <MP3FindSyncWord+0x38>
		if ( (buf[i+0] & SYNCWORDH) == SYNCWORDH && (buf[i+1] & SYNCWORDL) == SYNCWORDL )
 8000218:	68fb      	ldr	r3, [r7, #12]
 800021a:	687a      	ldr	r2, [r7, #4]
 800021c:	4413      	add	r3, r2
 800021e:	781b      	ldrb	r3, [r3, #0]
 8000220:	2bff      	cmp	r3, #255	; 0xff
 8000222:	d10a      	bne.n	800023a <MP3FindSyncWord+0x32>
 8000224:	68fb      	ldr	r3, [r7, #12]
 8000226:	3301      	adds	r3, #1
 8000228:	687a      	ldr	r2, [r7, #4]
 800022a:	4413      	add	r3, r2
 800022c:	781b      	ldrb	r3, [r3, #0]
 800022e:	f003 03e0 	and.w	r3, r3, #224	; 0xe0
 8000232:	2be0      	cmp	r3, #224	; 0xe0
 8000234:	d101      	bne.n	800023a <MP3FindSyncWord+0x32>
			return i;
 8000236:	68fb      	ldr	r3, [r7, #12]
 8000238:	e009      	b.n	800024e <MP3FindSyncWord+0x46>
	for (i = 0; i < nBytes - 1; i++) {
 800023a:	68fb      	ldr	r3, [r7, #12]
 800023c:	3301      	adds	r3, #1
 800023e:	60fb      	str	r3, [r7, #12]
 8000240:	683b      	ldr	r3, [r7, #0]
 8000242:	1e5a      	subs	r2, r3, #1
 8000244:	68fb      	ldr	r3, [r7, #12]
 8000246:	429a      	cmp	r2, r3
 8000248:	dce6      	bgt.n	8000218 <MP3FindSyncWord+0x10>
	}
	
	return -1;
 800024a:	f04f 33ff 	mov.w	r3, #4294967295
}
 800024e:	4618      	mov	r0, r3
 8000250:	3714      	adds	r7, #20
 8000252:	46bd      	mov	sp, r7
 8000254:	f85d 7b04 	ldr.w	r7, [sp], #4
 8000258:	4770      	bx	lr

0800025a <MP3FindFreeSync>:
 *              since free mode requires CBR (see spec) we generally only call
 *                this function once (first frame) then store the result (nSlots)
 *                and just use it from then on
 **************************************************************************************/
static int MP3FindFreeSync(unsigned char *buf, unsigned char firstFH[4], int nBytes)
{
 800025a:	b580      	push	{r7, lr}
 800025c:	b086      	sub	sp, #24
 800025e:	af00      	add	r7, sp, #0
 8000260:	60f8      	str	r0, [r7, #12]
 8000262:	60b9      	str	r1, [r7, #8]
 8000264:	607a      	str	r2, [r7, #4]
	int offset = 0;
 8000266:	2300      	movs	r3, #0
 8000268:	613b      	str	r3, [r7, #16]
	unsigned char *bufPtr = buf;
 800026a:	68fb      	ldr	r3, [r7, #12]
 800026c:	617b      	str	r3, [r7, #20]
	 *  - run out of nBytes (FindMP3SyncWord() returns -1)
	 *  - find the next valid frame header (sync word, version, layer, CRC flag, bitrate, and sample rate
	 *      in next header must match current header)
	 */
	while (1) {
		offset = MP3FindSyncWord(bufPtr, nBytes);
 800026e:	6879      	ldr	r1, [r7, #4]
 8000270:	6978      	ldr	r0, [r7, #20]
 8000272:	f7ff ffc9 	bl	8000208 <MP3FindSyncWord>
 8000276:	6138      	str	r0, [r7, #16]
		bufPtr += offset;
 8000278:	693b      	ldr	r3, [r7, #16]
 800027a:	697a      	ldr	r2, [r7, #20]
 800027c:	4413      	add	r3, r2
 800027e:	617b      	str	r3, [r7, #20]
		if (offset < 0) {
 8000280:	693b      	ldr	r3, [r7, #16]
 8000282:	2b00      	cmp	r3, #0
 8000284:	da02      	bge.n	800028c <MP3FindFreeSync+0x32>
			return -1;
 8000286:	f04f 33ff 	mov.w	r3, #4294967295
 800028a:	e032      	b.n	80002f2 <MP3FindFreeSync+0x98>
		} else if ( (bufPtr[0] == firstFH[0]) && (bufPtr[1] == firstFH[1]) && ((bufPtr[2] & 0xfc) == (firstFH[2] & 0xfc)) ) {
 800028c:	697b      	ldr	r3, [r7, #20]
 800028e:	781a      	ldrb	r2, [r3, #0]
 8000290:	68bb      	ldr	r3, [r7, #8]
 8000292:	781b      	ldrb	r3, [r3, #0]
 8000294:	429a      	cmp	r2, r3
 8000296:	d123      	bne.n	80002e0 <MP3FindFreeSync+0x86>
 8000298:	697b      	ldr	r3, [r7, #20]
 800029a:	3301      	adds	r3, #1
 800029c:	781a      	ldrb	r2, [r3, #0]
 800029e:	68bb      	ldr	r3, [r7, #8]
 80002a0:	3301      	adds	r3, #1
 80002a2:	781b      	ldrb	r3, [r3, #0]
 80002a4:	429a      	cmp	r2, r3
 80002a6:	d11b      	bne.n	80002e0 <MP3FindFreeSync+0x86>
 80002a8:	697b      	ldr	r3, [r7, #20]
 80002aa:	3302      	adds	r3, #2
 80002ac:	781a      	ldrb	r2, [r3, #0]
 80002ae:	68bb      	ldr	r3, [r7, #8]
 80002b0:	3302      	adds	r3, #2
 80002b2:	781b      	ldrb	r3, [r3, #0]
 80002b4:	4053      	eors	r3, r2
 80002b6:	b2db      	uxtb	r3, r3
 80002b8:	f003 03fc 	and.w	r3, r3, #252	; 0xfc
 80002bc:	2b00      	cmp	r3, #0
 80002be:	d10f      	bne.n	80002e0 <MP3FindFreeSync+0x86>
			/* want to return number of bytes per frame, NOT counting the padding byte, so subtract one if padFlag == 1 */
			if ((firstFH[2] >> 1) & 0x01)
 80002c0:	68bb      	ldr	r3, [r7, #8]
 80002c2:	3302      	adds	r3, #2
 80002c4:	781b      	ldrb	r3, [r3, #0]
 80002c6:	085b      	lsrs	r3, r3, #1
 80002c8:	b2db      	uxtb	r3, r3
 80002ca:	f003 0301 	and.w	r3, r3, #1
 80002ce:	2b00      	cmp	r3, #0
 80002d0:	d002      	beq.n	80002d8 <MP3FindFreeSync+0x7e>
				bufPtr--;
 80002d2:	697b      	ldr	r3, [r7, #20]
 80002d4:	3b01      	subs	r3, #1
 80002d6:	617b      	str	r3, [r7, #20]
			return bufPtr - buf;
 80002d8:	697a      	ldr	r2, [r7, #20]
 80002da:	68fb      	ldr	r3, [r7, #12]
 80002dc:	1ad3      	subs	r3, r2, r3
 80002de:	e008      	b.n	80002f2 <MP3FindFreeSync+0x98>
		}
		bufPtr += 3;
 80002e0:	697b      	ldr	r3, [r7, #20]
 80002e2:	3303      	adds	r3, #3
 80002e4:	617b      	str	r3, [r7, #20]
		nBytes -= (offset + 3);
 80002e6:	693b      	ldr	r3, [r7, #16]
 80002e8:	3303      	adds	r3, #3
 80002ea:	687a      	ldr	r2, [r7, #4]
 80002ec:	1ad3      	subs	r3, r2, r3
 80002ee:	607b      	str	r3, [r7, #4]
		offset = MP3FindSyncWord(bufPtr, nBytes);
 80002f0:	e7bd      	b.n	800026e <MP3FindFreeSync+0x14>
	};

	return -1;
}
 80002f2:	4618      	mov	r0, r3
 80002f4:	3718      	adds	r7, #24
 80002f6:	46bd      	mov	sp, r7
 80002f8:	bd80      	pop	{r7, pc}

080002fa <MP3GetLastFrameInfo>:
 * Return:      none
 *
 * Notes:       call this right after calling MP3Decode
 **************************************************************************************/
void MP3GetLastFrameInfo(HMP3Decoder hMP3Decoder, MP3FrameInfo *mp3FrameInfo)
{
 80002fa:	b490      	push	{r4, r7}
 80002fc:	b084      	sub	sp, #16
 80002fe:	af00      	add	r7, sp, #0
 8000300:	6078      	str	r0, [r7, #4]
 8000302:	6039      	str	r1, [r7, #0]
	MP3DecInfo *mp3DecInfo = (MP3DecInfo *)hMP3Decoder;
 8000304:	687b      	ldr	r3, [r7, #4]
 8000306:	60fb      	str	r3, [r7, #12]

	if (!mp3DecInfo || mp3DecInfo->layer != 3) {
 8000308:	68fb      	ldr	r3, [r7, #12]
 800030a:	2b00      	cmp	r3, #0
 800030c:	d004      	beq.n	8000318 <MP3GetLastFrameInfo+0x1e>
 800030e:	68fb      	ldr	r3, [r7, #12]
 8000310:	f8d3 37d0 	ldr.w	r3, [r3, #2000]	; 0x7d0
 8000314:	2b03      	cmp	r3, #3
 8000316:	d015      	beq.n	8000344 <MP3GetLastFrameInfo+0x4a>
		mp3FrameInfo->bitrate = 0;
 8000318:	683b      	ldr	r3, [r7, #0]
 800031a:	2200      	movs	r2, #0
 800031c:	601a      	str	r2, [r3, #0]
		mp3FrameInfo->nChans = 0;
 800031e:	683b      	ldr	r3, [r7, #0]
 8000320:	2200      	movs	r2, #0
 8000322:	605a      	str	r2, [r3, #4]
		mp3FrameInfo->samprate = 0;
 8000324:	683b      	ldr	r3, [r7, #0]
 8000326:	2200      	movs	r2, #0
 8000328:	609a      	str	r2, [r3, #8]
		mp3FrameInfo->bitsPerSample = 0;
 800032a:	683b      	ldr	r3, [r7, #0]
 800032c:	2200      	movs	r2, #0
 800032e:	60da      	str	r2, [r3, #12]
		mp3FrameInfo->outputSamps = 0;
 8000330:	683b      	ldr	r3, [r7, #0]
 8000332:	2200      	movs	r2, #0
 8000334:	611a      	str	r2, [r3, #16]
		mp3FrameInfo->layer = 0;
 8000336:	683b      	ldr	r3, [r7, #0]
 8000338:	2200      	movs	r2, #0
 800033a:	615a      	str	r2, [r3, #20]
		mp3FrameInfo->version = 0;
 800033c:	683b      	ldr	r3, [r7, #0]
 800033e:	2200      	movs	r2, #0
 8000340:	619a      	str	r2, [r3, #24]
 8000342:	e032      	b.n	80003aa <MP3GetLastFrameInfo+0xb0>
	} else {
		mp3FrameInfo->bitrate = mp3DecInfo->bitrate;
 8000344:	68fb      	ldr	r3, [r7, #12]
 8000346:	f8d3 27b8 	ldr.w	r2, [r3, #1976]	; 0x7b8
 800034a:	683b      	ldr	r3, [r7, #0]
 800034c:	601a      	str	r2, [r3, #0]
		mp3FrameInfo->nChans = mp3DecInfo->nChans;
 800034e:	68fb      	ldr	r3, [r7, #12]
 8000350:	f8d3 27bc 	ldr.w	r2, [r3, #1980]	; 0x7bc
 8000354:	683b      	ldr	r3, [r7, #0]
 8000356:	605a      	str	r2, [r3, #4]
		mp3FrameInfo->samprate = mp3DecInfo->samprate;
 8000358:	68fb      	ldr	r3, [r7, #12]
 800035a:	f8d3 27c0 	ldr.w	r2, [r3, #1984]	; 0x7c0
 800035e:	683b      	ldr	r3, [r7, #0]
 8000360:	609a      	str	r2, [r3, #8]
		mp3FrameInfo->bitsPerSample = 16;
 8000362:	683b      	ldr	r3, [r7, #0]
 8000364:	2210      	movs	r2, #16
 8000366:	60da      	str	r2, [r3, #12]
		mp3FrameInfo->outputSamps = mp3DecInfo->nChans * (int)samplesPerFrameTab[mp3DecInfo->version][mp3DecInfo->layer - 1];
 8000368:	68fb      	ldr	r3, [r7, #12]
 800036a:	f8d3 27bc 	ldr.w	r2, [r3, #1980]	; 0x7bc
 800036e:	68fb      	ldr	r3, [r7, #12]
 8000370:	f893 37d4 	ldrb.w	r3, [r3, #2004]	; 0x7d4
 8000374:	461c      	mov	r4, r3
 8000376:	68fb      	ldr	r3, [r7, #12]
 8000378:	f8d3 37d0 	ldr.w	r3, [r3, #2000]	; 0x7d0
 800037c:	1e59      	subs	r1, r3, #1
 800037e:	480d      	ldr	r0, [pc, #52]	; (80003b4 <MP3GetLastFrameInfo+0xba>)
 8000380:	4623      	mov	r3, r4
 8000382:	005b      	lsls	r3, r3, #1
 8000384:	4423      	add	r3, r4
 8000386:	440b      	add	r3, r1
 8000388:	f930 3013 	ldrsh.w	r3, [r0, r3, lsl #1]
 800038c:	fb03 f202 	mul.w	r2, r3, r2
 8000390:	683b      	ldr	r3, [r7, #0]
 8000392:	611a      	str	r2, [r3, #16]
		mp3FrameInfo->layer = mp3DecInfo->layer;
 8000394:	68fb      	ldr	r3, [r7, #12]
 8000396:	f8d3 27d0 	ldr.w	r2, [r3, #2000]	; 0x7d0
 800039a:	683b      	ldr	r3, [r7, #0]
 800039c:	615a      	str	r2, [r3, #20]
		mp3FrameInfo->version = mp3DecInfo->version;
 800039e:	68fb      	ldr	r3, [r7, #12]
 80003a0:	f893 37d4 	ldrb.w	r3, [r3, #2004]	; 0x7d4
 80003a4:	461a      	mov	r2, r3
 80003a6:	683b      	ldr	r3, [r7, #0]
 80003a8:	619a      	str	r2, [r3, #24]
	}
}
 80003aa:	bf00      	nop
 80003ac:	3710      	adds	r7, #16
 80003ae:	46bd      	mov	sp, r7
 80003b0:	bc90      	pop	{r4, r7}
 80003b2:	4770      	bx	lr
 80003b4:	0801777c 	.word	0x0801777c

080003b8 <MP3GetNextFrameInfo>:
 * Outputs:     filled-in MP3FrameInfo struct
 *
 * Return:      error code, defined in mp3dec.h (0 means no error, < 0 means error)
 **************************************************************************************/
int MP3GetNextFrameInfo(HMP3Decoder hMP3Decoder, MP3FrameInfo *mp3FrameInfo, unsigned char *buf)
{
 80003b8:	b580      	push	{r7, lr}
 80003ba:	b086      	sub	sp, #24
 80003bc:	af00      	add	r7, sp, #0
 80003be:	60f8      	str	r0, [r7, #12]
 80003c0:	60b9      	str	r1, [r7, #8]
 80003c2:	607a      	str	r2, [r7, #4]
	MP3DecInfo *mp3DecInfo = (MP3DecInfo *)hMP3Decoder;
 80003c4:	68fb      	ldr	r3, [r7, #12]
 80003c6:	617b      	str	r3, [r7, #20]

	if (!mp3DecInfo)
 80003c8:	697b      	ldr	r3, [r7, #20]
 80003ca:	2b00      	cmp	r3, #0
 80003cc:	d102      	bne.n	80003d4 <MP3GetNextFrameInfo+0x1c>
		return ERR_MP3_NULL_POINTER;
 80003ce:	f06f 0304 	mvn.w	r3, #4
 80003d2:	e014      	b.n	80003fe <MP3GetNextFrameInfo+0x46>

	if (UnpackFrameHeader(mp3DecInfo, buf) == -1 || mp3DecInfo->layer != 3)
 80003d4:	6879      	ldr	r1, [r7, #4]
 80003d6:	6978      	ldr	r0, [r7, #20]
 80003d8:	f000 fb64 	bl	8000aa4 <xmp3fixpt_UnpackFrameHeader>
 80003dc:	4603      	mov	r3, r0
 80003de:	f1b3 3fff 	cmp.w	r3, #4294967295
 80003e2:	d004      	beq.n	80003ee <MP3GetNextFrameInfo+0x36>
 80003e4:	697b      	ldr	r3, [r7, #20]
 80003e6:	f8d3 37d0 	ldr.w	r3, [r3, #2000]	; 0x7d0
 80003ea:	2b03      	cmp	r3, #3
 80003ec:	d002      	beq.n	80003f4 <MP3GetNextFrameInfo+0x3c>
		return ERR_MP3_INVALID_FRAMEHEADER;
 80003ee:	f06f 0305 	mvn.w	r3, #5
 80003f2:	e004      	b.n	80003fe <MP3GetNextFrameInfo+0x46>

	MP3GetLastFrameInfo(mp3DecInfo, mp3FrameInfo);
 80003f4:	68b9      	ldr	r1, [r7, #8]
 80003f6:	6978      	ldr	r0, [r7, #20]
 80003f8:	f7ff ff7f 	bl	80002fa <MP3GetLastFrameInfo>

	return ERR_MP3_NONE;
 80003fc:	2300      	movs	r3, #0
}
 80003fe:	4618      	mov	r0, r3
 8000400:	3718      	adds	r7, #24
 8000402:	46bd      	mov	sp, r7
 8000404:	bd80      	pop	{r7, pc}

08000406 <MP3ClearBadFrame>:
 * Outputs:     zeroed out pcm buffer
 *
 * Return:      none
 **************************************************************************************/
static void MP3ClearBadFrame(MP3DecInfo *mp3DecInfo, short *outbuf)
{
 8000406:	b480      	push	{r7}
 8000408:	b085      	sub	sp, #20
 800040a:	af00      	add	r7, sp, #0
 800040c:	6078      	str	r0, [r7, #4]
 800040e:	6039      	str	r1, [r7, #0]
	int i;

	if (!mp3DecInfo)
 8000410:	687b      	ldr	r3, [r7, #4]
 8000412:	2b00      	cmp	r3, #0
 8000414:	d01c      	beq.n	8000450 <MP3ClearBadFrame+0x4a>
		return;

	for (i = 0; i < mp3DecInfo->nGrans * mp3DecInfo->nGranSamps * mp3DecInfo->nChans; i++)
 8000416:	2300      	movs	r3, #0
 8000418:	60fb      	str	r3, [r7, #12]
 800041a:	e008      	b.n	800042e <MP3ClearBadFrame+0x28>
		outbuf[i] = 0;
 800041c:	68fb      	ldr	r3, [r7, #12]
 800041e:	005b      	lsls	r3, r3, #1
 8000420:	683a      	ldr	r2, [r7, #0]
 8000422:	4413      	add	r3, r2
 8000424:	2200      	movs	r2, #0
 8000426:	801a      	strh	r2, [r3, #0]
	for (i = 0; i < mp3DecInfo->nGrans * mp3DecInfo->nGranSamps * mp3DecInfo->nChans; i++)
 8000428:	68fb      	ldr	r3, [r7, #12]
 800042a:	3301      	adds	r3, #1
 800042c:	60fb      	str	r3, [r7, #12]
 800042e:	687b      	ldr	r3, [r7, #4]
 8000430:	f8d3 37c4 	ldr.w	r3, [r3, #1988]	; 0x7c4
 8000434:	687a      	ldr	r2, [r7, #4]
 8000436:	f8d2 27c8 	ldr.w	r2, [r2, #1992]	; 0x7c8
 800043a:	fb02 f303 	mul.w	r3, r2, r3
 800043e:	687a      	ldr	r2, [r7, #4]
 8000440:	f8d2 27bc 	ldr.w	r2, [r2, #1980]	; 0x7bc
 8000444:	fb02 f203 	mul.w	r2, r2, r3
 8000448:	68fb      	ldr	r3, [r7, #12]
 800044a:	429a      	cmp	r2, r3
 800044c:	dce6      	bgt.n	800041c <MP3ClearBadFrame+0x16>
 800044e:	e000      	b.n	8000452 <MP3ClearBadFrame+0x4c>
		return;
 8000450:	bf00      	nop
}
 8000452:	3714      	adds	r7, #20
 8000454:	46bd      	mov	sp, r7
 8000456:	f85d 7b04 	ldr.w	r7, [sp], #4
 800045a:	4770      	bx	lr

0800045c <MP3Decode>:
 *
 * Notes:       switching useSize on and off between frames in the same stream 
 *                is not supported (bit reservoir is not maintained if useSize on)
 **************************************************************************************/
int MP3Decode(HMP3Decoder hMP3Decoder, unsigned char **inbuf, int *bytesLeft, short *outbuf, int useSize)
{
 800045c:	b590      	push	{r4, r7, lr}
 800045e:	b095      	sub	sp, #84	; 0x54
 8000460:	af02      	add	r7, sp, #8
 8000462:	60f8      	str	r0, [r7, #12]
 8000464:	60b9      	str	r1, [r7, #8]
 8000466:	607a      	str	r2, [r7, #4]
 8000468:	603b      	str	r3, [r7, #0]
	int offset, bitOffset, mainBits, gr, ch, fhBytes, siBytes, freeFrameBytes;
	int prevBitOffset, sfBlockBits, huffBlockBits;
	unsigned char *mainPtr;
	MP3DecInfo *mp3DecInfo = (MP3DecInfo *)hMP3Decoder;
 800046a:	68fb      	ldr	r3, [r7, #12]
 800046c:	637b      	str	r3, [r7, #52]	; 0x34
//	ULONG32 ulTime;
//	StartYield(&ulTime);
	if (!mp3DecInfo)
 800046e:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8000470:	2b00      	cmp	r3, #0
 8000472:	d102      	bne.n	800047a <MP3Decode+0x1e>
		return ERR_MP3_NULL_POINTER;
 8000474:	f06f 0304 	mvn.w	r3, #4
 8000478:	e204      	b.n	8000884 <MP3Decode+0x428>

	/* unpack frame header */
	fhBytes = UnpackFrameHeader(mp3DecInfo, *inbuf);
 800047a:	68bb      	ldr	r3, [r7, #8]
 800047c:	681b      	ldr	r3, [r3, #0]
 800047e:	4619      	mov	r1, r3
 8000480:	6b78      	ldr	r0, [r7, #52]	; 0x34
 8000482:	f000 fb0f 	bl	8000aa4 <xmp3fixpt_UnpackFrameHeader>
 8000486:	6338      	str	r0, [r7, #48]	; 0x30
	if (fhBytes < 0)	
 8000488:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800048a:	2b00      	cmp	r3, #0
 800048c:	da02      	bge.n	8000494 <MP3Decode+0x38>
		return ERR_MP3_INVALID_FRAMEHEADER;		/* don't clear outbuf since we don't know size (failed to parse header) */
 800048e:	f06f 0305 	mvn.w	r3, #5
 8000492:	e1f7      	b.n	8000884 <MP3Decode+0x428>
	*inbuf += fhBytes;
 8000494:	68bb      	ldr	r3, [r7, #8]
 8000496:	681a      	ldr	r2, [r3, #0]
 8000498:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800049a:	441a      	add	r2, r3
 800049c:	68bb      	ldr	r3, [r7, #8]
 800049e:	601a      	str	r2, [r3, #0]
	
	/* unpack side info */
	siBytes = UnpackSideInfo(mp3DecInfo, *inbuf);
 80004a0:	68bb      	ldr	r3, [r7, #8]
 80004a2:	681b      	ldr	r3, [r3, #0]
 80004a4:	4619      	mov	r1, r3
 80004a6:	6b78      	ldr	r0, [r7, #52]	; 0x34
 80004a8:	f000 fc7e 	bl	8000da8 <xmp3fixpt_UnpackSideInfo>
 80004ac:	62f8      	str	r0, [r7, #44]	; 0x2c
	if (siBytes < 0) {
 80004ae:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80004b0:	2b00      	cmp	r3, #0
 80004b2:	da06      	bge.n	80004c2 <MP3Decode+0x66>
		MP3ClearBadFrame(mp3DecInfo, outbuf);
 80004b4:	6839      	ldr	r1, [r7, #0]
 80004b6:	6b78      	ldr	r0, [r7, #52]	; 0x34
 80004b8:	f7ff ffa5 	bl	8000406 <MP3ClearBadFrame>
		return ERR_MP3_INVALID_SIDEINFO;
 80004bc:	f06f 0306 	mvn.w	r3, #6
 80004c0:	e1e0      	b.n	8000884 <MP3Decode+0x428>
	}
	*inbuf += siBytes;
 80004c2:	68bb      	ldr	r3, [r7, #8]
 80004c4:	681a      	ldr	r2, [r3, #0]
 80004c6:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80004c8:	441a      	add	r2, r3
 80004ca:	68bb      	ldr	r3, [r7, #8]
 80004cc:	601a      	str	r2, [r3, #0]
	*bytesLeft -= (fhBytes + siBytes);
 80004ce:	687b      	ldr	r3, [r7, #4]
 80004d0:	681a      	ldr	r2, [r3, #0]
 80004d2:	6b39      	ldr	r1, [r7, #48]	; 0x30
 80004d4:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80004d6:	440b      	add	r3, r1
 80004d8:	1ad2      	subs	r2, r2, r3
 80004da:	687b      	ldr	r3, [r7, #4]
 80004dc:	601a      	str	r2, [r3, #0]
	
	/* if free mode, need to calculate bitrate and nSlots manually, based on frame size */
	if (mp3DecInfo->bitrate == 0 || mp3DecInfo->freeBitrateFlag) {
 80004de:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 80004e0:	f8d3 37b8 	ldr.w	r3, [r3, #1976]	; 0x7b8
 80004e4:	2b00      	cmp	r3, #0
 80004e6:	d004      	beq.n	80004f2 <MP3Decode+0x96>
 80004e8:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 80004ea:	f8d3 37b0 	ldr.w	r3, [r3, #1968]	; 0x7b0
 80004ee:	2b00      	cmp	r3, #0
 80004f0:	d04d      	beq.n	800058e <MP3Decode+0x132>
		if (!mp3DecInfo->freeBitrateFlag) {
 80004f2:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 80004f4:	f8d3 37b0 	ldr.w	r3, [r3, #1968]	; 0x7b0
 80004f8:	2b00      	cmp	r3, #0
 80004fa:	d13d      	bne.n	8000578 <MP3Decode+0x11c>
			/* first time through, need to scan for next sync word and figure out frame size */
			mp3DecInfo->freeBitrateFlag = 1;
 80004fc:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 80004fe:	2201      	movs	r2, #1
 8000500:	f8c3 27b0 	str.w	r2, [r3, #1968]	; 0x7b0
			mp3DecInfo->freeBitrateSlots = MP3FindFreeSync(*inbuf, *inbuf - fhBytes - siBytes, *bytesLeft);
 8000504:	68bb      	ldr	r3, [r7, #8]
 8000506:	6818      	ldr	r0, [r3, #0]
 8000508:	68bb      	ldr	r3, [r7, #8]
 800050a:	681a      	ldr	r2, [r3, #0]
 800050c:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800050e:	4259      	negs	r1, r3
 8000510:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8000512:	1acb      	subs	r3, r1, r3
 8000514:	18d1      	adds	r1, r2, r3
 8000516:	687b      	ldr	r3, [r7, #4]
 8000518:	681b      	ldr	r3, [r3, #0]
 800051a:	461a      	mov	r2, r3
 800051c:	f7ff fe9d 	bl	800025a <MP3FindFreeSync>
 8000520:	4602      	mov	r2, r0
 8000522:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8000524:	f8c3 27b4 	str.w	r2, [r3, #1972]	; 0x7b4
			if (mp3DecInfo->freeBitrateSlots < 0) {
 8000528:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800052a:	f8d3 37b4 	ldr.w	r3, [r3, #1972]	; 0x7b4
 800052e:	2b00      	cmp	r3, #0
 8000530:	da06      	bge.n	8000540 <MP3Decode+0xe4>
				MP3ClearBadFrame(mp3DecInfo, outbuf);
 8000532:	6839      	ldr	r1, [r7, #0]
 8000534:	6b78      	ldr	r0, [r7, #52]	; 0x34
 8000536:	f7ff ff66 	bl	8000406 <MP3ClearBadFrame>
				return ERR_MP3_FREE_BITRATE_SYNC;
 800053a:	f06f 0302 	mvn.w	r3, #2
 800053e:	e1a1      	b.n	8000884 <MP3Decode+0x428>
			}
			freeFrameBytes = mp3DecInfo->freeBitrateSlots + fhBytes + siBytes;
 8000540:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8000542:	f8d3 27b4 	ldr.w	r2, [r3, #1972]	; 0x7b4
 8000546:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8000548:	441a      	add	r2, r3
 800054a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800054c:	4413      	add	r3, r2
 800054e:	62bb      	str	r3, [r7, #40]	; 0x28
			mp3DecInfo->bitrate = (freeFrameBytes * mp3DecInfo->samprate * 8) / (mp3DecInfo->nGrans * mp3DecInfo->nGranSamps);
 8000550:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8000552:	f8d3 37c0 	ldr.w	r3, [r3, #1984]	; 0x7c0
 8000556:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8000558:	fb02 f303 	mul.w	r3, r2, r3
 800055c:	00da      	lsls	r2, r3, #3
 800055e:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8000560:	f8d3 37c4 	ldr.w	r3, [r3, #1988]	; 0x7c4
 8000564:	6b79      	ldr	r1, [r7, #52]	; 0x34
 8000566:	f8d1 17c8 	ldr.w	r1, [r1, #1992]	; 0x7c8
 800056a:	fb01 f303 	mul.w	r3, r1, r3
 800056e:	fb92 f2f3 	sdiv	r2, r2, r3
 8000572:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8000574:	f8c3 27b8 	str.w	r2, [r3, #1976]	; 0x7b8
		}
		mp3DecInfo->nSlots = mp3DecInfo->freeBitrateSlots + CheckPadBit(mp3DecInfo);	/* add pad byte, if required */
 8000578:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800057a:	f8d3 47b4 	ldr.w	r4, [r3, #1972]	; 0x7b4
 800057e:	6b78      	ldr	r0, [r7, #52]	; 0x34
 8000580:	f000 fa72 	bl	8000a68 <xmp3fixpt_CheckPadBit>
 8000584:	4603      	mov	r3, r0
 8000586:	18e2      	adds	r2, r4, r3
 8000588:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800058a:	f8c3 27cc 	str.w	r2, [r3, #1996]	; 0x7cc
	 *  - calling function assembles "self-contained" MP3 frames by shifting any main_data 
	 *      from the bit reservoir (in previous frames) to AFTER the sync word and side info
	 *  - calling function should set mainDataBegin to 0, and tell us exactly how large this
	 *      frame is (in bytesLeft)
	 */
	if (useSize) {
 800058e:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8000590:	2b00      	cmp	r3, #0
 8000592:	d02f      	beq.n	80005f4 <MP3Decode+0x198>
		mp3DecInfo->nSlots = *bytesLeft;
 8000594:	687b      	ldr	r3, [r7, #4]
 8000596:	681a      	ldr	r2, [r3, #0]
 8000598:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800059a:	f8c3 27cc 	str.w	r2, [r3, #1996]	; 0x7cc
		if (mp3DecInfo->mainDataBegin != 0 || mp3DecInfo->nSlots <= 0) {
 800059e:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 80005a0:	f8d3 37d8 	ldr.w	r3, [r3, #2008]	; 0x7d8
 80005a4:	2b00      	cmp	r3, #0
 80005a6:	d104      	bne.n	80005b2 <MP3Decode+0x156>
 80005a8:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 80005aa:	f8d3 37cc 	ldr.w	r3, [r3, #1996]	; 0x7cc
 80005ae:	2b00      	cmp	r3, #0
 80005b0:	dc06      	bgt.n	80005c0 <MP3Decode+0x164>
			/* error - non self-contained frame, or missing frame (size <= 0), could do loss concealment here */
			MP3ClearBadFrame(mp3DecInfo, outbuf);
 80005b2:	6839      	ldr	r1, [r7, #0]
 80005b4:	6b78      	ldr	r0, [r7, #52]	; 0x34
 80005b6:	f7ff ff26 	bl	8000406 <MP3ClearBadFrame>
			return ERR_MP3_INVALID_FRAMEHEADER;
 80005ba:	f06f 0305 	mvn.w	r3, #5
 80005be:	e161      	b.n	8000884 <MP3Decode+0x428>
		}

		/* can operate in-place on reformatted frames */
		mp3DecInfo->mainDataBytes = mp3DecInfo->nSlots;
 80005c0:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 80005c2:	f8d3 27cc 	ldr.w	r2, [r3, #1996]	; 0x7cc
 80005c6:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 80005c8:	f8c3 27dc 	str.w	r2, [r3, #2012]	; 0x7dc
		mainPtr = *inbuf;
 80005cc:	68bb      	ldr	r3, [r7, #8]
 80005ce:	681b      	ldr	r3, [r3, #0]
 80005d0:	63bb      	str	r3, [r7, #56]	; 0x38
		*inbuf += mp3DecInfo->nSlots;
 80005d2:	68bb      	ldr	r3, [r7, #8]
 80005d4:	681b      	ldr	r3, [r3, #0]
 80005d6:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 80005d8:	f8d2 27cc 	ldr.w	r2, [r2, #1996]	; 0x7cc
 80005dc:	441a      	add	r2, r3
 80005de:	68bb      	ldr	r3, [r7, #8]
 80005e0:	601a      	str	r2, [r3, #0]
		*bytesLeft -= (mp3DecInfo->nSlots);
 80005e2:	687b      	ldr	r3, [r7, #4]
 80005e4:	681a      	ldr	r2, [r3, #0]
 80005e6:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 80005e8:	f8d3 37cc 	ldr.w	r3, [r3, #1996]	; 0x7cc
 80005ec:	1ad2      	subs	r2, r2, r3
 80005ee:	687b      	ldr	r3, [r7, #4]
 80005f0:	601a      	str	r2, [r3, #0]
 80005f2:	e085      	b.n	8000700 <MP3Decode+0x2a4>
	} else {
		/* out of data - assume last or truncated frame */
		if (mp3DecInfo->nSlots > *bytesLeft) {
 80005f4:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 80005f6:	f8d3 27cc 	ldr.w	r2, [r3, #1996]	; 0x7cc
 80005fa:	687b      	ldr	r3, [r7, #4]
 80005fc:	681b      	ldr	r3, [r3, #0]
 80005fe:	429a      	cmp	r2, r3
 8000600:	dd06      	ble.n	8000610 <MP3Decode+0x1b4>
			MP3ClearBadFrame(mp3DecInfo, outbuf);
 8000602:	6839      	ldr	r1, [r7, #0]
 8000604:	6b78      	ldr	r0, [r7, #52]	; 0x34
 8000606:	f7ff fefe 	bl	8000406 <MP3ClearBadFrame>
			return ERR_MP3_INDATA_UNDERFLOW;	
 800060a:	f04f 33ff 	mov.w	r3, #4294967295
 800060e:	e139      	b.n	8000884 <MP3Decode+0x428>
		}
		/* fill main data buffer with enough new data for this frame */
		if (mp3DecInfo->mainDataBytes >= mp3DecInfo->mainDataBegin) {
 8000610:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8000612:	f8d3 27dc 	ldr.w	r2, [r3, #2012]	; 0x7dc
 8000616:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8000618:	f8d3 37d8 	ldr.w	r3, [r3, #2008]	; 0x7d8
 800061c:	429a      	cmp	r2, r3
 800061e:	db40      	blt.n	80006a2 <MP3Decode+0x246>
			/* adequate "old" main data available (i.e. bit reservoir) */
			memmove(mp3DecInfo->mainBuf, mp3DecInfo->mainBuf + mp3DecInfo->mainDataBytes - mp3DecInfo->mainDataBegin, mp3DecInfo->mainDataBegin);
 8000620:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8000622:	f103 001c 	add.w	r0, r3, #28
 8000626:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8000628:	f103 021c 	add.w	r2, r3, #28
 800062c:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800062e:	f8d3 37dc 	ldr.w	r3, [r3, #2012]	; 0x7dc
 8000632:	4619      	mov	r1, r3
 8000634:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8000636:	f8d3 37d8 	ldr.w	r3, [r3, #2008]	; 0x7d8
 800063a:	1acb      	subs	r3, r1, r3
 800063c:	18d1      	adds	r1, r2, r3
 800063e:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8000640:	f8d3 37d8 	ldr.w	r3, [r3, #2008]	; 0x7d8
 8000644:	461a      	mov	r2, r3
 8000646:	f016 fb50 	bl	8016cea <memmove>
			memcpy(mp3DecInfo->mainBuf + mp3DecInfo->mainDataBegin, *inbuf, mp3DecInfo->nSlots);
 800064a:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800064c:	331c      	adds	r3, #28
 800064e:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 8000650:	f8d2 27d8 	ldr.w	r2, [r2, #2008]	; 0x7d8
 8000654:	1898      	adds	r0, r3, r2
 8000656:	68bb      	ldr	r3, [r7, #8]
 8000658:	6819      	ldr	r1, [r3, #0]
 800065a:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800065c:	f8d3 37cc 	ldr.w	r3, [r3, #1996]	; 0x7cc
 8000660:	461a      	mov	r2, r3
 8000662:	f016 fb37 	bl	8016cd4 <memcpy>

			mp3DecInfo->mainDataBytes = mp3DecInfo->mainDataBegin + mp3DecInfo->nSlots;
 8000666:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8000668:	f8d3 27d8 	ldr.w	r2, [r3, #2008]	; 0x7d8
 800066c:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800066e:	f8d3 37cc 	ldr.w	r3, [r3, #1996]	; 0x7cc
 8000672:	441a      	add	r2, r3
 8000674:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8000676:	f8c3 27dc 	str.w	r2, [r3, #2012]	; 0x7dc
			*inbuf += mp3DecInfo->nSlots;
 800067a:	68bb      	ldr	r3, [r7, #8]
 800067c:	681b      	ldr	r3, [r3, #0]
 800067e:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 8000680:	f8d2 27cc 	ldr.w	r2, [r2, #1996]	; 0x7cc
 8000684:	441a      	add	r2, r3
 8000686:	68bb      	ldr	r3, [r7, #8]
 8000688:	601a      	str	r2, [r3, #0]
			*bytesLeft -= (mp3DecInfo->nSlots);
 800068a:	687b      	ldr	r3, [r7, #4]
 800068c:	681a      	ldr	r2, [r3, #0]
 800068e:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8000690:	f8d3 37cc 	ldr.w	r3, [r3, #1996]	; 0x7cc
 8000694:	1ad2      	subs	r2, r2, r3
 8000696:	687b      	ldr	r3, [r7, #4]
 8000698:	601a      	str	r2, [r3, #0]
			mainPtr = mp3DecInfo->mainBuf;
 800069a:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800069c:	331c      	adds	r3, #28
 800069e:	63bb      	str	r3, [r7, #56]	; 0x38
 80006a0:	e02e      	b.n	8000700 <MP3Decode+0x2a4>
		} else {
			/* not enough data in bit reservoir from previous frames (perhaps starting in middle of file) */
			memcpy(mp3DecInfo->mainBuf + mp3DecInfo->mainDataBytes, *inbuf, mp3DecInfo->nSlots);
 80006a2:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 80006a4:	331c      	adds	r3, #28
 80006a6:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 80006a8:	f8d2 27dc 	ldr.w	r2, [r2, #2012]	; 0x7dc
 80006ac:	1898      	adds	r0, r3, r2
 80006ae:	68bb      	ldr	r3, [r7, #8]
 80006b0:	6819      	ldr	r1, [r3, #0]
 80006b2:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 80006b4:	f8d3 37cc 	ldr.w	r3, [r3, #1996]	; 0x7cc
 80006b8:	461a      	mov	r2, r3
 80006ba:	f016 fb0b 	bl	8016cd4 <memcpy>
			mp3DecInfo->mainDataBytes += mp3DecInfo->nSlots;
 80006be:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 80006c0:	f8d3 27dc 	ldr.w	r2, [r3, #2012]	; 0x7dc
 80006c4:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 80006c6:	f8d3 37cc 	ldr.w	r3, [r3, #1996]	; 0x7cc
 80006ca:	441a      	add	r2, r3
 80006cc:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 80006ce:	f8c3 27dc 	str.w	r2, [r3, #2012]	; 0x7dc
			*inbuf += mp3DecInfo->nSlots;
 80006d2:	68bb      	ldr	r3, [r7, #8]
 80006d4:	681b      	ldr	r3, [r3, #0]
 80006d6:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 80006d8:	f8d2 27cc 	ldr.w	r2, [r2, #1996]	; 0x7cc
 80006dc:	441a      	add	r2, r3
 80006de:	68bb      	ldr	r3, [r7, #8]
 80006e0:	601a      	str	r2, [r3, #0]
			*bytesLeft -= (mp3DecInfo->nSlots);
 80006e2:	687b      	ldr	r3, [r7, #4]
 80006e4:	681a      	ldr	r2, [r3, #0]
 80006e6:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 80006e8:	f8d3 37cc 	ldr.w	r3, [r3, #1996]	; 0x7cc
 80006ec:	1ad2      	subs	r2, r2, r3
 80006ee:	687b      	ldr	r3, [r7, #4]
 80006f0:	601a      	str	r2, [r3, #0]
			MP3ClearBadFrame(mp3DecInfo, outbuf);
 80006f2:	6839      	ldr	r1, [r7, #0]
 80006f4:	6b78      	ldr	r0, [r7, #52]	; 0x34
 80006f6:	f7ff fe86 	bl	8000406 <MP3ClearBadFrame>
			return ERR_MP3_MAINDATA_UNDERFLOW;
 80006fa:	f06f 0301 	mvn.w	r3, #1
 80006fe:	e0c1      	b.n	8000884 <MP3Decode+0x428>
		}
	}
	bitOffset = 0;
 8000700:	2300      	movs	r3, #0
 8000702:	617b      	str	r3, [r7, #20]
	mainBits = mp3DecInfo->mainDataBytes * 8;
 8000704:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8000706:	f8d3 37dc 	ldr.w	r3, [r3, #2012]	; 0x7dc
 800070a:	00db      	lsls	r3, r3, #3
 800070c:	647b      	str	r3, [r7, #68]	; 0x44

	/* decode one complete frame */
	for (gr = 0; gr < mp3DecInfo->nGrans; gr++) {
 800070e:	2300      	movs	r3, #0
 8000710:	643b      	str	r3, [r7, #64]	; 0x40
 8000712:	e0af      	b.n	8000874 <MP3Decode+0x418>
		for (ch = 0; ch < mp3DecInfo->nChans; ch++) {
 8000714:	2300      	movs	r3, #0
 8000716:	63fb      	str	r3, [r7, #60]	; 0x3c
 8000718:	e05e      	b.n	80007d8 <MP3Decode+0x37c>
			/* unpack scale factors and compute size of scale factor block */
			prevBitOffset = bitOffset;
 800071a:	697b      	ldr	r3, [r7, #20]
 800071c:	627b      	str	r3, [r7, #36]	; 0x24
			offset = UnpackScaleFactors(mp3DecInfo, mainPtr, &bitOffset, mainBits, gr, ch);
 800071e:	f107 0214 	add.w	r2, r7, #20
 8000722:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8000724:	9301      	str	r3, [sp, #4]
 8000726:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8000728:	9300      	str	r3, [sp, #0]
 800072a:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800072c:	6bb9      	ldr	r1, [r7, #56]	; 0x38
 800072e:	6b78      	ldr	r0, [r7, #52]	; 0x34
 8000730:	f006 fb87 	bl	8006e42 <xmp3fixpt_UnpackScaleFactors>
 8000734:	6238      	str	r0, [r7, #32]

			sfBlockBits = 8*offset - prevBitOffset + bitOffset;
 8000736:	6a3b      	ldr	r3, [r7, #32]
 8000738:	00da      	lsls	r2, r3, #3
 800073a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800073c:	1ad2      	subs	r2, r2, r3
 800073e:	697b      	ldr	r3, [r7, #20]
 8000740:	4413      	add	r3, r2
 8000742:	61fb      	str	r3, [r7, #28]
			huffBlockBits = mp3DecInfo->part23Length[gr][ch] - sfBlockBits;
 8000744:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8000746:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 8000748:	0051      	lsls	r1, r2, #1
 800074a:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 800074c:	440a      	add	r2, r1
 800074e:	f502 72fc 	add.w	r2, r2, #504	; 0x1f8
 8000752:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 8000756:	69fb      	ldr	r3, [r7, #28]
 8000758:	1ad3      	subs	r3, r2, r3
 800075a:	61bb      	str	r3, [r7, #24]
			mainPtr += offset;
 800075c:	6a3b      	ldr	r3, [r7, #32]
 800075e:	6bba      	ldr	r2, [r7, #56]	; 0x38
 8000760:	4413      	add	r3, r2
 8000762:	63bb      	str	r3, [r7, #56]	; 0x38
			mainBits -= sfBlockBits;
 8000764:	6c7a      	ldr	r2, [r7, #68]	; 0x44
 8000766:	69fb      	ldr	r3, [r7, #28]
 8000768:	1ad3      	subs	r3, r2, r3
 800076a:	647b      	str	r3, [r7, #68]	; 0x44

			if (offset < 0 || mainBits < huffBlockBits) {
 800076c:	6a3b      	ldr	r3, [r7, #32]
 800076e:	2b00      	cmp	r3, #0
 8000770:	db03      	blt.n	800077a <MP3Decode+0x31e>
 8000772:	6c7a      	ldr	r2, [r7, #68]	; 0x44
 8000774:	69bb      	ldr	r3, [r7, #24]
 8000776:	429a      	cmp	r2, r3
 8000778:	da06      	bge.n	8000788 <MP3Decode+0x32c>
				MP3ClearBadFrame(mp3DecInfo, outbuf);
 800077a:	6839      	ldr	r1, [r7, #0]
 800077c:	6b78      	ldr	r0, [r7, #52]	; 0x34
 800077e:	f7ff fe42 	bl	8000406 <MP3ClearBadFrame>
				return ERR_MP3_INVALID_SCALEFACT;
 8000782:	f06f 0307 	mvn.w	r3, #7
 8000786:	e07d      	b.n	8000884 <MP3Decode+0x428>
			}

			/* decode Huffman code words */
			prevBitOffset = bitOffset;
 8000788:	697b      	ldr	r3, [r7, #20]
 800078a:	627b      	str	r3, [r7, #36]	; 0x24
			offset = DecodeHuffman(mp3DecInfo, mainPtr, &bitOffset, huffBlockBits, gr, ch);
 800078c:	f107 0214 	add.w	r2, r7, #20
 8000790:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8000792:	9301      	str	r3, [sp, #4]
 8000794:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8000796:	9300      	str	r3, [sp, #0]
 8000798:	69bb      	ldr	r3, [r7, #24]
 800079a:	6bb9      	ldr	r1, [r7, #56]	; 0x38
 800079c:	6b78      	ldr	r0, [r7, #52]	; 0x34
 800079e:	f002 fd81 	bl	80032a4 <xmp3fixpt_DecodeHuffman>
 80007a2:	6238      	str	r0, [r7, #32]
			if (offset < 0) {
 80007a4:	6a3b      	ldr	r3, [r7, #32]
 80007a6:	2b00      	cmp	r3, #0
 80007a8:	da06      	bge.n	80007b8 <MP3Decode+0x35c>
				MP3ClearBadFrame(mp3DecInfo, outbuf);
 80007aa:	6839      	ldr	r1, [r7, #0]
 80007ac:	6b78      	ldr	r0, [r7, #52]	; 0x34
 80007ae:	f7ff fe2a 	bl	8000406 <MP3ClearBadFrame>
				return ERR_MP3_INVALID_HUFFCODES;
 80007b2:	f06f 0308 	mvn.w	r3, #8
 80007b6:	e065      	b.n	8000884 <MP3Decode+0x428>
			}

			mainPtr += offset;
 80007b8:	6a3b      	ldr	r3, [r7, #32]
 80007ba:	6bba      	ldr	r2, [r7, #56]	; 0x38
 80007bc:	4413      	add	r3, r2
 80007be:	63bb      	str	r3, [r7, #56]	; 0x38
			mainBits -= (8*offset - prevBitOffset + bitOffset);
 80007c0:	6a3b      	ldr	r3, [r7, #32]
 80007c2:	00da      	lsls	r2, r3, #3
 80007c4:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80007c6:	1ad2      	subs	r2, r2, r3
 80007c8:	697b      	ldr	r3, [r7, #20]
 80007ca:	4413      	add	r3, r2
 80007cc:	6c7a      	ldr	r2, [r7, #68]	; 0x44
 80007ce:	1ad3      	subs	r3, r2, r3
 80007d0:	647b      	str	r3, [r7, #68]	; 0x44
		for (ch = 0; ch < mp3DecInfo->nChans; ch++) {
 80007d2:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 80007d4:	3301      	adds	r3, #1
 80007d6:	63fb      	str	r3, [r7, #60]	; 0x3c
 80007d8:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 80007da:	f8d3 27bc 	ldr.w	r2, [r3, #1980]	; 0x7bc
 80007de:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 80007e0:	429a      	cmp	r2, r3
 80007e2:	dc9a      	bgt.n	800071a <MP3Decode+0x2be>
		}
//		YieldIfRequired(&ulTime);
		/* dequantize coefficients, decode stereo, reorder short blocks */
		if (Dequantize(mp3DecInfo, gr) < 0) {
 80007e4:	6c39      	ldr	r1, [r7, #64]	; 0x40
 80007e6:	6b78      	ldr	r0, [r7, #52]	; 0x34
 80007e8:	f001 fc75 	bl	80020d6 <xmp3fixpt_Dequantize>
 80007ec:	4603      	mov	r3, r0
 80007ee:	2b00      	cmp	r3, #0
 80007f0:	da06      	bge.n	8000800 <MP3Decode+0x3a4>
			MP3ClearBadFrame(mp3DecInfo, outbuf);
 80007f2:	6839      	ldr	r1, [r7, #0]
 80007f4:	6b78      	ldr	r0, [r7, #52]	; 0x34
 80007f6:	f7ff fe06 	bl	8000406 <MP3ClearBadFrame>
			return ERR_MP3_INVALID_DEQUANTIZE;			
 80007fa:	f06f 0309 	mvn.w	r3, #9
 80007fe:	e041      	b.n	8000884 <MP3Decode+0x428>
		}

		/* alias reduction, inverse MDCT, overlap-add, frequency inversion */
		for (ch = 0; ch < mp3DecInfo->nChans; ch++)
 8000800:	2300      	movs	r3, #0
 8000802:	63fb      	str	r3, [r7, #60]	; 0x3c
 8000804:	e011      	b.n	800082a <MP3Decode+0x3ce>
			if (IMDCT(mp3DecInfo, gr, ch) < 0) {
 8000806:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 8000808:	6c39      	ldr	r1, [r7, #64]	; 0x40
 800080a:	6b78      	ldr	r0, [r7, #52]	; 0x34
 800080c:	f004 fb50 	bl	8004eb0 <xmp3fixpt_IMDCT>
 8000810:	4603      	mov	r3, r0
 8000812:	2b00      	cmp	r3, #0
 8000814:	da06      	bge.n	8000824 <MP3Decode+0x3c8>
				MP3ClearBadFrame(mp3DecInfo, outbuf);
 8000816:	6839      	ldr	r1, [r7, #0]
 8000818:	6b78      	ldr	r0, [r7, #52]	; 0x34
 800081a:	f7ff fdf4 	bl	8000406 <MP3ClearBadFrame>
				return ERR_MP3_INVALID_IMDCT;			
 800081e:	f06f 030a 	mvn.w	r3, #10
 8000822:	e02f      	b.n	8000884 <MP3Decode+0x428>
		for (ch = 0; ch < mp3DecInfo->nChans; ch++)
 8000824:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8000826:	3301      	adds	r3, #1
 8000828:	63fb      	str	r3, [r7, #60]	; 0x3c
 800082a:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800082c:	f8d3 27bc 	ldr.w	r2, [r3, #1980]	; 0x7bc
 8000830:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8000832:	429a      	cmp	r2, r3
 8000834:	dce7      	bgt.n	8000806 <MP3Decode+0x3aa>
			}

		/* subband transform - if stereo, interleaves pcm LRLRLR */
		if (Subband(mp3DecInfo, outbuf + gr*mp3DecInfo->nGranSamps*mp3DecInfo->nChans) < 0) {
 8000836:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8000838:	f8d3 37c8 	ldr.w	r3, [r3, #1992]	; 0x7c8
 800083c:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 800083e:	fb02 f303 	mul.w	r3, r2, r3
 8000842:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 8000844:	f8d2 27bc 	ldr.w	r2, [r2, #1980]	; 0x7bc
 8000848:	fb02 f303 	mul.w	r3, r2, r3
 800084c:	005b      	lsls	r3, r3, #1
 800084e:	683a      	ldr	r2, [r7, #0]
 8000850:	4413      	add	r3, r2
 8000852:	4619      	mov	r1, r3
 8000854:	6b78      	ldr	r0, [r7, #52]	; 0x34
 8000856:	f007 f8d1 	bl	80079fc <xmp3fixpt_Subband>
 800085a:	4603      	mov	r3, r0
 800085c:	2b00      	cmp	r3, #0
 800085e:	da06      	bge.n	800086e <MP3Decode+0x412>
			MP3ClearBadFrame(mp3DecInfo, outbuf);
 8000860:	6839      	ldr	r1, [r7, #0]
 8000862:	6b78      	ldr	r0, [r7, #52]	; 0x34
 8000864:	f7ff fdcf 	bl	8000406 <MP3ClearBadFrame>
			return ERR_MP3_INVALID_SUBBAND;			
 8000868:	f06f 030b 	mvn.w	r3, #11
 800086c:	e00a      	b.n	8000884 <MP3Decode+0x428>
	for (gr = 0; gr < mp3DecInfo->nGrans; gr++) {
 800086e:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8000870:	3301      	adds	r3, #1
 8000872:	643b      	str	r3, [r7, #64]	; 0x40
 8000874:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8000876:	f8d3 27c4 	ldr.w	r2, [r3, #1988]	; 0x7c4
 800087a:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800087c:	429a      	cmp	r2, r3
 800087e:	f73f af49 	bgt.w	8000714 <MP3Decode+0x2b8>
		}
	}
	return ERR_MP3_NONE;
 8000882:	2300      	movs	r3, #0
}
 8000884:	4618      	mov	r0, r3
 8000886:	374c      	adds	r7, #76	; 0x4c
 8000888:	46bd      	mov	sp, r7
 800088a:	bd90      	pop	{r4, r7, pc}

0800088c <xmp3fixpt_SetBitstreamPointer>:
 * Outputs:     filled bitstream info struct
 *
 * Return:      none
 **************************************************************************************/
void SetBitstreamPointer(BitStreamInfo *bsi, int nBytes, unsigned char *buf)
{
 800088c:	b480      	push	{r7}
 800088e:	b085      	sub	sp, #20
 8000890:	af00      	add	r7, sp, #0
 8000892:	60f8      	str	r0, [r7, #12]
 8000894:	60b9      	str	r1, [r7, #8]
 8000896:	607a      	str	r2, [r7, #4]
	/* init bitstream */
	bsi->bytePtr = buf;
 8000898:	68fb      	ldr	r3, [r7, #12]
 800089a:	687a      	ldr	r2, [r7, #4]
 800089c:	601a      	str	r2, [r3, #0]
	bsi->iCache = 0;		/* 4-byte unsigned int */
 800089e:	68fb      	ldr	r3, [r7, #12]
 80008a0:	2200      	movs	r2, #0
 80008a2:	605a      	str	r2, [r3, #4]
	bsi->cachedBits = 0;	/* i.e. zero bits in cache */
 80008a4:	68fb      	ldr	r3, [r7, #12]
 80008a6:	2200      	movs	r2, #0
 80008a8:	609a      	str	r2, [r3, #8]
	bsi->nBytes = nBytes;
 80008aa:	68fb      	ldr	r3, [r7, #12]
 80008ac:	68ba      	ldr	r2, [r7, #8]
 80008ae:	60da      	str	r2, [r3, #12]
}
 80008b0:	bf00      	nop
 80008b2:	3714      	adds	r7, #20
 80008b4:	46bd      	mov	sp, r7
 80008b6:	f85d 7b04 	ldr.w	r7, [sp], #4
 80008ba:	4770      	bx	lr

080008bc <RefillBitstreamCache>:
 *
 * TODO:        optimize for ARM
 *              possibly add little/big-endian modes for doing 32-bit loads
 **************************************************************************************/
static __inline void RefillBitstreamCache(BitStreamInfo *bsi)
{
 80008bc:	b480      	push	{r7}
 80008be:	b085      	sub	sp, #20
 80008c0:	af00      	add	r7, sp, #0
 80008c2:	6078      	str	r0, [r7, #4]
	int nBytes = bsi->nBytes;
 80008c4:	687b      	ldr	r3, [r7, #4]
 80008c6:	68db      	ldr	r3, [r3, #12]
 80008c8:	60fb      	str	r3, [r7, #12]

	/* optimize for common case, independent of machine endian-ness */
	if (nBytes >= 4) {
 80008ca:	68fb      	ldr	r3, [r7, #12]
 80008cc:	2b03      	cmp	r3, #3
 80008ce:	dd35      	ble.n	800093c <RefillBitstreamCache+0x80>
		bsi->iCache  = (*bsi->bytePtr++) << 24;
 80008d0:	687b      	ldr	r3, [r7, #4]
 80008d2:	681b      	ldr	r3, [r3, #0]
 80008d4:	1c59      	adds	r1, r3, #1
 80008d6:	687a      	ldr	r2, [r7, #4]
 80008d8:	6011      	str	r1, [r2, #0]
 80008da:	781b      	ldrb	r3, [r3, #0]
 80008dc:	061b      	lsls	r3, r3, #24
 80008de:	461a      	mov	r2, r3
 80008e0:	687b      	ldr	r3, [r7, #4]
 80008e2:	605a      	str	r2, [r3, #4]
		bsi->iCache |= (*bsi->bytePtr++) << 16;
 80008e4:	687b      	ldr	r3, [r7, #4]
 80008e6:	681b      	ldr	r3, [r3, #0]
 80008e8:	1c59      	adds	r1, r3, #1
 80008ea:	687a      	ldr	r2, [r7, #4]
 80008ec:	6011      	str	r1, [r2, #0]
 80008ee:	781b      	ldrb	r3, [r3, #0]
 80008f0:	041a      	lsls	r2, r3, #16
 80008f2:	687b      	ldr	r3, [r7, #4]
 80008f4:	685b      	ldr	r3, [r3, #4]
 80008f6:	431a      	orrs	r2, r3
 80008f8:	687b      	ldr	r3, [r7, #4]
 80008fa:	605a      	str	r2, [r3, #4]
		bsi->iCache |= (*bsi->bytePtr++) <<  8;
 80008fc:	687b      	ldr	r3, [r7, #4]
 80008fe:	681b      	ldr	r3, [r3, #0]
 8000900:	1c59      	adds	r1, r3, #1
 8000902:	687a      	ldr	r2, [r7, #4]
 8000904:	6011      	str	r1, [r2, #0]
 8000906:	781b      	ldrb	r3, [r3, #0]
 8000908:	021a      	lsls	r2, r3, #8
 800090a:	687b      	ldr	r3, [r7, #4]
 800090c:	685b      	ldr	r3, [r3, #4]
 800090e:	431a      	orrs	r2, r3
 8000910:	687b      	ldr	r3, [r7, #4]
 8000912:	605a      	str	r2, [r3, #4]
		bsi->iCache |= (*bsi->bytePtr++);
 8000914:	687b      	ldr	r3, [r7, #4]
 8000916:	681b      	ldr	r3, [r3, #0]
 8000918:	1c59      	adds	r1, r3, #1
 800091a:	687a      	ldr	r2, [r7, #4]
 800091c:	6011      	str	r1, [r2, #0]
 800091e:	781a      	ldrb	r2, [r3, #0]
 8000920:	687b      	ldr	r3, [r7, #4]
 8000922:	685b      	ldr	r3, [r3, #4]
 8000924:	431a      	orrs	r2, r3
 8000926:	687b      	ldr	r3, [r7, #4]
 8000928:	605a      	str	r2, [r3, #4]
		bsi->cachedBits = 32;
 800092a:	687b      	ldr	r3, [r7, #4]
 800092c:	2220      	movs	r2, #32
 800092e:	609a      	str	r2, [r3, #8]
		bsi->nBytes -= 4;
 8000930:	687b      	ldr	r3, [r7, #4]
 8000932:	68db      	ldr	r3, [r3, #12]
 8000934:	1f1a      	subs	r2, r3, #4
 8000936:	687b      	ldr	r3, [r7, #4]
 8000938:	60da      	str	r2, [r3, #12]
		}
		bsi->iCache <<= ((3 - bsi->nBytes)*8);
		bsi->cachedBits = 8*bsi->nBytes;
		bsi->nBytes = 0;
	}
}
 800093a:	e02a      	b.n	8000992 <RefillBitstreamCache+0xd6>
		bsi->iCache = 0;
 800093c:	687b      	ldr	r3, [r7, #4]
 800093e:	2200      	movs	r2, #0
 8000940:	605a      	str	r2, [r3, #4]
		while (nBytes--) {
 8000942:	e00f      	b.n	8000964 <RefillBitstreamCache+0xa8>
			bsi->iCache |= (*bsi->bytePtr++);
 8000944:	687b      	ldr	r3, [r7, #4]
 8000946:	681b      	ldr	r3, [r3, #0]
 8000948:	1c59      	adds	r1, r3, #1
 800094a:	687a      	ldr	r2, [r7, #4]
 800094c:	6011      	str	r1, [r2, #0]
 800094e:	781a      	ldrb	r2, [r3, #0]
 8000950:	687b      	ldr	r3, [r7, #4]
 8000952:	685b      	ldr	r3, [r3, #4]
 8000954:	431a      	orrs	r2, r3
 8000956:	687b      	ldr	r3, [r7, #4]
 8000958:	605a      	str	r2, [r3, #4]
			bsi->iCache <<= 8;
 800095a:	687b      	ldr	r3, [r7, #4]
 800095c:	685b      	ldr	r3, [r3, #4]
 800095e:	021a      	lsls	r2, r3, #8
 8000960:	687b      	ldr	r3, [r7, #4]
 8000962:	605a      	str	r2, [r3, #4]
		while (nBytes--) {
 8000964:	68fb      	ldr	r3, [r7, #12]
 8000966:	1e5a      	subs	r2, r3, #1
 8000968:	60fa      	str	r2, [r7, #12]
 800096a:	2b00      	cmp	r3, #0
 800096c:	d1ea      	bne.n	8000944 <RefillBitstreamCache+0x88>
		bsi->iCache <<= ((3 - bsi->nBytes)*8);
 800096e:	687b      	ldr	r3, [r7, #4]
 8000970:	685a      	ldr	r2, [r3, #4]
 8000972:	687b      	ldr	r3, [r7, #4]
 8000974:	68db      	ldr	r3, [r3, #12]
 8000976:	f1c3 0303 	rsb	r3, r3, #3
 800097a:	00db      	lsls	r3, r3, #3
 800097c:	409a      	lsls	r2, r3
 800097e:	687b      	ldr	r3, [r7, #4]
 8000980:	605a      	str	r2, [r3, #4]
		bsi->cachedBits = 8*bsi->nBytes;
 8000982:	687b      	ldr	r3, [r7, #4]
 8000984:	68db      	ldr	r3, [r3, #12]
 8000986:	00da      	lsls	r2, r3, #3
 8000988:	687b      	ldr	r3, [r7, #4]
 800098a:	609a      	str	r2, [r3, #8]
		bsi->nBytes = 0;
 800098c:	687b      	ldr	r3, [r7, #4]
 800098e:	2200      	movs	r2, #0
 8000990:	60da      	str	r2, [r3, #12]
}
 8000992:	bf00      	nop
 8000994:	3714      	adds	r7, #20
 8000996:	46bd      	mov	sp, r7
 8000998:	f85d 7b04 	ldr.w	r7, [sp], #4
 800099c:	4770      	bx	lr

0800099e <xmp3fixpt_GetBits>:
 *              if nBits = 0, returns 0 (useful for scalefactor unpacking)
 *
 * TODO:        optimize for ARM
 **************************************************************************************/
unsigned int GetBits(BitStreamInfo *bsi, int nBits)
{
 800099e:	b580      	push	{r7, lr}
 80009a0:	b084      	sub	sp, #16
 80009a2:	af00      	add	r7, sp, #0
 80009a4:	6078      	str	r0, [r7, #4]
 80009a6:	6039      	str	r1, [r7, #0]
	unsigned int data, lowBits;

	nBits &= 0x1f;							/* nBits mod 32 to avoid unpredictable results like >> by negative amount */
 80009a8:	683b      	ldr	r3, [r7, #0]
 80009aa:	f003 031f 	and.w	r3, r3, #31
 80009ae:	603b      	str	r3, [r7, #0]
	data = bsi->iCache >> (31 - nBits);		/* unsigned >> so zero-extend */
 80009b0:	687b      	ldr	r3, [r7, #4]
 80009b2:	685a      	ldr	r2, [r3, #4]
 80009b4:	683b      	ldr	r3, [r7, #0]
 80009b6:	f1c3 031f 	rsb	r3, r3, #31
 80009ba:	fa22 f303 	lsr.w	r3, r2, r3
 80009be:	60fb      	str	r3, [r7, #12]
	data >>= 1;								/* do as >> 31, >> 1 so that nBits = 0 works okay (returns 0) */
 80009c0:	68fb      	ldr	r3, [r7, #12]
 80009c2:	085b      	lsrs	r3, r3, #1
 80009c4:	60fb      	str	r3, [r7, #12]
	bsi->iCache <<= nBits;					/* left-justify cache */
 80009c6:	687b      	ldr	r3, [r7, #4]
 80009c8:	685a      	ldr	r2, [r3, #4]
 80009ca:	683b      	ldr	r3, [r7, #0]
 80009cc:	409a      	lsls	r2, r3
 80009ce:	687b      	ldr	r3, [r7, #4]
 80009d0:	605a      	str	r2, [r3, #4]
	bsi->cachedBits -= nBits;				/* how many bits have we drawn from the cache so far */
 80009d2:	687b      	ldr	r3, [r7, #4]
 80009d4:	689a      	ldr	r2, [r3, #8]
 80009d6:	683b      	ldr	r3, [r7, #0]
 80009d8:	1ad2      	subs	r2, r2, r3
 80009da:	687b      	ldr	r3, [r7, #4]
 80009dc:	609a      	str	r2, [r3, #8]

	/* if we cross an int boundary, refill the cache */
	if (bsi->cachedBits < 0) {
 80009de:	687b      	ldr	r3, [r7, #4]
 80009e0:	689b      	ldr	r3, [r3, #8]
 80009e2:	2b00      	cmp	r3, #0
 80009e4:	da1e      	bge.n	8000a24 <xmp3fixpt_GetBits+0x86>
		lowBits = -bsi->cachedBits;
 80009e6:	687b      	ldr	r3, [r7, #4]
 80009e8:	689b      	ldr	r3, [r3, #8]
 80009ea:	425b      	negs	r3, r3
 80009ec:	60bb      	str	r3, [r7, #8]
		RefillBitstreamCache(bsi);
 80009ee:	6878      	ldr	r0, [r7, #4]
 80009f0:	f7ff ff64 	bl	80008bc <RefillBitstreamCache>
		data |= bsi->iCache >> (32 - lowBits);		/* get the low-order bits */
 80009f4:	687b      	ldr	r3, [r7, #4]
 80009f6:	685a      	ldr	r2, [r3, #4]
 80009f8:	68bb      	ldr	r3, [r7, #8]
 80009fa:	f1c3 0320 	rsb	r3, r3, #32
 80009fe:	fa22 f303 	lsr.w	r3, r2, r3
 8000a02:	68fa      	ldr	r2, [r7, #12]
 8000a04:	4313      	orrs	r3, r2
 8000a06:	60fb      	str	r3, [r7, #12]
	
		bsi->cachedBits -= lowBits;			/* how many bits have we drawn from the cache so far */
 8000a08:	687b      	ldr	r3, [r7, #4]
 8000a0a:	689b      	ldr	r3, [r3, #8]
 8000a0c:	461a      	mov	r2, r3
 8000a0e:	68bb      	ldr	r3, [r7, #8]
 8000a10:	1ad3      	subs	r3, r2, r3
 8000a12:	461a      	mov	r2, r3
 8000a14:	687b      	ldr	r3, [r7, #4]
 8000a16:	609a      	str	r2, [r3, #8]
		bsi->iCache <<= lowBits;			/* left-justify cache */
 8000a18:	687b      	ldr	r3, [r7, #4]
 8000a1a:	685a      	ldr	r2, [r3, #4]
 8000a1c:	68bb      	ldr	r3, [r7, #8]
 8000a1e:	409a      	lsls	r2, r3
 8000a20:	687b      	ldr	r3, [r7, #4]
 8000a22:	605a      	str	r2, [r3, #4]
	}

	return data;
 8000a24:	68fb      	ldr	r3, [r7, #12]
}
 8000a26:	4618      	mov	r0, r3
 8000a28:	3710      	adds	r7, #16
 8000a2a:	46bd      	mov	sp, r7
 8000a2c:	bd80      	pop	{r7, pc}

08000a2e <xmp3fixpt_CalcBitsUsed>:
 * Outputs:     none
 *
 * Return:      number of bits read from bitstream, as offset from startBuf:startOffset
 **************************************************************************************/
int CalcBitsUsed(BitStreamInfo *bsi, unsigned char *startBuf, int startOffset)
{
 8000a2e:	b480      	push	{r7}
 8000a30:	b087      	sub	sp, #28
 8000a32:	af00      	add	r7, sp, #0
 8000a34:	60f8      	str	r0, [r7, #12]
 8000a36:	60b9      	str	r1, [r7, #8]
 8000a38:	607a      	str	r2, [r7, #4]
	int bitsUsed;

	bitsUsed  = (bsi->bytePtr - startBuf) * 8;
 8000a3a:	68fb      	ldr	r3, [r7, #12]
 8000a3c:	681b      	ldr	r3, [r3, #0]
 8000a3e:	461a      	mov	r2, r3
 8000a40:	68bb      	ldr	r3, [r7, #8]
 8000a42:	1ad3      	subs	r3, r2, r3
 8000a44:	00db      	lsls	r3, r3, #3
 8000a46:	617b      	str	r3, [r7, #20]
	bitsUsed -= bsi->cachedBits;
 8000a48:	68fb      	ldr	r3, [r7, #12]
 8000a4a:	689b      	ldr	r3, [r3, #8]
 8000a4c:	697a      	ldr	r2, [r7, #20]
 8000a4e:	1ad3      	subs	r3, r2, r3
 8000a50:	617b      	str	r3, [r7, #20]
	bitsUsed -= startOffset;
 8000a52:	697a      	ldr	r2, [r7, #20]
 8000a54:	687b      	ldr	r3, [r7, #4]
 8000a56:	1ad3      	subs	r3, r2, r3
 8000a58:	617b      	str	r3, [r7, #20]

	return bitsUsed;
 8000a5a:	697b      	ldr	r3, [r7, #20]
}
 8000a5c:	4618      	mov	r0, r3
 8000a5e:	371c      	adds	r7, #28
 8000a60:	46bd      	mov	sp, r7
 8000a62:	f85d 7b04 	ldr.w	r7, [sp], #4
 8000a66:	4770      	bx	lr

08000a68 <xmp3fixpt_CheckPadBit>:
 * Outputs:     none
 *
 * Return:      1 if pad bit is set, 0 if not, -1 if null input pointer
 **************************************************************************************/
int CheckPadBit(MP3DecInfo *mp3DecInfo)
{
 8000a68:	b480      	push	{r7}
 8000a6a:	b085      	sub	sp, #20
 8000a6c:	af00      	add	r7, sp, #0
 8000a6e:	6078      	str	r0, [r7, #4]
	FrameHeader *fh;

	/* validate pointers */
	if (!mp3DecInfo || !mp3DecInfo->FrameHeaderPS)
 8000a70:	687b      	ldr	r3, [r7, #4]
 8000a72:	2b00      	cmp	r3, #0
 8000a74:	d003      	beq.n	8000a7e <xmp3fixpt_CheckPadBit+0x16>
 8000a76:	687b      	ldr	r3, [r7, #4]
 8000a78:	681b      	ldr	r3, [r3, #0]
 8000a7a:	2b00      	cmp	r3, #0
 8000a7c:	d102      	bne.n	8000a84 <xmp3fixpt_CheckPadBit+0x1c>
		return -1;
 8000a7e:	f04f 33ff 	mov.w	r3, #4294967295
 8000a82:	e009      	b.n	8000a98 <xmp3fixpt_CheckPadBit+0x30>

	fh = ((FrameHeader *)(mp3DecInfo->FrameHeaderPS));
 8000a84:	687b      	ldr	r3, [r7, #4]
 8000a86:	681b      	ldr	r3, [r3, #0]
 8000a88:	60fb      	str	r3, [r7, #12]

	return (fh->paddingBit ? 1 : 0);
 8000a8a:	68fb      	ldr	r3, [r7, #12]
 8000a8c:	695b      	ldr	r3, [r3, #20]
 8000a8e:	2b00      	cmp	r3, #0
 8000a90:	bf14      	ite	ne
 8000a92:	2301      	movne	r3, #1
 8000a94:	2300      	moveq	r3, #0
 8000a96:	b2db      	uxtb	r3, r3
}
 8000a98:	4618      	mov	r0, r3
 8000a9a:	3714      	adds	r7, #20
 8000a9c:	46bd      	mov	sp, r7
 8000a9e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8000aa2:	4770      	bx	lr

08000aa4 <xmp3fixpt_UnpackFrameHeader>:
 *
 * TODO:        check for valid modes, depending on capabilities of decoder
 *              test CRC on actual stream (verify no endian problems)
 **************************************************************************************/
int UnpackFrameHeader(MP3DecInfo *mp3DecInfo, unsigned char *buf)
{
 8000aa4:	b490      	push	{r4, r7}
 8000aa6:	b084      	sub	sp, #16
 8000aa8:	af00      	add	r7, sp, #0
 8000aaa:	6078      	str	r0, [r7, #4]
 8000aac:	6039      	str	r1, [r7, #0]

	int verIdx;
	FrameHeader *fh;

	/* validate pointers and sync word */
	if (!mp3DecInfo || !mp3DecInfo->FrameHeaderPS || (buf[0] & SYNCWORDH) != SYNCWORDH || (buf[1] & SYNCWORDL) != SYNCWORDL)
 8000aae:	687b      	ldr	r3, [r7, #4]
 8000ab0:	2b00      	cmp	r3, #0
 8000ab2:	d00e      	beq.n	8000ad2 <xmp3fixpt_UnpackFrameHeader+0x2e>
 8000ab4:	687b      	ldr	r3, [r7, #4]
 8000ab6:	681b      	ldr	r3, [r3, #0]
 8000ab8:	2b00      	cmp	r3, #0
 8000aba:	d00a      	beq.n	8000ad2 <xmp3fixpt_UnpackFrameHeader+0x2e>
 8000abc:	683b      	ldr	r3, [r7, #0]
 8000abe:	781b      	ldrb	r3, [r3, #0]
 8000ac0:	2bff      	cmp	r3, #255	; 0xff
 8000ac2:	d106      	bne.n	8000ad2 <xmp3fixpt_UnpackFrameHeader+0x2e>
 8000ac4:	683b      	ldr	r3, [r7, #0]
 8000ac6:	3301      	adds	r3, #1
 8000ac8:	781b      	ldrb	r3, [r3, #0]
 8000aca:	f003 03e0 	and.w	r3, r3, #224	; 0xe0
 8000ace:	2be0      	cmp	r3, #224	; 0xe0
 8000ad0:	d002      	beq.n	8000ad8 <xmp3fixpt_UnpackFrameHeader+0x34>
		return -1;
 8000ad2:	f04f 33ff 	mov.w	r3, #4294967295
 8000ad6:	e155      	b.n	8000d84 <xmp3fixpt_UnpackFrameHeader+0x2e0>

	fh = ((FrameHeader *)(mp3DecInfo->FrameHeaderPS));
 8000ad8:	687b      	ldr	r3, [r7, #4]
 8000ada:	681b      	ldr	r3, [r3, #0]
 8000adc:	60fb      	str	r3, [r7, #12]

	/* read header fields - use bitmasks instead of GetBits() for speed, since format never varies */
	verIdx =         (buf[1] >> 3) & 0x03;
 8000ade:	683b      	ldr	r3, [r7, #0]
 8000ae0:	3301      	adds	r3, #1
 8000ae2:	781b      	ldrb	r3, [r3, #0]
 8000ae4:	08db      	lsrs	r3, r3, #3
 8000ae6:	b2db      	uxtb	r3, r3
 8000ae8:	f003 0303 	and.w	r3, r3, #3
 8000aec:	60bb      	str	r3, [r7, #8]
	fh->ver =        (MPEGVersion)( verIdx == 0 ? MPEG25 : ((verIdx & 0x01) ? MPEG1 : MPEG2) );
 8000aee:	68bb      	ldr	r3, [r7, #8]
 8000af0:	2b00      	cmp	r3, #0
 8000af2:	d009      	beq.n	8000b08 <xmp3fixpt_UnpackFrameHeader+0x64>
 8000af4:	68bb      	ldr	r3, [r7, #8]
 8000af6:	f003 0301 	and.w	r3, r3, #1
 8000afa:	2b00      	cmp	r3, #0
 8000afc:	bf0c      	ite	eq
 8000afe:	2301      	moveq	r3, #1
 8000b00:	2300      	movne	r3, #0
 8000b02:	b2db      	uxtb	r3, r3
 8000b04:	b2da      	uxtb	r2, r3
 8000b06:	e000      	b.n	8000b0a <xmp3fixpt_UnpackFrameHeader+0x66>
 8000b08:	2202      	movs	r2, #2
 8000b0a:	68fb      	ldr	r3, [r7, #12]
 8000b0c:	701a      	strb	r2, [r3, #0]
	fh->layer = 4 - ((buf[1] >> 1) & 0x03);     /* easy mapping of index to layer number, 4 = error */
 8000b0e:	683b      	ldr	r3, [r7, #0]
 8000b10:	3301      	adds	r3, #1
 8000b12:	781b      	ldrb	r3, [r3, #0]
 8000b14:	085b      	lsrs	r3, r3, #1
 8000b16:	b2db      	uxtb	r3, r3
 8000b18:	f003 0303 	and.w	r3, r3, #3
 8000b1c:	f1c3 0204 	rsb	r2, r3, #4
 8000b20:	68fb      	ldr	r3, [r7, #12]
 8000b22:	605a      	str	r2, [r3, #4]
	fh->crc =   1 - ((buf[1] >> 0) & 0x01);
 8000b24:	683b      	ldr	r3, [r7, #0]
 8000b26:	3301      	adds	r3, #1
 8000b28:	781b      	ldrb	r3, [r3, #0]
 8000b2a:	f003 0301 	and.w	r3, r3, #1
 8000b2e:	2b00      	cmp	r3, #0
 8000b30:	bf0c      	ite	eq
 8000b32:	2301      	moveq	r3, #1
 8000b34:	2300      	movne	r3, #0
 8000b36:	b2db      	uxtb	r3, r3
 8000b38:	461a      	mov	r2, r3
 8000b3a:	68fb      	ldr	r3, [r7, #12]
 8000b3c:	609a      	str	r2, [r3, #8]
	fh->brIdx =      (buf[2] >> 4) & 0x0f;
 8000b3e:	683b      	ldr	r3, [r7, #0]
 8000b40:	3302      	adds	r3, #2
 8000b42:	781b      	ldrb	r3, [r3, #0]
 8000b44:	091b      	lsrs	r3, r3, #4
 8000b46:	b2db      	uxtb	r3, r3
 8000b48:	f003 020f 	and.w	r2, r3, #15
 8000b4c:	68fb      	ldr	r3, [r7, #12]
 8000b4e:	60da      	str	r2, [r3, #12]
	fh->srIdx =      (buf[2] >> 2) & 0x03;
 8000b50:	683b      	ldr	r3, [r7, #0]
 8000b52:	3302      	adds	r3, #2
 8000b54:	781b      	ldrb	r3, [r3, #0]
 8000b56:	089b      	lsrs	r3, r3, #2
 8000b58:	b2db      	uxtb	r3, r3
 8000b5a:	f003 0203 	and.w	r2, r3, #3
 8000b5e:	68fb      	ldr	r3, [r7, #12]
 8000b60:	611a      	str	r2, [r3, #16]
	fh->paddingBit = (buf[2] >> 1) & 0x01;
 8000b62:	683b      	ldr	r3, [r7, #0]
 8000b64:	3302      	adds	r3, #2
 8000b66:	781b      	ldrb	r3, [r3, #0]
 8000b68:	085b      	lsrs	r3, r3, #1
 8000b6a:	b2db      	uxtb	r3, r3
 8000b6c:	f003 0201 	and.w	r2, r3, #1
 8000b70:	68fb      	ldr	r3, [r7, #12]
 8000b72:	615a      	str	r2, [r3, #20]
	fh->privateBit = (buf[2] >> 0) & 0x01;
 8000b74:	683b      	ldr	r3, [r7, #0]
 8000b76:	3302      	adds	r3, #2
 8000b78:	781b      	ldrb	r3, [r3, #0]
 8000b7a:	f003 0201 	and.w	r2, r3, #1
 8000b7e:	68fb      	ldr	r3, [r7, #12]
 8000b80:	619a      	str	r2, [r3, #24]
	fh->sMode =      (StereoMode)((buf[3] >> 6) & 0x03);      /* maps to correct enum (see definition) */    
 8000b82:	683b      	ldr	r3, [r7, #0]
 8000b84:	3303      	adds	r3, #3
 8000b86:	781b      	ldrb	r3, [r3, #0]
 8000b88:	099b      	lsrs	r3, r3, #6
 8000b8a:	b2da      	uxtb	r2, r3
 8000b8c:	68fb      	ldr	r3, [r7, #12]
 8000b8e:	771a      	strb	r2, [r3, #28]
	fh->modeExt =    (buf[3] >> 4) & 0x03;
 8000b90:	683b      	ldr	r3, [r7, #0]
 8000b92:	3303      	adds	r3, #3
 8000b94:	781b      	ldrb	r3, [r3, #0]
 8000b96:	091b      	lsrs	r3, r3, #4
 8000b98:	b2db      	uxtb	r3, r3
 8000b9a:	f003 0203 	and.w	r2, r3, #3
 8000b9e:	68fb      	ldr	r3, [r7, #12]
 8000ba0:	621a      	str	r2, [r3, #32]
	fh->copyFlag =   (buf[3] >> 3) & 0x01;
 8000ba2:	683b      	ldr	r3, [r7, #0]
 8000ba4:	3303      	adds	r3, #3
 8000ba6:	781b      	ldrb	r3, [r3, #0]
 8000ba8:	08db      	lsrs	r3, r3, #3
 8000baa:	b2db      	uxtb	r3, r3
 8000bac:	f003 0201 	and.w	r2, r3, #1
 8000bb0:	68fb      	ldr	r3, [r7, #12]
 8000bb2:	625a      	str	r2, [r3, #36]	; 0x24
	fh->origFlag =   (buf[3] >> 2) & 0x01;
 8000bb4:	683b      	ldr	r3, [r7, #0]
 8000bb6:	3303      	adds	r3, #3
 8000bb8:	781b      	ldrb	r3, [r3, #0]
 8000bba:	089b      	lsrs	r3, r3, #2
 8000bbc:	b2db      	uxtb	r3, r3
 8000bbe:	f003 0201 	and.w	r2, r3, #1
 8000bc2:	68fb      	ldr	r3, [r7, #12]
 8000bc4:	629a      	str	r2, [r3, #40]	; 0x28
	fh->emphasis =   (buf[3] >> 0) & 0x03;
 8000bc6:	683b      	ldr	r3, [r7, #0]
 8000bc8:	3303      	adds	r3, #3
 8000bca:	781b      	ldrb	r3, [r3, #0]
 8000bcc:	f003 0203 	and.w	r2, r3, #3
 8000bd0:	68fb      	ldr	r3, [r7, #12]
 8000bd2:	62da      	str	r2, [r3, #44]	; 0x2c

	/* check parameters to avoid indexing tables with bad values */
	if (fh->srIdx == 3 || fh->layer == 4 || fh->brIdx == 15)
 8000bd4:	68fb      	ldr	r3, [r7, #12]
 8000bd6:	691b      	ldr	r3, [r3, #16]
 8000bd8:	2b03      	cmp	r3, #3
 8000bda:	d007      	beq.n	8000bec <xmp3fixpt_UnpackFrameHeader+0x148>
 8000bdc:	68fb      	ldr	r3, [r7, #12]
 8000bde:	685b      	ldr	r3, [r3, #4]
 8000be0:	2b04      	cmp	r3, #4
 8000be2:	d003      	beq.n	8000bec <xmp3fixpt_UnpackFrameHeader+0x148>
 8000be4:	68fb      	ldr	r3, [r7, #12]
 8000be6:	68db      	ldr	r3, [r3, #12]
 8000be8:	2b0f      	cmp	r3, #15
 8000bea:	d102      	bne.n	8000bf2 <xmp3fixpt_UnpackFrameHeader+0x14e>
		return -1;
 8000bec:	f04f 33ff 	mov.w	r3, #4294967295
 8000bf0:	e0c8      	b.n	8000d84 <xmp3fixpt_UnpackFrameHeader+0x2e0>

	fh->sfBand = &sfBandTable[fh->ver][fh->srIdx];	/* for readability (we reference sfBandTable many times in decoder) */
 8000bf2:	68fb      	ldr	r3, [r7, #12]
 8000bf4:	781b      	ldrb	r3, [r3, #0]
 8000bf6:	4619      	mov	r1, r3
 8000bf8:	68fb      	ldr	r3, [r7, #12]
 8000bfa:	691b      	ldr	r3, [r3, #16]
 8000bfc:	224a      	movs	r2, #74	; 0x4a
 8000bfe:	fb02 f203 	mul.w	r2, r2, r3
 8000c02:	23de      	movs	r3, #222	; 0xde
 8000c04:	fb03 f301 	mul.w	r3, r3, r1
 8000c08:	4413      	add	r3, r2
 8000c0a:	4a61      	ldr	r2, [pc, #388]	; (8000d90 <xmp3fixpt_UnpackFrameHeader+0x2ec>)
 8000c0c:	441a      	add	r2, r3
 8000c0e:	68fb      	ldr	r3, [r7, #12]
 8000c10:	635a      	str	r2, [r3, #52]	; 0x34
	if (fh->sMode != Joint)		/* just to be safe (dequant, stproc check fh->modeExt) */
 8000c12:	68fb      	ldr	r3, [r7, #12]
 8000c14:	7f1b      	ldrb	r3, [r3, #28]
 8000c16:	2b01      	cmp	r3, #1
 8000c18:	d002      	beq.n	8000c20 <xmp3fixpt_UnpackFrameHeader+0x17c>
		fh->modeExt = 0;
 8000c1a:	68fb      	ldr	r3, [r7, #12]
 8000c1c:	2200      	movs	r2, #0
 8000c1e:	621a      	str	r2, [r3, #32]

	/* init user-accessible data */
	mp3DecInfo->nChans = (fh->sMode == Mono ? 1 : 2);
 8000c20:	68fb      	ldr	r3, [r7, #12]
 8000c22:	7f1b      	ldrb	r3, [r3, #28]
 8000c24:	2b03      	cmp	r3, #3
 8000c26:	d101      	bne.n	8000c2c <xmp3fixpt_UnpackFrameHeader+0x188>
 8000c28:	2201      	movs	r2, #1
 8000c2a:	e000      	b.n	8000c2e <xmp3fixpt_UnpackFrameHeader+0x18a>
 8000c2c:	2202      	movs	r2, #2
 8000c2e:	687b      	ldr	r3, [r7, #4]
 8000c30:	f8c3 27bc 	str.w	r2, [r3, #1980]	; 0x7bc
	mp3DecInfo->samprate = samplerateTab[fh->ver][fh->srIdx];
 8000c34:	68fb      	ldr	r3, [r7, #12]
 8000c36:	781b      	ldrb	r3, [r3, #0]
 8000c38:	4618      	mov	r0, r3
 8000c3a:	68fb      	ldr	r3, [r7, #12]
 8000c3c:	691a      	ldr	r2, [r3, #16]
 8000c3e:	4955      	ldr	r1, [pc, #340]	; (8000d94 <xmp3fixpt_UnpackFrameHeader+0x2f0>)
 8000c40:	4603      	mov	r3, r0
 8000c42:	005b      	lsls	r3, r3, #1
 8000c44:	4403      	add	r3, r0
 8000c46:	4413      	add	r3, r2
 8000c48:	f851 2023 	ldr.w	r2, [r1, r3, lsl #2]
 8000c4c:	687b      	ldr	r3, [r7, #4]
 8000c4e:	f8c3 27c0 	str.w	r2, [r3, #1984]	; 0x7c0
	mp3DecInfo->nGrans = (fh->ver == MPEG1 ? NGRANS_MPEG1 : NGRANS_MPEG2);
 8000c52:	68fb      	ldr	r3, [r7, #12]
 8000c54:	781b      	ldrb	r3, [r3, #0]
 8000c56:	2b00      	cmp	r3, #0
 8000c58:	d101      	bne.n	8000c5e <xmp3fixpt_UnpackFrameHeader+0x1ba>
 8000c5a:	2202      	movs	r2, #2
 8000c5c:	e000      	b.n	8000c60 <xmp3fixpt_UnpackFrameHeader+0x1bc>
 8000c5e:	2201      	movs	r2, #1
 8000c60:	687b      	ldr	r3, [r7, #4]
 8000c62:	f8c3 27c4 	str.w	r2, [r3, #1988]	; 0x7c4
	mp3DecInfo->nGranSamps = ((int)samplesPerFrameTab[fh->ver][fh->layer - 1]) / mp3DecInfo->nGrans;
 8000c66:	68fb      	ldr	r3, [r7, #12]
 8000c68:	781b      	ldrb	r3, [r3, #0]
 8000c6a:	4618      	mov	r0, r3
 8000c6c:	68fb      	ldr	r3, [r7, #12]
 8000c6e:	685b      	ldr	r3, [r3, #4]
 8000c70:	1e5a      	subs	r2, r3, #1
 8000c72:	4949      	ldr	r1, [pc, #292]	; (8000d98 <xmp3fixpt_UnpackFrameHeader+0x2f4>)
 8000c74:	4603      	mov	r3, r0
 8000c76:	005b      	lsls	r3, r3, #1
 8000c78:	4403      	add	r3, r0
 8000c7a:	4413      	add	r3, r2
 8000c7c:	f931 3013 	ldrsh.w	r3, [r1, r3, lsl #1]
 8000c80:	461a      	mov	r2, r3
 8000c82:	687b      	ldr	r3, [r7, #4]
 8000c84:	f8d3 37c4 	ldr.w	r3, [r3, #1988]	; 0x7c4
 8000c88:	fb92 f2f3 	sdiv	r2, r2, r3
 8000c8c:	687b      	ldr	r3, [r7, #4]
 8000c8e:	f8c3 27c8 	str.w	r2, [r3, #1992]	; 0x7c8
	mp3DecInfo->layer = fh->layer;
 8000c92:	68fb      	ldr	r3, [r7, #12]
 8000c94:	685a      	ldr	r2, [r3, #4]
 8000c96:	687b      	ldr	r3, [r7, #4]
 8000c98:	f8c3 27d0 	str.w	r2, [r3, #2000]	; 0x7d0
	mp3DecInfo->version = fh->ver;
 8000c9c:	68fb      	ldr	r3, [r7, #12]
 8000c9e:	781a      	ldrb	r2, [r3, #0]
 8000ca0:	687b      	ldr	r3, [r7, #4]
 8000ca2:	f883 27d4 	strb.w	r2, [r3, #2004]	; 0x7d4
	/* get bitrate and nSlots from table, unless brIdx == 0 (free mode) in which case caller must figure it out himself
	 * question - do we want to overwrite mp3DecInfo->bitrate with 0 each time if it's free mode, and
	 *  copy the pre-calculated actual free bitrate into it in mp3dec.c (according to the spec, 
	 *  this shouldn't be necessary, since it should be either all frames free or none free)
	 */
	if (fh->brIdx) {
 8000ca6:	68fb      	ldr	r3, [r7, #12]
 8000ca8:	68db      	ldr	r3, [r3, #12]
 8000caa:	2b00      	cmp	r3, #0
 8000cac:	d056      	beq.n	8000d5c <xmp3fixpt_UnpackFrameHeader+0x2b8>
		mp3DecInfo->bitrate = ((int)bitrateTab[fh->ver][fh->layer - 1][fh->brIdx]) * 1000;
 8000cae:	68fb      	ldr	r3, [r7, #12]
 8000cb0:	781b      	ldrb	r3, [r3, #0]
 8000cb2:	4619      	mov	r1, r3
 8000cb4:	68fb      	ldr	r3, [r7, #12]
 8000cb6:	685b      	ldr	r3, [r3, #4]
 8000cb8:	3b01      	subs	r3, #1
 8000cba:	68fa      	ldr	r2, [r7, #12]
 8000cbc:	68d0      	ldr	r0, [r2, #12]
 8000cbe:	4c37      	ldr	r4, [pc, #220]	; (8000d9c <xmp3fixpt_UnpackFrameHeader+0x2f8>)
 8000cc0:	461a      	mov	r2, r3
 8000cc2:	0112      	lsls	r2, r2, #4
 8000cc4:	1ad2      	subs	r2, r2, r3
 8000cc6:	460b      	mov	r3, r1
 8000cc8:	005b      	lsls	r3, r3, #1
 8000cca:	440b      	add	r3, r1
 8000ccc:	0119      	lsls	r1, r3, #4
 8000cce:	1ac9      	subs	r1, r1, r3
 8000cd0:	1853      	adds	r3, r2, r1
 8000cd2:	4403      	add	r3, r0
 8000cd4:	f934 3013 	ldrsh.w	r3, [r4, r3, lsl #1]
 8000cd8:	461a      	mov	r2, r3
 8000cda:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 8000cde:	fb03 f202 	mul.w	r2, r3, r2
 8000ce2:	687b      	ldr	r3, [r7, #4]
 8000ce4:	f8c3 27b8 	str.w	r2, [r3, #1976]	; 0x7b8
	
		/* nSlots = total frame bytes (from table) - sideInfo bytes - header - CRC (if present) + pad (if present) */
		mp3DecInfo->nSlots = (int)slotTab[fh->ver][fh->srIdx][fh->brIdx] - 
 8000ce8:	68fb      	ldr	r3, [r7, #12]
 8000cea:	781b      	ldrb	r3, [r3, #0]
 8000cec:	4619      	mov	r1, r3
 8000cee:	68fb      	ldr	r3, [r7, #12]
 8000cf0:	691b      	ldr	r3, [r3, #16]
 8000cf2:	68fa      	ldr	r2, [r7, #12]
 8000cf4:	68d0      	ldr	r0, [r2, #12]
 8000cf6:	4c2a      	ldr	r4, [pc, #168]	; (8000da0 <xmp3fixpt_UnpackFrameHeader+0x2fc>)
 8000cf8:	461a      	mov	r2, r3
 8000cfa:	0112      	lsls	r2, r2, #4
 8000cfc:	1ad2      	subs	r2, r2, r3
 8000cfe:	460b      	mov	r3, r1
 8000d00:	005b      	lsls	r3, r3, #1
 8000d02:	440b      	add	r3, r1
 8000d04:	0119      	lsls	r1, r3, #4
 8000d06:	1ac9      	subs	r1, r1, r3
 8000d08:	1853      	adds	r3, r2, r1
 8000d0a:	4403      	add	r3, r0
 8000d0c:	f934 3013 	ldrsh.w	r3, [r4, r3, lsl #1]
 8000d10:	4619      	mov	r1, r3
			(int)sideBytesTab[fh->ver][(fh->sMode == Mono ? 0 : 1)] - 
 8000d12:	68fb      	ldr	r3, [r7, #12]
 8000d14:	781b      	ldrb	r3, [r3, #0]
 8000d16:	461c      	mov	r4, r3
 8000d18:	68fb      	ldr	r3, [r7, #12]
 8000d1a:	7f1b      	ldrb	r3, [r3, #28]
 8000d1c:	2b03      	cmp	r3, #3
 8000d1e:	bf14      	ite	ne
 8000d20:	2301      	movne	r3, #1
 8000d22:	2300      	moveq	r3, #0
 8000d24:	b2db      	uxtb	r3, r3
 8000d26:	4618      	mov	r0, r3
 8000d28:	4a1e      	ldr	r2, [pc, #120]	; (8000da4 <xmp3fixpt_UnpackFrameHeader+0x300>)
 8000d2a:	0063      	lsls	r3, r4, #1
 8000d2c:	4403      	add	r3, r0
 8000d2e:	f932 3013 	ldrsh.w	r3, [r2, r3, lsl #1]
		mp3DecInfo->nSlots = (int)slotTab[fh->ver][fh->srIdx][fh->brIdx] - 
 8000d32:	1acb      	subs	r3, r1, r3
			(int)sideBytesTab[fh->ver][(fh->sMode == Mono ? 0 : 1)] - 
 8000d34:	1f1a      	subs	r2, r3, #4
			4 - (fh->crc ? 2 : 0) + (fh->paddingBit ? 1 : 0);
 8000d36:	68fb      	ldr	r3, [r7, #12]
 8000d38:	689b      	ldr	r3, [r3, #8]
 8000d3a:	2b00      	cmp	r3, #0
 8000d3c:	d001      	beq.n	8000d42 <xmp3fixpt_UnpackFrameHeader+0x29e>
 8000d3e:	2302      	movs	r3, #2
 8000d40:	e000      	b.n	8000d44 <xmp3fixpt_UnpackFrameHeader+0x2a0>
 8000d42:	2300      	movs	r3, #0
 8000d44:	1ad3      	subs	r3, r2, r3
 8000d46:	68fa      	ldr	r2, [r7, #12]
 8000d48:	6952      	ldr	r2, [r2, #20]
 8000d4a:	2a00      	cmp	r2, #0
 8000d4c:	bf14      	ite	ne
 8000d4e:	2201      	movne	r2, #1
 8000d50:	2200      	moveq	r2, #0
 8000d52:	b2d2      	uxtb	r2, r2
 8000d54:	441a      	add	r2, r3
		mp3DecInfo->nSlots = (int)slotTab[fh->ver][fh->srIdx][fh->brIdx] - 
 8000d56:	687b      	ldr	r3, [r7, #4]
 8000d58:	f8c3 27cc 	str.w	r2, [r3, #1996]	; 0x7cc
	}

	/* load crc word, if enabled, and return length of frame header (in bytes) */
	if (fh->crc) {
 8000d5c:	68fb      	ldr	r3, [r7, #12]
 8000d5e:	689b      	ldr	r3, [r3, #8]
 8000d60:	2b00      	cmp	r3, #0
 8000d62:	d00b      	beq.n	8000d7c <xmp3fixpt_UnpackFrameHeader+0x2d8>
		fh->CRCWord = ((int)buf[4] << 8 | (int)buf[5] << 0);
 8000d64:	683b      	ldr	r3, [r7, #0]
 8000d66:	3304      	adds	r3, #4
 8000d68:	781b      	ldrb	r3, [r3, #0]
 8000d6a:	021b      	lsls	r3, r3, #8
 8000d6c:	683a      	ldr	r2, [r7, #0]
 8000d6e:	3205      	adds	r2, #5
 8000d70:	7812      	ldrb	r2, [r2, #0]
 8000d72:	431a      	orrs	r2, r3
 8000d74:	68fb      	ldr	r3, [r7, #12]
 8000d76:	631a      	str	r2, [r3, #48]	; 0x30
		return 6;
 8000d78:	2306      	movs	r3, #6
 8000d7a:	e003      	b.n	8000d84 <xmp3fixpt_UnpackFrameHeader+0x2e0>
	} else {
		fh->CRCWord = 0;
 8000d7c:	68fb      	ldr	r3, [r7, #12]
 8000d7e:	2200      	movs	r2, #0
 8000d80:	631a      	str	r2, [r3, #48]	; 0x30
		return 4;
 8000d82:	2304      	movs	r3, #4
	}
}
 8000d84:	4618      	mov	r0, r3
 8000d86:	3710      	adds	r7, #16
 8000d88:	46bd      	mov	sp, r7
 8000d8a:	bc90      	pop	{r4, r7}
 8000d8c:	4770      	bx	lr
 8000d8e:	bf00      	nop
 8000d90:	080178b4 	.word	0x080178b4
 8000d94:	08017648 	.word	0x08017648
 8000d98:	0801777c 	.word	0x0801777c
 8000d9c:	0801766c 	.word	0x0801766c
 8000da0:	080177a4 	.word	0x080177a4
 8000da4:	08017798 	.word	0x08017798

08000da8 <xmp3fixpt_UnpackSideInfo>:
 *
 * Return:      length (in bytes) of side info data
 *              -1 if null input pointers
 **************************************************************************************/
int UnpackSideInfo(MP3DecInfo *mp3DecInfo, unsigned char *buf)
{
 8000da8:	b580      	push	{r7, lr}
 8000daa:	b08e      	sub	sp, #56	; 0x38
 8000dac:	af00      	add	r7, sp, #0
 8000dae:	6078      	str	r0, [r7, #4]
 8000db0:	6039      	str	r1, [r7, #0]
	FrameHeader *fh;
	SideInfo *si;
	SideInfoSub *sis;

	/* validate pointers and sync word */
	if (!mp3DecInfo || !mp3DecInfo->FrameHeaderPS || !mp3DecInfo->SideInfoPS)
 8000db2:	687b      	ldr	r3, [r7, #4]
 8000db4:	2b00      	cmp	r3, #0
 8000db6:	d007      	beq.n	8000dc8 <xmp3fixpt_UnpackSideInfo+0x20>
 8000db8:	687b      	ldr	r3, [r7, #4]
 8000dba:	681b      	ldr	r3, [r3, #0]
 8000dbc:	2b00      	cmp	r3, #0
 8000dbe:	d003      	beq.n	8000dc8 <xmp3fixpt_UnpackSideInfo+0x20>
 8000dc0:	687b      	ldr	r3, [r7, #4]
 8000dc2:	685b      	ldr	r3, [r3, #4]
 8000dc4:	2b00      	cmp	r3, #0
 8000dc6:	d102      	bne.n	8000dce <xmp3fixpt_UnpackSideInfo+0x26>
		return -1;
 8000dc8:	f04f 33ff 	mov.w	r3, #4294967295
 8000dcc:	e186      	b.n	80010dc <xmp3fixpt_UnpackSideInfo+0x334>

	fh = ((FrameHeader *)(mp3DecInfo->FrameHeaderPS));
 8000dce:	687b      	ldr	r3, [r7, #4]
 8000dd0:	681b      	ldr	r3, [r3, #0]
 8000dd2:	627b      	str	r3, [r7, #36]	; 0x24
	si = ((SideInfo *)(mp3DecInfo->SideInfoPS));
 8000dd4:	687b      	ldr	r3, [r7, #4]
 8000dd6:	685b      	ldr	r3, [r3, #4]
 8000dd8:	623b      	str	r3, [r7, #32]

	bsi = &bitStreamInfo;
 8000dda:	f107 0308 	add.w	r3, r7, #8
 8000dde:	61fb      	str	r3, [r7, #28]
	if (fh->ver == MPEG1) {
 8000de0:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8000de2:	781b      	ldrb	r3, [r3, #0]
 8000de4:	2b00      	cmp	r3, #0
 8000de6:	d147      	bne.n	8000e78 <xmp3fixpt_UnpackSideInfo+0xd0>
		/* MPEG 1 */
		nBytes = (fh->sMode == Mono ? SIBYTES_MPEG1_MONO : SIBYTES_MPEG1_STEREO);
 8000de8:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8000dea:	7f1b      	ldrb	r3, [r3, #28]
 8000dec:	2b03      	cmp	r3, #3
 8000dee:	d101      	bne.n	8000df4 <xmp3fixpt_UnpackSideInfo+0x4c>
 8000df0:	2311      	movs	r3, #17
 8000df2:	e000      	b.n	8000df6 <xmp3fixpt_UnpackSideInfo+0x4e>
 8000df4:	2320      	movs	r3, #32
 8000df6:	62bb      	str	r3, [r7, #40]	; 0x28
		SetBitstreamPointer(bsi, nBytes, buf);
 8000df8:	683a      	ldr	r2, [r7, #0]
 8000dfa:	6ab9      	ldr	r1, [r7, #40]	; 0x28
 8000dfc:	69f8      	ldr	r0, [r7, #28]
 8000dfe:	f7ff fd45 	bl	800088c <xmp3fixpt_SetBitstreamPointer>
		si->mainDataBegin = GetBits(bsi, 9);
 8000e02:	2109      	movs	r1, #9
 8000e04:	69f8      	ldr	r0, [r7, #28]
 8000e06:	f7ff fdca 	bl	800099e <xmp3fixpt_GetBits>
 8000e0a:	4603      	mov	r3, r0
 8000e0c:	461a      	mov	r2, r3
 8000e0e:	6a3b      	ldr	r3, [r7, #32]
 8000e10:	601a      	str	r2, [r3, #0]
		si->privateBits =   GetBits(bsi, (fh->sMode == Mono ? 5 : 3));
 8000e12:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8000e14:	7f1b      	ldrb	r3, [r3, #28]
 8000e16:	2b03      	cmp	r3, #3
 8000e18:	d101      	bne.n	8000e1e <xmp3fixpt_UnpackSideInfo+0x76>
 8000e1a:	2305      	movs	r3, #5
 8000e1c:	e000      	b.n	8000e20 <xmp3fixpt_UnpackSideInfo+0x78>
 8000e1e:	2303      	movs	r3, #3
 8000e20:	4619      	mov	r1, r3
 8000e22:	69f8      	ldr	r0, [r7, #28]
 8000e24:	f7ff fdbb 	bl	800099e <xmp3fixpt_GetBits>
 8000e28:	4603      	mov	r3, r0
 8000e2a:	461a      	mov	r2, r3
 8000e2c:	6a3b      	ldr	r3, [r7, #32]
 8000e2e:	605a      	str	r2, [r3, #4]

		for (ch = 0; ch < mp3DecInfo->nChans; ch++)
 8000e30:	2300      	movs	r3, #0
 8000e32:	633b      	str	r3, [r7, #48]	; 0x30
 8000e34:	e019      	b.n	8000e6a <xmp3fixpt_UnpackSideInfo+0xc2>
			for (bd = 0; bd < MAX_SCFBD; bd++)
 8000e36:	2300      	movs	r3, #0
 8000e38:	62fb      	str	r3, [r7, #44]	; 0x2c
 8000e3a:	e010      	b.n	8000e5e <xmp3fixpt_UnpackSideInfo+0xb6>
				si->scfsi[ch][bd] = GetBits(bsi, 1);
 8000e3c:	2101      	movs	r1, #1
 8000e3e:	69f8      	ldr	r0, [r7, #28]
 8000e40:	f7ff fdad 	bl	800099e <xmp3fixpt_GetBits>
 8000e44:	4603      	mov	r3, r0
 8000e46:	4618      	mov	r0, r3
 8000e48:	6a3b      	ldr	r3, [r7, #32]
 8000e4a:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 8000e4c:	0091      	lsls	r1, r2, #2
 8000e4e:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8000e50:	440a      	add	r2, r1
 8000e52:	3202      	adds	r2, #2
 8000e54:	f843 0022 	str.w	r0, [r3, r2, lsl #2]
			for (bd = 0; bd < MAX_SCFBD; bd++)
 8000e58:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8000e5a:	3301      	adds	r3, #1
 8000e5c:	62fb      	str	r3, [r7, #44]	; 0x2c
 8000e5e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8000e60:	2b03      	cmp	r3, #3
 8000e62:	ddeb      	ble.n	8000e3c <xmp3fixpt_UnpackSideInfo+0x94>
		for (ch = 0; ch < mp3DecInfo->nChans; ch++)
 8000e64:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8000e66:	3301      	adds	r3, #1
 8000e68:	633b      	str	r3, [r7, #48]	; 0x30
 8000e6a:	687b      	ldr	r3, [r7, #4]
 8000e6c:	f8d3 27bc 	ldr.w	r2, [r3, #1980]	; 0x7bc
 8000e70:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8000e72:	429a      	cmp	r2, r3
 8000e74:	dcdf      	bgt.n	8000e36 <xmp3fixpt_UnpackSideInfo+0x8e>
 8000e76:	e023      	b.n	8000ec0 <xmp3fixpt_UnpackSideInfo+0x118>
	} else {
		/* MPEG 2, MPEG 2.5 */
		nBytes = (fh->sMode == Mono ? SIBYTES_MPEG2_MONO : SIBYTES_MPEG2_STEREO);
 8000e78:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8000e7a:	7f1b      	ldrb	r3, [r3, #28]
 8000e7c:	2b03      	cmp	r3, #3
 8000e7e:	d101      	bne.n	8000e84 <xmp3fixpt_UnpackSideInfo+0xdc>
 8000e80:	2309      	movs	r3, #9
 8000e82:	e000      	b.n	8000e86 <xmp3fixpt_UnpackSideInfo+0xde>
 8000e84:	2311      	movs	r3, #17
 8000e86:	62bb      	str	r3, [r7, #40]	; 0x28
		SetBitstreamPointer(bsi, nBytes, buf);
 8000e88:	683a      	ldr	r2, [r7, #0]
 8000e8a:	6ab9      	ldr	r1, [r7, #40]	; 0x28
 8000e8c:	69f8      	ldr	r0, [r7, #28]
 8000e8e:	f7ff fcfd 	bl	800088c <xmp3fixpt_SetBitstreamPointer>
		si->mainDataBegin = GetBits(bsi, 8);
 8000e92:	2108      	movs	r1, #8
 8000e94:	69f8      	ldr	r0, [r7, #28]
 8000e96:	f7ff fd82 	bl	800099e <xmp3fixpt_GetBits>
 8000e9a:	4603      	mov	r3, r0
 8000e9c:	461a      	mov	r2, r3
 8000e9e:	6a3b      	ldr	r3, [r7, #32]
 8000ea0:	601a      	str	r2, [r3, #0]
		si->privateBits =   GetBits(bsi, (fh->sMode == Mono ? 1 : 2));
 8000ea2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8000ea4:	7f1b      	ldrb	r3, [r3, #28]
 8000ea6:	2b03      	cmp	r3, #3
 8000ea8:	d101      	bne.n	8000eae <xmp3fixpt_UnpackSideInfo+0x106>
 8000eaa:	2301      	movs	r3, #1
 8000eac:	e000      	b.n	8000eb0 <xmp3fixpt_UnpackSideInfo+0x108>
 8000eae:	2302      	movs	r3, #2
 8000eb0:	4619      	mov	r1, r3
 8000eb2:	69f8      	ldr	r0, [r7, #28]
 8000eb4:	f7ff fd73 	bl	800099e <xmp3fixpt_GetBits>
 8000eb8:	4603      	mov	r3, r0
 8000eba:	461a      	mov	r2, r3
 8000ebc:	6a3b      	ldr	r3, [r7, #32]
 8000ebe:	605a      	str	r2, [r3, #4]
	}

	for(gr =0; gr < mp3DecInfo->nGrans; gr++) {
 8000ec0:	2300      	movs	r3, #0
 8000ec2:	637b      	str	r3, [r7, #52]	; 0x34
 8000ec4:	e0fd      	b.n	80010c2 <xmp3fixpt_UnpackSideInfo+0x31a>
		for (ch = 0; ch < mp3DecInfo->nChans; ch++) {
 8000ec6:	2300      	movs	r3, #0
 8000ec8:	633b      	str	r3, [r7, #48]	; 0x30
 8000eca:	e0f0      	b.n	80010ae <xmp3fixpt_UnpackSideInfo+0x306>
			sis = &si->sis[gr][ch];						/* side info subblock for this granule, channel */
 8000ecc:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8000ece:	461a      	mov	r2, r3
 8000ed0:	00d2      	lsls	r2, r2, #3
 8000ed2:	441a      	add	r2, r3
 8000ed4:	00d3      	lsls	r3, r2, #3
 8000ed6:	461a      	mov	r2, r3
 8000ed8:	6b79      	ldr	r1, [r7, #52]	; 0x34
 8000eda:	460b      	mov	r3, r1
 8000edc:	00db      	lsls	r3, r3, #3
 8000ede:	440b      	add	r3, r1
 8000ee0:	011b      	lsls	r3, r3, #4
 8000ee2:	4413      	add	r3, r2
 8000ee4:	3328      	adds	r3, #40	; 0x28
 8000ee6:	6a3a      	ldr	r2, [r7, #32]
 8000ee8:	4413      	add	r3, r2
 8000eea:	61bb      	str	r3, [r7, #24]

			sis->part23Length =    GetBits(bsi, 12);
 8000eec:	210c      	movs	r1, #12
 8000eee:	69f8      	ldr	r0, [r7, #28]
 8000ef0:	f7ff fd55 	bl	800099e <xmp3fixpt_GetBits>
 8000ef4:	4603      	mov	r3, r0
 8000ef6:	461a      	mov	r2, r3
 8000ef8:	69bb      	ldr	r3, [r7, #24]
 8000efa:	601a      	str	r2, [r3, #0]
			sis->nBigvals =        GetBits(bsi, 9);
 8000efc:	2109      	movs	r1, #9
 8000efe:	69f8      	ldr	r0, [r7, #28]
 8000f00:	f7ff fd4d 	bl	800099e <xmp3fixpt_GetBits>
 8000f04:	4603      	mov	r3, r0
 8000f06:	461a      	mov	r2, r3
 8000f08:	69bb      	ldr	r3, [r7, #24]
 8000f0a:	605a      	str	r2, [r3, #4]
			sis->globalGain =      GetBits(bsi, 8);
 8000f0c:	2108      	movs	r1, #8
 8000f0e:	69f8      	ldr	r0, [r7, #28]
 8000f10:	f7ff fd45 	bl	800099e <xmp3fixpt_GetBits>
 8000f14:	4603      	mov	r3, r0
 8000f16:	461a      	mov	r2, r3
 8000f18:	69bb      	ldr	r3, [r7, #24]
 8000f1a:	609a      	str	r2, [r3, #8]
			sis->sfCompress =      GetBits(bsi, (fh->ver == MPEG1 ? 4 : 9));
 8000f1c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8000f1e:	781b      	ldrb	r3, [r3, #0]
 8000f20:	2b00      	cmp	r3, #0
 8000f22:	d101      	bne.n	8000f28 <xmp3fixpt_UnpackSideInfo+0x180>
 8000f24:	2304      	movs	r3, #4
 8000f26:	e000      	b.n	8000f2a <xmp3fixpt_UnpackSideInfo+0x182>
 8000f28:	2309      	movs	r3, #9
 8000f2a:	4619      	mov	r1, r3
 8000f2c:	69f8      	ldr	r0, [r7, #28]
 8000f2e:	f7ff fd36 	bl	800099e <xmp3fixpt_GetBits>
 8000f32:	4603      	mov	r3, r0
 8000f34:	461a      	mov	r2, r3
 8000f36:	69bb      	ldr	r3, [r7, #24]
 8000f38:	60da      	str	r2, [r3, #12]
			sis->winSwitchFlag =   GetBits(bsi, 1);
 8000f3a:	2101      	movs	r1, #1
 8000f3c:	69f8      	ldr	r0, [r7, #28]
 8000f3e:	f7ff fd2e 	bl	800099e <xmp3fixpt_GetBits>
 8000f42:	4603      	mov	r3, r0
 8000f44:	461a      	mov	r2, r3
 8000f46:	69bb      	ldr	r3, [r7, #24]
 8000f48:	611a      	str	r2, [r3, #16]

			if(sis->winSwitchFlag) {
 8000f4a:	69bb      	ldr	r3, [r7, #24]
 8000f4c:	691b      	ldr	r3, [r3, #16]
 8000f4e:	2b00      	cmp	r3, #0
 8000f50:	d05e      	beq.n	8001010 <xmp3fixpt_UnpackSideInfo+0x268>
				/* this is a start, stop, short, or mixed block */
				sis->blockType =       GetBits(bsi, 2);		/* 0 = normal, 1 = start, 2 = short, 3 = stop */
 8000f52:	2102      	movs	r1, #2
 8000f54:	69f8      	ldr	r0, [r7, #28]
 8000f56:	f7ff fd22 	bl	800099e <xmp3fixpt_GetBits>
 8000f5a:	4603      	mov	r3, r0
 8000f5c:	461a      	mov	r2, r3
 8000f5e:	69bb      	ldr	r3, [r7, #24]
 8000f60:	615a      	str	r2, [r3, #20]
				sis->mixedBlock =      GetBits(bsi, 1);		/* 0 = not mixed, 1 = mixed */
 8000f62:	2101      	movs	r1, #1
 8000f64:	69f8      	ldr	r0, [r7, #28]
 8000f66:	f7ff fd1a 	bl	800099e <xmp3fixpt_GetBits>
 8000f6a:	4603      	mov	r3, r0
 8000f6c:	461a      	mov	r2, r3
 8000f6e:	69bb      	ldr	r3, [r7, #24]
 8000f70:	619a      	str	r2, [r3, #24]
				sis->tableSelect[0] =  GetBits(bsi, 5);
 8000f72:	2105      	movs	r1, #5
 8000f74:	69f8      	ldr	r0, [r7, #28]
 8000f76:	f7ff fd12 	bl	800099e <xmp3fixpt_GetBits>
 8000f7a:	4603      	mov	r3, r0
 8000f7c:	461a      	mov	r2, r3
 8000f7e:	69bb      	ldr	r3, [r7, #24]
 8000f80:	61da      	str	r2, [r3, #28]
				sis->tableSelect[1] =  GetBits(bsi, 5);
 8000f82:	2105      	movs	r1, #5
 8000f84:	69f8      	ldr	r0, [r7, #28]
 8000f86:	f7ff fd0a 	bl	800099e <xmp3fixpt_GetBits>
 8000f8a:	4603      	mov	r3, r0
 8000f8c:	461a      	mov	r2, r3
 8000f8e:	69bb      	ldr	r3, [r7, #24]
 8000f90:	621a      	str	r2, [r3, #32]
				sis->tableSelect[2] =  0;					/* unused */
 8000f92:	69bb      	ldr	r3, [r7, #24]
 8000f94:	2200      	movs	r2, #0
 8000f96:	625a      	str	r2, [r3, #36]	; 0x24
				sis->subBlockGain[0] = GetBits(bsi, 3);
 8000f98:	2103      	movs	r1, #3
 8000f9a:	69f8      	ldr	r0, [r7, #28]
 8000f9c:	f7ff fcff 	bl	800099e <xmp3fixpt_GetBits>
 8000fa0:	4603      	mov	r3, r0
 8000fa2:	461a      	mov	r2, r3
 8000fa4:	69bb      	ldr	r3, [r7, #24]
 8000fa6:	629a      	str	r2, [r3, #40]	; 0x28
				sis->subBlockGain[1] = GetBits(bsi, 3);
 8000fa8:	2103      	movs	r1, #3
 8000faa:	69f8      	ldr	r0, [r7, #28]
 8000fac:	f7ff fcf7 	bl	800099e <xmp3fixpt_GetBits>
 8000fb0:	4603      	mov	r3, r0
 8000fb2:	461a      	mov	r2, r3
 8000fb4:	69bb      	ldr	r3, [r7, #24]
 8000fb6:	62da      	str	r2, [r3, #44]	; 0x2c
				sis->subBlockGain[2] = GetBits(bsi, 3);
 8000fb8:	2103      	movs	r1, #3
 8000fba:	69f8      	ldr	r0, [r7, #28]
 8000fbc:	f7ff fcef 	bl	800099e <xmp3fixpt_GetBits>
 8000fc0:	4603      	mov	r3, r0
 8000fc2:	461a      	mov	r2, r3
 8000fc4:	69bb      	ldr	r3, [r7, #24]
 8000fc6:	631a      	str	r2, [r3, #48]	; 0x30

				/* TODO - check logic */
				if (sis->blockType == 0) {
 8000fc8:	69bb      	ldr	r3, [r7, #24]
 8000fca:	695b      	ldr	r3, [r3, #20]
 8000fcc:	2b00      	cmp	r3, #0
 8000fce:	d109      	bne.n	8000fe4 <xmp3fixpt_UnpackSideInfo+0x23c>
					/* this should not be allowed, according to spec */
					sis->nBigvals = 0;
 8000fd0:	69bb      	ldr	r3, [r7, #24]
 8000fd2:	2200      	movs	r2, #0
 8000fd4:	605a      	str	r2, [r3, #4]
					sis->part23Length = 0;
 8000fd6:	69bb      	ldr	r3, [r7, #24]
 8000fd8:	2200      	movs	r2, #0
 8000fda:	601a      	str	r2, [r3, #0]
					sis->sfCompress = 0;
 8000fdc:	69bb      	ldr	r3, [r7, #24]
 8000fde:	2200      	movs	r2, #0
 8000fe0:	60da      	str	r2, [r3, #12]
 8000fe2:	e00e      	b.n	8001002 <xmp3fixpt_UnpackSideInfo+0x25a>
				} else if (sis->blockType == 2 && sis->mixedBlock == 0) {
 8000fe4:	69bb      	ldr	r3, [r7, #24]
 8000fe6:	695b      	ldr	r3, [r3, #20]
 8000fe8:	2b02      	cmp	r3, #2
 8000fea:	d107      	bne.n	8000ffc <xmp3fixpt_UnpackSideInfo+0x254>
 8000fec:	69bb      	ldr	r3, [r7, #24]
 8000fee:	699b      	ldr	r3, [r3, #24]
 8000ff0:	2b00      	cmp	r3, #0
 8000ff2:	d103      	bne.n	8000ffc <xmp3fixpt_UnpackSideInfo+0x254>
					/* short block, not mixed */
					sis->region0Count = 8;
 8000ff4:	69bb      	ldr	r3, [r7, #24]
 8000ff6:	2208      	movs	r2, #8
 8000ff8:	635a      	str	r2, [r3, #52]	; 0x34
 8000ffa:	e002      	b.n	8001002 <xmp3fixpt_UnpackSideInfo+0x25a>
				} else {
					/* start, stop, or short-mixed */
					sis->region0Count = 7;
 8000ffc:	69bb      	ldr	r3, [r7, #24]
 8000ffe:	2207      	movs	r2, #7
 8001000:	635a      	str	r2, [r3, #52]	; 0x34
				}
				sis->region1Count = 20 - sis->region0Count;
 8001002:	69bb      	ldr	r3, [r7, #24]
 8001004:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8001006:	f1c3 0214 	rsb	r2, r3, #20
 800100a:	69bb      	ldr	r3, [r7, #24]
 800100c:	639a      	str	r2, [r3, #56]	; 0x38
 800100e:	e02d      	b.n	800106c <xmp3fixpt_UnpackSideInfo+0x2c4>
			} else {
				/* this is a normal block */
				sis->blockType = 0;
 8001010:	69bb      	ldr	r3, [r7, #24]
 8001012:	2200      	movs	r2, #0
 8001014:	615a      	str	r2, [r3, #20]
				sis->mixedBlock = 0;
 8001016:	69bb      	ldr	r3, [r7, #24]
 8001018:	2200      	movs	r2, #0
 800101a:	619a      	str	r2, [r3, #24]
				sis->tableSelect[0] =  GetBits(bsi, 5);
 800101c:	2105      	movs	r1, #5
 800101e:	69f8      	ldr	r0, [r7, #28]
 8001020:	f7ff fcbd 	bl	800099e <xmp3fixpt_GetBits>
 8001024:	4603      	mov	r3, r0
 8001026:	461a      	mov	r2, r3
 8001028:	69bb      	ldr	r3, [r7, #24]
 800102a:	61da      	str	r2, [r3, #28]
				sis->tableSelect[1] =  GetBits(bsi, 5);
 800102c:	2105      	movs	r1, #5
 800102e:	69f8      	ldr	r0, [r7, #28]
 8001030:	f7ff fcb5 	bl	800099e <xmp3fixpt_GetBits>
 8001034:	4603      	mov	r3, r0
 8001036:	461a      	mov	r2, r3
 8001038:	69bb      	ldr	r3, [r7, #24]
 800103a:	621a      	str	r2, [r3, #32]
				sis->tableSelect[2] =  GetBits(bsi, 5);
 800103c:	2105      	movs	r1, #5
 800103e:	69f8      	ldr	r0, [r7, #28]
 8001040:	f7ff fcad 	bl	800099e <xmp3fixpt_GetBits>
 8001044:	4603      	mov	r3, r0
 8001046:	461a      	mov	r2, r3
 8001048:	69bb      	ldr	r3, [r7, #24]
 800104a:	625a      	str	r2, [r3, #36]	; 0x24
				sis->region0Count =    GetBits(bsi, 4);
 800104c:	2104      	movs	r1, #4
 800104e:	69f8      	ldr	r0, [r7, #28]
 8001050:	f7ff fca5 	bl	800099e <xmp3fixpt_GetBits>
 8001054:	4603      	mov	r3, r0
 8001056:	461a      	mov	r2, r3
 8001058:	69bb      	ldr	r3, [r7, #24]
 800105a:	635a      	str	r2, [r3, #52]	; 0x34
				sis->region1Count =    GetBits(bsi, 3);
 800105c:	2103      	movs	r1, #3
 800105e:	69f8      	ldr	r0, [r7, #28]
 8001060:	f7ff fc9d 	bl	800099e <xmp3fixpt_GetBits>
 8001064:	4603      	mov	r3, r0
 8001066:	461a      	mov	r2, r3
 8001068:	69bb      	ldr	r3, [r7, #24]
 800106a:	639a      	str	r2, [r3, #56]	; 0x38
			}
			sis->preFlag =           (fh->ver == MPEG1 ? GetBits(bsi, 1) : 0);
 800106c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800106e:	781b      	ldrb	r3, [r3, #0]
 8001070:	2b00      	cmp	r3, #0
 8001072:	d106      	bne.n	8001082 <xmp3fixpt_UnpackSideInfo+0x2da>
 8001074:	2101      	movs	r1, #1
 8001076:	69f8      	ldr	r0, [r7, #28]
 8001078:	f7ff fc91 	bl	800099e <xmp3fixpt_GetBits>
 800107c:	4603      	mov	r3, r0
 800107e:	461a      	mov	r2, r3
 8001080:	e000      	b.n	8001084 <xmp3fixpt_UnpackSideInfo+0x2dc>
 8001082:	2200      	movs	r2, #0
 8001084:	69bb      	ldr	r3, [r7, #24]
 8001086:	63da      	str	r2, [r3, #60]	; 0x3c
			sis->sfactScale =        GetBits(bsi, 1);
 8001088:	2101      	movs	r1, #1
 800108a:	69f8      	ldr	r0, [r7, #28]
 800108c:	f7ff fc87 	bl	800099e <xmp3fixpt_GetBits>
 8001090:	4603      	mov	r3, r0
 8001092:	461a      	mov	r2, r3
 8001094:	69bb      	ldr	r3, [r7, #24]
 8001096:	641a      	str	r2, [r3, #64]	; 0x40
			sis->count1TableSelect = GetBits(bsi, 1);
 8001098:	2101      	movs	r1, #1
 800109a:	69f8      	ldr	r0, [r7, #28]
 800109c:	f7ff fc7f 	bl	800099e <xmp3fixpt_GetBits>
 80010a0:	4603      	mov	r3, r0
 80010a2:	461a      	mov	r2, r3
 80010a4:	69bb      	ldr	r3, [r7, #24]
 80010a6:	645a      	str	r2, [r3, #68]	; 0x44
		for (ch = 0; ch < mp3DecInfo->nChans; ch++) {
 80010a8:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80010aa:	3301      	adds	r3, #1
 80010ac:	633b      	str	r3, [r7, #48]	; 0x30
 80010ae:	687b      	ldr	r3, [r7, #4]
 80010b0:	f8d3 27bc 	ldr.w	r2, [r3, #1980]	; 0x7bc
 80010b4:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80010b6:	429a      	cmp	r2, r3
 80010b8:	f73f af08 	bgt.w	8000ecc <xmp3fixpt_UnpackSideInfo+0x124>
	for(gr =0; gr < mp3DecInfo->nGrans; gr++) {
 80010bc:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 80010be:	3301      	adds	r3, #1
 80010c0:	637b      	str	r3, [r7, #52]	; 0x34
 80010c2:	687b      	ldr	r3, [r7, #4]
 80010c4:	f8d3 27c4 	ldr.w	r2, [r3, #1988]	; 0x7c4
 80010c8:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 80010ca:	429a      	cmp	r2, r3
 80010cc:	f73f aefb 	bgt.w	8000ec6 <xmp3fixpt_UnpackSideInfo+0x11e>
		}
	}
	mp3DecInfo->mainDataBegin = si->mainDataBegin;	/* needed by main decode loop */
 80010d0:	6a3b      	ldr	r3, [r7, #32]
 80010d2:	681a      	ldr	r2, [r3, #0]
 80010d4:	687b      	ldr	r3, [r7, #4]
 80010d6:	f8c3 27d8 	str.w	r2, [r3, #2008]	; 0x7d8

	ASSERT(nBytes == CalcBitsUsed(bsi, buf, 0) >> 3);

	return nBytes;	
 80010da:	6abb      	ldr	r3, [r7, #40]	; 0x28
}
 80010dc:	4618      	mov	r0, r3
 80010de:	3738      	adds	r7, #56	; 0x38
 80010e0:	46bd      	mov	sp, r7
 80010e2:	bd80      	pop	{r7, pc}

080010e4 <ClearBuffer>:
 * Return:      none
 *
 * Notes:       slow, platform-independent equivalent to memset(buf, 0, nBytes)
 **************************************************************************************/
static void ClearBuffer(void *buf, int nBytes)
{
 80010e4:	b480      	push	{r7}
 80010e6:	b085      	sub	sp, #20
 80010e8:	af00      	add	r7, sp, #0
 80010ea:	6078      	str	r0, [r7, #4]
 80010ec:	6039      	str	r1, [r7, #0]
	int i;
	unsigned char *cbuf = (unsigned char *)buf;
 80010ee:	687b      	ldr	r3, [r7, #4]
 80010f0:	60bb      	str	r3, [r7, #8]

	for (i = 0; i < nBytes; i++)
 80010f2:	2300      	movs	r3, #0
 80010f4:	60fb      	str	r3, [r7, #12]
 80010f6:	e007      	b.n	8001108 <ClearBuffer+0x24>
		cbuf[i] = 0;
 80010f8:	68fb      	ldr	r3, [r7, #12]
 80010fa:	68ba      	ldr	r2, [r7, #8]
 80010fc:	4413      	add	r3, r2
 80010fe:	2200      	movs	r2, #0
 8001100:	701a      	strb	r2, [r3, #0]
	for (i = 0; i < nBytes; i++)
 8001102:	68fb      	ldr	r3, [r7, #12]
 8001104:	3301      	adds	r3, #1
 8001106:	60fb      	str	r3, [r7, #12]
 8001108:	68fa      	ldr	r2, [r7, #12]
 800110a:	683b      	ldr	r3, [r7, #0]
 800110c:	429a      	cmp	r2, r3
 800110e:	dbf3      	blt.n	80010f8 <ClearBuffer+0x14>

	return;
 8001110:	bf00      	nop
}
 8001112:	3714      	adds	r7, #20
 8001114:	46bd      	mov	sp, r7
 8001116:	f85d 7b04 	ldr.w	r7, [sp], #4
 800111a:	4770      	bx	lr

0800111c <xmp3fixpt_AllocateBuffers>:
 *
 * Notes:       if one or more mallocs fail, function frees any buffers already
 *                allocated before returning
 **************************************************************************************/
MP3DecInfo *AllocateBuffers(void)
{
 800111c:	b580      	push	{r7, lr}
 800111e:	b088      	sub	sp, #32
 8001120:	af00      	add	r7, sp, #0
	static HuffmanInfo s_hi;
	static DequantInfo s_di;
	static IMDCTInfo s_mi;
	static SubbandInfo s_sbi;
	
	mp3DecInfo = &s_mp3DecInfo;
 8001122:	4b33      	ldr	r3, [pc, #204]	; (80011f0 <xmp3fixpt_AllocateBuffers+0xd4>)
 8001124:	61fb      	str	r3, [r7, #28]
	fh = &s_fh;
 8001126:	4b33      	ldr	r3, [pc, #204]	; (80011f4 <xmp3fixpt_AllocateBuffers+0xd8>)
 8001128:	61bb      	str	r3, [r7, #24]
	si = &s_si;
 800112a:	4b33      	ldr	r3, [pc, #204]	; (80011f8 <xmp3fixpt_AllocateBuffers+0xdc>)
 800112c:	617b      	str	r3, [r7, #20]
	sfi = &s_sfi;
 800112e:	4b33      	ldr	r3, [pc, #204]	; (80011fc <xmp3fixpt_AllocateBuffers+0xe0>)
 8001130:	613b      	str	r3, [r7, #16]
	hi = &s_hi;
 8001132:	4b33      	ldr	r3, [pc, #204]	; (8001200 <xmp3fixpt_AllocateBuffers+0xe4>)
 8001134:	60fb      	str	r3, [r7, #12]
	di = &s_di;
 8001136:	4b33      	ldr	r3, [pc, #204]	; (8001204 <xmp3fixpt_AllocateBuffers+0xe8>)
 8001138:	60bb      	str	r3, [r7, #8]
	mi = &s_mi;
 800113a:	4b33      	ldr	r3, [pc, #204]	; (8001208 <xmp3fixpt_AllocateBuffers+0xec>)
 800113c:	607b      	str	r3, [r7, #4]
	sbi = &s_sbi;
 800113e:	4b33      	ldr	r3, [pc, #204]	; (800120c <xmp3fixpt_AllocateBuffers+0xf0>)
 8001140:	603b      	str	r3, [r7, #0]
//	hi =  (HuffmanInfo *)     malloc(sizeof(HuffmanInfo));
//	di =  (DequantInfo *)     malloc(sizeof(DequantInfo));
//	mi =  (IMDCTInfo *)       malloc(sizeof(IMDCTInfo));
//	sbi = (SubbandInfo *)     malloc(sizeof(SubbandInfo));

	mp3DecInfo->FrameHeaderPS =     (void *)fh;
 8001142:	69fb      	ldr	r3, [r7, #28]
 8001144:	69ba      	ldr	r2, [r7, #24]
 8001146:	601a      	str	r2, [r3, #0]
	mp3DecInfo->SideInfoPS =        (void *)si;
 8001148:	69fb      	ldr	r3, [r7, #28]
 800114a:	697a      	ldr	r2, [r7, #20]
 800114c:	605a      	str	r2, [r3, #4]
	mp3DecInfo->ScaleFactorInfoPS = (void *)sfi;
 800114e:	69fb      	ldr	r3, [r7, #28]
 8001150:	693a      	ldr	r2, [r7, #16]
 8001152:	609a      	str	r2, [r3, #8]
	mp3DecInfo->HuffmanInfoPS =     (void *)hi;
 8001154:	69fb      	ldr	r3, [r7, #28]
 8001156:	68fa      	ldr	r2, [r7, #12]
 8001158:	60da      	str	r2, [r3, #12]
	mp3DecInfo->DequantInfoPS =     (void *)di;
 800115a:	69fb      	ldr	r3, [r7, #28]
 800115c:	68ba      	ldr	r2, [r7, #8]
 800115e:	611a      	str	r2, [r3, #16]
	mp3DecInfo->IMDCTInfoPS =       (void *)mi;
 8001160:	69fb      	ldr	r3, [r7, #28]
 8001162:	687a      	ldr	r2, [r7, #4]
 8001164:	615a      	str	r2, [r3, #20]
	mp3DecInfo->SubbandInfoPS =     (void *)sbi;
 8001166:	69fb      	ldr	r3, [r7, #28]
 8001168:	683a      	ldr	r2, [r7, #0]
 800116a:	619a      	str	r2, [r3, #24]

	if (!fh || !si || !sfi || !hi || !di || !mi || !sbi) {
 800116c:	69bb      	ldr	r3, [r7, #24]
 800116e:	2b00      	cmp	r3, #0
 8001170:	d011      	beq.n	8001196 <xmp3fixpt_AllocateBuffers+0x7a>
 8001172:	697b      	ldr	r3, [r7, #20]
 8001174:	2b00      	cmp	r3, #0
 8001176:	d00e      	beq.n	8001196 <xmp3fixpt_AllocateBuffers+0x7a>
 8001178:	693b      	ldr	r3, [r7, #16]
 800117a:	2b00      	cmp	r3, #0
 800117c:	d00b      	beq.n	8001196 <xmp3fixpt_AllocateBuffers+0x7a>
 800117e:	68fb      	ldr	r3, [r7, #12]
 8001180:	2b00      	cmp	r3, #0
 8001182:	d008      	beq.n	8001196 <xmp3fixpt_AllocateBuffers+0x7a>
 8001184:	68bb      	ldr	r3, [r7, #8]
 8001186:	2b00      	cmp	r3, #0
 8001188:	d005      	beq.n	8001196 <xmp3fixpt_AllocateBuffers+0x7a>
 800118a:	687b      	ldr	r3, [r7, #4]
 800118c:	2b00      	cmp	r3, #0
 800118e:	d002      	beq.n	8001196 <xmp3fixpt_AllocateBuffers+0x7a>
 8001190:	683b      	ldr	r3, [r7, #0]
 8001192:	2b00      	cmp	r3, #0
 8001194:	d104      	bne.n	80011a0 <xmp3fixpt_AllocateBuffers+0x84>
		FreeBuffers(mp3DecInfo);	/* safe to call - only frees memory that was successfully allocated */
 8001196:	69f8      	ldr	r0, [r7, #28]
 8001198:	f000 f83a 	bl	8001210 <xmp3fixpt_FreeBuffers>
		return 0;
 800119c:	2300      	movs	r3, #0
 800119e:	e022      	b.n	80011e6 <xmp3fixpt_AllocateBuffers+0xca>
	}

	/* important to do this - DSP primitives assume a bunch of state variables are 0 on first use */
	ClearBuffer(fh,  sizeof(FrameHeader));
 80011a0:	2138      	movs	r1, #56	; 0x38
 80011a2:	69b8      	ldr	r0, [r7, #24]
 80011a4:	f7ff ff9e 	bl	80010e4 <ClearBuffer>
	ClearBuffer(si,  sizeof(SideInfo));
 80011a8:	f44f 71a4 	mov.w	r1, #328	; 0x148
 80011ac:	6978      	ldr	r0, [r7, #20]
 80011ae:	f7ff ff99 	bl	80010e4 <ClearBuffer>
	ClearBuffer(sfi, sizeof(ScaleFactorInfo));
 80011b2:	f44f 718e 	mov.w	r1, #284	; 0x11c
 80011b6:	6938      	ldr	r0, [r7, #16]
 80011b8:	f7ff ff94 	bl	80010e4 <ClearBuffer>
	ClearBuffer(hi,  sizeof(HuffmanInfo));
 80011bc:	f241 2110 	movw	r1, #4624	; 0x1210
 80011c0:	68f8      	ldr	r0, [r7, #12]
 80011c2:	f7ff ff8f 	bl	80010e4 <ClearBuffer>
	ClearBuffer(di,  sizeof(DequantInfo));
 80011c6:	f44f 7152 	mov.w	r1, #840	; 0x348
 80011ca:	68b8      	ldr	r0, [r7, #8]
 80011cc:	f7ff ff8a 	bl	80010e4 <ClearBuffer>
	ClearBuffer(mi,  sizeof(IMDCTInfo));
 80011d0:	f44f 51d9 	mov.w	r1, #6944	; 0x1b20
 80011d4:	6878      	ldr	r0, [r7, #4]
 80011d6:	f7ff ff85 	bl	80010e4 <ClearBuffer>
	ClearBuffer(sbi, sizeof(SubbandInfo));
 80011da:	f242 2104 	movw	r1, #8708	; 0x2204
 80011de:	6838      	ldr	r0, [r7, #0]
 80011e0:	f7ff ff80 	bl	80010e4 <ClearBuffer>

	return mp3DecInfo;
 80011e4:	69fb      	ldr	r3, [r7, #28]
}
 80011e6:	4618      	mov	r0, r3
 80011e8:	3720      	adds	r7, #32
 80011ea:	46bd      	mov	sp, r7
 80011ec:	bd80      	pop	{r7, pc}
 80011ee:	bf00      	nop
 80011f0:	200000b4 	.word	0x200000b4
 80011f4:	200008a4 	.word	0x200008a4
 80011f8:	200008dc 	.word	0x200008dc
 80011fc:	20000a24 	.word	0x20000a24
 8001200:	20000b40 	.word	0x20000b40
 8001204:	20001d50 	.word	0x20001d50
 8001208:	20002098 	.word	0x20002098
 800120c:	20003bb8 	.word	0x20003bb8

08001210 <xmp3fixpt_FreeBuffers>:
 * Return:      none
 *
 * Notes:       safe to call even if some buffers were not allocated (uses SAFE_FREE)
 **************************************************************************************/
void FreeBuffers(MP3DecInfo *mp3DecInfo)
{
 8001210:	b480      	push	{r7}
 8001212:	b083      	sub	sp, #12
 8001214:	af00      	add	r7, sp, #0
 8001216:	6078      	str	r0, [r7, #4]
	if (!mp3DecInfo)
 8001218:	687b      	ldr	r3, [r7, #4]
 800121a:	2b00      	cmp	r3, #0
//	SAFE_FREE(mp3DecInfo->DequantInfoPS);
//	SAFE_FREE(mp3DecInfo->IMDCTInfoPS);
//	SAFE_FREE(mp3DecInfo->SubbandInfoPS);
//
//	SAFE_FREE(mp3DecInfo);
}
 800121c:	370c      	adds	r7, #12
 800121e:	46bd      	mov	sp, r7
 8001220:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001224:	4770      	bx	lr
 8001226:	bf00      	nop

08001228 <MULSHIFT32>:
	return numZeros;
}

#elif defined(ARM_TEST)
static __inline__ int MULSHIFT32(int x, int y)
{
 8001228:	b480      	push	{r7}
 800122a:	b085      	sub	sp, #20
 800122c:	af00      	add	r7, sp, #0
 800122e:	6078      	str	r0, [r7, #4]
 8001230:	6039      	str	r1, [r7, #0]
	int zlow;
	__asm__ volatile ("smull %0,%1,%2,%3" : "=&r" (zlow), "=r" (y) : "r" (x), "1" (y) : "cc");
 8001232:	6879      	ldr	r1, [r7, #4]
 8001234:	683b      	ldr	r3, [r7, #0]
 8001236:	fb81 2303 	smull	r2, r3, r1, r3
 800123a:	60fa      	str	r2, [r7, #12]
 800123c:	603b      	str	r3, [r7, #0]
	return y;
 800123e:	683b      	ldr	r3, [r7, #0]
}
 8001240:	4618      	mov	r0, r3
 8001242:	3714      	adds	r7, #20
 8001244:	46bd      	mov	sp, r7
 8001246:	f85d 7b04 	ldr.w	r7, [sp], #4
 800124a:	4770      	bx	lr

0800124c <xmp3fixpt_FDCT32>:
 * TODO:        code organization and optimization for ARM
 *              possibly interleave stereo (cut # of coef loads in half - may not have
 *                enough registers)
 **************************************************************************************/
void FDCT32(int *buf, int *dest, int offset, int oddBlock, int gb)
{
 800124c:	b590      	push	{r4, r7, lr}
 800124e:	b09f      	sub	sp, #124	; 0x7c
 8001250:	af00      	add	r7, sp, #0
 8001252:	60f8      	str	r0, [r7, #12]
 8001254:	60b9      	str	r1, [r7, #8]
 8001256:	607a      	str	r2, [r7, #4]
 8001258:	603b      	str	r3, [r7, #0]
    int i, s, tmp, es;
    const int *cptr = dcttab;
 800125a:	4b08      	ldr	r3, [pc, #32]	; (800127c <xmp3fixpt_FDCT32+0x30>)
 800125c:	66bb      	str	r3, [r7, #104]	; 0x68

	/* scaling - ensure at least 6 guard bits for DCT 
	 * (in practice this is already true 99% of time, so this code is
	 *  almost never triggered)
	 */
	es = 0;
 800125e:	2300      	movs	r3, #0
 8001260:	66fb      	str	r3, [r7, #108]	; 0x6c
	if (gb < 6) {
 8001262:	f8d7 3088 	ldr.w	r3, [r7, #136]	; 0x88
 8001266:	2b05      	cmp	r3, #5
 8001268:	dc1d      	bgt.n	80012a6 <xmp3fixpt_FDCT32+0x5a>
		es = 6 - gb;
 800126a:	f8d7 3088 	ldr.w	r3, [r7, #136]	; 0x88
 800126e:	f1c3 0306 	rsb	r3, r3, #6
 8001272:	66fb      	str	r3, [r7, #108]	; 0x6c
		for (i = 0; i < 32; i++)
 8001274:	2300      	movs	r3, #0
 8001276:	677b      	str	r3, [r7, #116]	; 0x74
 8001278:	e012      	b.n	80012a0 <xmp3fixpt_FDCT32+0x54>
 800127a:	bf00      	nop
 800127c:	08017b50 	.word	0x08017b50
			buf[i] >>= es;
 8001280:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 8001282:	009b      	lsls	r3, r3, #2
 8001284:	68fa      	ldr	r2, [r7, #12]
 8001286:	4413      	add	r3, r2
 8001288:	6f7a      	ldr	r2, [r7, #116]	; 0x74
 800128a:	0092      	lsls	r2, r2, #2
 800128c:	68f9      	ldr	r1, [r7, #12]
 800128e:	440a      	add	r2, r1
 8001290:	6811      	ldr	r1, [r2, #0]
 8001292:	6efa      	ldr	r2, [r7, #108]	; 0x6c
 8001294:	fa41 f202 	asr.w	r2, r1, r2
 8001298:	601a      	str	r2, [r3, #0]
		for (i = 0; i < 32; i++)
 800129a:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 800129c:	3301      	adds	r3, #1
 800129e:	677b      	str	r3, [r7, #116]	; 0x74
 80012a0:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 80012a2:	2b1f      	cmp	r3, #31
 80012a4:	ddec      	ble.n	8001280 <xmp3fixpt_FDCT32+0x34>
	}

	/* first pass */    
	D32FP(0, 1, 5, 1);
 80012a6:	68fb      	ldr	r3, [r7, #12]
 80012a8:	681b      	ldr	r3, [r3, #0]
 80012aa:	663b      	str	r3, [r7, #96]	; 0x60
 80012ac:	68fb      	ldr	r3, [r7, #12]
 80012ae:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
 80012b0:	65fb      	str	r3, [r7, #92]	; 0x5c
 80012b2:	68fb      	ldr	r3, [r7, #12]
 80012b4:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 80012b6:	65bb      	str	r3, [r7, #88]	; 0x58
 80012b8:	68fb      	ldr	r3, [r7, #12]
 80012ba:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 80012bc:	657b      	str	r3, [r7, #84]	; 0x54
 80012be:	6e3a      	ldr	r2, [r7, #96]	; 0x60
 80012c0:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 80012c2:	4413      	add	r3, r2
 80012c4:	653b      	str	r3, [r7, #80]	; 0x50
 80012c6:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 80012c8:	1d1a      	adds	r2, r3, #4
 80012ca:	66ba      	str	r2, [r7, #104]	; 0x68
 80012cc:	6818      	ldr	r0, [r3, #0]
 80012ce:	6e3a      	ldr	r2, [r7, #96]	; 0x60
 80012d0:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 80012d2:	1ad3      	subs	r3, r2, r3
 80012d4:	4619      	mov	r1, r3
 80012d6:	f7ff ffa7 	bl	8001228 <MULSHIFT32>
 80012da:	4603      	mov	r3, r0
 80012dc:	005b      	lsls	r3, r3, #1
 80012de:	64fb      	str	r3, [r7, #76]	; 0x4c
 80012e0:	6dba      	ldr	r2, [r7, #88]	; 0x58
 80012e2:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 80012e4:	4413      	add	r3, r2
 80012e6:	64bb      	str	r3, [r7, #72]	; 0x48
 80012e8:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 80012ea:	1d1a      	adds	r2, r3, #4
 80012ec:	66ba      	str	r2, [r7, #104]	; 0x68
 80012ee:	6818      	ldr	r0, [r3, #0]
 80012f0:	6dba      	ldr	r2, [r7, #88]	; 0x58
 80012f2:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 80012f4:	1ad3      	subs	r3, r2, r3
 80012f6:	4619      	mov	r1, r3
 80012f8:	f7ff ff96 	bl	8001228 <MULSHIFT32>
 80012fc:	4603      	mov	r3, r0
 80012fe:	015b      	lsls	r3, r3, #5
 8001300:	647b      	str	r3, [r7, #68]	; 0x44
 8001302:	6d3a      	ldr	r2, [r7, #80]	; 0x50
 8001304:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8001306:	441a      	add	r2, r3
 8001308:	68fb      	ldr	r3, [r7, #12]
 800130a:	601a      	str	r2, [r3, #0]
 800130c:	68fb      	ldr	r3, [r7, #12]
 800130e:	f103 043c 	add.w	r4, r3, #60	; 0x3c
 8001312:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 8001314:	6818      	ldr	r0, [r3, #0]
 8001316:	6d3a      	ldr	r2, [r7, #80]	; 0x50
 8001318:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 800131a:	1ad3      	subs	r3, r2, r3
 800131c:	4619      	mov	r1, r3
 800131e:	f7ff ff83 	bl	8001228 <MULSHIFT32>
 8001322:	4603      	mov	r3, r0
 8001324:	005b      	lsls	r3, r3, #1
 8001326:	6023      	str	r3, [r4, #0]
 8001328:	68fb      	ldr	r3, [r7, #12]
 800132a:	3340      	adds	r3, #64	; 0x40
 800132c:	6c79      	ldr	r1, [r7, #68]	; 0x44
 800132e:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
 8001330:	440a      	add	r2, r1
 8001332:	601a      	str	r2, [r3, #0]
 8001334:	68fb      	ldr	r3, [r7, #12]
 8001336:	f103 047c 	add.w	r4, r3, #124	; 0x7c
 800133a:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 800133c:	1d1a      	adds	r2, r3, #4
 800133e:	66ba      	str	r2, [r7, #104]	; 0x68
 8001340:	6818      	ldr	r0, [r3, #0]
 8001342:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
 8001344:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8001346:	1ad3      	subs	r3, r2, r3
 8001348:	4619      	mov	r1, r3
 800134a:	f7ff ff6d 	bl	8001228 <MULSHIFT32>
 800134e:	4603      	mov	r3, r0
 8001350:	005b      	lsls	r3, r3, #1
 8001352:	6023      	str	r3, [r4, #0]
	D32FP(1, 1, 3, 1);
 8001354:	68fb      	ldr	r3, [r7, #12]
 8001356:	685b      	ldr	r3, [r3, #4]
 8001358:	663b      	str	r3, [r7, #96]	; 0x60
 800135a:	68fb      	ldr	r3, [r7, #12]
 800135c:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 800135e:	65fb      	str	r3, [r7, #92]	; 0x5c
 8001360:	68fb      	ldr	r3, [r7, #12]
 8001362:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8001364:	65bb      	str	r3, [r7, #88]	; 0x58
 8001366:	68fb      	ldr	r3, [r7, #12]
 8001368:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800136a:	657b      	str	r3, [r7, #84]	; 0x54
 800136c:	6e3a      	ldr	r2, [r7, #96]	; 0x60
 800136e:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 8001370:	4413      	add	r3, r2
 8001372:	653b      	str	r3, [r7, #80]	; 0x50
 8001374:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 8001376:	1d1a      	adds	r2, r3, #4
 8001378:	66ba      	str	r2, [r7, #104]	; 0x68
 800137a:	6818      	ldr	r0, [r3, #0]
 800137c:	6e3a      	ldr	r2, [r7, #96]	; 0x60
 800137e:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 8001380:	1ad3      	subs	r3, r2, r3
 8001382:	4619      	mov	r1, r3
 8001384:	f7ff ff50 	bl	8001228 <MULSHIFT32>
 8001388:	4603      	mov	r3, r0
 800138a:	005b      	lsls	r3, r3, #1
 800138c:	64fb      	str	r3, [r7, #76]	; 0x4c
 800138e:	6dba      	ldr	r2, [r7, #88]	; 0x58
 8001390:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8001392:	4413      	add	r3, r2
 8001394:	64bb      	str	r3, [r7, #72]	; 0x48
 8001396:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 8001398:	1d1a      	adds	r2, r3, #4
 800139a:	66ba      	str	r2, [r7, #104]	; 0x68
 800139c:	6818      	ldr	r0, [r3, #0]
 800139e:	6dba      	ldr	r2, [r7, #88]	; 0x58
 80013a0:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 80013a2:	1ad3      	subs	r3, r2, r3
 80013a4:	4619      	mov	r1, r3
 80013a6:	f7ff ff3f 	bl	8001228 <MULSHIFT32>
 80013aa:	4603      	mov	r3, r0
 80013ac:	00db      	lsls	r3, r3, #3
 80013ae:	647b      	str	r3, [r7, #68]	; 0x44
 80013b0:	68fb      	ldr	r3, [r7, #12]
 80013b2:	3304      	adds	r3, #4
 80013b4:	6d39      	ldr	r1, [r7, #80]	; 0x50
 80013b6:	6cba      	ldr	r2, [r7, #72]	; 0x48
 80013b8:	440a      	add	r2, r1
 80013ba:	601a      	str	r2, [r3, #0]
 80013bc:	68fb      	ldr	r3, [r7, #12]
 80013be:	f103 0438 	add.w	r4, r3, #56	; 0x38
 80013c2:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 80013c4:	6818      	ldr	r0, [r3, #0]
 80013c6:	6d3a      	ldr	r2, [r7, #80]	; 0x50
 80013c8:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 80013ca:	1ad3      	subs	r3, r2, r3
 80013cc:	4619      	mov	r1, r3
 80013ce:	f7ff ff2b 	bl	8001228 <MULSHIFT32>
 80013d2:	4603      	mov	r3, r0
 80013d4:	005b      	lsls	r3, r3, #1
 80013d6:	6023      	str	r3, [r4, #0]
 80013d8:	68fb      	ldr	r3, [r7, #12]
 80013da:	3344      	adds	r3, #68	; 0x44
 80013dc:	6c79      	ldr	r1, [r7, #68]	; 0x44
 80013de:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
 80013e0:	440a      	add	r2, r1
 80013e2:	601a      	str	r2, [r3, #0]
 80013e4:	68fb      	ldr	r3, [r7, #12]
 80013e6:	f103 0478 	add.w	r4, r3, #120	; 0x78
 80013ea:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 80013ec:	1d1a      	adds	r2, r3, #4
 80013ee:	66ba      	str	r2, [r7, #104]	; 0x68
 80013f0:	6818      	ldr	r0, [r3, #0]
 80013f2:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
 80013f4:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 80013f6:	1ad3      	subs	r3, r2, r3
 80013f8:	4619      	mov	r1, r3
 80013fa:	f7ff ff15 	bl	8001228 <MULSHIFT32>
 80013fe:	4603      	mov	r3, r0
 8001400:	005b      	lsls	r3, r3, #1
 8001402:	6023      	str	r3, [r4, #0]
	D32FP(2, 1, 3, 1);
 8001404:	68fb      	ldr	r3, [r7, #12]
 8001406:	689b      	ldr	r3, [r3, #8]
 8001408:	663b      	str	r3, [r7, #96]	; 0x60
 800140a:	68fb      	ldr	r3, [r7, #12]
 800140c:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 800140e:	65fb      	str	r3, [r7, #92]	; 0x5c
 8001410:	68fb      	ldr	r3, [r7, #12]
 8001412:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8001414:	65bb      	str	r3, [r7, #88]	; 0x58
 8001416:	68fb      	ldr	r3, [r7, #12]
 8001418:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 800141a:	657b      	str	r3, [r7, #84]	; 0x54
 800141c:	6e3a      	ldr	r2, [r7, #96]	; 0x60
 800141e:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 8001420:	4413      	add	r3, r2
 8001422:	653b      	str	r3, [r7, #80]	; 0x50
 8001424:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 8001426:	1d1a      	adds	r2, r3, #4
 8001428:	66ba      	str	r2, [r7, #104]	; 0x68
 800142a:	6818      	ldr	r0, [r3, #0]
 800142c:	6e3a      	ldr	r2, [r7, #96]	; 0x60
 800142e:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 8001430:	1ad3      	subs	r3, r2, r3
 8001432:	4619      	mov	r1, r3
 8001434:	f7ff fef8 	bl	8001228 <MULSHIFT32>
 8001438:	4603      	mov	r3, r0
 800143a:	005b      	lsls	r3, r3, #1
 800143c:	64fb      	str	r3, [r7, #76]	; 0x4c
 800143e:	6dba      	ldr	r2, [r7, #88]	; 0x58
 8001440:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8001442:	4413      	add	r3, r2
 8001444:	64bb      	str	r3, [r7, #72]	; 0x48
 8001446:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 8001448:	1d1a      	adds	r2, r3, #4
 800144a:	66ba      	str	r2, [r7, #104]	; 0x68
 800144c:	6818      	ldr	r0, [r3, #0]
 800144e:	6dba      	ldr	r2, [r7, #88]	; 0x58
 8001450:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8001452:	1ad3      	subs	r3, r2, r3
 8001454:	4619      	mov	r1, r3
 8001456:	f7ff fee7 	bl	8001228 <MULSHIFT32>
 800145a:	4603      	mov	r3, r0
 800145c:	00db      	lsls	r3, r3, #3
 800145e:	647b      	str	r3, [r7, #68]	; 0x44
 8001460:	68fb      	ldr	r3, [r7, #12]
 8001462:	3308      	adds	r3, #8
 8001464:	6d39      	ldr	r1, [r7, #80]	; 0x50
 8001466:	6cba      	ldr	r2, [r7, #72]	; 0x48
 8001468:	440a      	add	r2, r1
 800146a:	601a      	str	r2, [r3, #0]
 800146c:	68fb      	ldr	r3, [r7, #12]
 800146e:	f103 0434 	add.w	r4, r3, #52	; 0x34
 8001472:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 8001474:	6818      	ldr	r0, [r3, #0]
 8001476:	6d3a      	ldr	r2, [r7, #80]	; 0x50
 8001478:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 800147a:	1ad3      	subs	r3, r2, r3
 800147c:	4619      	mov	r1, r3
 800147e:	f7ff fed3 	bl	8001228 <MULSHIFT32>
 8001482:	4603      	mov	r3, r0
 8001484:	005b      	lsls	r3, r3, #1
 8001486:	6023      	str	r3, [r4, #0]
 8001488:	68fb      	ldr	r3, [r7, #12]
 800148a:	3348      	adds	r3, #72	; 0x48
 800148c:	6c79      	ldr	r1, [r7, #68]	; 0x44
 800148e:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
 8001490:	440a      	add	r2, r1
 8001492:	601a      	str	r2, [r3, #0]
 8001494:	68fb      	ldr	r3, [r7, #12]
 8001496:	f103 0474 	add.w	r4, r3, #116	; 0x74
 800149a:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 800149c:	1d1a      	adds	r2, r3, #4
 800149e:	66ba      	str	r2, [r7, #104]	; 0x68
 80014a0:	6818      	ldr	r0, [r3, #0]
 80014a2:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
 80014a4:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 80014a6:	1ad3      	subs	r3, r2, r3
 80014a8:	4619      	mov	r1, r3
 80014aa:	f7ff febd 	bl	8001228 <MULSHIFT32>
 80014ae:	4603      	mov	r3, r0
 80014b0:	005b      	lsls	r3, r3, #1
 80014b2:	6023      	str	r3, [r4, #0]
	D32FP(3, 1, 2, 1);
 80014b4:	68fb      	ldr	r3, [r7, #12]
 80014b6:	68db      	ldr	r3, [r3, #12]
 80014b8:	663b      	str	r3, [r7, #96]	; 0x60
 80014ba:	68fb      	ldr	r3, [r7, #12]
 80014bc:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 80014be:	65fb      	str	r3, [r7, #92]	; 0x5c
 80014c0:	68fb      	ldr	r3, [r7, #12]
 80014c2:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80014c4:	65bb      	str	r3, [r7, #88]	; 0x58
 80014c6:	68fb      	ldr	r3, [r7, #12]
 80014c8:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 80014ca:	657b      	str	r3, [r7, #84]	; 0x54
 80014cc:	6e3a      	ldr	r2, [r7, #96]	; 0x60
 80014ce:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 80014d0:	4413      	add	r3, r2
 80014d2:	653b      	str	r3, [r7, #80]	; 0x50
 80014d4:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 80014d6:	1d1a      	adds	r2, r3, #4
 80014d8:	66ba      	str	r2, [r7, #104]	; 0x68
 80014da:	6818      	ldr	r0, [r3, #0]
 80014dc:	6e3a      	ldr	r2, [r7, #96]	; 0x60
 80014de:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 80014e0:	1ad3      	subs	r3, r2, r3
 80014e2:	4619      	mov	r1, r3
 80014e4:	f7ff fea0 	bl	8001228 <MULSHIFT32>
 80014e8:	4603      	mov	r3, r0
 80014ea:	005b      	lsls	r3, r3, #1
 80014ec:	64fb      	str	r3, [r7, #76]	; 0x4c
 80014ee:	6dba      	ldr	r2, [r7, #88]	; 0x58
 80014f0:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 80014f2:	4413      	add	r3, r2
 80014f4:	64bb      	str	r3, [r7, #72]	; 0x48
 80014f6:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 80014f8:	1d1a      	adds	r2, r3, #4
 80014fa:	66ba      	str	r2, [r7, #104]	; 0x68
 80014fc:	6818      	ldr	r0, [r3, #0]
 80014fe:	6dba      	ldr	r2, [r7, #88]	; 0x58
 8001500:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8001502:	1ad3      	subs	r3, r2, r3
 8001504:	4619      	mov	r1, r3
 8001506:	f7ff fe8f 	bl	8001228 <MULSHIFT32>
 800150a:	4603      	mov	r3, r0
 800150c:	009b      	lsls	r3, r3, #2
 800150e:	647b      	str	r3, [r7, #68]	; 0x44
 8001510:	68fb      	ldr	r3, [r7, #12]
 8001512:	330c      	adds	r3, #12
 8001514:	6d39      	ldr	r1, [r7, #80]	; 0x50
 8001516:	6cba      	ldr	r2, [r7, #72]	; 0x48
 8001518:	440a      	add	r2, r1
 800151a:	601a      	str	r2, [r3, #0]
 800151c:	68fb      	ldr	r3, [r7, #12]
 800151e:	f103 0430 	add.w	r4, r3, #48	; 0x30
 8001522:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 8001524:	6818      	ldr	r0, [r3, #0]
 8001526:	6d3a      	ldr	r2, [r7, #80]	; 0x50
 8001528:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 800152a:	1ad3      	subs	r3, r2, r3
 800152c:	4619      	mov	r1, r3
 800152e:	f7ff fe7b 	bl	8001228 <MULSHIFT32>
 8001532:	4603      	mov	r3, r0
 8001534:	005b      	lsls	r3, r3, #1
 8001536:	6023      	str	r3, [r4, #0]
 8001538:	68fb      	ldr	r3, [r7, #12]
 800153a:	334c      	adds	r3, #76	; 0x4c
 800153c:	6c79      	ldr	r1, [r7, #68]	; 0x44
 800153e:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
 8001540:	440a      	add	r2, r1
 8001542:	601a      	str	r2, [r3, #0]
 8001544:	68fb      	ldr	r3, [r7, #12]
 8001546:	f103 0470 	add.w	r4, r3, #112	; 0x70
 800154a:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 800154c:	1d1a      	adds	r2, r3, #4
 800154e:	66ba      	str	r2, [r7, #104]	; 0x68
 8001550:	6818      	ldr	r0, [r3, #0]
 8001552:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
 8001554:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8001556:	1ad3      	subs	r3, r2, r3
 8001558:	4619      	mov	r1, r3
 800155a:	f7ff fe65 	bl	8001228 <MULSHIFT32>
 800155e:	4603      	mov	r3, r0
 8001560:	005b      	lsls	r3, r3, #1
 8001562:	6023      	str	r3, [r4, #0]
	D32FP(4, 1, 2, 1);
 8001564:	68fb      	ldr	r3, [r7, #12]
 8001566:	691b      	ldr	r3, [r3, #16]
 8001568:	663b      	str	r3, [r7, #96]	; 0x60
 800156a:	68fb      	ldr	r3, [r7, #12]
 800156c:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 800156e:	65fb      	str	r3, [r7, #92]	; 0x5c
 8001570:	68fb      	ldr	r3, [r7, #12]
 8001572:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8001574:	65bb      	str	r3, [r7, #88]	; 0x58
 8001576:	68fb      	ldr	r3, [r7, #12]
 8001578:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 800157a:	657b      	str	r3, [r7, #84]	; 0x54
 800157c:	6e3a      	ldr	r2, [r7, #96]	; 0x60
 800157e:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 8001580:	4413      	add	r3, r2
 8001582:	653b      	str	r3, [r7, #80]	; 0x50
 8001584:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 8001586:	1d1a      	adds	r2, r3, #4
 8001588:	66ba      	str	r2, [r7, #104]	; 0x68
 800158a:	6818      	ldr	r0, [r3, #0]
 800158c:	6e3a      	ldr	r2, [r7, #96]	; 0x60
 800158e:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 8001590:	1ad3      	subs	r3, r2, r3
 8001592:	4619      	mov	r1, r3
 8001594:	f7ff fe48 	bl	8001228 <MULSHIFT32>
 8001598:	4603      	mov	r3, r0
 800159a:	005b      	lsls	r3, r3, #1
 800159c:	64fb      	str	r3, [r7, #76]	; 0x4c
 800159e:	6dba      	ldr	r2, [r7, #88]	; 0x58
 80015a0:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 80015a2:	4413      	add	r3, r2
 80015a4:	64bb      	str	r3, [r7, #72]	; 0x48
 80015a6:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 80015a8:	1d1a      	adds	r2, r3, #4
 80015aa:	66ba      	str	r2, [r7, #104]	; 0x68
 80015ac:	6818      	ldr	r0, [r3, #0]
 80015ae:	6dba      	ldr	r2, [r7, #88]	; 0x58
 80015b0:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 80015b2:	1ad3      	subs	r3, r2, r3
 80015b4:	4619      	mov	r1, r3
 80015b6:	f7ff fe37 	bl	8001228 <MULSHIFT32>
 80015ba:	4603      	mov	r3, r0
 80015bc:	009b      	lsls	r3, r3, #2
 80015be:	647b      	str	r3, [r7, #68]	; 0x44
 80015c0:	68fb      	ldr	r3, [r7, #12]
 80015c2:	3310      	adds	r3, #16
 80015c4:	6d39      	ldr	r1, [r7, #80]	; 0x50
 80015c6:	6cba      	ldr	r2, [r7, #72]	; 0x48
 80015c8:	440a      	add	r2, r1
 80015ca:	601a      	str	r2, [r3, #0]
 80015cc:	68fb      	ldr	r3, [r7, #12]
 80015ce:	f103 042c 	add.w	r4, r3, #44	; 0x2c
 80015d2:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 80015d4:	6818      	ldr	r0, [r3, #0]
 80015d6:	6d3a      	ldr	r2, [r7, #80]	; 0x50
 80015d8:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 80015da:	1ad3      	subs	r3, r2, r3
 80015dc:	4619      	mov	r1, r3
 80015de:	f7ff fe23 	bl	8001228 <MULSHIFT32>
 80015e2:	4603      	mov	r3, r0
 80015e4:	005b      	lsls	r3, r3, #1
 80015e6:	6023      	str	r3, [r4, #0]
 80015e8:	68fb      	ldr	r3, [r7, #12]
 80015ea:	3350      	adds	r3, #80	; 0x50
 80015ec:	6c79      	ldr	r1, [r7, #68]	; 0x44
 80015ee:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
 80015f0:	440a      	add	r2, r1
 80015f2:	601a      	str	r2, [r3, #0]
 80015f4:	68fb      	ldr	r3, [r7, #12]
 80015f6:	f103 046c 	add.w	r4, r3, #108	; 0x6c
 80015fa:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 80015fc:	1d1a      	adds	r2, r3, #4
 80015fe:	66ba      	str	r2, [r7, #104]	; 0x68
 8001600:	6818      	ldr	r0, [r3, #0]
 8001602:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
 8001604:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8001606:	1ad3      	subs	r3, r2, r3
 8001608:	4619      	mov	r1, r3
 800160a:	f7ff fe0d 	bl	8001228 <MULSHIFT32>
 800160e:	4603      	mov	r3, r0
 8001610:	005b      	lsls	r3, r3, #1
 8001612:	6023      	str	r3, [r4, #0]
	D32FP(5, 1, 1, 2);
 8001614:	68fb      	ldr	r3, [r7, #12]
 8001616:	695b      	ldr	r3, [r3, #20]
 8001618:	663b      	str	r3, [r7, #96]	; 0x60
 800161a:	68fb      	ldr	r3, [r7, #12]
 800161c:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 800161e:	65fb      	str	r3, [r7, #92]	; 0x5c
 8001620:	68fb      	ldr	r3, [r7, #12]
 8001622:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8001624:	65bb      	str	r3, [r7, #88]	; 0x58
 8001626:	68fb      	ldr	r3, [r7, #12]
 8001628:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 800162a:	657b      	str	r3, [r7, #84]	; 0x54
 800162c:	6e3a      	ldr	r2, [r7, #96]	; 0x60
 800162e:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 8001630:	4413      	add	r3, r2
 8001632:	653b      	str	r3, [r7, #80]	; 0x50
 8001634:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 8001636:	1d1a      	adds	r2, r3, #4
 8001638:	66ba      	str	r2, [r7, #104]	; 0x68
 800163a:	6818      	ldr	r0, [r3, #0]
 800163c:	6e3a      	ldr	r2, [r7, #96]	; 0x60
 800163e:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 8001640:	1ad3      	subs	r3, r2, r3
 8001642:	4619      	mov	r1, r3
 8001644:	f7ff fdf0 	bl	8001228 <MULSHIFT32>
 8001648:	4603      	mov	r3, r0
 800164a:	005b      	lsls	r3, r3, #1
 800164c:	64fb      	str	r3, [r7, #76]	; 0x4c
 800164e:	6dba      	ldr	r2, [r7, #88]	; 0x58
 8001650:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8001652:	4413      	add	r3, r2
 8001654:	64bb      	str	r3, [r7, #72]	; 0x48
 8001656:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 8001658:	1d1a      	adds	r2, r3, #4
 800165a:	66ba      	str	r2, [r7, #104]	; 0x68
 800165c:	6818      	ldr	r0, [r3, #0]
 800165e:	6dba      	ldr	r2, [r7, #88]	; 0x58
 8001660:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8001662:	1ad3      	subs	r3, r2, r3
 8001664:	4619      	mov	r1, r3
 8001666:	f7ff fddf 	bl	8001228 <MULSHIFT32>
 800166a:	4603      	mov	r3, r0
 800166c:	005b      	lsls	r3, r3, #1
 800166e:	647b      	str	r3, [r7, #68]	; 0x44
 8001670:	68fb      	ldr	r3, [r7, #12]
 8001672:	3314      	adds	r3, #20
 8001674:	6d39      	ldr	r1, [r7, #80]	; 0x50
 8001676:	6cba      	ldr	r2, [r7, #72]	; 0x48
 8001678:	440a      	add	r2, r1
 800167a:	601a      	str	r2, [r3, #0]
 800167c:	68fb      	ldr	r3, [r7, #12]
 800167e:	f103 0428 	add.w	r4, r3, #40	; 0x28
 8001682:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 8001684:	6818      	ldr	r0, [r3, #0]
 8001686:	6d3a      	ldr	r2, [r7, #80]	; 0x50
 8001688:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 800168a:	1ad3      	subs	r3, r2, r3
 800168c:	4619      	mov	r1, r3
 800168e:	f7ff fdcb 	bl	8001228 <MULSHIFT32>
 8001692:	4603      	mov	r3, r0
 8001694:	009b      	lsls	r3, r3, #2
 8001696:	6023      	str	r3, [r4, #0]
 8001698:	68fb      	ldr	r3, [r7, #12]
 800169a:	3354      	adds	r3, #84	; 0x54
 800169c:	6c79      	ldr	r1, [r7, #68]	; 0x44
 800169e:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
 80016a0:	440a      	add	r2, r1
 80016a2:	601a      	str	r2, [r3, #0]
 80016a4:	68fb      	ldr	r3, [r7, #12]
 80016a6:	f103 0468 	add.w	r4, r3, #104	; 0x68
 80016aa:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 80016ac:	1d1a      	adds	r2, r3, #4
 80016ae:	66ba      	str	r2, [r7, #104]	; 0x68
 80016b0:	6818      	ldr	r0, [r3, #0]
 80016b2:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
 80016b4:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 80016b6:	1ad3      	subs	r3, r2, r3
 80016b8:	4619      	mov	r1, r3
 80016ba:	f7ff fdb5 	bl	8001228 <MULSHIFT32>
 80016be:	4603      	mov	r3, r0
 80016c0:	009b      	lsls	r3, r3, #2
 80016c2:	6023      	str	r3, [r4, #0]
	D32FP(6, 1, 1, 2);
 80016c4:	68fb      	ldr	r3, [r7, #12]
 80016c6:	699b      	ldr	r3, [r3, #24]
 80016c8:	663b      	str	r3, [r7, #96]	; 0x60
 80016ca:	68fb      	ldr	r3, [r7, #12]
 80016cc:	6e5b      	ldr	r3, [r3, #100]	; 0x64
 80016ce:	65fb      	str	r3, [r7, #92]	; 0x5c
 80016d0:	68fb      	ldr	r3, [r7, #12]
 80016d2:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80016d4:	65bb      	str	r3, [r7, #88]	; 0x58
 80016d6:	68fb      	ldr	r3, [r7, #12]
 80016d8:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 80016da:	657b      	str	r3, [r7, #84]	; 0x54
 80016dc:	6e3a      	ldr	r2, [r7, #96]	; 0x60
 80016de:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 80016e0:	4413      	add	r3, r2
 80016e2:	653b      	str	r3, [r7, #80]	; 0x50
 80016e4:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 80016e6:	1d1a      	adds	r2, r3, #4
 80016e8:	66ba      	str	r2, [r7, #104]	; 0x68
 80016ea:	6818      	ldr	r0, [r3, #0]
 80016ec:	6e3a      	ldr	r2, [r7, #96]	; 0x60
 80016ee:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 80016f0:	1ad3      	subs	r3, r2, r3
 80016f2:	4619      	mov	r1, r3
 80016f4:	f7ff fd98 	bl	8001228 <MULSHIFT32>
 80016f8:	4603      	mov	r3, r0
 80016fa:	005b      	lsls	r3, r3, #1
 80016fc:	64fb      	str	r3, [r7, #76]	; 0x4c
 80016fe:	6dba      	ldr	r2, [r7, #88]	; 0x58
 8001700:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8001702:	4413      	add	r3, r2
 8001704:	64bb      	str	r3, [r7, #72]	; 0x48
 8001706:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 8001708:	1d1a      	adds	r2, r3, #4
 800170a:	66ba      	str	r2, [r7, #104]	; 0x68
 800170c:	6818      	ldr	r0, [r3, #0]
 800170e:	6dba      	ldr	r2, [r7, #88]	; 0x58
 8001710:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8001712:	1ad3      	subs	r3, r2, r3
 8001714:	4619      	mov	r1, r3
 8001716:	f7ff fd87 	bl	8001228 <MULSHIFT32>
 800171a:	4603      	mov	r3, r0
 800171c:	005b      	lsls	r3, r3, #1
 800171e:	647b      	str	r3, [r7, #68]	; 0x44
 8001720:	68fb      	ldr	r3, [r7, #12]
 8001722:	3318      	adds	r3, #24
 8001724:	6d39      	ldr	r1, [r7, #80]	; 0x50
 8001726:	6cba      	ldr	r2, [r7, #72]	; 0x48
 8001728:	440a      	add	r2, r1
 800172a:	601a      	str	r2, [r3, #0]
 800172c:	68fb      	ldr	r3, [r7, #12]
 800172e:	f103 0424 	add.w	r4, r3, #36	; 0x24
 8001732:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 8001734:	6818      	ldr	r0, [r3, #0]
 8001736:	6d3a      	ldr	r2, [r7, #80]	; 0x50
 8001738:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 800173a:	1ad3      	subs	r3, r2, r3
 800173c:	4619      	mov	r1, r3
 800173e:	f7ff fd73 	bl	8001228 <MULSHIFT32>
 8001742:	4603      	mov	r3, r0
 8001744:	009b      	lsls	r3, r3, #2
 8001746:	6023      	str	r3, [r4, #0]
 8001748:	68fb      	ldr	r3, [r7, #12]
 800174a:	3358      	adds	r3, #88	; 0x58
 800174c:	6c79      	ldr	r1, [r7, #68]	; 0x44
 800174e:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
 8001750:	440a      	add	r2, r1
 8001752:	601a      	str	r2, [r3, #0]
 8001754:	68fb      	ldr	r3, [r7, #12]
 8001756:	f103 0464 	add.w	r4, r3, #100	; 0x64
 800175a:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 800175c:	1d1a      	adds	r2, r3, #4
 800175e:	66ba      	str	r2, [r7, #104]	; 0x68
 8001760:	6818      	ldr	r0, [r3, #0]
 8001762:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
 8001764:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8001766:	1ad3      	subs	r3, r2, r3
 8001768:	4619      	mov	r1, r3
 800176a:	f7ff fd5d 	bl	8001228 <MULSHIFT32>
 800176e:	4603      	mov	r3, r0
 8001770:	009b      	lsls	r3, r3, #2
 8001772:	6023      	str	r3, [r4, #0]
	D32FP(7, 1, 1, 4);
 8001774:	68fb      	ldr	r3, [r7, #12]
 8001776:	69db      	ldr	r3, [r3, #28]
 8001778:	663b      	str	r3, [r7, #96]	; 0x60
 800177a:	68fb      	ldr	r3, [r7, #12]
 800177c:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 800177e:	65fb      	str	r3, [r7, #92]	; 0x5c
 8001780:	68fb      	ldr	r3, [r7, #12]
 8001782:	6a1b      	ldr	r3, [r3, #32]
 8001784:	65bb      	str	r3, [r7, #88]	; 0x58
 8001786:	68fb      	ldr	r3, [r7, #12]
 8001788:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 800178a:	657b      	str	r3, [r7, #84]	; 0x54
 800178c:	6e3a      	ldr	r2, [r7, #96]	; 0x60
 800178e:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 8001790:	4413      	add	r3, r2
 8001792:	653b      	str	r3, [r7, #80]	; 0x50
 8001794:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 8001796:	1d1a      	adds	r2, r3, #4
 8001798:	66ba      	str	r2, [r7, #104]	; 0x68
 800179a:	6818      	ldr	r0, [r3, #0]
 800179c:	6e3a      	ldr	r2, [r7, #96]	; 0x60
 800179e:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 80017a0:	1ad3      	subs	r3, r2, r3
 80017a2:	4619      	mov	r1, r3
 80017a4:	f7ff fd40 	bl	8001228 <MULSHIFT32>
 80017a8:	4603      	mov	r3, r0
 80017aa:	005b      	lsls	r3, r3, #1
 80017ac:	64fb      	str	r3, [r7, #76]	; 0x4c
 80017ae:	6dba      	ldr	r2, [r7, #88]	; 0x58
 80017b0:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 80017b2:	4413      	add	r3, r2
 80017b4:	64bb      	str	r3, [r7, #72]	; 0x48
 80017b6:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 80017b8:	1d1a      	adds	r2, r3, #4
 80017ba:	66ba      	str	r2, [r7, #104]	; 0x68
 80017bc:	6818      	ldr	r0, [r3, #0]
 80017be:	6dba      	ldr	r2, [r7, #88]	; 0x58
 80017c0:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 80017c2:	1ad3      	subs	r3, r2, r3
 80017c4:	4619      	mov	r1, r3
 80017c6:	f7ff fd2f 	bl	8001228 <MULSHIFT32>
 80017ca:	4603      	mov	r3, r0
 80017cc:	005b      	lsls	r3, r3, #1
 80017ce:	647b      	str	r3, [r7, #68]	; 0x44
 80017d0:	68fb      	ldr	r3, [r7, #12]
 80017d2:	331c      	adds	r3, #28
 80017d4:	6d39      	ldr	r1, [r7, #80]	; 0x50
 80017d6:	6cba      	ldr	r2, [r7, #72]	; 0x48
 80017d8:	440a      	add	r2, r1
 80017da:	601a      	str	r2, [r3, #0]
 80017dc:	68fb      	ldr	r3, [r7, #12]
 80017de:	f103 0420 	add.w	r4, r3, #32
 80017e2:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 80017e4:	6818      	ldr	r0, [r3, #0]
 80017e6:	6d3a      	ldr	r2, [r7, #80]	; 0x50
 80017e8:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 80017ea:	1ad3      	subs	r3, r2, r3
 80017ec:	4619      	mov	r1, r3
 80017ee:	f7ff fd1b 	bl	8001228 <MULSHIFT32>
 80017f2:	4603      	mov	r3, r0
 80017f4:	011b      	lsls	r3, r3, #4
 80017f6:	6023      	str	r3, [r4, #0]
 80017f8:	68fb      	ldr	r3, [r7, #12]
 80017fa:	335c      	adds	r3, #92	; 0x5c
 80017fc:	6c79      	ldr	r1, [r7, #68]	; 0x44
 80017fe:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
 8001800:	440a      	add	r2, r1
 8001802:	601a      	str	r2, [r3, #0]
 8001804:	68fb      	ldr	r3, [r7, #12]
 8001806:	f103 0460 	add.w	r4, r3, #96	; 0x60
 800180a:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 800180c:	1d1a      	adds	r2, r3, #4
 800180e:	66ba      	str	r2, [r7, #104]	; 0x68
 8001810:	6818      	ldr	r0, [r3, #0]
 8001812:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
 8001814:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8001816:	1ad3      	subs	r3, r2, r3
 8001818:	4619      	mov	r1, r3
 800181a:	f7ff fd05 	bl	8001228 <MULSHIFT32>
 800181e:	4603      	mov	r3, r0
 8001820:	011b      	lsls	r3, r3, #4
 8001822:	6023      	str	r3, [r4, #0]

	/* second pass */
	for (i = 4; i > 0; i--) {
 8001824:	2304      	movs	r3, #4
 8001826:	677b      	str	r3, [r7, #116]	; 0x74
 8001828:	e104      	b.n	8001a34 <xmp3fixpt_FDCT32+0x7e8>
		a0 = buf[0]; 	    a7 = buf[7];		a3 = buf[3];	    a4 = buf[4];
 800182a:	68fb      	ldr	r3, [r7, #12]
 800182c:	681b      	ldr	r3, [r3, #0]
 800182e:	663b      	str	r3, [r7, #96]	; 0x60
 8001830:	68fb      	ldr	r3, [r7, #12]
 8001832:	69db      	ldr	r3, [r3, #28]
 8001834:	643b      	str	r3, [r7, #64]	; 0x40
 8001836:	68fb      	ldr	r3, [r7, #12]
 8001838:	68db      	ldr	r3, [r3, #12]
 800183a:	65fb      	str	r3, [r7, #92]	; 0x5c
 800183c:	68fb      	ldr	r3, [r7, #12]
 800183e:	691b      	ldr	r3, [r3, #16]
 8001840:	63fb      	str	r3, [r7, #60]	; 0x3c
		b0 = a0 + a7;	    b7 = MULSHIFT32(*cptr++, a0 - a7) << 1;
 8001842:	6e3a      	ldr	r2, [r7, #96]	; 0x60
 8001844:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8001846:	4413      	add	r3, r2
 8001848:	653b      	str	r3, [r7, #80]	; 0x50
 800184a:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 800184c:	1d1a      	adds	r2, r3, #4
 800184e:	66ba      	str	r2, [r7, #104]	; 0x68
 8001850:	6818      	ldr	r0, [r3, #0]
 8001852:	6e3a      	ldr	r2, [r7, #96]	; 0x60
 8001854:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8001856:	1ad3      	subs	r3, r2, r3
 8001858:	4619      	mov	r1, r3
 800185a:	f7ff fce5 	bl	8001228 <MULSHIFT32>
 800185e:	4603      	mov	r3, r0
 8001860:	005b      	lsls	r3, r3, #1
 8001862:	63bb      	str	r3, [r7, #56]	; 0x38
		b3 = a3 + a4;	    b4 = MULSHIFT32(*cptr++, a3 - a4) << 3;
 8001864:	6dfa      	ldr	r2, [r7, #92]	; 0x5c
 8001866:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8001868:	4413      	add	r3, r2
 800186a:	64fb      	str	r3, [r7, #76]	; 0x4c
 800186c:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 800186e:	1d1a      	adds	r2, r3, #4
 8001870:	66ba      	str	r2, [r7, #104]	; 0x68
 8001872:	6818      	ldr	r0, [r3, #0]
 8001874:	6dfa      	ldr	r2, [r7, #92]	; 0x5c
 8001876:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8001878:	1ad3      	subs	r3, r2, r3
 800187a:	4619      	mov	r1, r3
 800187c:	f7ff fcd4 	bl	8001228 <MULSHIFT32>
 8001880:	4603      	mov	r3, r0
 8001882:	00db      	lsls	r3, r3, #3
 8001884:	637b      	str	r3, [r7, #52]	; 0x34
		a0 = b0 + b3;	    a3 = MULSHIFT32(*cptr,   b0 - b3) << 1;
 8001886:	6d3a      	ldr	r2, [r7, #80]	; 0x50
 8001888:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800188a:	4413      	add	r3, r2
 800188c:	663b      	str	r3, [r7, #96]	; 0x60
 800188e:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 8001890:	6818      	ldr	r0, [r3, #0]
 8001892:	6d3a      	ldr	r2, [r7, #80]	; 0x50
 8001894:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8001896:	1ad3      	subs	r3, r2, r3
 8001898:	4619      	mov	r1, r3
 800189a:	f7ff fcc5 	bl	8001228 <MULSHIFT32>
 800189e:	4603      	mov	r3, r0
 80018a0:	005b      	lsls	r3, r3, #1
 80018a2:	65fb      	str	r3, [r7, #92]	; 0x5c
		a4 = b4 + b7;		a7 = MULSHIFT32(*cptr++, b7 - b4) << 1;
 80018a4:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 80018a6:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 80018a8:	4413      	add	r3, r2
 80018aa:	63fb      	str	r3, [r7, #60]	; 0x3c
 80018ac:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 80018ae:	1d1a      	adds	r2, r3, #4
 80018b0:	66ba      	str	r2, [r7, #104]	; 0x68
 80018b2:	6818      	ldr	r0, [r3, #0]
 80018b4:	6bba      	ldr	r2, [r7, #56]	; 0x38
 80018b6:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 80018b8:	1ad3      	subs	r3, r2, r3
 80018ba:	4619      	mov	r1, r3
 80018bc:	f7ff fcb4 	bl	8001228 <MULSHIFT32>
 80018c0:	4603      	mov	r3, r0
 80018c2:	005b      	lsls	r3, r3, #1
 80018c4:	643b      	str	r3, [r7, #64]	; 0x40

		a1 = buf[1];	    a6 = buf[6];	    a2 = buf[2];	    a5 = buf[5];
 80018c6:	68fb      	ldr	r3, [r7, #12]
 80018c8:	685b      	ldr	r3, [r3, #4]
 80018ca:	65bb      	str	r3, [r7, #88]	; 0x58
 80018cc:	68fb      	ldr	r3, [r7, #12]
 80018ce:	699b      	ldr	r3, [r3, #24]
 80018d0:	633b      	str	r3, [r7, #48]	; 0x30
 80018d2:	68fb      	ldr	r3, [r7, #12]
 80018d4:	689b      	ldr	r3, [r3, #8]
 80018d6:	657b      	str	r3, [r7, #84]	; 0x54
 80018d8:	68fb      	ldr	r3, [r7, #12]
 80018da:	695b      	ldr	r3, [r3, #20]
 80018dc:	62fb      	str	r3, [r7, #44]	; 0x2c
		b1 = a1 + a6;	    b6 = MULSHIFT32(*cptr++, a1 - a6) << 1;
 80018de:	6dba      	ldr	r2, [r7, #88]	; 0x58
 80018e0:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80018e2:	4413      	add	r3, r2
 80018e4:	64bb      	str	r3, [r7, #72]	; 0x48
 80018e6:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 80018e8:	1d1a      	adds	r2, r3, #4
 80018ea:	66ba      	str	r2, [r7, #104]	; 0x68
 80018ec:	6818      	ldr	r0, [r3, #0]
 80018ee:	6dba      	ldr	r2, [r7, #88]	; 0x58
 80018f0:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80018f2:	1ad3      	subs	r3, r2, r3
 80018f4:	4619      	mov	r1, r3
 80018f6:	f7ff fc97 	bl	8001228 <MULSHIFT32>
 80018fa:	4603      	mov	r3, r0
 80018fc:	005b      	lsls	r3, r3, #1
 80018fe:	62bb      	str	r3, [r7, #40]	; 0x28
		b2 = a2 + a5;	    b5 = MULSHIFT32(*cptr++, a2 - a5) << 1;
 8001900:	6d7a      	ldr	r2, [r7, #84]	; 0x54
 8001902:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8001904:	4413      	add	r3, r2
 8001906:	647b      	str	r3, [r7, #68]	; 0x44
 8001908:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 800190a:	1d1a      	adds	r2, r3, #4
 800190c:	66ba      	str	r2, [r7, #104]	; 0x68
 800190e:	6818      	ldr	r0, [r3, #0]
 8001910:	6d7a      	ldr	r2, [r7, #84]	; 0x54
 8001912:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8001914:	1ad3      	subs	r3, r2, r3
 8001916:	4619      	mov	r1, r3
 8001918:	f7ff fc86 	bl	8001228 <MULSHIFT32>
 800191c:	4603      	mov	r3, r0
 800191e:	005b      	lsls	r3, r3, #1
 8001920:	627b      	str	r3, [r7, #36]	; 0x24
		a1 = b1 + b2;		a2 = MULSHIFT32(*cptr,   b1 - b2) << 2;
 8001922:	6cba      	ldr	r2, [r7, #72]	; 0x48
 8001924:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8001926:	4413      	add	r3, r2
 8001928:	65bb      	str	r3, [r7, #88]	; 0x58
 800192a:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 800192c:	6818      	ldr	r0, [r3, #0]
 800192e:	6cba      	ldr	r2, [r7, #72]	; 0x48
 8001930:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8001932:	1ad3      	subs	r3, r2, r3
 8001934:	4619      	mov	r1, r3
 8001936:	f7ff fc77 	bl	8001228 <MULSHIFT32>
 800193a:	4603      	mov	r3, r0
 800193c:	009b      	lsls	r3, r3, #2
 800193e:	657b      	str	r3, [r7, #84]	; 0x54
		a5 = b5 + b6;	    a6 = MULSHIFT32(*cptr++, b6 - b5) << 2;
 8001940:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8001942:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8001944:	4413      	add	r3, r2
 8001946:	62fb      	str	r3, [r7, #44]	; 0x2c
 8001948:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 800194a:	1d1a      	adds	r2, r3, #4
 800194c:	66ba      	str	r2, [r7, #104]	; 0x68
 800194e:	6818      	ldr	r0, [r3, #0]
 8001950:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8001952:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8001954:	1ad3      	subs	r3, r2, r3
 8001956:	4619      	mov	r1, r3
 8001958:	f7ff fc66 	bl	8001228 <MULSHIFT32>
 800195c:	4603      	mov	r3, r0
 800195e:	009b      	lsls	r3, r3, #2
 8001960:	633b      	str	r3, [r7, #48]	; 0x30

		b0 = a0 + a1;	    b1 = MULSHIFT32(COS4_0, a0 - a1) << 1;
 8001962:	6e3a      	ldr	r2, [r7, #96]	; 0x60
 8001964:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8001966:	4413      	add	r3, r2
 8001968:	653b      	str	r3, [r7, #80]	; 0x50
 800196a:	6e3a      	ldr	r2, [r7, #96]	; 0x60
 800196c:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 800196e:	1ad3      	subs	r3, r2, r3
 8001970:	4619      	mov	r1, r3
 8001972:	4846      	ldr	r0, [pc, #280]	; (8001a8c <xmp3fixpt_FDCT32+0x840>)
 8001974:	f7ff fc58 	bl	8001228 <MULSHIFT32>
 8001978:	4603      	mov	r3, r0
 800197a:	005b      	lsls	r3, r3, #1
 800197c:	64bb      	str	r3, [r7, #72]	; 0x48
		b2 = a2 + a3;	    b3 = MULSHIFT32(COS4_0, a3 - a2) << 1;
 800197e:	6d7a      	ldr	r2, [r7, #84]	; 0x54
 8001980:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 8001982:	4413      	add	r3, r2
 8001984:	647b      	str	r3, [r7, #68]	; 0x44
 8001986:	6dfa      	ldr	r2, [r7, #92]	; 0x5c
 8001988:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 800198a:	1ad3      	subs	r3, r2, r3
 800198c:	4619      	mov	r1, r3
 800198e:	483f      	ldr	r0, [pc, #252]	; (8001a8c <xmp3fixpt_FDCT32+0x840>)
 8001990:	f7ff fc4a 	bl	8001228 <MULSHIFT32>
 8001994:	4603      	mov	r3, r0
 8001996:	005b      	lsls	r3, r3, #1
 8001998:	64fb      	str	r3, [r7, #76]	; 0x4c
		buf[0] = b0;	    buf[1] = b1;
 800199a:	68fb      	ldr	r3, [r7, #12]
 800199c:	6d3a      	ldr	r2, [r7, #80]	; 0x50
 800199e:	601a      	str	r2, [r3, #0]
 80019a0:	68fb      	ldr	r3, [r7, #12]
 80019a2:	3304      	adds	r3, #4
 80019a4:	6cba      	ldr	r2, [r7, #72]	; 0x48
 80019a6:	601a      	str	r2, [r3, #0]
		buf[2] = b2 + b3;	buf[3] = b3;
 80019a8:	68fb      	ldr	r3, [r7, #12]
 80019aa:	3308      	adds	r3, #8
 80019ac:	6c79      	ldr	r1, [r7, #68]	; 0x44
 80019ae:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
 80019b0:	440a      	add	r2, r1
 80019b2:	601a      	str	r2, [r3, #0]
 80019b4:	68fb      	ldr	r3, [r7, #12]
 80019b6:	330c      	adds	r3, #12
 80019b8:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
 80019ba:	601a      	str	r2, [r3, #0]

		b4 = a4 + a5;	    b5 = MULSHIFT32(COS4_0, a4 - a5) << 1;
 80019bc:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 80019be:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80019c0:	4413      	add	r3, r2
 80019c2:	637b      	str	r3, [r7, #52]	; 0x34
 80019c4:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 80019c6:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80019c8:	1ad3      	subs	r3, r2, r3
 80019ca:	4619      	mov	r1, r3
 80019cc:	482f      	ldr	r0, [pc, #188]	; (8001a8c <xmp3fixpt_FDCT32+0x840>)
 80019ce:	f7ff fc2b 	bl	8001228 <MULSHIFT32>
 80019d2:	4603      	mov	r3, r0
 80019d4:	005b      	lsls	r3, r3, #1
 80019d6:	627b      	str	r3, [r7, #36]	; 0x24
		b6 = a6 + a7;	    b7 = MULSHIFT32(COS4_0, a7 - a6) << 1;
 80019d8:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 80019da:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 80019dc:	4413      	add	r3, r2
 80019de:	62bb      	str	r3, [r7, #40]	; 0x28
 80019e0:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 80019e2:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80019e4:	1ad3      	subs	r3, r2, r3
 80019e6:	4619      	mov	r1, r3
 80019e8:	4828      	ldr	r0, [pc, #160]	; (8001a8c <xmp3fixpt_FDCT32+0x840>)
 80019ea:	f7ff fc1d 	bl	8001228 <MULSHIFT32>
 80019ee:	4603      	mov	r3, r0
 80019f0:	005b      	lsls	r3, r3, #1
 80019f2:	63bb      	str	r3, [r7, #56]	; 0x38
		b6 += b7;
 80019f4:	6aba      	ldr	r2, [r7, #40]	; 0x28
 80019f6:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 80019f8:	4413      	add	r3, r2
 80019fa:	62bb      	str	r3, [r7, #40]	; 0x28
		buf[4] = b4 + b6;	buf[5] = b5 + b7;
 80019fc:	68fb      	ldr	r3, [r7, #12]
 80019fe:	3310      	adds	r3, #16
 8001a00:	6b79      	ldr	r1, [r7, #52]	; 0x34
 8001a02:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8001a04:	440a      	add	r2, r1
 8001a06:	601a      	str	r2, [r3, #0]
 8001a08:	68fb      	ldr	r3, [r7, #12]
 8001a0a:	3314      	adds	r3, #20
 8001a0c:	6a79      	ldr	r1, [r7, #36]	; 0x24
 8001a0e:	6bba      	ldr	r2, [r7, #56]	; 0x38
 8001a10:	440a      	add	r2, r1
 8001a12:	601a      	str	r2, [r3, #0]
		buf[6] = b5 + b6;	buf[7] = b7;
 8001a14:	68fb      	ldr	r3, [r7, #12]
 8001a16:	3318      	adds	r3, #24
 8001a18:	6a79      	ldr	r1, [r7, #36]	; 0x24
 8001a1a:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8001a1c:	440a      	add	r2, r1
 8001a1e:	601a      	str	r2, [r3, #0]
 8001a20:	68fb      	ldr	r3, [r7, #12]
 8001a22:	331c      	adds	r3, #28
 8001a24:	6bba      	ldr	r2, [r7, #56]	; 0x38
 8001a26:	601a      	str	r2, [r3, #0]

		buf += 8;
 8001a28:	68fb      	ldr	r3, [r7, #12]
 8001a2a:	3320      	adds	r3, #32
 8001a2c:	60fb      	str	r3, [r7, #12]
	for (i = 4; i > 0; i--) {
 8001a2e:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 8001a30:	3b01      	subs	r3, #1
 8001a32:	677b      	str	r3, [r7, #116]	; 0x74
 8001a34:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 8001a36:	2b00      	cmp	r3, #0
 8001a38:	f73f aef7 	bgt.w	800182a <xmp3fixpt_FDCT32+0x5de>
	}
	buf -= 32;	/* reset */
 8001a3c:	68fb      	ldr	r3, [r7, #12]
 8001a3e:	3b80      	subs	r3, #128	; 0x80
 8001a40:	60fb      	str	r3, [r7, #12]

	/* sample 0 - always delayed one block */
	d = dest + 64*16 + ((offset - oddBlock) & 7) + (oddBlock ? 0 : VBUF_LENGTH);
 8001a42:	687a      	ldr	r2, [r7, #4]
 8001a44:	683b      	ldr	r3, [r7, #0]
 8001a46:	1ad3      	subs	r3, r2, r3
 8001a48:	f003 0307 	and.w	r3, r3, #7
 8001a4c:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 8001a50:	009a      	lsls	r2, r3, #2
 8001a52:	683b      	ldr	r3, [r7, #0]
 8001a54:	2b00      	cmp	r3, #0
 8001a56:	d001      	beq.n	8001a5c <xmp3fixpt_FDCT32+0x810>
 8001a58:	2300      	movs	r3, #0
 8001a5a:	e001      	b.n	8001a60 <xmp3fixpt_FDCT32+0x814>
 8001a5c:	f44f 5388 	mov.w	r3, #4352	; 0x1100
 8001a60:	4413      	add	r3, r2
 8001a62:	68ba      	ldr	r2, [r7, #8]
 8001a64:	4413      	add	r3, r2
 8001a66:	667b      	str	r3, [r7, #100]	; 0x64
	s = buf[ 0];				d[0] = d[8] = s;
 8001a68:	68fb      	ldr	r3, [r7, #12]
 8001a6a:	681b      	ldr	r3, [r3, #0]
 8001a6c:	673b      	str	r3, [r7, #112]	; 0x70
 8001a6e:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8001a70:	3320      	adds	r3, #32
 8001a72:	6f3a      	ldr	r2, [r7, #112]	; 0x70
 8001a74:	601a      	str	r2, [r3, #0]
 8001a76:	681a      	ldr	r2, [r3, #0]
 8001a78:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8001a7a:	601a      	str	r2, [r3, #0]
    
	/* samples 16 to 31 */
	d = dest + offset + (oddBlock ? VBUF_LENGTH  : 0);
 8001a7c:	687b      	ldr	r3, [r7, #4]
 8001a7e:	009a      	lsls	r2, r3, #2
 8001a80:	683b      	ldr	r3, [r7, #0]
 8001a82:	2b00      	cmp	r3, #0
 8001a84:	d004      	beq.n	8001a90 <xmp3fixpt_FDCT32+0x844>
 8001a86:	f44f 5388 	mov.w	r3, #4352	; 0x1100
 8001a8a:	e002      	b.n	8001a92 <xmp3fixpt_FDCT32+0x846>
 8001a8c:	5a82799a 	.word	0x5a82799a
 8001a90:	2300      	movs	r3, #0
 8001a92:	4413      	add	r3, r2
 8001a94:	68ba      	ldr	r2, [r7, #8]
 8001a96:	4413      	add	r3, r2
 8001a98:	667b      	str	r3, [r7, #100]	; 0x64

	s = buf[ 1];				d[0] = d[8] = s;	d += 64;
 8001a9a:	68fb      	ldr	r3, [r7, #12]
 8001a9c:	685b      	ldr	r3, [r3, #4]
 8001a9e:	673b      	str	r3, [r7, #112]	; 0x70
 8001aa0:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8001aa2:	3320      	adds	r3, #32
 8001aa4:	6f3a      	ldr	r2, [r7, #112]	; 0x70
 8001aa6:	601a      	str	r2, [r3, #0]
 8001aa8:	681a      	ldr	r2, [r3, #0]
 8001aaa:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8001aac:	601a      	str	r2, [r3, #0]
 8001aae:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8001ab0:	f503 7380 	add.w	r3, r3, #256	; 0x100
 8001ab4:	667b      	str	r3, [r7, #100]	; 0x64

	tmp = buf[25] + buf[29];
 8001ab6:	68fb      	ldr	r3, [r7, #12]
 8001ab8:	3364      	adds	r3, #100	; 0x64
 8001aba:	681a      	ldr	r2, [r3, #0]
 8001abc:	68fb      	ldr	r3, [r7, #12]
 8001abe:	3374      	adds	r3, #116	; 0x74
 8001ac0:	681b      	ldr	r3, [r3, #0]
 8001ac2:	4413      	add	r3, r2
 8001ac4:	623b      	str	r3, [r7, #32]
	s = buf[17] + tmp;			d[0] = d[8] = s;	d += 64;
 8001ac6:	68fb      	ldr	r3, [r7, #12]
 8001ac8:	3344      	adds	r3, #68	; 0x44
 8001aca:	681a      	ldr	r2, [r3, #0]
 8001acc:	6a3b      	ldr	r3, [r7, #32]
 8001ace:	4413      	add	r3, r2
 8001ad0:	673b      	str	r3, [r7, #112]	; 0x70
 8001ad2:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8001ad4:	3320      	adds	r3, #32
 8001ad6:	6f3a      	ldr	r2, [r7, #112]	; 0x70
 8001ad8:	601a      	str	r2, [r3, #0]
 8001ada:	681a      	ldr	r2, [r3, #0]
 8001adc:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8001ade:	601a      	str	r2, [r3, #0]
 8001ae0:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8001ae2:	f503 7380 	add.w	r3, r3, #256	; 0x100
 8001ae6:	667b      	str	r3, [r7, #100]	; 0x64
	s = buf[ 9] + buf[13];		d[0] = d[8] = s;	d += 64;
 8001ae8:	68fb      	ldr	r3, [r7, #12]
 8001aea:	3324      	adds	r3, #36	; 0x24
 8001aec:	681a      	ldr	r2, [r3, #0]
 8001aee:	68fb      	ldr	r3, [r7, #12]
 8001af0:	3334      	adds	r3, #52	; 0x34
 8001af2:	681b      	ldr	r3, [r3, #0]
 8001af4:	4413      	add	r3, r2
 8001af6:	673b      	str	r3, [r7, #112]	; 0x70
 8001af8:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8001afa:	3320      	adds	r3, #32
 8001afc:	6f3a      	ldr	r2, [r7, #112]	; 0x70
 8001afe:	601a      	str	r2, [r3, #0]
 8001b00:	681a      	ldr	r2, [r3, #0]
 8001b02:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8001b04:	601a      	str	r2, [r3, #0]
 8001b06:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8001b08:	f503 7380 	add.w	r3, r3, #256	; 0x100
 8001b0c:	667b      	str	r3, [r7, #100]	; 0x64
	s = buf[21] + tmp;			d[0] = d[8] = s;	d += 64;
 8001b0e:	68fb      	ldr	r3, [r7, #12]
 8001b10:	3354      	adds	r3, #84	; 0x54
 8001b12:	681a      	ldr	r2, [r3, #0]
 8001b14:	6a3b      	ldr	r3, [r7, #32]
 8001b16:	4413      	add	r3, r2
 8001b18:	673b      	str	r3, [r7, #112]	; 0x70
 8001b1a:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8001b1c:	3320      	adds	r3, #32
 8001b1e:	6f3a      	ldr	r2, [r7, #112]	; 0x70
 8001b20:	601a      	str	r2, [r3, #0]
 8001b22:	681a      	ldr	r2, [r3, #0]
 8001b24:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8001b26:	601a      	str	r2, [r3, #0]
 8001b28:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8001b2a:	f503 7380 	add.w	r3, r3, #256	; 0x100
 8001b2e:	667b      	str	r3, [r7, #100]	; 0x64

	tmp = buf[29] + buf[27];
 8001b30:	68fb      	ldr	r3, [r7, #12]
 8001b32:	3374      	adds	r3, #116	; 0x74
 8001b34:	681a      	ldr	r2, [r3, #0]
 8001b36:	68fb      	ldr	r3, [r7, #12]
 8001b38:	336c      	adds	r3, #108	; 0x6c
 8001b3a:	681b      	ldr	r3, [r3, #0]
 8001b3c:	4413      	add	r3, r2
 8001b3e:	623b      	str	r3, [r7, #32]
	s = buf[ 5];				d[0] = d[8] = s;	d += 64;
 8001b40:	68fb      	ldr	r3, [r7, #12]
 8001b42:	695b      	ldr	r3, [r3, #20]
 8001b44:	673b      	str	r3, [r7, #112]	; 0x70
 8001b46:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8001b48:	3320      	adds	r3, #32
 8001b4a:	6f3a      	ldr	r2, [r7, #112]	; 0x70
 8001b4c:	601a      	str	r2, [r3, #0]
 8001b4e:	681a      	ldr	r2, [r3, #0]
 8001b50:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8001b52:	601a      	str	r2, [r3, #0]
 8001b54:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8001b56:	f503 7380 	add.w	r3, r3, #256	; 0x100
 8001b5a:	667b      	str	r3, [r7, #100]	; 0x64
	s = buf[21] + tmp;			d[0] = d[8] = s;	d += 64;
 8001b5c:	68fb      	ldr	r3, [r7, #12]
 8001b5e:	3354      	adds	r3, #84	; 0x54
 8001b60:	681a      	ldr	r2, [r3, #0]
 8001b62:	6a3b      	ldr	r3, [r7, #32]
 8001b64:	4413      	add	r3, r2
 8001b66:	673b      	str	r3, [r7, #112]	; 0x70
 8001b68:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8001b6a:	3320      	adds	r3, #32
 8001b6c:	6f3a      	ldr	r2, [r7, #112]	; 0x70
 8001b6e:	601a      	str	r2, [r3, #0]
 8001b70:	681a      	ldr	r2, [r3, #0]
 8001b72:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8001b74:	601a      	str	r2, [r3, #0]
 8001b76:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8001b78:	f503 7380 	add.w	r3, r3, #256	; 0x100
 8001b7c:	667b      	str	r3, [r7, #100]	; 0x64
	s = buf[13] + buf[11];		d[0] = d[8] = s;	d += 64;
 8001b7e:	68fb      	ldr	r3, [r7, #12]
 8001b80:	3334      	adds	r3, #52	; 0x34
 8001b82:	681a      	ldr	r2, [r3, #0]
 8001b84:	68fb      	ldr	r3, [r7, #12]
 8001b86:	332c      	adds	r3, #44	; 0x2c
 8001b88:	681b      	ldr	r3, [r3, #0]
 8001b8a:	4413      	add	r3, r2
 8001b8c:	673b      	str	r3, [r7, #112]	; 0x70
 8001b8e:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8001b90:	3320      	adds	r3, #32
 8001b92:	6f3a      	ldr	r2, [r7, #112]	; 0x70
 8001b94:	601a      	str	r2, [r3, #0]
 8001b96:	681a      	ldr	r2, [r3, #0]
 8001b98:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8001b9a:	601a      	str	r2, [r3, #0]
 8001b9c:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8001b9e:	f503 7380 	add.w	r3, r3, #256	; 0x100
 8001ba2:	667b      	str	r3, [r7, #100]	; 0x64
	s = buf[19] + tmp;			d[0] = d[8] = s;	d += 64;
 8001ba4:	68fb      	ldr	r3, [r7, #12]
 8001ba6:	334c      	adds	r3, #76	; 0x4c
 8001ba8:	681a      	ldr	r2, [r3, #0]
 8001baa:	6a3b      	ldr	r3, [r7, #32]
 8001bac:	4413      	add	r3, r2
 8001bae:	673b      	str	r3, [r7, #112]	; 0x70
 8001bb0:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8001bb2:	3320      	adds	r3, #32
 8001bb4:	6f3a      	ldr	r2, [r7, #112]	; 0x70
 8001bb6:	601a      	str	r2, [r3, #0]
 8001bb8:	681a      	ldr	r2, [r3, #0]
 8001bba:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8001bbc:	601a      	str	r2, [r3, #0]
 8001bbe:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8001bc0:	f503 7380 	add.w	r3, r3, #256	; 0x100
 8001bc4:	667b      	str	r3, [r7, #100]	; 0x64

	tmp = buf[27] + buf[31];
 8001bc6:	68fb      	ldr	r3, [r7, #12]
 8001bc8:	336c      	adds	r3, #108	; 0x6c
 8001bca:	681a      	ldr	r2, [r3, #0]
 8001bcc:	68fb      	ldr	r3, [r7, #12]
 8001bce:	337c      	adds	r3, #124	; 0x7c
 8001bd0:	681b      	ldr	r3, [r3, #0]
 8001bd2:	4413      	add	r3, r2
 8001bd4:	623b      	str	r3, [r7, #32]
	s = buf[ 3];				d[0] = d[8] = s;	d += 64;
 8001bd6:	68fb      	ldr	r3, [r7, #12]
 8001bd8:	68db      	ldr	r3, [r3, #12]
 8001bda:	673b      	str	r3, [r7, #112]	; 0x70
 8001bdc:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8001bde:	3320      	adds	r3, #32
 8001be0:	6f3a      	ldr	r2, [r7, #112]	; 0x70
 8001be2:	601a      	str	r2, [r3, #0]
 8001be4:	681a      	ldr	r2, [r3, #0]
 8001be6:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8001be8:	601a      	str	r2, [r3, #0]
 8001bea:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8001bec:	f503 7380 	add.w	r3, r3, #256	; 0x100
 8001bf0:	667b      	str	r3, [r7, #100]	; 0x64
	s = buf[19] + tmp;			d[0] = d[8] = s;	d += 64;
 8001bf2:	68fb      	ldr	r3, [r7, #12]
 8001bf4:	334c      	adds	r3, #76	; 0x4c
 8001bf6:	681a      	ldr	r2, [r3, #0]
 8001bf8:	6a3b      	ldr	r3, [r7, #32]
 8001bfa:	4413      	add	r3, r2
 8001bfc:	673b      	str	r3, [r7, #112]	; 0x70
 8001bfe:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8001c00:	3320      	adds	r3, #32
 8001c02:	6f3a      	ldr	r2, [r7, #112]	; 0x70
 8001c04:	601a      	str	r2, [r3, #0]
 8001c06:	681a      	ldr	r2, [r3, #0]
 8001c08:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8001c0a:	601a      	str	r2, [r3, #0]
 8001c0c:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8001c0e:	f503 7380 	add.w	r3, r3, #256	; 0x100
 8001c12:	667b      	str	r3, [r7, #100]	; 0x64
	s = buf[11] + buf[15];		d[0] = d[8] = s;	d += 64;
 8001c14:	68fb      	ldr	r3, [r7, #12]
 8001c16:	332c      	adds	r3, #44	; 0x2c
 8001c18:	681a      	ldr	r2, [r3, #0]
 8001c1a:	68fb      	ldr	r3, [r7, #12]
 8001c1c:	333c      	adds	r3, #60	; 0x3c
 8001c1e:	681b      	ldr	r3, [r3, #0]
 8001c20:	4413      	add	r3, r2
 8001c22:	673b      	str	r3, [r7, #112]	; 0x70
 8001c24:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8001c26:	3320      	adds	r3, #32
 8001c28:	6f3a      	ldr	r2, [r7, #112]	; 0x70
 8001c2a:	601a      	str	r2, [r3, #0]
 8001c2c:	681a      	ldr	r2, [r3, #0]
 8001c2e:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8001c30:	601a      	str	r2, [r3, #0]
 8001c32:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8001c34:	f503 7380 	add.w	r3, r3, #256	; 0x100
 8001c38:	667b      	str	r3, [r7, #100]	; 0x64
	s = buf[23] + tmp;			d[0] = d[8] = s;	d += 64;
 8001c3a:	68fb      	ldr	r3, [r7, #12]
 8001c3c:	335c      	adds	r3, #92	; 0x5c
 8001c3e:	681a      	ldr	r2, [r3, #0]
 8001c40:	6a3b      	ldr	r3, [r7, #32]
 8001c42:	4413      	add	r3, r2
 8001c44:	673b      	str	r3, [r7, #112]	; 0x70
 8001c46:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8001c48:	3320      	adds	r3, #32
 8001c4a:	6f3a      	ldr	r2, [r7, #112]	; 0x70
 8001c4c:	601a      	str	r2, [r3, #0]
 8001c4e:	681a      	ldr	r2, [r3, #0]
 8001c50:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8001c52:	601a      	str	r2, [r3, #0]
 8001c54:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8001c56:	f503 7380 	add.w	r3, r3, #256	; 0x100
 8001c5a:	667b      	str	r3, [r7, #100]	; 0x64

	tmp = buf[31];
 8001c5c:	68fb      	ldr	r3, [r7, #12]
 8001c5e:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
 8001c60:	623b      	str	r3, [r7, #32]
	s = buf[ 7];				d[0] = d[8] = s;	d += 64;
 8001c62:	68fb      	ldr	r3, [r7, #12]
 8001c64:	69db      	ldr	r3, [r3, #28]
 8001c66:	673b      	str	r3, [r7, #112]	; 0x70
 8001c68:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8001c6a:	3320      	adds	r3, #32
 8001c6c:	6f3a      	ldr	r2, [r7, #112]	; 0x70
 8001c6e:	601a      	str	r2, [r3, #0]
 8001c70:	681a      	ldr	r2, [r3, #0]
 8001c72:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8001c74:	601a      	str	r2, [r3, #0]
 8001c76:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8001c78:	f503 7380 	add.w	r3, r3, #256	; 0x100
 8001c7c:	667b      	str	r3, [r7, #100]	; 0x64
	s = buf[23] + tmp;			d[0] = d[8] = s;	d += 64;
 8001c7e:	68fb      	ldr	r3, [r7, #12]
 8001c80:	335c      	adds	r3, #92	; 0x5c
 8001c82:	681a      	ldr	r2, [r3, #0]
 8001c84:	6a3b      	ldr	r3, [r7, #32]
 8001c86:	4413      	add	r3, r2
 8001c88:	673b      	str	r3, [r7, #112]	; 0x70
 8001c8a:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8001c8c:	3320      	adds	r3, #32
 8001c8e:	6f3a      	ldr	r2, [r7, #112]	; 0x70
 8001c90:	601a      	str	r2, [r3, #0]
 8001c92:	681a      	ldr	r2, [r3, #0]
 8001c94:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8001c96:	601a      	str	r2, [r3, #0]
 8001c98:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8001c9a:	f503 7380 	add.w	r3, r3, #256	; 0x100
 8001c9e:	667b      	str	r3, [r7, #100]	; 0x64
	s = buf[15];				d[0] = d[8] = s;	d += 64;
 8001ca0:	68fb      	ldr	r3, [r7, #12]
 8001ca2:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8001ca4:	673b      	str	r3, [r7, #112]	; 0x70
 8001ca6:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8001ca8:	3320      	adds	r3, #32
 8001caa:	6f3a      	ldr	r2, [r7, #112]	; 0x70
 8001cac:	601a      	str	r2, [r3, #0]
 8001cae:	681a      	ldr	r2, [r3, #0]
 8001cb0:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8001cb2:	601a      	str	r2, [r3, #0]
 8001cb4:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8001cb6:	f503 7380 	add.w	r3, r3, #256	; 0x100
 8001cba:	667b      	str	r3, [r7, #100]	; 0x64
	s = tmp;					d[0] = d[8] = s;
 8001cbc:	6a3b      	ldr	r3, [r7, #32]
 8001cbe:	673b      	str	r3, [r7, #112]	; 0x70
 8001cc0:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8001cc2:	3320      	adds	r3, #32
 8001cc4:	6f3a      	ldr	r2, [r7, #112]	; 0x70
 8001cc6:	601a      	str	r2, [r3, #0]
 8001cc8:	681a      	ldr	r2, [r3, #0]
 8001cca:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8001ccc:	601a      	str	r2, [r3, #0]

	/* samples 16 to 1 (sample 16 used again) */
	d = dest + 16 + ((offset - oddBlock) & 7) + (oddBlock ? 0 : VBUF_LENGTH);
 8001cce:	687a      	ldr	r2, [r7, #4]
 8001cd0:	683b      	ldr	r3, [r7, #0]
 8001cd2:	1ad3      	subs	r3, r2, r3
 8001cd4:	f003 0307 	and.w	r3, r3, #7
 8001cd8:	3310      	adds	r3, #16
 8001cda:	009a      	lsls	r2, r3, #2
 8001cdc:	683b      	ldr	r3, [r7, #0]
 8001cde:	2b00      	cmp	r3, #0
 8001ce0:	d001      	beq.n	8001ce6 <xmp3fixpt_FDCT32+0xa9a>
 8001ce2:	2300      	movs	r3, #0
 8001ce4:	e001      	b.n	8001cea <xmp3fixpt_FDCT32+0xa9e>
 8001ce6:	f44f 5388 	mov.w	r3, #4352	; 0x1100
 8001cea:	4413      	add	r3, r2
 8001cec:	68ba      	ldr	r2, [r7, #8]
 8001cee:	4413      	add	r3, r2
 8001cf0:	667b      	str	r3, [r7, #100]	; 0x64

	s = buf[ 1];				d[0] = d[8] = s;	d += 64;
 8001cf2:	68fb      	ldr	r3, [r7, #12]
 8001cf4:	685b      	ldr	r3, [r3, #4]
 8001cf6:	673b      	str	r3, [r7, #112]	; 0x70
 8001cf8:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8001cfa:	3320      	adds	r3, #32
 8001cfc:	6f3a      	ldr	r2, [r7, #112]	; 0x70
 8001cfe:	601a      	str	r2, [r3, #0]
 8001d00:	681a      	ldr	r2, [r3, #0]
 8001d02:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8001d04:	601a      	str	r2, [r3, #0]
 8001d06:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8001d08:	f503 7380 	add.w	r3, r3, #256	; 0x100
 8001d0c:	667b      	str	r3, [r7, #100]	; 0x64

	tmp = buf[30] + buf[25];
 8001d0e:	68fb      	ldr	r3, [r7, #12]
 8001d10:	3378      	adds	r3, #120	; 0x78
 8001d12:	681a      	ldr	r2, [r3, #0]
 8001d14:	68fb      	ldr	r3, [r7, #12]
 8001d16:	3364      	adds	r3, #100	; 0x64
 8001d18:	681b      	ldr	r3, [r3, #0]
 8001d1a:	4413      	add	r3, r2
 8001d1c:	623b      	str	r3, [r7, #32]
	s = buf[17] + tmp;			d[0] = d[8] = s;	d += 64;
 8001d1e:	68fb      	ldr	r3, [r7, #12]
 8001d20:	3344      	adds	r3, #68	; 0x44
 8001d22:	681a      	ldr	r2, [r3, #0]
 8001d24:	6a3b      	ldr	r3, [r7, #32]
 8001d26:	4413      	add	r3, r2
 8001d28:	673b      	str	r3, [r7, #112]	; 0x70
 8001d2a:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8001d2c:	3320      	adds	r3, #32
 8001d2e:	6f3a      	ldr	r2, [r7, #112]	; 0x70
 8001d30:	601a      	str	r2, [r3, #0]
 8001d32:	681a      	ldr	r2, [r3, #0]
 8001d34:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8001d36:	601a      	str	r2, [r3, #0]
 8001d38:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8001d3a:	f503 7380 	add.w	r3, r3, #256	; 0x100
 8001d3e:	667b      	str	r3, [r7, #100]	; 0x64
	s = buf[14] + buf[ 9];		d[0] = d[8] = s;	d += 64;
 8001d40:	68fb      	ldr	r3, [r7, #12]
 8001d42:	3338      	adds	r3, #56	; 0x38
 8001d44:	681a      	ldr	r2, [r3, #0]
 8001d46:	68fb      	ldr	r3, [r7, #12]
 8001d48:	3324      	adds	r3, #36	; 0x24
 8001d4a:	681b      	ldr	r3, [r3, #0]
 8001d4c:	4413      	add	r3, r2
 8001d4e:	673b      	str	r3, [r7, #112]	; 0x70
 8001d50:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8001d52:	3320      	adds	r3, #32
 8001d54:	6f3a      	ldr	r2, [r7, #112]	; 0x70
 8001d56:	601a      	str	r2, [r3, #0]
 8001d58:	681a      	ldr	r2, [r3, #0]
 8001d5a:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8001d5c:	601a      	str	r2, [r3, #0]
 8001d5e:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8001d60:	f503 7380 	add.w	r3, r3, #256	; 0x100
 8001d64:	667b      	str	r3, [r7, #100]	; 0x64
	s = buf[22] + tmp;			d[0] = d[8] = s;	d += 64;
 8001d66:	68fb      	ldr	r3, [r7, #12]
 8001d68:	3358      	adds	r3, #88	; 0x58
 8001d6a:	681a      	ldr	r2, [r3, #0]
 8001d6c:	6a3b      	ldr	r3, [r7, #32]
 8001d6e:	4413      	add	r3, r2
 8001d70:	673b      	str	r3, [r7, #112]	; 0x70
 8001d72:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8001d74:	3320      	adds	r3, #32
 8001d76:	6f3a      	ldr	r2, [r7, #112]	; 0x70
 8001d78:	601a      	str	r2, [r3, #0]
 8001d7a:	681a      	ldr	r2, [r3, #0]
 8001d7c:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8001d7e:	601a      	str	r2, [r3, #0]
 8001d80:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8001d82:	f503 7380 	add.w	r3, r3, #256	; 0x100
 8001d86:	667b      	str	r3, [r7, #100]	; 0x64
	s = buf[ 6];				d[0] = d[8] = s;	d += 64;
 8001d88:	68fb      	ldr	r3, [r7, #12]
 8001d8a:	699b      	ldr	r3, [r3, #24]
 8001d8c:	673b      	str	r3, [r7, #112]	; 0x70
 8001d8e:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8001d90:	3320      	adds	r3, #32
 8001d92:	6f3a      	ldr	r2, [r7, #112]	; 0x70
 8001d94:	601a      	str	r2, [r3, #0]
 8001d96:	681a      	ldr	r2, [r3, #0]
 8001d98:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8001d9a:	601a      	str	r2, [r3, #0]
 8001d9c:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8001d9e:	f503 7380 	add.w	r3, r3, #256	; 0x100
 8001da2:	667b      	str	r3, [r7, #100]	; 0x64

	tmp = buf[26] + buf[30];
 8001da4:	68fb      	ldr	r3, [r7, #12]
 8001da6:	3368      	adds	r3, #104	; 0x68
 8001da8:	681a      	ldr	r2, [r3, #0]
 8001daa:	68fb      	ldr	r3, [r7, #12]
 8001dac:	3378      	adds	r3, #120	; 0x78
 8001dae:	681b      	ldr	r3, [r3, #0]
 8001db0:	4413      	add	r3, r2
 8001db2:	623b      	str	r3, [r7, #32]
	s = buf[22] + tmp;			d[0] = d[8] = s;	d += 64;
 8001db4:	68fb      	ldr	r3, [r7, #12]
 8001db6:	3358      	adds	r3, #88	; 0x58
 8001db8:	681a      	ldr	r2, [r3, #0]
 8001dba:	6a3b      	ldr	r3, [r7, #32]
 8001dbc:	4413      	add	r3, r2
 8001dbe:	673b      	str	r3, [r7, #112]	; 0x70
 8001dc0:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8001dc2:	3320      	adds	r3, #32
 8001dc4:	6f3a      	ldr	r2, [r7, #112]	; 0x70
 8001dc6:	601a      	str	r2, [r3, #0]
 8001dc8:	681a      	ldr	r2, [r3, #0]
 8001dca:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8001dcc:	601a      	str	r2, [r3, #0]
 8001dce:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8001dd0:	f503 7380 	add.w	r3, r3, #256	; 0x100
 8001dd4:	667b      	str	r3, [r7, #100]	; 0x64
	s = buf[10] + buf[14];		d[0] = d[8] = s;	d += 64;
 8001dd6:	68fb      	ldr	r3, [r7, #12]
 8001dd8:	3328      	adds	r3, #40	; 0x28
 8001dda:	681a      	ldr	r2, [r3, #0]
 8001ddc:	68fb      	ldr	r3, [r7, #12]
 8001dde:	3338      	adds	r3, #56	; 0x38
 8001de0:	681b      	ldr	r3, [r3, #0]
 8001de2:	4413      	add	r3, r2
 8001de4:	673b      	str	r3, [r7, #112]	; 0x70
 8001de6:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8001de8:	3320      	adds	r3, #32
 8001dea:	6f3a      	ldr	r2, [r7, #112]	; 0x70
 8001dec:	601a      	str	r2, [r3, #0]
 8001dee:	681a      	ldr	r2, [r3, #0]
 8001df0:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8001df2:	601a      	str	r2, [r3, #0]
 8001df4:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8001df6:	f503 7380 	add.w	r3, r3, #256	; 0x100
 8001dfa:	667b      	str	r3, [r7, #100]	; 0x64
	s = buf[18] + tmp;			d[0] = d[8] = s;	d += 64;
 8001dfc:	68fb      	ldr	r3, [r7, #12]
 8001dfe:	3348      	adds	r3, #72	; 0x48
 8001e00:	681a      	ldr	r2, [r3, #0]
 8001e02:	6a3b      	ldr	r3, [r7, #32]
 8001e04:	4413      	add	r3, r2
 8001e06:	673b      	str	r3, [r7, #112]	; 0x70
 8001e08:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8001e0a:	3320      	adds	r3, #32
 8001e0c:	6f3a      	ldr	r2, [r7, #112]	; 0x70
 8001e0e:	601a      	str	r2, [r3, #0]
 8001e10:	681a      	ldr	r2, [r3, #0]
 8001e12:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8001e14:	601a      	str	r2, [r3, #0]
 8001e16:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8001e18:	f503 7380 	add.w	r3, r3, #256	; 0x100
 8001e1c:	667b      	str	r3, [r7, #100]	; 0x64
	s = buf[ 2];				d[0] = d[8] = s;	d += 64;
 8001e1e:	68fb      	ldr	r3, [r7, #12]
 8001e20:	689b      	ldr	r3, [r3, #8]
 8001e22:	673b      	str	r3, [r7, #112]	; 0x70
 8001e24:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8001e26:	3320      	adds	r3, #32
 8001e28:	6f3a      	ldr	r2, [r7, #112]	; 0x70
 8001e2a:	601a      	str	r2, [r3, #0]
 8001e2c:	681a      	ldr	r2, [r3, #0]
 8001e2e:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8001e30:	601a      	str	r2, [r3, #0]
 8001e32:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8001e34:	f503 7380 	add.w	r3, r3, #256	; 0x100
 8001e38:	667b      	str	r3, [r7, #100]	; 0x64

	tmp = buf[28] + buf[26];
 8001e3a:	68fb      	ldr	r3, [r7, #12]
 8001e3c:	3370      	adds	r3, #112	; 0x70
 8001e3e:	681a      	ldr	r2, [r3, #0]
 8001e40:	68fb      	ldr	r3, [r7, #12]
 8001e42:	3368      	adds	r3, #104	; 0x68
 8001e44:	681b      	ldr	r3, [r3, #0]
 8001e46:	4413      	add	r3, r2
 8001e48:	623b      	str	r3, [r7, #32]
	s = buf[18] + tmp;			d[0] = d[8] = s;	d += 64;
 8001e4a:	68fb      	ldr	r3, [r7, #12]
 8001e4c:	3348      	adds	r3, #72	; 0x48
 8001e4e:	681a      	ldr	r2, [r3, #0]
 8001e50:	6a3b      	ldr	r3, [r7, #32]
 8001e52:	4413      	add	r3, r2
 8001e54:	673b      	str	r3, [r7, #112]	; 0x70
 8001e56:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8001e58:	3320      	adds	r3, #32
 8001e5a:	6f3a      	ldr	r2, [r7, #112]	; 0x70
 8001e5c:	601a      	str	r2, [r3, #0]
 8001e5e:	681a      	ldr	r2, [r3, #0]
 8001e60:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8001e62:	601a      	str	r2, [r3, #0]
 8001e64:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8001e66:	f503 7380 	add.w	r3, r3, #256	; 0x100
 8001e6a:	667b      	str	r3, [r7, #100]	; 0x64
	s = buf[12] + buf[10];		d[0] = d[8] = s;	d += 64;
 8001e6c:	68fb      	ldr	r3, [r7, #12]
 8001e6e:	3330      	adds	r3, #48	; 0x30
 8001e70:	681a      	ldr	r2, [r3, #0]
 8001e72:	68fb      	ldr	r3, [r7, #12]
 8001e74:	3328      	adds	r3, #40	; 0x28
 8001e76:	681b      	ldr	r3, [r3, #0]
 8001e78:	4413      	add	r3, r2
 8001e7a:	673b      	str	r3, [r7, #112]	; 0x70
 8001e7c:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8001e7e:	3320      	adds	r3, #32
 8001e80:	6f3a      	ldr	r2, [r7, #112]	; 0x70
 8001e82:	601a      	str	r2, [r3, #0]
 8001e84:	681a      	ldr	r2, [r3, #0]
 8001e86:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8001e88:	601a      	str	r2, [r3, #0]
 8001e8a:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8001e8c:	f503 7380 	add.w	r3, r3, #256	; 0x100
 8001e90:	667b      	str	r3, [r7, #100]	; 0x64
	s = buf[20] + tmp;			d[0] = d[8] = s;	d += 64;
 8001e92:	68fb      	ldr	r3, [r7, #12]
 8001e94:	3350      	adds	r3, #80	; 0x50
 8001e96:	681a      	ldr	r2, [r3, #0]
 8001e98:	6a3b      	ldr	r3, [r7, #32]
 8001e9a:	4413      	add	r3, r2
 8001e9c:	673b      	str	r3, [r7, #112]	; 0x70
 8001e9e:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8001ea0:	3320      	adds	r3, #32
 8001ea2:	6f3a      	ldr	r2, [r7, #112]	; 0x70
 8001ea4:	601a      	str	r2, [r3, #0]
 8001ea6:	681a      	ldr	r2, [r3, #0]
 8001ea8:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8001eaa:	601a      	str	r2, [r3, #0]
 8001eac:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8001eae:	f503 7380 	add.w	r3, r3, #256	; 0x100
 8001eb2:	667b      	str	r3, [r7, #100]	; 0x64
	s = buf[ 4];				d[0] = d[8] = s;	d += 64;
 8001eb4:	68fb      	ldr	r3, [r7, #12]
 8001eb6:	691b      	ldr	r3, [r3, #16]
 8001eb8:	673b      	str	r3, [r7, #112]	; 0x70
 8001eba:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8001ebc:	3320      	adds	r3, #32
 8001ebe:	6f3a      	ldr	r2, [r7, #112]	; 0x70
 8001ec0:	601a      	str	r2, [r3, #0]
 8001ec2:	681a      	ldr	r2, [r3, #0]
 8001ec4:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8001ec6:	601a      	str	r2, [r3, #0]
 8001ec8:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8001eca:	f503 7380 	add.w	r3, r3, #256	; 0x100
 8001ece:	667b      	str	r3, [r7, #100]	; 0x64

	tmp = buf[24] + buf[28];
 8001ed0:	68fb      	ldr	r3, [r7, #12]
 8001ed2:	3360      	adds	r3, #96	; 0x60
 8001ed4:	681a      	ldr	r2, [r3, #0]
 8001ed6:	68fb      	ldr	r3, [r7, #12]
 8001ed8:	3370      	adds	r3, #112	; 0x70
 8001eda:	681b      	ldr	r3, [r3, #0]
 8001edc:	4413      	add	r3, r2
 8001ede:	623b      	str	r3, [r7, #32]
	s = buf[20] + tmp;			d[0] = d[8] = s;	d += 64;
 8001ee0:	68fb      	ldr	r3, [r7, #12]
 8001ee2:	3350      	adds	r3, #80	; 0x50
 8001ee4:	681a      	ldr	r2, [r3, #0]
 8001ee6:	6a3b      	ldr	r3, [r7, #32]
 8001ee8:	4413      	add	r3, r2
 8001eea:	673b      	str	r3, [r7, #112]	; 0x70
 8001eec:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8001eee:	3320      	adds	r3, #32
 8001ef0:	6f3a      	ldr	r2, [r7, #112]	; 0x70
 8001ef2:	601a      	str	r2, [r3, #0]
 8001ef4:	681a      	ldr	r2, [r3, #0]
 8001ef6:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8001ef8:	601a      	str	r2, [r3, #0]
 8001efa:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8001efc:	f503 7380 	add.w	r3, r3, #256	; 0x100
 8001f00:	667b      	str	r3, [r7, #100]	; 0x64
	s = buf[ 8] + buf[12];		d[0] = d[8] = s;	d += 64;
 8001f02:	68fb      	ldr	r3, [r7, #12]
 8001f04:	3320      	adds	r3, #32
 8001f06:	681a      	ldr	r2, [r3, #0]
 8001f08:	68fb      	ldr	r3, [r7, #12]
 8001f0a:	3330      	adds	r3, #48	; 0x30
 8001f0c:	681b      	ldr	r3, [r3, #0]
 8001f0e:	4413      	add	r3, r2
 8001f10:	673b      	str	r3, [r7, #112]	; 0x70
 8001f12:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8001f14:	3320      	adds	r3, #32
 8001f16:	6f3a      	ldr	r2, [r7, #112]	; 0x70
 8001f18:	601a      	str	r2, [r3, #0]
 8001f1a:	681a      	ldr	r2, [r3, #0]
 8001f1c:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8001f1e:	601a      	str	r2, [r3, #0]
 8001f20:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8001f22:	f503 7380 	add.w	r3, r3, #256	; 0x100
 8001f26:	667b      	str	r3, [r7, #100]	; 0x64
	s = buf[16] + tmp;			d[0] = d[8] = s;
 8001f28:	68fb      	ldr	r3, [r7, #12]
 8001f2a:	3340      	adds	r3, #64	; 0x40
 8001f2c:	681a      	ldr	r2, [r3, #0]
 8001f2e:	6a3b      	ldr	r3, [r7, #32]
 8001f30:	4413      	add	r3, r2
 8001f32:	673b      	str	r3, [r7, #112]	; 0x70
 8001f34:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8001f36:	3320      	adds	r3, #32
 8001f38:	6f3a      	ldr	r2, [r7, #112]	; 0x70
 8001f3a:	601a      	str	r2, [r3, #0]
 8001f3c:	681a      	ldr	r2, [r3, #0]
 8001f3e:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8001f40:	601a      	str	r2, [r3, #0]

	/* this is so rarely invoked that it's not worth making two versions of the output
	 *   shuffle code (one for no shift, one for clip + variable shift) like in IMDCT
	 * here we just load, clip, shift, and store on the rare instances that es != 0
	 */
	if (es) {
 8001f42:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 8001f44:	2b00      	cmp	r3, #0
 8001f46:	f000 80b2 	beq.w	80020ae <xmp3fixpt_FDCT32+0xe62>
		d = dest + 64*16 + ((offset - oddBlock) & 7) + (oddBlock ? 0 : VBUF_LENGTH);
 8001f4a:	687a      	ldr	r2, [r7, #4]
 8001f4c:	683b      	ldr	r3, [r7, #0]
 8001f4e:	1ad3      	subs	r3, r2, r3
 8001f50:	f003 0307 	and.w	r3, r3, #7
 8001f54:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 8001f58:	009a      	lsls	r2, r3, #2
 8001f5a:	683b      	ldr	r3, [r7, #0]
 8001f5c:	2b00      	cmp	r3, #0
 8001f5e:	d001      	beq.n	8001f64 <xmp3fixpt_FDCT32+0xd18>
 8001f60:	2300      	movs	r3, #0
 8001f62:	e001      	b.n	8001f68 <xmp3fixpt_FDCT32+0xd1c>
 8001f64:	f44f 5388 	mov.w	r3, #4352	; 0x1100
 8001f68:	4413      	add	r3, r2
 8001f6a:	68ba      	ldr	r2, [r7, #8]
 8001f6c:	4413      	add	r3, r2
 8001f6e:	667b      	str	r3, [r7, #100]	; 0x64
		s = d[0];	CLIP_2N(s, 31 - es);	d[0] = d[8] = (s << es);
 8001f70:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8001f72:	681b      	ldr	r3, [r3, #0]
 8001f74:	673b      	str	r3, [r7, #112]	; 0x70
 8001f76:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 8001f78:	17db      	asrs	r3, r3, #31
 8001f7a:	61fb      	str	r3, [r7, #28]
 8001f7c:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 8001f7e:	f1c3 031f 	rsb	r3, r3, #31
 8001f82:	6f3a      	ldr	r2, [r7, #112]	; 0x70
 8001f84:	411a      	asrs	r2, r3
 8001f86:	69fb      	ldr	r3, [r7, #28]
 8001f88:	429a      	cmp	r2, r3
 8001f8a:	d009      	beq.n	8001fa0 <xmp3fixpt_FDCT32+0xd54>
 8001f8c:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 8001f8e:	f1c3 031f 	rsb	r3, r3, #31
 8001f92:	2201      	movs	r2, #1
 8001f94:	fa02 f303 	lsl.w	r3, r2, r3
 8001f98:	1e5a      	subs	r2, r3, #1
 8001f9a:	69fb      	ldr	r3, [r7, #28]
 8001f9c:	4053      	eors	r3, r2
 8001f9e:	673b      	str	r3, [r7, #112]	; 0x70
 8001fa0:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8001fa2:	3320      	adds	r3, #32
 8001fa4:	6f39      	ldr	r1, [r7, #112]	; 0x70
 8001fa6:	6efa      	ldr	r2, [r7, #108]	; 0x6c
 8001fa8:	fa01 f202 	lsl.w	r2, r1, r2
 8001fac:	601a      	str	r2, [r3, #0]
 8001fae:	681a      	ldr	r2, [r3, #0]
 8001fb0:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8001fb2:	601a      	str	r2, [r3, #0]
	
		d = dest + offset + (oddBlock ? VBUF_LENGTH  : 0);
 8001fb4:	687b      	ldr	r3, [r7, #4]
 8001fb6:	009a      	lsls	r2, r3, #2
 8001fb8:	683b      	ldr	r3, [r7, #0]
 8001fba:	2b00      	cmp	r3, #0
 8001fbc:	d002      	beq.n	8001fc4 <xmp3fixpt_FDCT32+0xd78>
 8001fbe:	f44f 5388 	mov.w	r3, #4352	; 0x1100
 8001fc2:	e000      	b.n	8001fc6 <xmp3fixpt_FDCT32+0xd7a>
 8001fc4:	2300      	movs	r3, #0
 8001fc6:	4413      	add	r3, r2
 8001fc8:	68ba      	ldr	r2, [r7, #8]
 8001fca:	4413      	add	r3, r2
 8001fcc:	667b      	str	r3, [r7, #100]	; 0x64
		for (i = 16; i <= 31; i++) {
 8001fce:	2310      	movs	r3, #16
 8001fd0:	677b      	str	r3, [r7, #116]	; 0x74
 8001fd2:	e028      	b.n	8002026 <xmp3fixpt_FDCT32+0xdda>
			s = d[0];	CLIP_2N(s, 31 - es);	d[0] = d[8] = (s << es);	d += 64;
 8001fd4:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8001fd6:	681b      	ldr	r3, [r3, #0]
 8001fd8:	673b      	str	r3, [r7, #112]	; 0x70
 8001fda:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 8001fdc:	17db      	asrs	r3, r3, #31
 8001fde:	61bb      	str	r3, [r7, #24]
 8001fe0:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 8001fe2:	f1c3 031f 	rsb	r3, r3, #31
 8001fe6:	6f3a      	ldr	r2, [r7, #112]	; 0x70
 8001fe8:	411a      	asrs	r2, r3
 8001fea:	69bb      	ldr	r3, [r7, #24]
 8001fec:	429a      	cmp	r2, r3
 8001fee:	d009      	beq.n	8002004 <xmp3fixpt_FDCT32+0xdb8>
 8001ff0:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 8001ff2:	f1c3 031f 	rsb	r3, r3, #31
 8001ff6:	2201      	movs	r2, #1
 8001ff8:	fa02 f303 	lsl.w	r3, r2, r3
 8001ffc:	1e5a      	subs	r2, r3, #1
 8001ffe:	69bb      	ldr	r3, [r7, #24]
 8002000:	4053      	eors	r3, r2
 8002002:	673b      	str	r3, [r7, #112]	; 0x70
 8002004:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8002006:	3320      	adds	r3, #32
 8002008:	6f39      	ldr	r1, [r7, #112]	; 0x70
 800200a:	6efa      	ldr	r2, [r7, #108]	; 0x6c
 800200c:	fa01 f202 	lsl.w	r2, r1, r2
 8002010:	601a      	str	r2, [r3, #0]
 8002012:	681a      	ldr	r2, [r3, #0]
 8002014:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8002016:	601a      	str	r2, [r3, #0]
 8002018:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 800201a:	f503 7380 	add.w	r3, r3, #256	; 0x100
 800201e:	667b      	str	r3, [r7, #100]	; 0x64
		for (i = 16; i <= 31; i++) {
 8002020:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 8002022:	3301      	adds	r3, #1
 8002024:	677b      	str	r3, [r7, #116]	; 0x74
 8002026:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 8002028:	2b1f      	cmp	r3, #31
 800202a:	ddd3      	ble.n	8001fd4 <xmp3fixpt_FDCT32+0xd88>
		}

		d = dest + 16 + ((offset - oddBlock) & 7) + (oddBlock ? 0 : VBUF_LENGTH);
 800202c:	687a      	ldr	r2, [r7, #4]
 800202e:	683b      	ldr	r3, [r7, #0]
 8002030:	1ad3      	subs	r3, r2, r3
 8002032:	f003 0307 	and.w	r3, r3, #7
 8002036:	3310      	adds	r3, #16
 8002038:	009a      	lsls	r2, r3, #2
 800203a:	683b      	ldr	r3, [r7, #0]
 800203c:	2b00      	cmp	r3, #0
 800203e:	d001      	beq.n	8002044 <xmp3fixpt_FDCT32+0xdf8>
 8002040:	2300      	movs	r3, #0
 8002042:	e001      	b.n	8002048 <xmp3fixpt_FDCT32+0xdfc>
 8002044:	f44f 5388 	mov.w	r3, #4352	; 0x1100
 8002048:	4413      	add	r3, r2
 800204a:	68ba      	ldr	r2, [r7, #8]
 800204c:	4413      	add	r3, r2
 800204e:	667b      	str	r3, [r7, #100]	; 0x64
		for (i = 15; i >= 0; i--) {
 8002050:	230f      	movs	r3, #15
 8002052:	677b      	str	r3, [r7, #116]	; 0x74
 8002054:	e028      	b.n	80020a8 <xmp3fixpt_FDCT32+0xe5c>
			s = d[0];	CLIP_2N(s, 31 - es);	d[0] = d[8] = (s << es);	d += 64;
 8002056:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8002058:	681b      	ldr	r3, [r3, #0]
 800205a:	673b      	str	r3, [r7, #112]	; 0x70
 800205c:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 800205e:	17db      	asrs	r3, r3, #31
 8002060:	617b      	str	r3, [r7, #20]
 8002062:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 8002064:	f1c3 031f 	rsb	r3, r3, #31
 8002068:	6f3a      	ldr	r2, [r7, #112]	; 0x70
 800206a:	411a      	asrs	r2, r3
 800206c:	697b      	ldr	r3, [r7, #20]
 800206e:	429a      	cmp	r2, r3
 8002070:	d009      	beq.n	8002086 <xmp3fixpt_FDCT32+0xe3a>
 8002072:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 8002074:	f1c3 031f 	rsb	r3, r3, #31
 8002078:	2201      	movs	r2, #1
 800207a:	fa02 f303 	lsl.w	r3, r2, r3
 800207e:	1e5a      	subs	r2, r3, #1
 8002080:	697b      	ldr	r3, [r7, #20]
 8002082:	4053      	eors	r3, r2
 8002084:	673b      	str	r3, [r7, #112]	; 0x70
 8002086:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8002088:	3320      	adds	r3, #32
 800208a:	6f39      	ldr	r1, [r7, #112]	; 0x70
 800208c:	6efa      	ldr	r2, [r7, #108]	; 0x6c
 800208e:	fa01 f202 	lsl.w	r2, r1, r2
 8002092:	601a      	str	r2, [r3, #0]
 8002094:	681a      	ldr	r2, [r3, #0]
 8002096:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8002098:	601a      	str	r2, [r3, #0]
 800209a:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 800209c:	f503 7380 	add.w	r3, r3, #256	; 0x100
 80020a0:	667b      	str	r3, [r7, #100]	; 0x64
		for (i = 15; i >= 0; i--) {
 80020a2:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 80020a4:	3b01      	subs	r3, #1
 80020a6:	677b      	str	r3, [r7, #116]	; 0x74
 80020a8:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 80020aa:	2b00      	cmp	r3, #0
 80020ac:	dad3      	bge.n	8002056 <xmp3fixpt_FDCT32+0xe0a>
		}
	}
}
 80020ae:	bf00      	nop
 80020b0:	377c      	adds	r7, #124	; 0x7c
 80020b2:	46bd      	mov	sp, r7
 80020b4:	bd90      	pop	{r4, r7, pc}
 80020b6:	bf00      	nop

080020b8 <CLZ>:

	return x;
}

static __inline int CLZ(int x)
{
 80020b8:	b480      	push	{r7}
 80020ba:	b085      	sub	sp, #20
 80020bc:	af00      	add	r7, sp, #0
 80020be:	6078      	str	r0, [r7, #4]
while (!(x & 0x80000000)) {
numZeros++;
x <
}*/

	__asm__ ("clz %0, %1" : "=r" (numZeros) : "r" (x) : "cc");
 80020c0:	687b      	ldr	r3, [r7, #4]
 80020c2:	fab3 f383 	clz	r3, r3
 80020c6:	60fb      	str	r3, [r7, #12]

	return numZeros;
 80020c8:	68fb      	ldr	r3, [r7, #12]
}
 80020ca:	4618      	mov	r0, r3
 80020cc:	3714      	adds	r7, #20
 80020ce:	46bd      	mov	sp, r7
 80020d0:	f85d 7b04 	ldr.w	r7, [sp], #4
 80020d4:	4770      	bx	lr

080020d6 <xmp3fixpt_Dequantize>:
 *                round to PCM (>> by 15 less than we otherwise would have).
 *              Equivalently, we can think of the dequantized coefficients as 
 *                Q(DQ_FRACBITS_OUT - 15) with no implicit bias. 
 **************************************************************************************/
int Dequantize(MP3DecInfo *mp3DecInfo, int gr)
{
 80020d6:	b5f0      	push	{r4, r5, r6, r7, lr}
 80020d8:	b095      	sub	sp, #84	; 0x54
 80020da:	af06      	add	r7, sp, #24
 80020dc:	6078      	str	r0, [r7, #4]
 80020de:	6039      	str	r1, [r7, #0]
	HuffmanInfo *hi;
	DequantInfo *di;
	CriticalBandInfo *cbi;

	/* validate pointers */
	if (!mp3DecInfo || !mp3DecInfo->FrameHeaderPS || !mp3DecInfo->SideInfoPS || !mp3DecInfo->ScaleFactorInfoPS || 
 80020e0:	687b      	ldr	r3, [r7, #4]
 80020e2:	2b00      	cmp	r3, #0
 80020e4:	d013      	beq.n	800210e <xmp3fixpt_Dequantize+0x38>
 80020e6:	687b      	ldr	r3, [r7, #4]
 80020e8:	681b      	ldr	r3, [r3, #0]
 80020ea:	2b00      	cmp	r3, #0
 80020ec:	d00f      	beq.n	800210e <xmp3fixpt_Dequantize+0x38>
 80020ee:	687b      	ldr	r3, [r7, #4]
 80020f0:	685b      	ldr	r3, [r3, #4]
 80020f2:	2b00      	cmp	r3, #0
 80020f4:	d00b      	beq.n	800210e <xmp3fixpt_Dequantize+0x38>
 80020f6:	687b      	ldr	r3, [r7, #4]
 80020f8:	689b      	ldr	r3, [r3, #8]
 80020fa:	2b00      	cmp	r3, #0
 80020fc:	d007      	beq.n	800210e <xmp3fixpt_Dequantize+0x38>
		!mp3DecInfo->HuffmanInfoPS || !mp3DecInfo->DequantInfoPS)
 80020fe:	687b      	ldr	r3, [r7, #4]
 8002100:	68db      	ldr	r3, [r3, #12]
	if (!mp3DecInfo || !mp3DecInfo->FrameHeaderPS || !mp3DecInfo->SideInfoPS || !mp3DecInfo->ScaleFactorInfoPS || 
 8002102:	2b00      	cmp	r3, #0
 8002104:	d003      	beq.n	800210e <xmp3fixpt_Dequantize+0x38>
		!mp3DecInfo->HuffmanInfoPS || !mp3DecInfo->DequantInfoPS)
 8002106:	687b      	ldr	r3, [r7, #4]
 8002108:	691b      	ldr	r3, [r3, #16]
 800210a:	2b00      	cmp	r3, #0
 800210c:	d102      	bne.n	8002114 <xmp3fixpt_Dequantize+0x3e>
		return -1;
 800210e:	f04f 33ff 	mov.w	r3, #4294967295
 8002112:	e19b      	b.n	800244c <xmp3fixpt_Dequantize+0x376>

	fh = (FrameHeader *)(mp3DecInfo->FrameHeaderPS);
 8002114:	687b      	ldr	r3, [r7, #4]
 8002116:	681b      	ldr	r3, [r3, #0]
 8002118:	62bb      	str	r3, [r7, #40]	; 0x28

	/* si is an array of up to 4 structs, stored as gr0ch0, gr0ch1, gr1ch0, gr1ch1 */
	si = (SideInfo *)(mp3DecInfo->SideInfoPS);
 800211a:	687b      	ldr	r3, [r7, #4]
 800211c:	685b      	ldr	r3, [r3, #4]
 800211e:	627b      	str	r3, [r7, #36]	; 0x24
	sfi = (ScaleFactorInfo *)(mp3DecInfo->ScaleFactorInfoPS);
 8002120:	687b      	ldr	r3, [r7, #4]
 8002122:	689b      	ldr	r3, [r3, #8]
 8002124:	623b      	str	r3, [r7, #32]
	hi = (HuffmanInfo *)mp3DecInfo->HuffmanInfoPS;
 8002126:	687b      	ldr	r3, [r7, #4]
 8002128:	68db      	ldr	r3, [r3, #12]
 800212a:	61fb      	str	r3, [r7, #28]
	di = (DequantInfo *)mp3DecInfo->DequantInfoPS;
 800212c:	687b      	ldr	r3, [r7, #4]
 800212e:	691b      	ldr	r3, [r3, #16]
 8002130:	61bb      	str	r3, [r7, #24]
	cbi = di->cbi;
 8002132:	69bb      	ldr	r3, [r7, #24]
 8002134:	f503 7346 	add.w	r3, r3, #792	; 0x318
 8002138:	617b      	str	r3, [r7, #20]
	mOut[0] = mOut[1] = 0;
 800213a:	2300      	movs	r3, #0
 800213c:	613b      	str	r3, [r7, #16]
 800213e:	693b      	ldr	r3, [r7, #16]
 8002140:	60fb      	str	r3, [r7, #12]

	/* dequantize all the samples in each channel */
	for (ch = 0; ch < mp3DecInfo->nChans; ch++) {
 8002142:	2300      	movs	r3, #0
 8002144:	633b      	str	r3, [r7, #48]	; 0x30
 8002146:	e045      	b.n	80021d4 <xmp3fixpt_Dequantize+0xfe>
		hi->gb[ch] = DequantChannel(hi->huffDecBuf[ch], di->workBuf, &hi->nonZeroBound[ch], fh,
 8002148:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 800214a:	4613      	mov	r3, r2
 800214c:	00db      	lsls	r3, r3, #3
 800214e:	4413      	add	r3, r2
 8002150:	021b      	lsls	r3, r3, #8
 8002152:	69fa      	ldr	r2, [r7, #28]
 8002154:	18d4      	adds	r4, r2, r3
 8002156:	69bd      	ldr	r5, [r7, #24]
 8002158:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800215a:	f503 6390 	add.w	r3, r3, #1152	; 0x480
 800215e:	009b      	lsls	r3, r3, #2
 8002160:	69fa      	ldr	r2, [r7, #28]
 8002162:	18d6      	adds	r6, r2, r3
 8002164:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8002166:	461a      	mov	r2, r3
 8002168:	00d2      	lsls	r2, r2, #3
 800216a:	441a      	add	r2, r3
 800216c:	00d3      	lsls	r3, r2, #3
 800216e:	461a      	mov	r2, r3
 8002170:	6839      	ldr	r1, [r7, #0]
 8002172:	460b      	mov	r3, r1
 8002174:	00db      	lsls	r3, r3, #3
 8002176:	440b      	add	r3, r1
 8002178:	011b      	lsls	r3, r3, #4
 800217a:	4413      	add	r3, r2
 800217c:	3328      	adds	r3, #40	; 0x28
 800217e:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8002180:	18d0      	adds	r0, r2, r3
 8002182:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8002184:	461a      	mov	r2, r3
 8002186:	0152      	lsls	r2, r2, #5
 8002188:	1ad2      	subs	r2, r2, r3
 800218a:	0053      	lsls	r3, r2, #1
 800218c:	461a      	mov	r2, r3
 800218e:	6839      	ldr	r1, [r7, #0]
 8002190:	460b      	mov	r3, r1
 8002192:	015b      	lsls	r3, r3, #5
 8002194:	1a5b      	subs	r3, r3, r1
 8002196:	009b      	lsls	r3, r3, #2
 8002198:	4413      	add	r3, r2
 800219a:	6a3a      	ldr	r2, [r7, #32]
 800219c:	18d1      	adds	r1, r2, r3
			&si->sis[gr][ch], &sfi->sfis[gr][ch], &cbi[ch]);
 800219e:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 80021a0:	4613      	mov	r3, r2
 80021a2:	005b      	lsls	r3, r3, #1
 80021a4:	4413      	add	r3, r2
 80021a6:	00db      	lsls	r3, r3, #3
 80021a8:	461a      	mov	r2, r3
		hi->gb[ch] = DequantChannel(hi->huffDecBuf[ch], di->workBuf, &hi->nonZeroBound[ch], fh,
 80021aa:	697b      	ldr	r3, [r7, #20]
 80021ac:	4413      	add	r3, r2
 80021ae:	9302      	str	r3, [sp, #8]
 80021b0:	9101      	str	r1, [sp, #4]
 80021b2:	9000      	str	r0, [sp, #0]
 80021b4:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80021b6:	4632      	mov	r2, r6
 80021b8:	4629      	mov	r1, r5
 80021ba:	4620      	mov	r0, r4
 80021bc:	f000 fa9e 	bl	80026fc <xmp3fixpt_DequantChannel>
 80021c0:	4601      	mov	r1, r0
 80021c2:	69fb      	ldr	r3, [r7, #28]
 80021c4:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 80021c6:	f202 4282 	addw	r2, r2, #1154	; 0x482
 80021ca:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
	for (ch = 0; ch < mp3DecInfo->nChans; ch++) {
 80021ce:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80021d0:	3301      	adds	r3, #1
 80021d2:	633b      	str	r3, [r7, #48]	; 0x30
 80021d4:	687b      	ldr	r3, [r7, #4]
 80021d6:	f8d3 27bc 	ldr.w	r2, [r3, #1980]	; 0x7bc
 80021da:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80021dc:	429a      	cmp	r2, r3
 80021de:	dcb3      	bgt.n	8002148 <xmp3fixpt_Dequantize+0x72>
	/* joint stereo processing assumes one guard bit in input samples
	 * it's extremely rare not to have at least one gb, so if this is the case
	 *   just make a pass over the data and clip to [-2^30+1, 2^30-1]
	 * in practice this may never happen
	 */
	if (fh->modeExt && (hi->gb[0] < 1 || hi->gb[1] < 1)) {
 80021e0:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80021e2:	6a1b      	ldr	r3, [r3, #32]
 80021e4:	2b00      	cmp	r3, #0
 80021e6:	d062      	beq.n	80022ae <xmp3fixpt_Dequantize+0x1d8>
 80021e8:	69fb      	ldr	r3, [r7, #28]
 80021ea:	f503 5390 	add.w	r3, r3, #4608	; 0x1200
 80021ee:	3308      	adds	r3, #8
 80021f0:	681b      	ldr	r3, [r3, #0]
 80021f2:	2b00      	cmp	r3, #0
 80021f4:	dd06      	ble.n	8002204 <xmp3fixpt_Dequantize+0x12e>
 80021f6:	69fb      	ldr	r3, [r7, #28]
 80021f8:	f503 5390 	add.w	r3, r3, #4608	; 0x1200
 80021fc:	330c      	adds	r3, #12
 80021fe:	681b      	ldr	r3, [r3, #0]
 8002200:	2b00      	cmp	r3, #0
 8002202:	dc54      	bgt.n	80022ae <xmp3fixpt_Dequantize+0x1d8>
		for (i = 0; i < hi->nonZeroBound[0]; i++) {
 8002204:	2300      	movs	r3, #0
 8002206:	637b      	str	r3, [r7, #52]	; 0x34
 8002208:	e01b      	b.n	8002242 <xmp3fixpt_Dequantize+0x16c>
			if (hi->huffDecBuf[0][i] < -0x3fffffff)	 hi->huffDecBuf[0][i] = -0x3fffffff;
 800220a:	69fb      	ldr	r3, [r7, #28]
 800220c:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 800220e:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8002212:	f1b3 4f40 	cmp.w	r3, #3221225472	; 0xc0000000
 8002216:	dc04      	bgt.n	8002222 <xmp3fixpt_Dequantize+0x14c>
 8002218:	69fb      	ldr	r3, [r7, #28]
 800221a:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 800221c:	498d      	ldr	r1, [pc, #564]	; (8002454 <xmp3fixpt_Dequantize+0x37e>)
 800221e:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
			if (hi->huffDecBuf[0][i] >  0x3fffffff)	 hi->huffDecBuf[0][i] =  0x3fffffff;
 8002222:	69fb      	ldr	r3, [r7, #28]
 8002224:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 8002226:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 800222a:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
 800222e:	db05      	blt.n	800223c <xmp3fixpt_Dequantize+0x166>
 8002230:	69fb      	ldr	r3, [r7, #28]
 8002232:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 8002234:	f06f 4140 	mvn.w	r1, #3221225472	; 0xc0000000
 8002238:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
		for (i = 0; i < hi->nonZeroBound[0]; i++) {
 800223c:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800223e:	3301      	adds	r3, #1
 8002240:	637b      	str	r3, [r7, #52]	; 0x34
 8002242:	69fb      	ldr	r3, [r7, #28]
 8002244:	f503 5390 	add.w	r3, r3, #4608	; 0x1200
 8002248:	681a      	ldr	r2, [r3, #0]
 800224a:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800224c:	429a      	cmp	r2, r3
 800224e:	dcdc      	bgt.n	800220a <xmp3fixpt_Dequantize+0x134>
		}
		for (i = 0; i < hi->nonZeroBound[1]; i++) {
 8002250:	2300      	movs	r3, #0
 8002252:	637b      	str	r3, [r7, #52]	; 0x34
 8002254:	e023      	b.n	800229e <xmp3fixpt_Dequantize+0x1c8>
			if (hi->huffDecBuf[1][i] < -0x3fffffff)	 hi->huffDecBuf[1][i] = -0x3fffffff;
 8002256:	69fb      	ldr	r3, [r7, #28]
 8002258:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 800225a:	f502 7210 	add.w	r2, r2, #576	; 0x240
 800225e:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8002262:	f1b3 4f40 	cmp.w	r3, #3221225472	; 0xc0000000
 8002266:	dc06      	bgt.n	8002276 <xmp3fixpt_Dequantize+0x1a0>
 8002268:	69fb      	ldr	r3, [r7, #28]
 800226a:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 800226c:	f502 7210 	add.w	r2, r2, #576	; 0x240
 8002270:	4978      	ldr	r1, [pc, #480]	; (8002454 <xmp3fixpt_Dequantize+0x37e>)
 8002272:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
			if (hi->huffDecBuf[1][i] >  0x3fffffff)	 hi->huffDecBuf[1][i] =  0x3fffffff;
 8002276:	69fb      	ldr	r3, [r7, #28]
 8002278:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 800227a:	f502 7210 	add.w	r2, r2, #576	; 0x240
 800227e:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8002282:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
 8002286:	db07      	blt.n	8002298 <xmp3fixpt_Dequantize+0x1c2>
 8002288:	69fb      	ldr	r3, [r7, #28]
 800228a:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 800228c:	f502 7210 	add.w	r2, r2, #576	; 0x240
 8002290:	f06f 4140 	mvn.w	r1, #3221225472	; 0xc0000000
 8002294:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
		for (i = 0; i < hi->nonZeroBound[1]; i++) {
 8002298:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800229a:	3301      	adds	r3, #1
 800229c:	637b      	str	r3, [r7, #52]	; 0x34
 800229e:	69fb      	ldr	r3, [r7, #28]
 80022a0:	f503 5390 	add.w	r3, r3, #4608	; 0x1200
 80022a4:	3304      	adds	r3, #4
 80022a6:	681a      	ldr	r2, [r3, #0]
 80022a8:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 80022aa:	429a      	cmp	r2, r3
 80022ac:	dcd3      	bgt.n	8002256 <xmp3fixpt_Dequantize+0x180>
		}
	}

	/* do mid-side stereo processing, if enabled */
	if (fh->modeExt >> 1) {
 80022ae:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80022b0:	6a1b      	ldr	r3, [r3, #32]
 80022b2:	105b      	asrs	r3, r3, #1
 80022b4:	2b00      	cmp	r3, #0
 80022b6:	d039      	beq.n	800232c <xmp3fixpt_Dequantize+0x256>
		if (fh->modeExt & 0x01) {
 80022b8:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80022ba:	6a1b      	ldr	r3, [r3, #32]
 80022bc:	f003 0301 	and.w	r3, r3, #1
 80022c0:	2b00      	cmp	r3, #0
 80022c2:	d01f      	beq.n	8002304 <xmp3fixpt_Dequantize+0x22e>
			/* intensity stereo enabled - run mid-side up to start of right zero region */
			if (cbi[1].cbType == 0)
 80022c4:	697b      	ldr	r3, [r7, #20]
 80022c6:	3318      	adds	r3, #24
 80022c8:	681b      	ldr	r3, [r3, #0]
 80022ca:	2b00      	cmp	r3, #0
 80022cc:	d109      	bne.n	80022e2 <xmp3fixpt_Dequantize+0x20c>
				nSamps = fh->sfBand->l[cbi[1].cbEndL + 1];
 80022ce:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80022d0:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 80022d2:	697a      	ldr	r2, [r7, #20]
 80022d4:	3218      	adds	r2, #24
 80022d6:	6952      	ldr	r2, [r2, #20]
 80022d8:	3201      	adds	r2, #1
 80022da:	f933 3012 	ldrsh.w	r3, [r3, r2, lsl #1]
 80022de:	62fb      	str	r3, [r7, #44]	; 0x2c
 80022e0:	e01d      	b.n	800231e <xmp3fixpt_Dequantize+0x248>
			else 
				nSamps = 3 * fh->sfBand->s[cbi[1].cbEndSMax + 1];
 80022e2:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80022e4:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 80022e6:	697b      	ldr	r3, [r7, #20]
 80022e8:	3318      	adds	r3, #24
 80022ea:	691b      	ldr	r3, [r3, #16]
 80022ec:	3301      	adds	r3, #1
 80022ee:	3314      	adds	r3, #20
 80022f0:	005b      	lsls	r3, r3, #1
 80022f2:	4413      	add	r3, r2
 80022f4:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
 80022f8:	461a      	mov	r2, r3
 80022fa:	4613      	mov	r3, r2
 80022fc:	005b      	lsls	r3, r3, #1
 80022fe:	4413      	add	r3, r2
 8002300:	62fb      	str	r3, [r7, #44]	; 0x2c
 8002302:	e00c      	b.n	800231e <xmp3fixpt_Dequantize+0x248>
		} else {
			/* intensity stereo disabled - run mid-side on whole spectrum */
			nSamps = MAX(hi->nonZeroBound[0], hi->nonZeroBound[1]);
 8002304:	69fb      	ldr	r3, [r7, #28]
 8002306:	f503 5390 	add.w	r3, r3, #4608	; 0x1200
 800230a:	3304      	adds	r3, #4
 800230c:	681a      	ldr	r2, [r3, #0]
 800230e:	69fb      	ldr	r3, [r7, #28]
 8002310:	f503 5390 	add.w	r3, r3, #4608	; 0x1200
 8002314:	681b      	ldr	r3, [r3, #0]
 8002316:	4293      	cmp	r3, r2
 8002318:	bfb8      	it	lt
 800231a:	4613      	movlt	r3, r2
 800231c:	62fb      	str	r3, [r7, #44]	; 0x2c
		}
		MidSideProc(hi->huffDecBuf, nSamps, mOut);
 800231e:	69fb      	ldr	r3, [r7, #28]
 8002320:	f107 020c 	add.w	r2, r7, #12
 8002324:	6af9      	ldr	r1, [r7, #44]	; 0x2c
 8002326:	4618      	mov	r0, r3
 8002328:	f004 fe8e 	bl	8007048 <xmp3fixpt_MidSideProc>
	}

	/* do intensity stereo processing, if enabled */
	if (fh->modeExt & 0x01) {
 800232c:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800232e:	6a1b      	ldr	r3, [r3, #32]
 8002330:	f003 0301 	and.w	r3, r3, #1
 8002334:	2b00      	cmp	r3, #0
 8002336:	d056      	beq.n	80023e6 <xmp3fixpt_Dequantize+0x310>
		nSamps = hi->nonZeroBound[0];
 8002338:	69fb      	ldr	r3, [r7, #28]
 800233a:	f503 5390 	add.w	r3, r3, #4608	; 0x1200
 800233e:	681b      	ldr	r3, [r3, #0]
 8002340:	62fb      	str	r3, [r7, #44]	; 0x2c
		if (fh->ver == MPEG1) {
 8002342:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8002344:	781b      	ldrb	r3, [r3, #0]
 8002346:	2b00      	cmp	r3, #0
 8002348:	d124      	bne.n	8002394 <xmp3fixpt_Dequantize+0x2be>
			IntensityProcMPEG1(hi->huffDecBuf, nSamps, fh, &sfi->sfis[gr][1], di->cbi, 
 800234a:	69fd      	ldr	r5, [r7, #28]
 800234c:	683a      	ldr	r2, [r7, #0]
 800234e:	4613      	mov	r3, r2
 8002350:	015b      	lsls	r3, r3, #5
 8002352:	1a9b      	subs	r3, r3, r2
 8002354:	009b      	lsls	r3, r3, #2
 8002356:	333e      	adds	r3, #62	; 0x3e
 8002358:	6a3a      	ldr	r2, [r7, #32]
 800235a:	18d6      	adds	r6, r2, r3
 800235c:	69bb      	ldr	r3, [r7, #24]
 800235e:	f503 7146 	add.w	r1, r3, #792	; 0x318
				fh->modeExt >> 1, si->sis[gr][1].mixedBlock, mOut);
 8002362:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8002364:	6a1b      	ldr	r3, [r3, #32]
			IntensityProcMPEG1(hi->huffDecBuf, nSamps, fh, &sfi->sfis[gr][1], di->cbi, 
 8002366:	1058      	asrs	r0, r3, #1
 8002368:	6a7c      	ldr	r4, [r7, #36]	; 0x24
 800236a:	683a      	ldr	r2, [r7, #0]
 800236c:	4613      	mov	r3, r2
 800236e:	00db      	lsls	r3, r3, #3
 8002370:	4413      	add	r3, r2
 8002372:	011b      	lsls	r3, r3, #4
 8002374:	4423      	add	r3, r4
 8002376:	3388      	adds	r3, #136	; 0x88
 8002378:	681b      	ldr	r3, [r3, #0]
 800237a:	f107 020c 	add.w	r2, r7, #12
 800237e:	9203      	str	r2, [sp, #12]
 8002380:	9302      	str	r3, [sp, #8]
 8002382:	9001      	str	r0, [sp, #4]
 8002384:	9100      	str	r1, [sp, #0]
 8002386:	4633      	mov	r3, r6
 8002388:	6aba      	ldr	r2, [r7, #40]	; 0x28
 800238a:	6af9      	ldr	r1, [r7, #44]	; 0x2c
 800238c:	4628      	mov	r0, r5
 800238e:	f004 feb5 	bl	80070fc <xmp3fixpt_IntensityProcMPEG1>
 8002392:	e028      	b.n	80023e6 <xmp3fixpt_Dequantize+0x310>
		} else {
			IntensityProcMPEG2(hi->huffDecBuf, nSamps, fh, &sfi->sfis[gr][1], di->cbi, &sfi->sfjs,
 8002394:	69fe      	ldr	r6, [r7, #28]
 8002396:	683a      	ldr	r2, [r7, #0]
 8002398:	4613      	mov	r3, r2
 800239a:	015b      	lsls	r3, r3, #5
 800239c:	1a9b      	subs	r3, r3, r2
 800239e:	009b      	lsls	r3, r3, #2
 80023a0:	333e      	adds	r3, #62	; 0x3e
 80023a2:	6a3a      	ldr	r2, [r7, #32]
 80023a4:	eb02 0e03 	add.w	lr, r2, r3
 80023a8:	69bb      	ldr	r3, [r7, #24]
 80023aa:	f503 7146 	add.w	r1, r3, #792	; 0x318
 80023ae:	6a3b      	ldr	r3, [r7, #32]
 80023b0:	f103 00f8 	add.w	r0, r3, #248	; 0xf8
				fh->modeExt >> 1, si->sis[gr][1].mixedBlock, mOut);
 80023b4:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80023b6:	6a1b      	ldr	r3, [r3, #32]
			IntensityProcMPEG2(hi->huffDecBuf, nSamps, fh, &sfi->sfis[gr][1], di->cbi, &sfi->sfjs,
 80023b8:	105c      	asrs	r4, r3, #1
 80023ba:	6a7d      	ldr	r5, [r7, #36]	; 0x24
 80023bc:	683a      	ldr	r2, [r7, #0]
 80023be:	4613      	mov	r3, r2
 80023c0:	00db      	lsls	r3, r3, #3
 80023c2:	4413      	add	r3, r2
 80023c4:	011b      	lsls	r3, r3, #4
 80023c6:	442b      	add	r3, r5
 80023c8:	3388      	adds	r3, #136	; 0x88
 80023ca:	681b      	ldr	r3, [r3, #0]
 80023cc:	f107 020c 	add.w	r2, r7, #12
 80023d0:	9204      	str	r2, [sp, #16]
 80023d2:	9303      	str	r3, [sp, #12]
 80023d4:	9402      	str	r4, [sp, #8]
 80023d6:	9001      	str	r0, [sp, #4]
 80023d8:	9100      	str	r1, [sp, #0]
 80023da:	4673      	mov	r3, lr
 80023dc:	6aba      	ldr	r2, [r7, #40]	; 0x28
 80023de:	6af9      	ldr	r1, [r7, #44]	; 0x2c
 80023e0:	4630      	mov	r0, r6
 80023e2:	f005 f89e 	bl	8007522 <xmp3fixpt_IntensityProcMPEG2>
		}
	}

	/* adjust guard bit count and nonZeroBound if we did any stereo processing */
	if (fh->modeExt) {
 80023e6:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80023e8:	6a1b      	ldr	r3, [r3, #32]
 80023ea:	2b00      	cmp	r3, #0
 80023ec:	d02d      	beq.n	800244a <xmp3fixpt_Dequantize+0x374>
		hi->gb[0] = CLZ(mOut[0]) - 1;
 80023ee:	68fb      	ldr	r3, [r7, #12]
 80023f0:	4618      	mov	r0, r3
 80023f2:	f7ff fe61 	bl	80020b8 <CLZ>
 80023f6:	4603      	mov	r3, r0
 80023f8:	1e5a      	subs	r2, r3, #1
 80023fa:	69fb      	ldr	r3, [r7, #28]
 80023fc:	f503 5390 	add.w	r3, r3, #4608	; 0x1200
 8002400:	3308      	adds	r3, #8
 8002402:	601a      	str	r2, [r3, #0]
		hi->gb[1] = CLZ(mOut[1]) - 1;
 8002404:	693b      	ldr	r3, [r7, #16]
 8002406:	4618      	mov	r0, r3
 8002408:	f7ff fe56 	bl	80020b8 <CLZ>
 800240c:	4603      	mov	r3, r0
 800240e:	1e5a      	subs	r2, r3, #1
 8002410:	69fb      	ldr	r3, [r7, #28]
 8002412:	f503 5390 	add.w	r3, r3, #4608	; 0x1200
 8002416:	330c      	adds	r3, #12
 8002418:	601a      	str	r2, [r3, #0]
		nSamps = MAX(hi->nonZeroBound[0], hi->nonZeroBound[1]);
 800241a:	69fb      	ldr	r3, [r7, #28]
 800241c:	f503 5390 	add.w	r3, r3, #4608	; 0x1200
 8002420:	3304      	adds	r3, #4
 8002422:	681a      	ldr	r2, [r3, #0]
 8002424:	69fb      	ldr	r3, [r7, #28]
 8002426:	f503 5390 	add.w	r3, r3, #4608	; 0x1200
 800242a:	681b      	ldr	r3, [r3, #0]
 800242c:	4293      	cmp	r3, r2
 800242e:	bfb8      	it	lt
 8002430:	4613      	movlt	r3, r2
 8002432:	62fb      	str	r3, [r7, #44]	; 0x2c
		hi->nonZeroBound[0] = nSamps;
 8002434:	69fb      	ldr	r3, [r7, #28]
 8002436:	f503 5390 	add.w	r3, r3, #4608	; 0x1200
 800243a:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 800243c:	601a      	str	r2, [r3, #0]
		hi->nonZeroBound[1] = nSamps;
 800243e:	69fb      	ldr	r3, [r7, #28]
 8002440:	f503 5390 	add.w	r3, r3, #4608	; 0x1200
 8002444:	3304      	adds	r3, #4
 8002446:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8002448:	601a      	str	r2, [r3, #0]
	}

	/* output format Q(DQ_FRACBITS_OUT) */
	return 0;
 800244a:	2300      	movs	r3, #0
}
 800244c:	4618      	mov	r0, r3
 800244e:	373c      	adds	r7, #60	; 0x3c
 8002450:	46bd      	mov	sp, r7
 8002452:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8002454:	c0000001 	.word	0xc0000001

08002458 <MULSHIFT32>:
{
 8002458:	b480      	push	{r7}
 800245a:	b085      	sub	sp, #20
 800245c:	af00      	add	r7, sp, #0
 800245e:	6078      	str	r0, [r7, #4]
 8002460:	6039      	str	r1, [r7, #0]
	__asm__ volatile ("smull %0,%1,%2,%3" : "=&r" (zlow), "=r" (y) : "r" (x), "1" (y) : "cc");
 8002462:	6879      	ldr	r1, [r7, #4]
 8002464:	683b      	ldr	r3, [r7, #0]
 8002466:	fb81 2303 	smull	r2, r3, r1, r3
 800246a:	60fa      	str	r2, [r7, #12]
 800246c:	603b      	str	r3, [r7, #0]
	return y;
 800246e:	683b      	ldr	r3, [r7, #0]
}
 8002470:	4618      	mov	r0, r3
 8002472:	3714      	adds	r7, #20
 8002474:	46bd      	mov	sp, r7
 8002476:	f85d 7b04 	ldr.w	r7, [sp], #4
 800247a:	4770      	bx	lr

0800247c <CLZ>:
{
 800247c:	b480      	push	{r7}
 800247e:	b085      	sub	sp, #20
 8002480:	af00      	add	r7, sp, #0
 8002482:	6078      	str	r0, [r7, #4]
	__asm__ ("clz %0, %1" : "=r" (numZeros) : "r" (x) : "cc");
 8002484:	687b      	ldr	r3, [r7, #4]
 8002486:	fab3 f383 	clz	r3, r3
 800248a:	60fb      	str	r3, [r7, #12]
	return numZeros;
 800248c:	68fb      	ldr	r3, [r7, #12]
}
 800248e:	4618      	mov	r0, r3
 8002490:	3714      	adds	r7, #20
 8002492:	46bd      	mov	sp, r7
 8002494:	f85d 7b04 	ldr.w	r7, [sp], #4
 8002498:	4770      	bx	lr

0800249a <DequantBlock>:
 * Outputs:     dequantized samples in Q25 format
 *
 * Return:      bitwise-OR of the unsigned outputs (for guard bit calculations)
 **************************************************************************************/
static int DequantBlock(int *inbuf, int *outbuf, int num, int scale)
{
 800249a:	b580      	push	{r7, lr}
 800249c:	b092      	sub	sp, #72	; 0x48
 800249e:	af00      	add	r7, sp, #0
 80024a0:	60f8      	str	r0, [r7, #12]
 80024a2:	60b9      	str	r1, [r7, #8]
 80024a4:	607a      	str	r2, [r7, #4]
 80024a6:	603b      	str	r3, [r7, #0]
	int tab4[4];
	int scalef, scalei, shift;
	int sx, x, y;
	int mask = 0;
 80024a8:	2300      	movs	r3, #0
 80024aa:	63bb      	str	r3, [r7, #56]	; 0x38
	const int *tab16, *coef;

	tab16 = pow43_14[scale & 0x3];
 80024ac:	683b      	ldr	r3, [r7, #0]
 80024ae:	f003 0303 	and.w	r3, r3, #3
 80024b2:	019b      	lsls	r3, r3, #6
 80024b4:	4a89      	ldr	r2, [pc, #548]	; (80026dc <DequantBlock+0x242>)
 80024b6:	4413      	add	r3, r2
 80024b8:	637b      	str	r3, [r7, #52]	; 0x34
	scalef = pow14[scale & 0x3];
 80024ba:	683b      	ldr	r3, [r7, #0]
 80024bc:	f003 0303 	and.w	r3, r3, #3
 80024c0:	4a87      	ldr	r2, [pc, #540]	; (80026e0 <DequantBlock+0x246>)
 80024c2:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 80024c6:	633b      	str	r3, [r7, #48]	; 0x30
	scalei = MIN(scale >> 2, 31);	/* smallest input scale = -47, so smallest scalei = -12 */
 80024c8:	683b      	ldr	r3, [r7, #0]
 80024ca:	109b      	asrs	r3, r3, #2
 80024cc:	2b1f      	cmp	r3, #31
 80024ce:	bfa8      	it	ge
 80024d0:	231f      	movge	r3, #31
 80024d2:	62fb      	str	r3, [r7, #44]	; 0x2c

	/* cache first 4 values */
	shift = MIN(scalei + 3, 31);
 80024d4:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80024d6:	3303      	adds	r3, #3
 80024d8:	2b1f      	cmp	r3, #31
 80024da:	bfa8      	it	ge
 80024dc:	231f      	movge	r3, #31
 80024de:	647b      	str	r3, [r7, #68]	; 0x44
	shift = MAX(shift, 0);
 80024e0:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 80024e2:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
 80024e6:	647b      	str	r3, [r7, #68]	; 0x44
	tab4[0] = 0;
 80024e8:	2300      	movs	r3, #0
 80024ea:	617b      	str	r3, [r7, #20]
	tab4[1] = tab16[1] >> shift;
 80024ec:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 80024ee:	3304      	adds	r3, #4
 80024f0:	681a      	ldr	r2, [r3, #0]
 80024f2:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 80024f4:	fa42 f303 	asr.w	r3, r2, r3
 80024f8:	61bb      	str	r3, [r7, #24]
	tab4[2] = tab16[2] >> shift;
 80024fa:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 80024fc:	3308      	adds	r3, #8
 80024fe:	681a      	ldr	r2, [r3, #0]
 8002500:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8002502:	fa42 f303 	asr.w	r3, r2, r3
 8002506:	61fb      	str	r3, [r7, #28]
	tab4[3] = tab16[3] >> shift;
 8002508:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800250a:	330c      	adds	r3, #12
 800250c:	681a      	ldr	r2, [r3, #0]
 800250e:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8002510:	fa42 f303 	asr.w	r3, r2, r3
 8002514:	623b      	str	r3, [r7, #32]

	do {

		sx = *inbuf++;
 8002516:	68fb      	ldr	r3, [r7, #12]
 8002518:	1d1a      	adds	r2, r3, #4
 800251a:	60fa      	str	r2, [r7, #12]
 800251c:	681b      	ldr	r3, [r3, #0]
 800251e:	62bb      	str	r3, [r7, #40]	; 0x28
		x = sx & 0x7fffffff;	/* sx = sign|mag */
 8002520:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8002522:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
 8002526:	643b      	str	r3, [r7, #64]	; 0x40

		if (x < 4) {
 8002528:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800252a:	2b03      	cmp	r3, #3
 800252c:	dc08      	bgt.n	8002540 <DequantBlock+0xa6>

			y = tab4[x];
 800252e:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8002530:	009b      	lsls	r3, r3, #2
 8002532:	f107 0248 	add.w	r2, r7, #72	; 0x48
 8002536:	4413      	add	r3, r2
 8002538:	f853 3c34 	ldr.w	r3, [r3, #-52]
 800253c:	63fb      	str	r3, [r7, #60]	; 0x3c
 800253e:	e0b2      	b.n	80026a6 <DequantBlock+0x20c>

		} else if (x < 16) {
 8002540:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8002542:	2b0f      	cmp	r3, #15
 8002544:	dc14      	bgt.n	8002570 <DequantBlock+0xd6>

			y = tab16[x];
 8002546:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8002548:	009b      	lsls	r3, r3, #2
 800254a:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 800254c:	4413      	add	r3, r2
 800254e:	681b      	ldr	r3, [r3, #0]
 8002550:	63fb      	str	r3, [r7, #60]	; 0x3c
			y = (scalei < 0) ? y << -scalei : y >> scalei;
 8002552:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8002554:	2b00      	cmp	r3, #0
 8002556:	da05      	bge.n	8002564 <DequantBlock+0xca>
 8002558:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800255a:	425b      	negs	r3, r3
 800255c:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 800255e:	fa02 f303 	lsl.w	r3, r2, r3
 8002562:	e003      	b.n	800256c <DequantBlock+0xd2>
 8002564:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 8002566:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8002568:	fa42 f303 	asr.w	r3, r2, r3
 800256c:	63fb      	str	r3, [r7, #60]	; 0x3c
 800256e:	e09a      	b.n	80026a6 <DequantBlock+0x20c>

		} else {

			if (x < 64) {
 8002570:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8002572:	2b3f      	cmp	r3, #63	; 0x3f
 8002574:	dc0e      	bgt.n	8002594 <DequantBlock+0xfa>

				y = pow43[x-16];
 8002576:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8002578:	3b10      	subs	r3, #16
 800257a:	4a5a      	ldr	r2, [pc, #360]	; (80026e4 <DequantBlock+0x24a>)
 800257c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 8002580:	63fb      	str	r3, [r7, #60]	; 0x3c

				/* fractional scale */
				y = MULSHIFT32(y, scalef);
 8002582:	6b39      	ldr	r1, [r7, #48]	; 0x30
 8002584:	6bf8      	ldr	r0, [r7, #60]	; 0x3c
 8002586:	f7ff ff67 	bl	8002458 <MULSHIFT32>
 800258a:	63f8      	str	r0, [r7, #60]	; 0x3c
				shift = scalei - 3;
 800258c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800258e:	3b03      	subs	r3, #3
 8002590:	647b      	str	r3, [r7, #68]	; 0x44
 8002592:	e06c      	b.n	800266e <DequantBlock+0x1d4>

			} else {

				/* normalize to [0x40000000, 0x7fffffff] */
				x <<= 17;
 8002594:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8002596:	045b      	lsls	r3, r3, #17
 8002598:	643b      	str	r3, [r7, #64]	; 0x40
				shift = 0;
 800259a:	2300      	movs	r3, #0
 800259c:	647b      	str	r3, [r7, #68]	; 0x44
				if (x < 0x08000000)
 800259e:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 80025a0:	f1b3 6f00 	cmp.w	r3, #134217728	; 0x8000000
 80025a4:	da05      	bge.n	80025b2 <DequantBlock+0x118>
					x <<= 4, shift += 4;
 80025a6:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 80025a8:	011b      	lsls	r3, r3, #4
 80025aa:	643b      	str	r3, [r7, #64]	; 0x40
 80025ac:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 80025ae:	3304      	adds	r3, #4
 80025b0:	647b      	str	r3, [r7, #68]	; 0x44
				if (x < 0x20000000)
 80025b2:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 80025b4:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
 80025b8:	da05      	bge.n	80025c6 <DequantBlock+0x12c>
					x <<= 2, shift += 2;
 80025ba:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 80025bc:	009b      	lsls	r3, r3, #2
 80025be:	643b      	str	r3, [r7, #64]	; 0x40
 80025c0:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 80025c2:	3302      	adds	r3, #2
 80025c4:	647b      	str	r3, [r7, #68]	; 0x44
				if (x < 0x40000000)
 80025c6:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 80025c8:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
 80025cc:	da05      	bge.n	80025da <DequantBlock+0x140>
					x <<= 1, shift += 1;
 80025ce:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 80025d0:	005b      	lsls	r3, r3, #1
 80025d2:	643b      	str	r3, [r7, #64]	; 0x40
 80025d4:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 80025d6:	3301      	adds	r3, #1
 80025d8:	647b      	str	r3, [r7, #68]	; 0x44

				coef = (x < SQRTHALF) ? poly43lo : poly43hi;
 80025da:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 80025dc:	4a42      	ldr	r2, [pc, #264]	; (80026e8 <DequantBlock+0x24e>)
 80025de:	4293      	cmp	r3, r2
 80025e0:	dc01      	bgt.n	80025e6 <DequantBlock+0x14c>
 80025e2:	4b42      	ldr	r3, [pc, #264]	; (80026ec <DequantBlock+0x252>)
 80025e4:	e000      	b.n	80025e8 <DequantBlock+0x14e>
 80025e6:	4b42      	ldr	r3, [pc, #264]	; (80026f0 <DequantBlock+0x256>)
 80025e8:	627b      	str	r3, [r7, #36]	; 0x24

				/* polynomial */
				y = coef[0];
 80025ea:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80025ec:	681b      	ldr	r3, [r3, #0]
 80025ee:	63fb      	str	r3, [r7, #60]	; 0x3c
				y = MULSHIFT32(y, x) + coef[1];
 80025f0:	6c39      	ldr	r1, [r7, #64]	; 0x40
 80025f2:	6bf8      	ldr	r0, [r7, #60]	; 0x3c
 80025f4:	f7ff ff30 	bl	8002458 <MULSHIFT32>
 80025f8:	4602      	mov	r2, r0
 80025fa:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80025fc:	3304      	adds	r3, #4
 80025fe:	681b      	ldr	r3, [r3, #0]
 8002600:	4413      	add	r3, r2
 8002602:	63fb      	str	r3, [r7, #60]	; 0x3c
				y = MULSHIFT32(y, x) + coef[2];
 8002604:	6c39      	ldr	r1, [r7, #64]	; 0x40
 8002606:	6bf8      	ldr	r0, [r7, #60]	; 0x3c
 8002608:	f7ff ff26 	bl	8002458 <MULSHIFT32>
 800260c:	4602      	mov	r2, r0
 800260e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8002610:	3308      	adds	r3, #8
 8002612:	681b      	ldr	r3, [r3, #0]
 8002614:	4413      	add	r3, r2
 8002616:	63fb      	str	r3, [r7, #60]	; 0x3c
				y = MULSHIFT32(y, x) + coef[3];
 8002618:	6c39      	ldr	r1, [r7, #64]	; 0x40
 800261a:	6bf8      	ldr	r0, [r7, #60]	; 0x3c
 800261c:	f7ff ff1c 	bl	8002458 <MULSHIFT32>
 8002620:	4602      	mov	r2, r0
 8002622:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8002624:	330c      	adds	r3, #12
 8002626:	681b      	ldr	r3, [r3, #0]
 8002628:	4413      	add	r3, r2
 800262a:	63fb      	str	r3, [r7, #60]	; 0x3c
				y = MULSHIFT32(y, x) + coef[4];
 800262c:	6c39      	ldr	r1, [r7, #64]	; 0x40
 800262e:	6bf8      	ldr	r0, [r7, #60]	; 0x3c
 8002630:	f7ff ff12 	bl	8002458 <MULSHIFT32>
 8002634:	4602      	mov	r2, r0
 8002636:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8002638:	3310      	adds	r3, #16
 800263a:	681b      	ldr	r3, [r3, #0]
 800263c:	4413      	add	r3, r2
 800263e:	63fb      	str	r3, [r7, #60]	; 0x3c
				y = MULSHIFT32(y, pow2frac[shift]) << 3;
 8002640:	4a2c      	ldr	r2, [pc, #176]	; (80026f4 <DequantBlock+0x25a>)
 8002642:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8002644:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 8002648:	4619      	mov	r1, r3
 800264a:	6bf8      	ldr	r0, [r7, #60]	; 0x3c
 800264c:	f7ff ff04 	bl	8002458 <MULSHIFT32>
 8002650:	4603      	mov	r3, r0
 8002652:	00db      	lsls	r3, r3, #3
 8002654:	63fb      	str	r3, [r7, #60]	; 0x3c

				/* fractional scale */
				y = MULSHIFT32(y, scalef);
 8002656:	6b39      	ldr	r1, [r7, #48]	; 0x30
 8002658:	6bf8      	ldr	r0, [r7, #60]	; 0x3c
 800265a:	f7ff fefd 	bl	8002458 <MULSHIFT32>
 800265e:	63f8      	str	r0, [r7, #60]	; 0x3c
				shift = scalei - pow2exp[shift];
 8002660:	4a25      	ldr	r2, [pc, #148]	; (80026f8 <DequantBlock+0x25e>)
 8002662:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8002664:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 8002668:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 800266a:	1ad3      	subs	r3, r2, r3
 800266c:	647b      	str	r3, [r7, #68]	; 0x44
			}

			/* integer scale */
			if (shift < 0) {
 800266e:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8002670:	2b00      	cmp	r3, #0
 8002672:	da13      	bge.n	800269c <DequantBlock+0x202>
				shift = -shift;
 8002674:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8002676:	425b      	negs	r3, r3
 8002678:	647b      	str	r3, [r7, #68]	; 0x44
				if (y > (0x7fffffff >> shift))
 800267a:	f06f 4200 	mvn.w	r2, #2147483648	; 0x80000000
 800267e:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8002680:	411a      	asrs	r2, r3
 8002682:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8002684:	429a      	cmp	r2, r3
 8002686:	da03      	bge.n	8002690 <DequantBlock+0x1f6>
					y = 0x7fffffff;		/* clip */
 8002688:	f06f 4300 	mvn.w	r3, #2147483648	; 0x80000000
 800268c:	63fb      	str	r3, [r7, #60]	; 0x3c
 800268e:	e00a      	b.n	80026a6 <DequantBlock+0x20c>
				else
					y <<= shift;
 8002690:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 8002692:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8002694:	fa02 f303 	lsl.w	r3, r2, r3
 8002698:	63fb      	str	r3, [r7, #60]	; 0x3c
 800269a:	e004      	b.n	80026a6 <DequantBlock+0x20c>
			} else {
				y >>= shift;
 800269c:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 800269e:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 80026a0:	fa42 f303 	asr.w	r3, r2, r3
 80026a4:	63fb      	str	r3, [r7, #60]	; 0x3c
			}
		}

		/* sign and store */
		mask |= y;
 80026a6:	6bba      	ldr	r2, [r7, #56]	; 0x38
 80026a8:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 80026aa:	4313      	orrs	r3, r2
 80026ac:	63bb      	str	r3, [r7, #56]	; 0x38
		*outbuf++ = (sx < 0) ? -y : y;
 80026ae:	68bb      	ldr	r3, [r7, #8]
 80026b0:	1d1a      	adds	r2, r3, #4
 80026b2:	60ba      	str	r2, [r7, #8]
 80026b4:	6aba      	ldr	r2, [r7, #40]	; 0x28
 80026b6:	2a00      	cmp	r2, #0
 80026b8:	da02      	bge.n	80026c0 <DequantBlock+0x226>
 80026ba:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 80026bc:	4252      	negs	r2, r2
 80026be:	e000      	b.n	80026c2 <DequantBlock+0x228>
 80026c0:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 80026c2:	601a      	str	r2, [r3, #0]

	} while (--num);
 80026c4:	687b      	ldr	r3, [r7, #4]
 80026c6:	3b01      	subs	r3, #1
 80026c8:	607b      	str	r3, [r7, #4]
 80026ca:	687b      	ldr	r3, [r7, #4]
 80026cc:	2b00      	cmp	r3, #0
 80026ce:	f47f af22 	bne.w	8002516 <DequantBlock+0x7c>

	return mask;
 80026d2:	6bbb      	ldr	r3, [r7, #56]	; 0x38
}
 80026d4:	4618      	mov	r0, r3
 80026d6:	3748      	adds	r7, #72	; 0x48
 80026d8:	46bd      	mov	sp, r7
 80026da:	bd80      	pop	{r7, pc}
 80026dc:	08017c38 	.word	0x08017c38
 80026e0:	08017c28 	.word	0x08017c28
 80026e4:	08017d38 	.word	0x08017d38
 80026e8:	5a827999 	.word	0x5a827999
 80026ec:	08017df8 	.word	0x08017df8
 80026f0:	08017e0c 	.word	0x08017e0c
 80026f4:	08017e40 	.word	0x08017e40
 80026f8:	08017e20 	.word	0x08017e20

080026fc <xmp3fixpt_DequantChannel>:
 *
 * Notes:       dequantized samples in Q(DQ_FRACBITS_OUT) format 
 **************************************************************************************/
int DequantChannel(int *sampleBuf, int *workBuf, int *nonZeroBound, FrameHeader *fh, SideInfoSub *sis, 
					ScaleFactorInfoSub *sfis, CriticalBandInfo *cbi)
{
 80026fc:	b580      	push	{r7, lr}
 80026fe:	b096      	sub	sp, #88	; 0x58
 8002700:	af00      	add	r7, sp, #0
 8002702:	60f8      	str	r0, [r7, #12]
 8002704:	60b9      	str	r1, [r7, #8]
 8002706:	607a      	str	r2, [r7, #4]
 8002708:	603b      	str	r3, [r7, #0]
	int globalGain, gainI;
	int cbMax[3];
	ARRAY3 *buf;    /* short block reorder */
	
	/* set default start/end points for short/long blocks - will update with non-zero cb info */
	if (sis->blockType == 2) {
 800270a:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 800270c:	695b      	ldr	r3, [r3, #20]
 800270e:	2b02      	cmp	r3, #2
 8002710:	d117      	bne.n	8002742 <xmp3fixpt_DequantChannel+0x46>
		cbStartL = 0;
 8002712:	2300      	movs	r3, #0
 8002714:	633b      	str	r3, [r7, #48]	; 0x30
		if (sis->mixedBlock) { 
 8002716:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 8002718:	699b      	ldr	r3, [r3, #24]
 800271a:	2b00      	cmp	r3, #0
 800271c:	d00a      	beq.n	8002734 <xmp3fixpt_DequantChannel+0x38>
			cbEndL = (fh->ver == MPEG1 ? 8 : 6); 
 800271e:	683b      	ldr	r3, [r7, #0]
 8002720:	781b      	ldrb	r3, [r3, #0]
 8002722:	2b00      	cmp	r3, #0
 8002724:	d101      	bne.n	800272a <xmp3fixpt_DequantChannel+0x2e>
 8002726:	2308      	movs	r3, #8
 8002728:	e000      	b.n	800272c <xmp3fixpt_DequantChannel+0x30>
 800272a:	2306      	movs	r3, #6
 800272c:	647b      	str	r3, [r7, #68]	; 0x44
			cbStartS = 3; 
 800272e:	2303      	movs	r3, #3
 8002730:	643b      	str	r3, [r7, #64]	; 0x40
 8002732:	e003      	b.n	800273c <xmp3fixpt_DequantChannel+0x40>
		} else {
			cbEndL = 0; 
 8002734:	2300      	movs	r3, #0
 8002736:	647b      	str	r3, [r7, #68]	; 0x44
			cbStartS = 0;
 8002738:	2300      	movs	r3, #0
 800273a:	643b      	str	r3, [r7, #64]	; 0x40
		}
		cbEndS = 13;
 800273c:	230d      	movs	r3, #13
 800273e:	63fb      	str	r3, [r7, #60]	; 0x3c
 8002740:	e007      	b.n	8002752 <xmp3fixpt_DequantChannel+0x56>
	} else {
		/* long block */
		cbStartL = 0;
 8002742:	2300      	movs	r3, #0
 8002744:	633b      	str	r3, [r7, #48]	; 0x30
		cbEndL =   22;
 8002746:	2316      	movs	r3, #22
 8002748:	647b      	str	r3, [r7, #68]	; 0x44
		cbStartS = 13;
 800274a:	230d      	movs	r3, #13
 800274c:	643b      	str	r3, [r7, #64]	; 0x40
		cbEndS =   13;
 800274e:	230d      	movs	r3, #13
 8002750:	63fb      	str	r3, [r7, #60]	; 0x3c
	}
	cbMax[2] = cbMax[1] = cbMax[0] = 0;
 8002752:	2300      	movs	r3, #0
 8002754:	613b      	str	r3, [r7, #16]
 8002756:	693b      	ldr	r3, [r7, #16]
 8002758:	617b      	str	r3, [r7, #20]
 800275a:	697b      	ldr	r3, [r7, #20]
 800275c:	61bb      	str	r3, [r7, #24]
	gbMask = 0;
 800275e:	2300      	movs	r3, #0
 8002760:	63bb      	str	r3, [r7, #56]	; 0x38
	i = 0;
 8002762:	2300      	movs	r3, #0
 8002764:	657b      	str	r3, [r7, #84]	; 0x54

	/* sfactScale = 0 --> quantizer step size = 2
	 * sfactScale = 1 --> quantizer step size = sqrt(2)
	 *   so sfactMultiplier = 2 or 4 (jump through globalGain by powers of 2 or sqrt(2))
	 */
	sfactMultiplier = 2 * (sis->sfactScale + 1);
 8002766:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 8002768:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 800276a:	3301      	adds	r3, #1
 800276c:	005b      	lsls	r3, r3, #1
 800276e:	62fb      	str	r3, [r7, #44]	; 0x2c

	/* offset globalGain by -2 if midSide enabled, for 1/sqrt(2) used in MidSideProc()
	 *  (DequantBlock() does 0.25 * gainI so knocking it down by two is the same as 
	 *   dividing every sample by sqrt(2) = multiplying by 2^-.5)
	 */
	globalGain = sis->globalGain;
 8002770:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 8002772:	689b      	ldr	r3, [r3, #8]
 8002774:	637b      	str	r3, [r7, #52]	; 0x34
	if (fh->modeExt >> 1)
 8002776:	683b      	ldr	r3, [r7, #0]
 8002778:	6a1b      	ldr	r3, [r3, #32]
 800277a:	105b      	asrs	r3, r3, #1
 800277c:	2b00      	cmp	r3, #0
 800277e:	d002      	beq.n	8002786 <xmp3fixpt_DequantChannel+0x8a>
		 globalGain -= 2;
 8002780:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8002782:	3b02      	subs	r3, #2
 8002784:	637b      	str	r3, [r7, #52]	; 0x34
	globalGain += IMDCT_SCALE;		/* scale everything by sqrt(2), for fast IMDCT36 */
 8002786:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8002788:	3302      	adds	r3, #2
 800278a:	637b      	str	r3, [r7, #52]	; 0x34

	/* long blocks */
	for (cb = 0; cb < cbEndL; cb++) {
 800278c:	2300      	movs	r3, #0
 800278e:	64bb      	str	r3, [r7, #72]	; 0x48
 8002790:	e04c      	b.n	800282c <xmp3fixpt_DequantChannel+0x130>

		nonZero = 0;
 8002792:	2300      	movs	r3, #0
 8002794:	62bb      	str	r3, [r7, #40]	; 0x28
		nSamps = fh->sfBand->l[cb + 1] - fh->sfBand->l[cb];
 8002796:	683b      	ldr	r3, [r7, #0]
 8002798:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 800279a:	6cba      	ldr	r2, [r7, #72]	; 0x48
 800279c:	3201      	adds	r2, #1
 800279e:	f933 3012 	ldrsh.w	r3, [r3, r2, lsl #1]
 80027a2:	4619      	mov	r1, r3
 80027a4:	683b      	ldr	r3, [r7, #0]
 80027a6:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 80027a8:	6cba      	ldr	r2, [r7, #72]	; 0x48
 80027aa:	f933 3012 	ldrsh.w	r3, [r3, r2, lsl #1]
 80027ae:	1acb      	subs	r3, r1, r3
 80027b0:	627b      	str	r3, [r7, #36]	; 0x24
		gainI = 210 - globalGain + sfactMultiplier * (sfis->l[cb] + (sis->preFlag ? (int)preTab[cb] : 0));
 80027b2:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 80027b4:	f1c3 02d2 	rsb	r2, r3, #210	; 0xd2
 80027b8:	6e79      	ldr	r1, [r7, #100]	; 0x64
 80027ba:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 80027bc:	440b      	add	r3, r1
 80027be:	781b      	ldrb	r3, [r3, #0]
 80027c0:	4618      	mov	r0, r3
 80027c2:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 80027c4:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 80027c6:	2b00      	cmp	r3, #0
 80027c8:	d004      	beq.n	80027d4 <xmp3fixpt_DequantChannel+0xd8>
 80027ca:	49a1      	ldr	r1, [pc, #644]	; (8002a50 <xmp3fixpt_DequantChannel+0x354>)
 80027cc:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 80027ce:	440b      	add	r3, r1
 80027d0:	781b      	ldrb	r3, [r3, #0]
 80027d2:	e000      	b.n	80027d6 <xmp3fixpt_DequantChannel+0xda>
 80027d4:	2300      	movs	r3, #0
 80027d6:	4403      	add	r3, r0
 80027d8:	6af9      	ldr	r1, [r7, #44]	; 0x2c
 80027da:	fb01 f303 	mul.w	r3, r1, r3
 80027de:	4413      	add	r3, r2
 80027e0:	623b      	str	r3, [r7, #32]

		nonZero |= DequantBlock(sampleBuf + i, sampleBuf + i, nSamps, gainI);
 80027e2:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 80027e4:	009b      	lsls	r3, r3, #2
 80027e6:	68fa      	ldr	r2, [r7, #12]
 80027e8:	18d0      	adds	r0, r2, r3
 80027ea:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 80027ec:	009b      	lsls	r3, r3, #2
 80027ee:	68fa      	ldr	r2, [r7, #12]
 80027f0:	18d1      	adds	r1, r2, r3
 80027f2:	6a3b      	ldr	r3, [r7, #32]
 80027f4:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 80027f6:	f7ff fe50 	bl	800249a <DequantBlock>
 80027fa:	4602      	mov	r2, r0
 80027fc:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80027fe:	4313      	orrs	r3, r2
 8002800:	62bb      	str	r3, [r7, #40]	; 0x28
		i += nSamps;
 8002802:	6d7a      	ldr	r2, [r7, #84]	; 0x54
 8002804:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8002806:	4413      	add	r3, r2
 8002808:	657b      	str	r3, [r7, #84]	; 0x54

		/* update highest non-zero critical band */
		if (nonZero) 
 800280a:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800280c:	2b00      	cmp	r3, #0
 800280e:	d001      	beq.n	8002814 <xmp3fixpt_DequantChannel+0x118>
			cbMax[0] = cb;
 8002810:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8002812:	613b      	str	r3, [r7, #16]
		gbMask |= nonZero;
 8002814:	6bba      	ldr	r2, [r7, #56]	; 0x38
 8002816:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8002818:	4313      	orrs	r3, r2
 800281a:	63bb      	str	r3, [r7, #56]	; 0x38

		if (i >= *nonZeroBound) 
 800281c:	687b      	ldr	r3, [r7, #4]
 800281e:	681a      	ldr	r2, [r3, #0]
 8002820:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8002822:	429a      	cmp	r2, r3
 8002824:	dd07      	ble.n	8002836 <xmp3fixpt_DequantChannel+0x13a>
	for (cb = 0; cb < cbEndL; cb++) {
 8002826:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8002828:	3301      	adds	r3, #1
 800282a:	64bb      	str	r3, [r7, #72]	; 0x48
 800282c:	6cba      	ldr	r2, [r7, #72]	; 0x48
 800282e:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8002830:	429a      	cmp	r2, r3
 8002832:	dbae      	blt.n	8002792 <xmp3fixpt_DequantChannel+0x96>
 8002834:	e000      	b.n	8002838 <xmp3fixpt_DequantChannel+0x13c>
			break;
 8002836:	bf00      	nop
	}

	/* set cbi (Type, EndS[], EndSMax will be overwritten if we proceed to do short blocks) */
	cbi->cbType = 0;			/* long only */
 8002838:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 800283a:	2200      	movs	r2, #0
 800283c:	601a      	str	r2, [r3, #0]
	cbi->cbEndL  = cbMax[0];
 800283e:	693a      	ldr	r2, [r7, #16]
 8002840:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 8002842:	615a      	str	r2, [r3, #20]
	cbi->cbEndS[0] = cbi->cbEndS[1] = cbi->cbEndS[2] = 0;
 8002844:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 8002846:	2200      	movs	r2, #0
 8002848:	60da      	str	r2, [r3, #12]
 800284a:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 800284c:	68da      	ldr	r2, [r3, #12]
 800284e:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 8002850:	609a      	str	r2, [r3, #8]
 8002852:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 8002854:	689a      	ldr	r2, [r3, #8]
 8002856:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 8002858:	605a      	str	r2, [r3, #4]
	cbi->cbEndSMax = 0;
 800285a:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 800285c:	2200      	movs	r2, #0
 800285e:	611a      	str	r2, [r3, #16]

	/* early exit if no short blocks */
	if (cbStartS >= 12) 
 8002860:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8002862:	2b0b      	cmp	r3, #11
 8002864:	dd05      	ble.n	8002872 <xmp3fixpt_DequantChannel+0x176>
		return CLZ(gbMask) - 1;
 8002866:	6bb8      	ldr	r0, [r7, #56]	; 0x38
 8002868:	f7ff fe08 	bl	800247c <CLZ>
 800286c:	4603      	mov	r3, r0
 800286e:	3b01      	subs	r3, #1
 8002870:	e0ea      	b.n	8002a48 <xmp3fixpt_DequantChannel+0x34c>
	
	/* short blocks */
	cbMax[2] = cbMax[1] = cbMax[0] = cbStartS;
 8002872:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8002874:	613b      	str	r3, [r7, #16]
 8002876:	693b      	ldr	r3, [r7, #16]
 8002878:	617b      	str	r3, [r7, #20]
 800287a:	697b      	ldr	r3, [r7, #20]
 800287c:	61bb      	str	r3, [r7, #24]
	for (cb = cbStartS; cb < cbEndS; cb++) {
 800287e:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8002880:	64bb      	str	r3, [r7, #72]	; 0x48
 8002882:	e0ad      	b.n	80029e0 <xmp3fixpt_DequantChannel+0x2e4>

		nSamps = fh->sfBand->s[cb + 1] - fh->sfBand->s[cb];
 8002884:	683b      	ldr	r3, [r7, #0]
 8002886:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8002888:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 800288a:	3301      	adds	r3, #1
 800288c:	3314      	adds	r3, #20
 800288e:	005b      	lsls	r3, r3, #1
 8002890:	4413      	add	r3, r2
 8002892:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
 8002896:	4619      	mov	r1, r3
 8002898:	683b      	ldr	r3, [r7, #0]
 800289a:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 800289c:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 800289e:	3314      	adds	r3, #20
 80028a0:	005b      	lsls	r3, r3, #1
 80028a2:	4413      	add	r3, r2
 80028a4:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
 80028a8:	1acb      	subs	r3, r1, r3
 80028aa:	627b      	str	r3, [r7, #36]	; 0x24
		for (w = 0; w < 3; w++) {
 80028ac:	2300      	movs	r3, #0
 80028ae:	64fb      	str	r3, [r7, #76]	; 0x4c
 80028b0:	e046      	b.n	8002940 <xmp3fixpt_DequantChannel+0x244>
			nonZero =  0;
 80028b2:	2300      	movs	r3, #0
 80028b4:	62bb      	str	r3, [r7, #40]	; 0x28
			gainI = 210 - globalGain + 8*sis->subBlockGain[w] + sfactMultiplier*(sfis->s[cb][w]);
 80028b6:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 80028b8:	f1c3 02d2 	rsb	r2, r3, #210	; 0xd2
 80028bc:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 80028be:	6cf9      	ldr	r1, [r7, #76]	; 0x4c
 80028c0:	310a      	adds	r1, #10
 80028c2:	f853 3021 	ldr.w	r3, [r3, r1, lsl #2]
 80028c6:	00db      	lsls	r3, r3, #3
 80028c8:	18d1      	adds	r1, r2, r3
 80028ca:	6e78      	ldr	r0, [r7, #100]	; 0x64
 80028cc:	6cba      	ldr	r2, [r7, #72]	; 0x48
 80028ce:	4613      	mov	r3, r2
 80028d0:	005b      	lsls	r3, r3, #1
 80028d2:	4413      	add	r3, r2
 80028d4:	18c2      	adds	r2, r0, r3
 80028d6:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 80028d8:	4413      	add	r3, r2
 80028da:	3317      	adds	r3, #23
 80028dc:	781b      	ldrb	r3, [r3, #0]
 80028de:	461a      	mov	r2, r3
 80028e0:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80028e2:	fb03 f302 	mul.w	r3, r3, r2
 80028e6:	440b      	add	r3, r1
 80028e8:	623b      	str	r3, [r7, #32]

			nonZero |= DequantBlock(sampleBuf + i + nSamps*w, workBuf + nSamps*w, nSamps, gainI);
 80028ea:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80028ec:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
 80028ee:	fb02 f303 	mul.w	r3, r2, r3
 80028f2:	461a      	mov	r2, r3
 80028f4:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 80028f6:	4413      	add	r3, r2
 80028f8:	009b      	lsls	r3, r3, #2
 80028fa:	68fa      	ldr	r2, [r7, #12]
 80028fc:	18d0      	adds	r0, r2, r3
 80028fe:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8002900:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
 8002902:	fb02 f303 	mul.w	r3, r2, r3
 8002906:	009b      	lsls	r3, r3, #2
 8002908:	68ba      	ldr	r2, [r7, #8]
 800290a:	18d1      	adds	r1, r2, r3
 800290c:	6a3b      	ldr	r3, [r7, #32]
 800290e:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8002910:	f7ff fdc3 	bl	800249a <DequantBlock>
 8002914:	4602      	mov	r2, r0
 8002916:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8002918:	4313      	orrs	r3, r2
 800291a:	62bb      	str	r3, [r7, #40]	; 0x28

			/* update highest non-zero critical band */
			if (nonZero)
 800291c:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800291e:	2b00      	cmp	r3, #0
 8002920:	d007      	beq.n	8002932 <xmp3fixpt_DequantChannel+0x236>
				cbMax[w] = cb;
 8002922:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8002924:	009b      	lsls	r3, r3, #2
 8002926:	f107 0258 	add.w	r2, r7, #88	; 0x58
 800292a:	4413      	add	r3, r2
 800292c:	6cba      	ldr	r2, [r7, #72]	; 0x48
 800292e:	f843 2c48 	str.w	r2, [r3, #-72]
			gbMask |= nonZero;
 8002932:	6bba      	ldr	r2, [r7, #56]	; 0x38
 8002934:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8002936:	4313      	orrs	r3, r2
 8002938:	63bb      	str	r3, [r7, #56]	; 0x38
		for (w = 0; w < 3; w++) {
 800293a:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800293c:	3301      	adds	r3, #1
 800293e:	64fb      	str	r3, [r7, #76]	; 0x4c
 8002940:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8002942:	2b02      	cmp	r3, #2
 8002944:	ddb5      	ble.n	80028b2 <xmp3fixpt_DequantChannel+0x1b6>
		}

		/* reorder blocks */
		buf = (ARRAY3 *)(sampleBuf + i);
 8002946:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8002948:	009b      	lsls	r3, r3, #2
 800294a:	68fa      	ldr	r2, [r7, #12]
 800294c:	4413      	add	r3, r2
 800294e:	61fb      	str	r3, [r7, #28]
		i += 3*nSamps;
 8002950:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8002952:	4613      	mov	r3, r2
 8002954:	005b      	lsls	r3, r3, #1
 8002956:	4413      	add	r3, r2
 8002958:	6d7a      	ldr	r2, [r7, #84]	; 0x54
 800295a:	4413      	add	r3, r2
 800295c:	657b      	str	r3, [r7, #84]	; 0x54
		for (j = 0; j < nSamps; j++) {
 800295e:	2300      	movs	r3, #0
 8002960:	653b      	str	r3, [r7, #80]	; 0x50
 8002962:	e031      	b.n	80029c8 <xmp3fixpt_DequantChannel+0x2cc>
			buf[j][0] = workBuf[0*nSamps + j];
 8002964:	6d3a      	ldr	r2, [r7, #80]	; 0x50
 8002966:	4613      	mov	r3, r2
 8002968:	005b      	lsls	r3, r3, #1
 800296a:	4413      	add	r3, r2
 800296c:	009b      	lsls	r3, r3, #2
 800296e:	461a      	mov	r2, r3
 8002970:	69fb      	ldr	r3, [r7, #28]
 8002972:	4413      	add	r3, r2
 8002974:	6d3a      	ldr	r2, [r7, #80]	; 0x50
 8002976:	0092      	lsls	r2, r2, #2
 8002978:	68b9      	ldr	r1, [r7, #8]
 800297a:	440a      	add	r2, r1
 800297c:	6812      	ldr	r2, [r2, #0]
 800297e:	601a      	str	r2, [r3, #0]
			buf[j][1] = workBuf[1*nSamps + j];
 8002980:	6d3a      	ldr	r2, [r7, #80]	; 0x50
 8002982:	4613      	mov	r3, r2
 8002984:	005b      	lsls	r3, r3, #1
 8002986:	4413      	add	r3, r2
 8002988:	009b      	lsls	r3, r3, #2
 800298a:	461a      	mov	r2, r3
 800298c:	69fb      	ldr	r3, [r7, #28]
 800298e:	4413      	add	r3, r2
 8002990:	6a79      	ldr	r1, [r7, #36]	; 0x24
 8002992:	6d3a      	ldr	r2, [r7, #80]	; 0x50
 8002994:	440a      	add	r2, r1
 8002996:	0092      	lsls	r2, r2, #2
 8002998:	68b9      	ldr	r1, [r7, #8]
 800299a:	440a      	add	r2, r1
 800299c:	6812      	ldr	r2, [r2, #0]
 800299e:	605a      	str	r2, [r3, #4]
			buf[j][2] = workBuf[2*nSamps + j];
 80029a0:	6d3a      	ldr	r2, [r7, #80]	; 0x50
 80029a2:	4613      	mov	r3, r2
 80029a4:	005b      	lsls	r3, r3, #1
 80029a6:	4413      	add	r3, r2
 80029a8:	009b      	lsls	r3, r3, #2
 80029aa:	461a      	mov	r2, r3
 80029ac:	69fb      	ldr	r3, [r7, #28]
 80029ae:	4413      	add	r3, r2
 80029b0:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 80029b2:	0051      	lsls	r1, r2, #1
 80029b4:	6d3a      	ldr	r2, [r7, #80]	; 0x50
 80029b6:	440a      	add	r2, r1
 80029b8:	0092      	lsls	r2, r2, #2
 80029ba:	68b9      	ldr	r1, [r7, #8]
 80029bc:	440a      	add	r2, r1
 80029be:	6812      	ldr	r2, [r2, #0]
 80029c0:	609a      	str	r2, [r3, #8]
		for (j = 0; j < nSamps; j++) {
 80029c2:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 80029c4:	3301      	adds	r3, #1
 80029c6:	653b      	str	r3, [r7, #80]	; 0x50
 80029c8:	6d3a      	ldr	r2, [r7, #80]	; 0x50
 80029ca:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80029cc:	429a      	cmp	r2, r3
 80029ce:	dbc9      	blt.n	8002964 <xmp3fixpt_DequantChannel+0x268>
		}

		ASSERT(3*nSamps <= MAX_REORDER_SAMPS);

		if (i >= *nonZeroBound) 
 80029d0:	687b      	ldr	r3, [r7, #4]
 80029d2:	681a      	ldr	r2, [r3, #0]
 80029d4:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 80029d6:	429a      	cmp	r2, r3
 80029d8:	dd08      	ble.n	80029ec <xmp3fixpt_DequantChannel+0x2f0>
	for (cb = cbStartS; cb < cbEndS; cb++) {
 80029da:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 80029dc:	3301      	adds	r3, #1
 80029de:	64bb      	str	r3, [r7, #72]	; 0x48
 80029e0:	6cba      	ldr	r2, [r7, #72]	; 0x48
 80029e2:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 80029e4:	429a      	cmp	r2, r3
 80029e6:	f6ff af4d 	blt.w	8002884 <xmp3fixpt_DequantChannel+0x188>
 80029ea:	e000      	b.n	80029ee <xmp3fixpt_DequantChannel+0x2f2>
			break;
 80029ec:	bf00      	nop
	 * however, the original nzb is no longer necessarily true
	 *   for each cb, buf[][] is updated with 3*nSamps samples (i increases 3*nSamps each time)
	 *   (buf[j + 1][0] = 3 (input) samples ahead of buf[j][0])
     * so update nonZeroBound to i
	 */
	*nonZeroBound = i;
 80029ee:	687b      	ldr	r3, [r7, #4]
 80029f0:	6d7a      	ldr	r2, [r7, #84]	; 0x54
 80029f2:	601a      	str	r2, [r3, #0]

	ASSERT(*nonZeroBound <= MAX_NSAMP);

	cbi->cbType = (sis->mixedBlock ? 2 : 1);	/* 2 = mixed short/long, 1 = short only */
 80029f4:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 80029f6:	699b      	ldr	r3, [r3, #24]
 80029f8:	2b00      	cmp	r3, #0
 80029fa:	d001      	beq.n	8002a00 <xmp3fixpt_DequantChannel+0x304>
 80029fc:	2202      	movs	r2, #2
 80029fe:	e000      	b.n	8002a02 <xmp3fixpt_DequantChannel+0x306>
 8002a00:	2201      	movs	r2, #1
 8002a02:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 8002a04:	601a      	str	r2, [r3, #0]

	cbi->cbEndS[0] = cbMax[0];
 8002a06:	693a      	ldr	r2, [r7, #16]
 8002a08:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 8002a0a:	605a      	str	r2, [r3, #4]
	cbi->cbEndS[1] = cbMax[1];
 8002a0c:	697a      	ldr	r2, [r7, #20]
 8002a0e:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 8002a10:	609a      	str	r2, [r3, #8]
	cbi->cbEndS[2] = cbMax[2];
 8002a12:	69ba      	ldr	r2, [r7, #24]
 8002a14:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 8002a16:	60da      	str	r2, [r3, #12]

	cbi->cbEndSMax = cbMax[0];
 8002a18:	693a      	ldr	r2, [r7, #16]
 8002a1a:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 8002a1c:	611a      	str	r2, [r3, #16]
	cbi->cbEndSMax = MAX(cbi->cbEndSMax, cbMax[1]);
 8002a1e:	697a      	ldr	r2, [r7, #20]
 8002a20:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 8002a22:	691b      	ldr	r3, [r3, #16]
 8002a24:	429a      	cmp	r2, r3
 8002a26:	bfb8      	it	lt
 8002a28:	461a      	movlt	r2, r3
 8002a2a:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 8002a2c:	611a      	str	r2, [r3, #16]
	cbi->cbEndSMax = MAX(cbi->cbEndSMax, cbMax[2]);
 8002a2e:	69ba      	ldr	r2, [r7, #24]
 8002a30:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 8002a32:	691b      	ldr	r3, [r3, #16]
 8002a34:	429a      	cmp	r2, r3
 8002a36:	bfb8      	it	lt
 8002a38:	461a      	movlt	r2, r3
 8002a3a:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 8002a3c:	611a      	str	r2, [r3, #16]

	return CLZ(gbMask) - 1;
 8002a3e:	6bb8      	ldr	r0, [r7, #56]	; 0x38
 8002a40:	f7ff fd1c 	bl	800247c <CLZ>
 8002a44:	4603      	mov	r3, r0
 8002a46:	3b01      	subs	r3, #1
}
 8002a48:	4618      	mov	r0, r3
 8002a4a:	3758      	adds	r7, #88	; 0x58
 8002a4c:	46bd      	mov	sp, r7
 8002a4e:	bd80      	pop	{r7, pc}
 8002a50:	08017c10 	.word	0x08017c10

08002a54 <DecodeHuffmanPairs>:
 * Notes:       assumes that nVals is an even number
 *              si_huff.bit tests every Huffman codeword in every table (though not
 *                necessarily all linBits outputs for x,y > 15)
 **************************************************************************************/
static int DecodeHuffmanPairs(int *xy, int nVals, int tabIdx, int bitsLeft, unsigned char *buf, int bitOffset)
{
 8002a54:	b480      	push	{r7}
 8002a56:	b095      	sub	sp, #84	; 0x54
 8002a58:	af00      	add	r7, sp, #0
 8002a5a:	60f8      	str	r0, [r7, #12]
 8002a5c:	60b9      	str	r1, [r7, #8]
 8002a5e:	607a      	str	r2, [r7, #4]
 8002a60:	603b      	str	r3, [r7, #0]
	int cachedBits, padBits, len, startBits, linBits, maxBits, minBits;
	HuffTabType tabType;
	unsigned short cw, *tBase, *tCurr;
	unsigned int cache;

	if(nVals <= 0) 
 8002a62:	68bb      	ldr	r3, [r7, #8]
 8002a64:	2b00      	cmp	r3, #0
 8002a66:	dc01      	bgt.n	8002a6c <DecodeHuffmanPairs+0x18>
		return 0;
 8002a68:	2300      	movs	r3, #0
 8002a6a:	e2d8      	b.n	800301e <DecodeHuffmanPairs+0x5ca>

	if (bitsLeft < 0)
 8002a6c:	683b      	ldr	r3, [r7, #0]
 8002a6e:	2b00      	cmp	r3, #0
 8002a70:	da02      	bge.n	8002a78 <DecodeHuffmanPairs+0x24>
		return -1;
 8002a72:	f04f 33ff 	mov.w	r3, #4294967295
 8002a76:	e2d2      	b.n	800301e <DecodeHuffmanPairs+0x5ca>
	startBits = bitsLeft;
 8002a78:	683b      	ldr	r3, [r7, #0]
 8002a7a:	633b      	str	r3, [r7, #48]	; 0x30

	tBase = (unsigned short *)(huffTable + huffTabOffset[tabIdx]);
 8002a7c:	4a9b      	ldr	r2, [pc, #620]	; (8002cec <DecodeHuffmanPairs+0x298>)
 8002a7e:	687b      	ldr	r3, [r7, #4]
 8002a80:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 8002a84:	005b      	lsls	r3, r3, #1
 8002a86:	4a9a      	ldr	r2, [pc, #616]	; (8002cf0 <DecodeHuffmanPairs+0x29c>)
 8002a88:	4413      	add	r3, r2
 8002a8a:	62fb      	str	r3, [r7, #44]	; 0x2c
	linBits = huffTabLookup[tabIdx].linBits;
 8002a8c:	4a99      	ldr	r2, [pc, #612]	; (8002cf4 <DecodeHuffmanPairs+0x2a0>)
 8002a8e:	687b      	ldr	r3, [r7, #4]
 8002a90:	f852 3033 	ldr.w	r3, [r2, r3, lsl #3]
 8002a94:	62bb      	str	r3, [r7, #40]	; 0x28
	tabType = huffTabLookup[tabIdx].tabType;
 8002a96:	4a97      	ldr	r2, [pc, #604]	; (8002cf4 <DecodeHuffmanPairs+0x2a0>)
 8002a98:	687b      	ldr	r3, [r7, #4]
 8002a9a:	00db      	lsls	r3, r3, #3
 8002a9c:	4413      	add	r3, r2
 8002a9e:	791b      	ldrb	r3, [r3, #4]
 8002aa0:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
	ASSERT(tabIdx < HUFF_PAIRTABS);
	ASSERT(tabIdx >= 0);
	ASSERT(tabType != invalidTab);

	/* initially fill cache with any partial byte */
	cache = 0;
 8002aa4:	2300      	movs	r3, #0
 8002aa6:	637b      	str	r3, [r7, #52]	; 0x34
	cachedBits = (8 - bitOffset) & 0x07;
 8002aa8:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 8002aaa:	425b      	negs	r3, r3
 8002aac:	f003 0307 	and.w	r3, r3, #7
 8002ab0:	643b      	str	r3, [r7, #64]	; 0x40
	if (cachedBits)
 8002ab2:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8002ab4:	2b00      	cmp	r3, #0
 8002ab6:	d00a      	beq.n	8002ace <DecodeHuffmanPairs+0x7a>
		cache = (unsigned int)(*buf++) << (32 - cachedBits);
 8002ab8:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8002aba:	1c5a      	adds	r2, r3, #1
 8002abc:	65ba      	str	r2, [r7, #88]	; 0x58
 8002abe:	781b      	ldrb	r3, [r3, #0]
 8002ac0:	461a      	mov	r2, r3
 8002ac2:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8002ac4:	f1c3 0320 	rsb	r3, r3, #32
 8002ac8:	fa02 f303 	lsl.w	r3, r2, r3
 8002acc:	637b      	str	r3, [r7, #52]	; 0x34
	bitsLeft -= cachedBits;
 8002ace:	683a      	ldr	r2, [r7, #0]
 8002ad0:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8002ad2:	1ad3      	subs	r3, r2, r3
 8002ad4:	603b      	str	r3, [r7, #0]

	if (tabType == noBits) {
 8002ad6:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
 8002ada:	2b00      	cmp	r3, #0
 8002adc:	d118      	bne.n	8002b10 <DecodeHuffmanPairs+0xbc>
		/* table 0, no data, x = y = 0 */
		for (i = 0; i < nVals; i+=2) {
 8002ade:	2300      	movs	r3, #0
 8002ae0:	64fb      	str	r3, [r7, #76]	; 0x4c
 8002ae2:	e00f      	b.n	8002b04 <DecodeHuffmanPairs+0xb0>
			xy[i+0] = 0;
 8002ae4:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8002ae6:	009b      	lsls	r3, r3, #2
 8002ae8:	68fa      	ldr	r2, [r7, #12]
 8002aea:	4413      	add	r3, r2
 8002aec:	2200      	movs	r2, #0
 8002aee:	601a      	str	r2, [r3, #0]
			xy[i+1] = 0;
 8002af0:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8002af2:	3301      	adds	r3, #1
 8002af4:	009b      	lsls	r3, r3, #2
 8002af6:	68fa      	ldr	r2, [r7, #12]
 8002af8:	4413      	add	r3, r2
 8002afa:	2200      	movs	r2, #0
 8002afc:	601a      	str	r2, [r3, #0]
		for (i = 0; i < nVals; i+=2) {
 8002afe:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8002b00:	3302      	adds	r3, #2
 8002b02:	64fb      	str	r3, [r7, #76]	; 0x4c
 8002b04:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
 8002b06:	68bb      	ldr	r3, [r7, #8]
 8002b08:	429a      	cmp	r2, r3
 8002b0a:	dbeb      	blt.n	8002ae4 <DecodeHuffmanPairs+0x90>
		}
		return 0;
 8002b0c:	2300      	movs	r3, #0
 8002b0e:	e286      	b.n	800301e <DecodeHuffmanPairs+0x5ca>
	} else if (tabType == oneShot) {
 8002b10:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
 8002b14:	2b01      	cmp	r3, #1
 8002b16:	f040 80da 	bne.w	8002cce <DecodeHuffmanPairs+0x27a>
		/* single lookup, no escapes */
		maxBits = GetMaxbits(tBase[0]);
 8002b1a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8002b1c:	881b      	ldrh	r3, [r3, #0]
 8002b1e:	f003 030f 	and.w	r3, r3, #15
 8002b22:	623b      	str	r3, [r7, #32]
		tBase++;
 8002b24:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8002b26:	3302      	adds	r3, #2
 8002b28:	62fb      	str	r3, [r7, #44]	; 0x2c
		padBits = 0;
 8002b2a:	2300      	movs	r3, #0
 8002b2c:	63fb      	str	r3, [r7, #60]	; 0x3c
		while (nVals > 0) {
 8002b2e:	e0c0      	b.n	8002cb2 <DecodeHuffmanPairs+0x25e>
			/* refill cache - assumes cachedBits <= 16 */
			if (bitsLeft >= 16) {
 8002b30:	683b      	ldr	r3, [r7, #0]
 8002b32:	2b0f      	cmp	r3, #15
 8002b34:	dd20      	ble.n	8002b78 <DecodeHuffmanPairs+0x124>
				/* load 2 new bytes into left-justified cache */
				cache |= (unsigned int)(*buf++) << (24 - cachedBits);
 8002b36:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8002b38:	1c5a      	adds	r2, r3, #1
 8002b3a:	65ba      	str	r2, [r7, #88]	; 0x58
 8002b3c:	781b      	ldrb	r3, [r3, #0]
 8002b3e:	461a      	mov	r2, r3
 8002b40:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8002b42:	f1c3 0318 	rsb	r3, r3, #24
 8002b46:	fa02 f303 	lsl.w	r3, r2, r3
 8002b4a:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 8002b4c:	4313      	orrs	r3, r2
 8002b4e:	637b      	str	r3, [r7, #52]	; 0x34
				cache |= (unsigned int)(*buf++) << (16 - cachedBits);
 8002b50:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8002b52:	1c5a      	adds	r2, r3, #1
 8002b54:	65ba      	str	r2, [r7, #88]	; 0x58
 8002b56:	781b      	ldrb	r3, [r3, #0]
 8002b58:	461a      	mov	r2, r3
 8002b5a:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8002b5c:	f1c3 0310 	rsb	r3, r3, #16
 8002b60:	fa02 f303 	lsl.w	r3, r2, r3
 8002b64:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 8002b66:	4313      	orrs	r3, r2
 8002b68:	637b      	str	r3, [r7, #52]	; 0x34
				cachedBits += 16;
 8002b6a:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8002b6c:	3310      	adds	r3, #16
 8002b6e:	643b      	str	r3, [r7, #64]	; 0x40
				bitsLeft -= 16;
 8002b70:	683b      	ldr	r3, [r7, #0]
 8002b72:	3b10      	subs	r3, #16
 8002b74:	603b      	str	r3, [r7, #0]
 8002b76:	e096      	b.n	8002ca6 <DecodeHuffmanPairs+0x252>
			} else {
				/* last time through, pad cache with zeros and drain cache */
				if (cachedBits + bitsLeft <= 0)	return -1;
 8002b78:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 8002b7a:	683b      	ldr	r3, [r7, #0]
 8002b7c:	4413      	add	r3, r2
 8002b7e:	2b00      	cmp	r3, #0
 8002b80:	dc02      	bgt.n	8002b88 <DecodeHuffmanPairs+0x134>
 8002b82:	f04f 33ff 	mov.w	r3, #4294967295
 8002b86:	e24a      	b.n	800301e <DecodeHuffmanPairs+0x5ca>
				if (bitsLeft > 0)	cache |= (unsigned int)(*buf++) << (24 - cachedBits);
 8002b88:	683b      	ldr	r3, [r7, #0]
 8002b8a:	2b00      	cmp	r3, #0
 8002b8c:	dd0c      	ble.n	8002ba8 <DecodeHuffmanPairs+0x154>
 8002b8e:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8002b90:	1c5a      	adds	r2, r3, #1
 8002b92:	65ba      	str	r2, [r7, #88]	; 0x58
 8002b94:	781b      	ldrb	r3, [r3, #0]
 8002b96:	461a      	mov	r2, r3
 8002b98:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8002b9a:	f1c3 0318 	rsb	r3, r3, #24
 8002b9e:	fa02 f303 	lsl.w	r3, r2, r3
 8002ba2:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 8002ba4:	4313      	orrs	r3, r2
 8002ba6:	637b      	str	r3, [r7, #52]	; 0x34
				if (bitsLeft > 8)	cache |= (unsigned int)(*buf++) << (16 - cachedBits);
 8002ba8:	683b      	ldr	r3, [r7, #0]
 8002baa:	2b08      	cmp	r3, #8
 8002bac:	dd0c      	ble.n	8002bc8 <DecodeHuffmanPairs+0x174>
 8002bae:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8002bb0:	1c5a      	adds	r2, r3, #1
 8002bb2:	65ba      	str	r2, [r7, #88]	; 0x58
 8002bb4:	781b      	ldrb	r3, [r3, #0]
 8002bb6:	461a      	mov	r2, r3
 8002bb8:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8002bba:	f1c3 0310 	rsb	r3, r3, #16
 8002bbe:	fa02 f303 	lsl.w	r3, r2, r3
 8002bc2:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 8002bc4:	4313      	orrs	r3, r2
 8002bc6:	637b      	str	r3, [r7, #52]	; 0x34
				cachedBits += bitsLeft;
 8002bc8:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 8002bca:	683b      	ldr	r3, [r7, #0]
 8002bcc:	4413      	add	r3, r2
 8002bce:	643b      	str	r3, [r7, #64]	; 0x40
				bitsLeft = 0;
 8002bd0:	2300      	movs	r3, #0
 8002bd2:	603b      	str	r3, [r7, #0]

				cache &= (signed int)0x80000000 >> (cachedBits - 1);
 8002bd4:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8002bd6:	3b01      	subs	r3, #1
 8002bd8:	f04f 4200 	mov.w	r2, #2147483648	; 0x80000000
 8002bdc:	fa42 f303 	asr.w	r3, r2, r3
 8002be0:	461a      	mov	r2, r3
 8002be2:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8002be4:	4013      	ands	r3, r2
 8002be6:	637b      	str	r3, [r7, #52]	; 0x34
				padBits = 11;
 8002be8:	230b      	movs	r3, #11
 8002bea:	63fb      	str	r3, [r7, #60]	; 0x3c
				cachedBits += padBits;	/* okay if this is > 32 (0's automatically shifted in from right) */
 8002bec:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 8002bee:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8002bf0:	4413      	add	r3, r2
 8002bf2:	643b      	str	r3, [r7, #64]	; 0x40
			}

			/* largest maxBits = 9, plus 2 for sign bits, so make sure cache has at least 11 bits */
			while (nVals > 0 && cachedBits >= 11 ) {
 8002bf4:	e057      	b.n	8002ca6 <DecodeHuffmanPairs+0x252>
				cw = tBase[cache >> (32 - maxBits)];
 8002bf6:	6a3b      	ldr	r3, [r7, #32]
 8002bf8:	f1c3 0320 	rsb	r3, r3, #32
 8002bfc:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 8002bfe:	fa22 f303 	lsr.w	r3, r2, r3
 8002c02:	005b      	lsls	r3, r3, #1
 8002c04:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8002c06:	4413      	add	r3, r2
 8002c08:	881b      	ldrh	r3, [r3, #0]
 8002c0a:	83fb      	strh	r3, [r7, #30]
				len = GetHLen(cw);
 8002c0c:	8bfb      	ldrh	r3, [r7, #30]
 8002c0e:	0b1b      	lsrs	r3, r3, #12
 8002c10:	b29b      	uxth	r3, r3
 8002c12:	f003 030f 	and.w	r3, r3, #15
 8002c16:	61bb      	str	r3, [r7, #24]
				cachedBits -= len;
 8002c18:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 8002c1a:	69bb      	ldr	r3, [r7, #24]
 8002c1c:	1ad3      	subs	r3, r2, r3
 8002c1e:	643b      	str	r3, [r7, #64]	; 0x40
				cache <<= len;
 8002c20:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 8002c22:	69bb      	ldr	r3, [r7, #24]
 8002c24:	fa02 f303 	lsl.w	r3, r2, r3
 8002c28:	637b      	str	r3, [r7, #52]	; 0x34

				x = GetCWX(cw);		if (x)	{ApplySign(x, cache); cache <<= 1; cachedBits--;}
 8002c2a:	8bfb      	ldrh	r3, [r7, #30]
 8002c2c:	091b      	lsrs	r3, r3, #4
 8002c2e:	b29b      	uxth	r3, r3
 8002c30:	f003 030f 	and.w	r3, r3, #15
 8002c34:	64bb      	str	r3, [r7, #72]	; 0x48
 8002c36:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8002c38:	2b00      	cmp	r3, #0
 8002c3a:	d00b      	beq.n	8002c54 <DecodeHuffmanPairs+0x200>
 8002c3c:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8002c3e:	f003 4200 	and.w	r2, r3, #2147483648	; 0x80000000
 8002c42:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8002c44:	4313      	orrs	r3, r2
 8002c46:	64bb      	str	r3, [r7, #72]	; 0x48
 8002c48:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8002c4a:	005b      	lsls	r3, r3, #1
 8002c4c:	637b      	str	r3, [r7, #52]	; 0x34
 8002c4e:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8002c50:	3b01      	subs	r3, #1
 8002c52:	643b      	str	r3, [r7, #64]	; 0x40
				y = GetCWY(cw);		if (y)	{ApplySign(y, cache); cache <<= 1; cachedBits--;}
 8002c54:	8bfb      	ldrh	r3, [r7, #30]
 8002c56:	0a1b      	lsrs	r3, r3, #8
 8002c58:	b29b      	uxth	r3, r3
 8002c5a:	f003 030f 	and.w	r3, r3, #15
 8002c5e:	647b      	str	r3, [r7, #68]	; 0x44
 8002c60:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8002c62:	2b00      	cmp	r3, #0
 8002c64:	d00b      	beq.n	8002c7e <DecodeHuffmanPairs+0x22a>
 8002c66:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8002c68:	f003 4200 	and.w	r2, r3, #2147483648	; 0x80000000
 8002c6c:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8002c6e:	4313      	orrs	r3, r2
 8002c70:	647b      	str	r3, [r7, #68]	; 0x44
 8002c72:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8002c74:	005b      	lsls	r3, r3, #1
 8002c76:	637b      	str	r3, [r7, #52]	; 0x34
 8002c78:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8002c7a:	3b01      	subs	r3, #1
 8002c7c:	643b      	str	r3, [r7, #64]	; 0x40

				/* ran out of bits - should never have consumed padBits */
				if (cachedBits < padBits)
 8002c7e:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 8002c80:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8002c82:	429a      	cmp	r2, r3
 8002c84:	da02      	bge.n	8002c8c <DecodeHuffmanPairs+0x238>
					return -1;
 8002c86:	f04f 33ff 	mov.w	r3, #4294967295
 8002c8a:	e1c8      	b.n	800301e <DecodeHuffmanPairs+0x5ca>

				*xy++ = x;
 8002c8c:	68fb      	ldr	r3, [r7, #12]
 8002c8e:	1d1a      	adds	r2, r3, #4
 8002c90:	60fa      	str	r2, [r7, #12]
 8002c92:	6cba      	ldr	r2, [r7, #72]	; 0x48
 8002c94:	601a      	str	r2, [r3, #0]
				*xy++ = y;
 8002c96:	68fb      	ldr	r3, [r7, #12]
 8002c98:	1d1a      	adds	r2, r3, #4
 8002c9a:	60fa      	str	r2, [r7, #12]
 8002c9c:	6c7a      	ldr	r2, [r7, #68]	; 0x44
 8002c9e:	601a      	str	r2, [r3, #0]
				nVals -= 2;
 8002ca0:	68bb      	ldr	r3, [r7, #8]
 8002ca2:	3b02      	subs	r3, #2
 8002ca4:	60bb      	str	r3, [r7, #8]
			while (nVals > 0 && cachedBits >= 11 ) {
 8002ca6:	68bb      	ldr	r3, [r7, #8]
 8002ca8:	2b00      	cmp	r3, #0
 8002caa:	dd02      	ble.n	8002cb2 <DecodeHuffmanPairs+0x25e>
 8002cac:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8002cae:	2b0a      	cmp	r3, #10
 8002cb0:	dca1      	bgt.n	8002bf6 <DecodeHuffmanPairs+0x1a2>
		while (nVals > 0) {
 8002cb2:	68bb      	ldr	r3, [r7, #8]
 8002cb4:	2b00      	cmp	r3, #0
 8002cb6:	f73f af3b 	bgt.w	8002b30 <DecodeHuffmanPairs+0xdc>
			}
		}
		bitsLeft += (cachedBits - padBits);
 8002cba:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 8002cbc:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8002cbe:	1ad3      	subs	r3, r2, r3
 8002cc0:	683a      	ldr	r2, [r7, #0]
 8002cc2:	4413      	add	r3, r2
 8002cc4:	603b      	str	r3, [r7, #0]
		return (startBits - bitsLeft);
 8002cc6:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 8002cc8:	683b      	ldr	r3, [r7, #0]
 8002cca:	1ad3      	subs	r3, r2, r3
 8002ccc:	e1a7      	b.n	800301e <DecodeHuffmanPairs+0x5ca>
	} else if (tabType == loopLinbits || tabType == loopNoLinbits) {
 8002cce:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
 8002cd2:	2b03      	cmp	r3, #3
 8002cd4:	d004      	beq.n	8002ce0 <DecodeHuffmanPairs+0x28c>
 8002cd6:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
 8002cda:	2b02      	cmp	r3, #2
 8002cdc:	f040 819d 	bne.w	800301a <DecodeHuffmanPairs+0x5c6>
		tCurr = tBase;
 8002ce0:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8002ce2:	63bb      	str	r3, [r7, #56]	; 0x38
		padBits = 0;
 8002ce4:	2300      	movs	r3, #0
 8002ce6:	63fb      	str	r3, [r7, #60]	; 0x3c
		while (nVals > 0) {
 8002ce8:	e189      	b.n	8002ffe <DecodeHuffmanPairs+0x5aa>
 8002cea:	bf00      	nop
 8002cec:	08019f84 	.word	0x08019f84
 8002cf0:	08017e60 	.word	0x08017e60
 8002cf4:	0801a004 	.word	0x0801a004
			/* refill cache - assumes cachedBits <= 16 */
			if (bitsLeft >= 16) {
 8002cf8:	683b      	ldr	r3, [r7, #0]
 8002cfa:	2b0f      	cmp	r3, #15
 8002cfc:	dd20      	ble.n	8002d40 <DecodeHuffmanPairs+0x2ec>
				/* load 2 new bytes into left-justified cache */
				cache |= (unsigned int)(*buf++) << (24 - cachedBits);
 8002cfe:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8002d00:	1c5a      	adds	r2, r3, #1
 8002d02:	65ba      	str	r2, [r7, #88]	; 0x58
 8002d04:	781b      	ldrb	r3, [r3, #0]
 8002d06:	461a      	mov	r2, r3
 8002d08:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8002d0a:	f1c3 0318 	rsb	r3, r3, #24
 8002d0e:	fa02 f303 	lsl.w	r3, r2, r3
 8002d12:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 8002d14:	4313      	orrs	r3, r2
 8002d16:	637b      	str	r3, [r7, #52]	; 0x34
				cache |= (unsigned int)(*buf++) << (16 - cachedBits);
 8002d18:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8002d1a:	1c5a      	adds	r2, r3, #1
 8002d1c:	65ba      	str	r2, [r7, #88]	; 0x58
 8002d1e:	781b      	ldrb	r3, [r3, #0]
 8002d20:	461a      	mov	r2, r3
 8002d22:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8002d24:	f1c3 0310 	rsb	r3, r3, #16
 8002d28:	fa02 f303 	lsl.w	r3, r2, r3
 8002d2c:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 8002d2e:	4313      	orrs	r3, r2
 8002d30:	637b      	str	r3, [r7, #52]	; 0x34
				cachedBits += 16;
 8002d32:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8002d34:	3310      	adds	r3, #16
 8002d36:	643b      	str	r3, [r7, #64]	; 0x40
				bitsLeft -= 16;
 8002d38:	683b      	ldr	r3, [r7, #0]
 8002d3a:	3b10      	subs	r3, #16
 8002d3c:	603b      	str	r3, [r7, #0]
 8002d3e:	e157      	b.n	8002ff0 <DecodeHuffmanPairs+0x59c>
			} else {
				/* last time through, pad cache with zeros and drain cache */
				if (cachedBits + bitsLeft <= 0)	return -1;
 8002d40:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 8002d42:	683b      	ldr	r3, [r7, #0]
 8002d44:	4413      	add	r3, r2
 8002d46:	2b00      	cmp	r3, #0
 8002d48:	dc02      	bgt.n	8002d50 <DecodeHuffmanPairs+0x2fc>
 8002d4a:	f04f 33ff 	mov.w	r3, #4294967295
 8002d4e:	e166      	b.n	800301e <DecodeHuffmanPairs+0x5ca>
				if (bitsLeft > 0)	cache |= (unsigned int)(*buf++) << (24 - cachedBits);
 8002d50:	683b      	ldr	r3, [r7, #0]
 8002d52:	2b00      	cmp	r3, #0
 8002d54:	dd0c      	ble.n	8002d70 <DecodeHuffmanPairs+0x31c>
 8002d56:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8002d58:	1c5a      	adds	r2, r3, #1
 8002d5a:	65ba      	str	r2, [r7, #88]	; 0x58
 8002d5c:	781b      	ldrb	r3, [r3, #0]
 8002d5e:	461a      	mov	r2, r3
 8002d60:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8002d62:	f1c3 0318 	rsb	r3, r3, #24
 8002d66:	fa02 f303 	lsl.w	r3, r2, r3
 8002d6a:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 8002d6c:	4313      	orrs	r3, r2
 8002d6e:	637b      	str	r3, [r7, #52]	; 0x34
				if (bitsLeft > 8)	cache |= (unsigned int)(*buf++) << (16 - cachedBits);
 8002d70:	683b      	ldr	r3, [r7, #0]
 8002d72:	2b08      	cmp	r3, #8
 8002d74:	dd0c      	ble.n	8002d90 <DecodeHuffmanPairs+0x33c>
 8002d76:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8002d78:	1c5a      	adds	r2, r3, #1
 8002d7a:	65ba      	str	r2, [r7, #88]	; 0x58
 8002d7c:	781b      	ldrb	r3, [r3, #0]
 8002d7e:	461a      	mov	r2, r3
 8002d80:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8002d82:	f1c3 0310 	rsb	r3, r3, #16
 8002d86:	fa02 f303 	lsl.w	r3, r2, r3
 8002d8a:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 8002d8c:	4313      	orrs	r3, r2
 8002d8e:	637b      	str	r3, [r7, #52]	; 0x34
				cachedBits += bitsLeft;
 8002d90:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 8002d92:	683b      	ldr	r3, [r7, #0]
 8002d94:	4413      	add	r3, r2
 8002d96:	643b      	str	r3, [r7, #64]	; 0x40
				bitsLeft = 0;
 8002d98:	2300      	movs	r3, #0
 8002d9a:	603b      	str	r3, [r7, #0]

				cache &= (signed int)0x80000000 >> (cachedBits - 1);
 8002d9c:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8002d9e:	3b01      	subs	r3, #1
 8002da0:	f04f 4200 	mov.w	r2, #2147483648	; 0x80000000
 8002da4:	fa42 f303 	asr.w	r3, r2, r3
 8002da8:	461a      	mov	r2, r3
 8002daa:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8002dac:	4013      	ands	r3, r2
 8002dae:	637b      	str	r3, [r7, #52]	; 0x34
				padBits = 11;
 8002db0:	230b      	movs	r3, #11
 8002db2:	63fb      	str	r3, [r7, #60]	; 0x3c
				cachedBits += padBits;	/* okay if this is > 32 (0's automatically shifted in from right) */
 8002db4:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 8002db6:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8002db8:	4413      	add	r3, r2
 8002dba:	643b      	str	r3, [r7, #64]	; 0x40
			}

			/* largest maxBits = 9, plus 2 for sign bits, so make sure cache has at least 11 bits */
			while (nVals > 0 && cachedBits >= 11 ) {
 8002dbc:	e118      	b.n	8002ff0 <DecodeHuffmanPairs+0x59c>
				maxBits = GetMaxbits(tCurr[0]);
 8002dbe:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8002dc0:	881b      	ldrh	r3, [r3, #0]
 8002dc2:	f003 030f 	and.w	r3, r3, #15
 8002dc6:	623b      	str	r3, [r7, #32]
				cw = tCurr[(cache >> (32 - maxBits)) + 1];
 8002dc8:	6a3b      	ldr	r3, [r7, #32]
 8002dca:	f1c3 0320 	rsb	r3, r3, #32
 8002dce:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 8002dd0:	fa22 f303 	lsr.w	r3, r2, r3
 8002dd4:	3301      	adds	r3, #1
 8002dd6:	005b      	lsls	r3, r3, #1
 8002dd8:	6bba      	ldr	r2, [r7, #56]	; 0x38
 8002dda:	4413      	add	r3, r2
 8002ddc:	881b      	ldrh	r3, [r3, #0]
 8002dde:	83fb      	strh	r3, [r7, #30]
				len = GetHLen(cw);
 8002de0:	8bfb      	ldrh	r3, [r7, #30]
 8002de2:	0b1b      	lsrs	r3, r3, #12
 8002de4:	b29b      	uxth	r3, r3
 8002de6:	f003 030f 	and.w	r3, r3, #15
 8002dea:	61bb      	str	r3, [r7, #24]
				if (!len) {
 8002dec:	69bb      	ldr	r3, [r7, #24]
 8002dee:	2b00      	cmp	r3, #0
 8002df0:	d10e      	bne.n	8002e10 <DecodeHuffmanPairs+0x3bc>
					cachedBits -= maxBits;
 8002df2:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 8002df4:	6a3b      	ldr	r3, [r7, #32]
 8002df6:	1ad3      	subs	r3, r2, r3
 8002df8:	643b      	str	r3, [r7, #64]	; 0x40
					cache <<= maxBits;
 8002dfa:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 8002dfc:	6a3b      	ldr	r3, [r7, #32]
 8002dfe:	fa02 f303 	lsl.w	r3, r2, r3
 8002e02:	637b      	str	r3, [r7, #52]	; 0x34
					tCurr += cw;
 8002e04:	8bfb      	ldrh	r3, [r7, #30]
 8002e06:	005b      	lsls	r3, r3, #1
 8002e08:	6bba      	ldr	r2, [r7, #56]	; 0x38
 8002e0a:	4413      	add	r3, r2
 8002e0c:	63bb      	str	r3, [r7, #56]	; 0x38
					continue;
 8002e0e:	e0ef      	b.n	8002ff0 <DecodeHuffmanPairs+0x59c>
				}
				cachedBits -= len;
 8002e10:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 8002e12:	69bb      	ldr	r3, [r7, #24]
 8002e14:	1ad3      	subs	r3, r2, r3
 8002e16:	643b      	str	r3, [r7, #64]	; 0x40
				cache <<= len;
 8002e18:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 8002e1a:	69bb      	ldr	r3, [r7, #24]
 8002e1c:	fa02 f303 	lsl.w	r3, r2, r3
 8002e20:	637b      	str	r3, [r7, #52]	; 0x34
			
				x = GetCWX(cw);
 8002e22:	8bfb      	ldrh	r3, [r7, #30]
 8002e24:	091b      	lsrs	r3, r3, #4
 8002e26:	b29b      	uxth	r3, r3
 8002e28:	f003 030f 	and.w	r3, r3, #15
 8002e2c:	64bb      	str	r3, [r7, #72]	; 0x48
				y = GetCWY(cw);
 8002e2e:	8bfb      	ldrh	r3, [r7, #30]
 8002e30:	0a1b      	lsrs	r3, r3, #8
 8002e32:	b29b      	uxth	r3, r3
 8002e34:	f003 030f 	and.w	r3, r3, #15
 8002e38:	647b      	str	r3, [r7, #68]	; 0x44

				if (x == 15 && tabType == loopLinbits) {
 8002e3a:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8002e3c:	2b0f      	cmp	r3, #15
 8002e3e:	d153      	bne.n	8002ee8 <DecodeHuffmanPairs+0x494>
 8002e40:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
 8002e44:	2b03      	cmp	r3, #3
 8002e46:	d14f      	bne.n	8002ee8 <DecodeHuffmanPairs+0x494>
					minBits = linBits + 1 + (y ? 1 : 0);
 8002e48:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8002e4a:	3301      	adds	r3, #1
 8002e4c:	6c7a      	ldr	r2, [r7, #68]	; 0x44
 8002e4e:	2a00      	cmp	r2, #0
 8002e50:	bf14      	ite	ne
 8002e52:	2201      	movne	r2, #1
 8002e54:	2200      	moveq	r2, #0
 8002e56:	b2d2      	uxtb	r2, r2
 8002e58:	4413      	add	r3, r2
 8002e5a:	617b      	str	r3, [r7, #20]
					if (cachedBits + bitsLeft < minBits)
 8002e5c:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 8002e5e:	683b      	ldr	r3, [r7, #0]
 8002e60:	441a      	add	r2, r3
 8002e62:	697b      	ldr	r3, [r7, #20]
 8002e64:	429a      	cmp	r2, r3
 8002e66:	da15      	bge.n	8002e94 <DecodeHuffmanPairs+0x440>
						return -1;
 8002e68:	f04f 33ff 	mov.w	r3, #4294967295
 8002e6c:	e0d7      	b.n	800301e <DecodeHuffmanPairs+0x5ca>
					while (cachedBits < minBits) {
						cache |= (unsigned int)(*buf++) << (24 - cachedBits);
 8002e6e:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8002e70:	1c5a      	adds	r2, r3, #1
 8002e72:	65ba      	str	r2, [r7, #88]	; 0x58
 8002e74:	781b      	ldrb	r3, [r3, #0]
 8002e76:	461a      	mov	r2, r3
 8002e78:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8002e7a:	f1c3 0318 	rsb	r3, r3, #24
 8002e7e:	fa02 f303 	lsl.w	r3, r2, r3
 8002e82:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 8002e84:	4313      	orrs	r3, r2
 8002e86:	637b      	str	r3, [r7, #52]	; 0x34
						cachedBits += 8;
 8002e88:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8002e8a:	3308      	adds	r3, #8
 8002e8c:	643b      	str	r3, [r7, #64]	; 0x40
						bitsLeft -= 8;
 8002e8e:	683b      	ldr	r3, [r7, #0]
 8002e90:	3b08      	subs	r3, #8
 8002e92:	603b      	str	r3, [r7, #0]
					while (cachedBits < minBits) {
 8002e94:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 8002e96:	697b      	ldr	r3, [r7, #20]
 8002e98:	429a      	cmp	r2, r3
 8002e9a:	dbe8      	blt.n	8002e6e <DecodeHuffmanPairs+0x41a>
					}
					if (bitsLeft < 0) {
 8002e9c:	683b      	ldr	r3, [r7, #0]
 8002e9e:	2b00      	cmp	r3, #0
 8002ea0:	da0f      	bge.n	8002ec2 <DecodeHuffmanPairs+0x46e>
						cachedBits += bitsLeft;
 8002ea2:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 8002ea4:	683b      	ldr	r3, [r7, #0]
 8002ea6:	4413      	add	r3, r2
 8002ea8:	643b      	str	r3, [r7, #64]	; 0x40
						bitsLeft = 0;
 8002eaa:	2300      	movs	r3, #0
 8002eac:	603b      	str	r3, [r7, #0]
						cache &= (signed int)0x80000000 >> (cachedBits - 1);
 8002eae:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8002eb0:	3b01      	subs	r3, #1
 8002eb2:	f04f 4200 	mov.w	r2, #2147483648	; 0x80000000
 8002eb6:	fa42 f303 	asr.w	r3, r2, r3
 8002eba:	461a      	mov	r2, r3
 8002ebc:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8002ebe:	4013      	ands	r3, r2
 8002ec0:	637b      	str	r3, [r7, #52]	; 0x34
					}
					x += (int)(cache >> (32 - linBits));
 8002ec2:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8002ec4:	f1c3 0320 	rsb	r3, r3, #32
 8002ec8:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 8002eca:	fa22 f303 	lsr.w	r3, r2, r3
 8002ece:	461a      	mov	r2, r3
 8002ed0:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8002ed2:	4413      	add	r3, r2
 8002ed4:	64bb      	str	r3, [r7, #72]	; 0x48
					cachedBits -= linBits;
 8002ed6:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 8002ed8:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8002eda:	1ad3      	subs	r3, r2, r3
 8002edc:	643b      	str	r3, [r7, #64]	; 0x40
					cache <<= linBits;
 8002ede:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 8002ee0:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8002ee2:	fa02 f303 	lsl.w	r3, r2, r3
 8002ee6:	637b      	str	r3, [r7, #52]	; 0x34
				}
				if (x)	{ApplySign(x, cache); cache <<= 1; cachedBits--;}
 8002ee8:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8002eea:	2b00      	cmp	r3, #0
 8002eec:	d00b      	beq.n	8002f06 <DecodeHuffmanPairs+0x4b2>
 8002eee:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8002ef0:	f003 4200 	and.w	r2, r3, #2147483648	; 0x80000000
 8002ef4:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8002ef6:	4313      	orrs	r3, r2
 8002ef8:	64bb      	str	r3, [r7, #72]	; 0x48
 8002efa:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8002efc:	005b      	lsls	r3, r3, #1
 8002efe:	637b      	str	r3, [r7, #52]	; 0x34
 8002f00:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8002f02:	3b01      	subs	r3, #1
 8002f04:	643b      	str	r3, [r7, #64]	; 0x40

				if (y == 15 && tabType == loopLinbits) {
 8002f06:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8002f08:	2b0f      	cmp	r3, #15
 8002f0a:	d14c      	bne.n	8002fa6 <DecodeHuffmanPairs+0x552>
 8002f0c:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
 8002f10:	2b03      	cmp	r3, #3
 8002f12:	d148      	bne.n	8002fa6 <DecodeHuffmanPairs+0x552>
					minBits = linBits + 1;
 8002f14:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8002f16:	3301      	adds	r3, #1
 8002f18:	617b      	str	r3, [r7, #20]
					if (cachedBits + bitsLeft < minBits)
 8002f1a:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 8002f1c:	683b      	ldr	r3, [r7, #0]
 8002f1e:	441a      	add	r2, r3
 8002f20:	697b      	ldr	r3, [r7, #20]
 8002f22:	429a      	cmp	r2, r3
 8002f24:	da15      	bge.n	8002f52 <DecodeHuffmanPairs+0x4fe>
						return -1;
 8002f26:	f04f 33ff 	mov.w	r3, #4294967295
 8002f2a:	e078      	b.n	800301e <DecodeHuffmanPairs+0x5ca>
					while (cachedBits < minBits) {
						cache |= (unsigned int)(*buf++) << (24 - cachedBits);
 8002f2c:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8002f2e:	1c5a      	adds	r2, r3, #1
 8002f30:	65ba      	str	r2, [r7, #88]	; 0x58
 8002f32:	781b      	ldrb	r3, [r3, #0]
 8002f34:	461a      	mov	r2, r3
 8002f36:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8002f38:	f1c3 0318 	rsb	r3, r3, #24
 8002f3c:	fa02 f303 	lsl.w	r3, r2, r3
 8002f40:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 8002f42:	4313      	orrs	r3, r2
 8002f44:	637b      	str	r3, [r7, #52]	; 0x34
						cachedBits += 8;
 8002f46:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8002f48:	3308      	adds	r3, #8
 8002f4a:	643b      	str	r3, [r7, #64]	; 0x40
						bitsLeft -= 8;
 8002f4c:	683b      	ldr	r3, [r7, #0]
 8002f4e:	3b08      	subs	r3, #8
 8002f50:	603b      	str	r3, [r7, #0]
					while (cachedBits < minBits) {
 8002f52:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 8002f54:	697b      	ldr	r3, [r7, #20]
 8002f56:	429a      	cmp	r2, r3
 8002f58:	dbe8      	blt.n	8002f2c <DecodeHuffmanPairs+0x4d8>
					}
					if (bitsLeft < 0) {
 8002f5a:	683b      	ldr	r3, [r7, #0]
 8002f5c:	2b00      	cmp	r3, #0
 8002f5e:	da0f      	bge.n	8002f80 <DecodeHuffmanPairs+0x52c>
						cachedBits += bitsLeft;
 8002f60:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 8002f62:	683b      	ldr	r3, [r7, #0]
 8002f64:	4413      	add	r3, r2
 8002f66:	643b      	str	r3, [r7, #64]	; 0x40
						bitsLeft = 0;
 8002f68:	2300      	movs	r3, #0
 8002f6a:	603b      	str	r3, [r7, #0]
						cache &= (signed int)0x80000000 >> (cachedBits - 1);
 8002f6c:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8002f6e:	3b01      	subs	r3, #1
 8002f70:	f04f 4200 	mov.w	r2, #2147483648	; 0x80000000
 8002f74:	fa42 f303 	asr.w	r3, r2, r3
 8002f78:	461a      	mov	r2, r3
 8002f7a:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8002f7c:	4013      	ands	r3, r2
 8002f7e:	637b      	str	r3, [r7, #52]	; 0x34
					}
					y += (int)(cache >> (32 - linBits));
 8002f80:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8002f82:	f1c3 0320 	rsb	r3, r3, #32
 8002f86:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 8002f88:	fa22 f303 	lsr.w	r3, r2, r3
 8002f8c:	461a      	mov	r2, r3
 8002f8e:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8002f90:	4413      	add	r3, r2
 8002f92:	647b      	str	r3, [r7, #68]	; 0x44
					cachedBits -= linBits;
 8002f94:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 8002f96:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8002f98:	1ad3      	subs	r3, r2, r3
 8002f9a:	643b      	str	r3, [r7, #64]	; 0x40
					cache <<= linBits;
 8002f9c:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 8002f9e:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8002fa0:	fa02 f303 	lsl.w	r3, r2, r3
 8002fa4:	637b      	str	r3, [r7, #52]	; 0x34
				}
				if (y)	{ApplySign(y, cache); cache <<= 1; cachedBits--;}
 8002fa6:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8002fa8:	2b00      	cmp	r3, #0
 8002faa:	d00b      	beq.n	8002fc4 <DecodeHuffmanPairs+0x570>
 8002fac:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8002fae:	f003 4200 	and.w	r2, r3, #2147483648	; 0x80000000
 8002fb2:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8002fb4:	4313      	orrs	r3, r2
 8002fb6:	647b      	str	r3, [r7, #68]	; 0x44
 8002fb8:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8002fba:	005b      	lsls	r3, r3, #1
 8002fbc:	637b      	str	r3, [r7, #52]	; 0x34
 8002fbe:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8002fc0:	3b01      	subs	r3, #1
 8002fc2:	643b      	str	r3, [r7, #64]	; 0x40

				/* ran out of bits - should never have consumed padBits */
				if (cachedBits < padBits)
 8002fc4:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 8002fc6:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8002fc8:	429a      	cmp	r2, r3
 8002fca:	da02      	bge.n	8002fd2 <DecodeHuffmanPairs+0x57e>
					return -1;
 8002fcc:	f04f 33ff 	mov.w	r3, #4294967295
 8002fd0:	e025      	b.n	800301e <DecodeHuffmanPairs+0x5ca>

				*xy++ = x;
 8002fd2:	68fb      	ldr	r3, [r7, #12]
 8002fd4:	1d1a      	adds	r2, r3, #4
 8002fd6:	60fa      	str	r2, [r7, #12]
 8002fd8:	6cba      	ldr	r2, [r7, #72]	; 0x48
 8002fda:	601a      	str	r2, [r3, #0]
				*xy++ = y;
 8002fdc:	68fb      	ldr	r3, [r7, #12]
 8002fde:	1d1a      	adds	r2, r3, #4
 8002fe0:	60fa      	str	r2, [r7, #12]
 8002fe2:	6c7a      	ldr	r2, [r7, #68]	; 0x44
 8002fe4:	601a      	str	r2, [r3, #0]
				nVals -= 2;
 8002fe6:	68bb      	ldr	r3, [r7, #8]
 8002fe8:	3b02      	subs	r3, #2
 8002fea:	60bb      	str	r3, [r7, #8]
				tCurr = tBase;
 8002fec:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8002fee:	63bb      	str	r3, [r7, #56]	; 0x38
			while (nVals > 0 && cachedBits >= 11 ) {
 8002ff0:	68bb      	ldr	r3, [r7, #8]
 8002ff2:	2b00      	cmp	r3, #0
 8002ff4:	dd03      	ble.n	8002ffe <DecodeHuffmanPairs+0x5aa>
 8002ff6:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8002ff8:	2b0a      	cmp	r3, #10
 8002ffa:	f73f aee0 	bgt.w	8002dbe <DecodeHuffmanPairs+0x36a>
		while (nVals > 0) {
 8002ffe:	68bb      	ldr	r3, [r7, #8]
 8003000:	2b00      	cmp	r3, #0
 8003002:	f73f ae79 	bgt.w	8002cf8 <DecodeHuffmanPairs+0x2a4>
			}
		}
		bitsLeft += (cachedBits - padBits);
 8003006:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 8003008:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800300a:	1ad3      	subs	r3, r2, r3
 800300c:	683a      	ldr	r2, [r7, #0]
 800300e:	4413      	add	r3, r2
 8003010:	603b      	str	r3, [r7, #0]
		return (startBits - bitsLeft);
 8003012:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 8003014:	683b      	ldr	r3, [r7, #0]
 8003016:	1ad3      	subs	r3, r2, r3
 8003018:	e001      	b.n	800301e <DecodeHuffmanPairs+0x5ca>
	}

	/* error in bitstream - trying to access unused Huffman table */
	return -1;
 800301a:	f04f 33ff 	mov.w	r3, #4294967295
}
 800301e:	4618      	mov	r0, r3
 8003020:	3754      	adds	r7, #84	; 0x54
 8003022:	46bd      	mov	sp, r7
 8003024:	f85d 7b04 	ldr.w	r7, [sp], #4
 8003028:	4770      	bx	lr

0800302a <DecodeHuffmanQuads>:
 *                of the quad word after which all samples are 0)
 * 
 * Notes:        si_huff.bit tests every vwxy output in both quad tables
 **************************************************************************************/
static int DecodeHuffmanQuads(int *vwxy, int nVals, int tabIdx, int bitsLeft, unsigned char *buf, int bitOffset)
{
 800302a:	b480      	push	{r7}
 800302c:	b091      	sub	sp, #68	; 0x44
 800302e:	af00      	add	r7, sp, #0
 8003030:	60f8      	str	r0, [r7, #12]
 8003032:	60b9      	str	r1, [r7, #8]
 8003034:	607a      	str	r2, [r7, #4]
 8003036:	603b      	str	r3, [r7, #0]
	int i, v, w, x, y;
	int len, maxBits, cachedBits, padBits;
	unsigned int cache;
	unsigned char cw, *tBase;

	if (bitsLeft <= 0)
 8003038:	683b      	ldr	r3, [r7, #0]
 800303a:	2b00      	cmp	r3, #0
 800303c:	dc01      	bgt.n	8003042 <DecodeHuffmanQuads+0x18>
		return 0;
 800303e:	2300      	movs	r3, #0
 8003040:	e124      	b.n	800328c <DecodeHuffmanQuads+0x262>

	tBase = (unsigned char *)quadTable + quadTabOffset[tabIdx];
 8003042:	4a95      	ldr	r2, [pc, #596]	; (8003298 <DecodeHuffmanQuads+0x26e>)
 8003044:	687b      	ldr	r3, [r7, #4]
 8003046:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 800304a:	461a      	mov	r2, r3
 800304c:	4b93      	ldr	r3, [pc, #588]	; (800329c <DecodeHuffmanQuads+0x272>)
 800304e:	4413      	add	r3, r2
 8003050:	61fb      	str	r3, [r7, #28]
	maxBits = quadTabMaxBits[tabIdx];
 8003052:	4a93      	ldr	r2, [pc, #588]	; (80032a0 <DecodeHuffmanQuads+0x276>)
 8003054:	687b      	ldr	r3, [r7, #4]
 8003056:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 800305a:	61bb      	str	r3, [r7, #24]

	/* initially fill cache with any partial byte */
	cache = 0;
 800305c:	2300      	movs	r3, #0
 800305e:	623b      	str	r3, [r7, #32]
	cachedBits = (8 - bitOffset) & 0x07;
 8003060:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8003062:	425b      	negs	r3, r3
 8003064:	f003 0307 	and.w	r3, r3, #7
 8003068:	62bb      	str	r3, [r7, #40]	; 0x28
	if (cachedBits)
 800306a:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800306c:	2b00      	cmp	r3, #0
 800306e:	d00a      	beq.n	8003086 <DecodeHuffmanQuads+0x5c>
		cache = (unsigned int)(*buf++) << (32 - cachedBits);
 8003070:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8003072:	1c5a      	adds	r2, r3, #1
 8003074:	64ba      	str	r2, [r7, #72]	; 0x48
 8003076:	781b      	ldrb	r3, [r3, #0]
 8003078:	461a      	mov	r2, r3
 800307a:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800307c:	f1c3 0320 	rsb	r3, r3, #32
 8003080:	fa02 f303 	lsl.w	r3, r2, r3
 8003084:	623b      	str	r3, [r7, #32]
	bitsLeft -= cachedBits;
 8003086:	683a      	ldr	r2, [r7, #0]
 8003088:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800308a:	1ad3      	subs	r3, r2, r3
 800308c:	603b      	str	r3, [r7, #0]

	i = padBits = 0;
 800308e:	2300      	movs	r3, #0
 8003090:	627b      	str	r3, [r7, #36]	; 0x24
 8003092:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8003094:	63fb      	str	r3, [r7, #60]	; 0x3c
	while (i < (nVals - 3)) {
 8003096:	e0f2      	b.n	800327e <DecodeHuffmanQuads+0x254>
		/* refill cache - assumes cachedBits <= 16 */
		if (bitsLeft >= 16) {
 8003098:	683b      	ldr	r3, [r7, #0]
 800309a:	2b0f      	cmp	r3, #15
 800309c:	dd20      	ble.n	80030e0 <DecodeHuffmanQuads+0xb6>
			/* load 2 new bytes into left-justified cache */
			cache |= (unsigned int)(*buf++) << (24 - cachedBits);
 800309e:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 80030a0:	1c5a      	adds	r2, r3, #1
 80030a2:	64ba      	str	r2, [r7, #72]	; 0x48
 80030a4:	781b      	ldrb	r3, [r3, #0]
 80030a6:	461a      	mov	r2, r3
 80030a8:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80030aa:	f1c3 0318 	rsb	r3, r3, #24
 80030ae:	fa02 f303 	lsl.w	r3, r2, r3
 80030b2:	6a3a      	ldr	r2, [r7, #32]
 80030b4:	4313      	orrs	r3, r2
 80030b6:	623b      	str	r3, [r7, #32]
			cache |= (unsigned int)(*buf++) << (16 - cachedBits);
 80030b8:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 80030ba:	1c5a      	adds	r2, r3, #1
 80030bc:	64ba      	str	r2, [r7, #72]	; 0x48
 80030be:	781b      	ldrb	r3, [r3, #0]
 80030c0:	461a      	mov	r2, r3
 80030c2:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80030c4:	f1c3 0310 	rsb	r3, r3, #16
 80030c8:	fa02 f303 	lsl.w	r3, r2, r3
 80030cc:	6a3a      	ldr	r2, [r7, #32]
 80030ce:	4313      	orrs	r3, r2
 80030d0:	623b      	str	r3, [r7, #32]
			cachedBits += 16;
 80030d2:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80030d4:	3310      	adds	r3, #16
 80030d6:	62bb      	str	r3, [r7, #40]	; 0x28
			bitsLeft -= 16;
 80030d8:	683b      	ldr	r3, [r7, #0]
 80030da:	3b10      	subs	r3, #16
 80030dc:	603b      	str	r3, [r7, #0]
 80030de:	e0c5      	b.n	800326c <DecodeHuffmanQuads+0x242>
		} else {
			/* last time through, pad cache with zeros and drain cache */
			if (cachedBits + bitsLeft <= 0) return i;
 80030e0:	6aba      	ldr	r2, [r7, #40]	; 0x28
 80030e2:	683b      	ldr	r3, [r7, #0]
 80030e4:	4413      	add	r3, r2
 80030e6:	2b00      	cmp	r3, #0
 80030e8:	dc01      	bgt.n	80030ee <DecodeHuffmanQuads+0xc4>
 80030ea:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 80030ec:	e0ce      	b.n	800328c <DecodeHuffmanQuads+0x262>
			if (bitsLeft > 0)	cache |= (unsigned int)(*buf++) << (24 - cachedBits);
 80030ee:	683b      	ldr	r3, [r7, #0]
 80030f0:	2b00      	cmp	r3, #0
 80030f2:	dd0c      	ble.n	800310e <DecodeHuffmanQuads+0xe4>
 80030f4:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 80030f6:	1c5a      	adds	r2, r3, #1
 80030f8:	64ba      	str	r2, [r7, #72]	; 0x48
 80030fa:	781b      	ldrb	r3, [r3, #0]
 80030fc:	461a      	mov	r2, r3
 80030fe:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8003100:	f1c3 0318 	rsb	r3, r3, #24
 8003104:	fa02 f303 	lsl.w	r3, r2, r3
 8003108:	6a3a      	ldr	r2, [r7, #32]
 800310a:	4313      	orrs	r3, r2
 800310c:	623b      	str	r3, [r7, #32]
			if (bitsLeft > 8)	cache |= (unsigned int)(*buf++) << (16 - cachedBits);
 800310e:	683b      	ldr	r3, [r7, #0]
 8003110:	2b08      	cmp	r3, #8
 8003112:	dd0c      	ble.n	800312e <DecodeHuffmanQuads+0x104>
 8003114:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8003116:	1c5a      	adds	r2, r3, #1
 8003118:	64ba      	str	r2, [r7, #72]	; 0x48
 800311a:	781b      	ldrb	r3, [r3, #0]
 800311c:	461a      	mov	r2, r3
 800311e:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8003120:	f1c3 0310 	rsb	r3, r3, #16
 8003124:	fa02 f303 	lsl.w	r3, r2, r3
 8003128:	6a3a      	ldr	r2, [r7, #32]
 800312a:	4313      	orrs	r3, r2
 800312c:	623b      	str	r3, [r7, #32]
			cachedBits += bitsLeft;
 800312e:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8003130:	683b      	ldr	r3, [r7, #0]
 8003132:	4413      	add	r3, r2
 8003134:	62bb      	str	r3, [r7, #40]	; 0x28
			bitsLeft = 0;
 8003136:	2300      	movs	r3, #0
 8003138:	603b      	str	r3, [r7, #0]

			cache &= (signed int)0x80000000 >> (cachedBits - 1);
 800313a:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800313c:	3b01      	subs	r3, #1
 800313e:	f04f 4200 	mov.w	r2, #2147483648	; 0x80000000
 8003142:	fa42 f303 	asr.w	r3, r2, r3
 8003146:	461a      	mov	r2, r3
 8003148:	6a3b      	ldr	r3, [r7, #32]
 800314a:	4013      	ands	r3, r2
 800314c:	623b      	str	r3, [r7, #32]
			padBits = 10;
 800314e:	230a      	movs	r3, #10
 8003150:	627b      	str	r3, [r7, #36]	; 0x24
			cachedBits += padBits;	/* okay if this is > 32 (0's automatically shifted in from right) */
 8003152:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8003154:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8003156:	4413      	add	r3, r2
 8003158:	62bb      	str	r3, [r7, #40]	; 0x28
		}

		/* largest maxBits = 6, plus 4 for sign bits, so make sure cache has at least 10 bits */
		while (i < (nVals - 3) && cachedBits >= 10 ) {
 800315a:	e087      	b.n	800326c <DecodeHuffmanQuads+0x242>
			cw = tBase[cache >> (32 - maxBits)];
 800315c:	69bb      	ldr	r3, [r7, #24]
 800315e:	f1c3 0320 	rsb	r3, r3, #32
 8003162:	6a3a      	ldr	r2, [r7, #32]
 8003164:	fa22 f303 	lsr.w	r3, r2, r3
 8003168:	69fa      	ldr	r2, [r7, #28]
 800316a:	4413      	add	r3, r2
 800316c:	781b      	ldrb	r3, [r3, #0]
 800316e:	75fb      	strb	r3, [r7, #23]
			len = GetHLenQ(cw);
 8003170:	7dfb      	ldrb	r3, [r7, #23]
 8003172:	091b      	lsrs	r3, r3, #4
 8003174:	b2db      	uxtb	r3, r3
 8003176:	f003 030f 	and.w	r3, r3, #15
 800317a:	613b      	str	r3, [r7, #16]
			cachedBits -= len;
 800317c:	6aba      	ldr	r2, [r7, #40]	; 0x28
 800317e:	693b      	ldr	r3, [r7, #16]
 8003180:	1ad3      	subs	r3, r2, r3
 8003182:	62bb      	str	r3, [r7, #40]	; 0x28
			cache <<= len;
 8003184:	6a3a      	ldr	r2, [r7, #32]
 8003186:	693b      	ldr	r3, [r7, #16]
 8003188:	fa02 f303 	lsl.w	r3, r2, r3
 800318c:	623b      	str	r3, [r7, #32]

			v = GetCWVQ(cw);	if(v) {ApplySign(v, cache); cache <<= 1; cachedBits--;}
 800318e:	7dfb      	ldrb	r3, [r7, #23]
 8003190:	08db      	lsrs	r3, r3, #3
 8003192:	b2db      	uxtb	r3, r3
 8003194:	f003 0301 	and.w	r3, r3, #1
 8003198:	63bb      	str	r3, [r7, #56]	; 0x38
 800319a:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800319c:	2b00      	cmp	r3, #0
 800319e:	d00b      	beq.n	80031b8 <DecodeHuffmanQuads+0x18e>
 80031a0:	6a3b      	ldr	r3, [r7, #32]
 80031a2:	f003 4200 	and.w	r2, r3, #2147483648	; 0x80000000
 80031a6:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 80031a8:	4313      	orrs	r3, r2
 80031aa:	63bb      	str	r3, [r7, #56]	; 0x38
 80031ac:	6a3b      	ldr	r3, [r7, #32]
 80031ae:	005b      	lsls	r3, r3, #1
 80031b0:	623b      	str	r3, [r7, #32]
 80031b2:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80031b4:	3b01      	subs	r3, #1
 80031b6:	62bb      	str	r3, [r7, #40]	; 0x28
			w = GetCWWQ(cw);	if(w) {ApplySign(w, cache); cache <<= 1; cachedBits--;}
 80031b8:	7dfb      	ldrb	r3, [r7, #23]
 80031ba:	089b      	lsrs	r3, r3, #2
 80031bc:	b2db      	uxtb	r3, r3
 80031be:	f003 0301 	and.w	r3, r3, #1
 80031c2:	637b      	str	r3, [r7, #52]	; 0x34
 80031c4:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 80031c6:	2b00      	cmp	r3, #0
 80031c8:	d00b      	beq.n	80031e2 <DecodeHuffmanQuads+0x1b8>
 80031ca:	6a3b      	ldr	r3, [r7, #32]
 80031cc:	f003 4200 	and.w	r2, r3, #2147483648	; 0x80000000
 80031d0:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 80031d2:	4313      	orrs	r3, r2
 80031d4:	637b      	str	r3, [r7, #52]	; 0x34
 80031d6:	6a3b      	ldr	r3, [r7, #32]
 80031d8:	005b      	lsls	r3, r3, #1
 80031da:	623b      	str	r3, [r7, #32]
 80031dc:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80031de:	3b01      	subs	r3, #1
 80031e0:	62bb      	str	r3, [r7, #40]	; 0x28
			x = GetCWXQ(cw);	if(x) {ApplySign(x, cache); cache <<= 1; cachedBits--;}
 80031e2:	7dfb      	ldrb	r3, [r7, #23]
 80031e4:	085b      	lsrs	r3, r3, #1
 80031e6:	b2db      	uxtb	r3, r3
 80031e8:	f003 0301 	and.w	r3, r3, #1
 80031ec:	633b      	str	r3, [r7, #48]	; 0x30
 80031ee:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80031f0:	2b00      	cmp	r3, #0
 80031f2:	d00b      	beq.n	800320c <DecodeHuffmanQuads+0x1e2>
 80031f4:	6a3b      	ldr	r3, [r7, #32]
 80031f6:	f003 4200 	and.w	r2, r3, #2147483648	; 0x80000000
 80031fa:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80031fc:	4313      	orrs	r3, r2
 80031fe:	633b      	str	r3, [r7, #48]	; 0x30
 8003200:	6a3b      	ldr	r3, [r7, #32]
 8003202:	005b      	lsls	r3, r3, #1
 8003204:	623b      	str	r3, [r7, #32]
 8003206:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8003208:	3b01      	subs	r3, #1
 800320a:	62bb      	str	r3, [r7, #40]	; 0x28
			y = GetCWYQ(cw);	if(y) {ApplySign(y, cache); cache <<= 1; cachedBits--;}
 800320c:	7dfb      	ldrb	r3, [r7, #23]
 800320e:	f003 0301 	and.w	r3, r3, #1
 8003212:	62fb      	str	r3, [r7, #44]	; 0x2c
 8003214:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8003216:	2b00      	cmp	r3, #0
 8003218:	d00b      	beq.n	8003232 <DecodeHuffmanQuads+0x208>
 800321a:	6a3b      	ldr	r3, [r7, #32]
 800321c:	f003 4200 	and.w	r2, r3, #2147483648	; 0x80000000
 8003220:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8003222:	4313      	orrs	r3, r2
 8003224:	62fb      	str	r3, [r7, #44]	; 0x2c
 8003226:	6a3b      	ldr	r3, [r7, #32]
 8003228:	005b      	lsls	r3, r3, #1
 800322a:	623b      	str	r3, [r7, #32]
 800322c:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800322e:	3b01      	subs	r3, #1
 8003230:	62bb      	str	r3, [r7, #40]	; 0x28

			/* ran out of bits - okay (means we're done) */
			if (cachedBits < padBits)
 8003232:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8003234:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8003236:	429a      	cmp	r2, r3
 8003238:	da01      	bge.n	800323e <DecodeHuffmanQuads+0x214>
				return i;
 800323a:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800323c:	e026      	b.n	800328c <DecodeHuffmanQuads+0x262>

			*vwxy++ = v;
 800323e:	68fb      	ldr	r3, [r7, #12]
 8003240:	1d1a      	adds	r2, r3, #4
 8003242:	60fa      	str	r2, [r7, #12]
 8003244:	6bba      	ldr	r2, [r7, #56]	; 0x38
 8003246:	601a      	str	r2, [r3, #0]
			*vwxy++ = w;
 8003248:	68fb      	ldr	r3, [r7, #12]
 800324a:	1d1a      	adds	r2, r3, #4
 800324c:	60fa      	str	r2, [r7, #12]
 800324e:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 8003250:	601a      	str	r2, [r3, #0]
			*vwxy++ = x;
 8003252:	68fb      	ldr	r3, [r7, #12]
 8003254:	1d1a      	adds	r2, r3, #4
 8003256:	60fa      	str	r2, [r7, #12]
 8003258:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 800325a:	601a      	str	r2, [r3, #0]
			*vwxy++ = y;
 800325c:	68fb      	ldr	r3, [r7, #12]
 800325e:	1d1a      	adds	r2, r3, #4
 8003260:	60fa      	str	r2, [r7, #12]
 8003262:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8003264:	601a      	str	r2, [r3, #0]
			i += 4;
 8003266:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8003268:	3304      	adds	r3, #4
 800326a:	63fb      	str	r3, [r7, #60]	; 0x3c
		while (i < (nVals - 3) && cachedBits >= 10 ) {
 800326c:	68bb      	ldr	r3, [r7, #8]
 800326e:	1eda      	subs	r2, r3, #3
 8003270:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8003272:	429a      	cmp	r2, r3
 8003274:	dd03      	ble.n	800327e <DecodeHuffmanQuads+0x254>
 8003276:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8003278:	2b09      	cmp	r3, #9
 800327a:	f73f af6f 	bgt.w	800315c <DecodeHuffmanQuads+0x132>
	while (i < (nVals - 3)) {
 800327e:	68bb      	ldr	r3, [r7, #8]
 8003280:	1eda      	subs	r2, r3, #3
 8003282:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8003284:	429a      	cmp	r2, r3
 8003286:	f73f af07 	bgt.w	8003098 <DecodeHuffmanQuads+0x6e>
		}
	}

	/* decoded max number of quad values */
	return i;
 800328a:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
}
 800328c:	4618      	mov	r0, r3
 800328e:	3744      	adds	r7, #68	; 0x44
 8003290:	46bd      	mov	sp, r7
 8003292:	f85d 7b04 	ldr.w	r7, [sp], #4
 8003296:	4770      	bx	lr
 8003298:	0801a154 	.word	0x0801a154
 800329c:	0801a104 	.word	0x0801a104
 80032a0:	0801a15c 	.word	0x0801a15c

080032a4 <xmp3fixpt_DecodeHuffman>:
 *                byte located at buf + offset)
 *              -1 if null input pointers, huffBlockBits < 0, or decoder runs 
 *                out of bits prematurely (invalid bitstream)
 **************************************************************************************/
int DecodeHuffman(MP3DecInfo *mp3DecInfo, unsigned char *buf, int *bitOffset, int huffBlockBits, int gr, int ch)
{
 80032a4:	b580      	push	{r7, lr}
 80032a6:	b096      	sub	sp, #88	; 0x58
 80032a8:	af02      	add	r7, sp, #8
 80032aa:	60f8      	str	r0, [r7, #12]
 80032ac:	60b9      	str	r1, [r7, #8]
 80032ae:	607a      	str	r2, [r7, #4]
 80032b0:	603b      	str	r3, [r7, #0]
	int r1Start, r2Start, rEnd[4];	/* region boundaries */
	int i, w, bitsUsed, bitsLeft;
	unsigned char *startBuf = buf;
 80032b2:	68bb      	ldr	r3, [r7, #8]
 80032b4:	63fb      	str	r3, [r7, #60]	; 0x3c
	SideInfoSub *sis;
	ScaleFactorInfo *sfi;
	HuffmanInfo *hi;

	/* validate pointers */
	if (!mp3DecInfo || !mp3DecInfo->FrameHeaderPS || !mp3DecInfo->SideInfoPS || !mp3DecInfo->ScaleFactorInfoPS || !mp3DecInfo->HuffmanInfoPS)
 80032b6:	68fb      	ldr	r3, [r7, #12]
 80032b8:	2b00      	cmp	r3, #0
 80032ba:	d00f      	beq.n	80032dc <xmp3fixpt_DecodeHuffman+0x38>
 80032bc:	68fb      	ldr	r3, [r7, #12]
 80032be:	681b      	ldr	r3, [r3, #0]
 80032c0:	2b00      	cmp	r3, #0
 80032c2:	d00b      	beq.n	80032dc <xmp3fixpt_DecodeHuffman+0x38>
 80032c4:	68fb      	ldr	r3, [r7, #12]
 80032c6:	685b      	ldr	r3, [r3, #4]
 80032c8:	2b00      	cmp	r3, #0
 80032ca:	d007      	beq.n	80032dc <xmp3fixpt_DecodeHuffman+0x38>
 80032cc:	68fb      	ldr	r3, [r7, #12]
 80032ce:	689b      	ldr	r3, [r3, #8]
 80032d0:	2b00      	cmp	r3, #0
 80032d2:	d003      	beq.n	80032dc <xmp3fixpt_DecodeHuffman+0x38>
 80032d4:	68fb      	ldr	r3, [r7, #12]
 80032d6:	68db      	ldr	r3, [r3, #12]
 80032d8:	2b00      	cmp	r3, #0
 80032da:	d102      	bne.n	80032e2 <xmp3fixpt_DecodeHuffman+0x3e>
		return -1;
 80032dc:	f04f 33ff 	mov.w	r3, #4294967295
 80032e0:	e145      	b.n	800356e <xmp3fixpt_DecodeHuffman+0x2ca>

	fh = ((FrameHeader *)(mp3DecInfo->FrameHeaderPS));
 80032e2:	68fb      	ldr	r3, [r7, #12]
 80032e4:	681b      	ldr	r3, [r3, #0]
 80032e6:	63bb      	str	r3, [r7, #56]	; 0x38
	si = ((SideInfo *)(mp3DecInfo->SideInfoPS));
 80032e8:	68fb      	ldr	r3, [r7, #12]
 80032ea:	685b      	ldr	r3, [r3, #4]
 80032ec:	637b      	str	r3, [r7, #52]	; 0x34
	sis = &si->sis[gr][ch];
 80032ee:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 80032f0:	461a      	mov	r2, r3
 80032f2:	00d2      	lsls	r2, r2, #3
 80032f4:	441a      	add	r2, r3
 80032f6:	00d3      	lsls	r3, r2, #3
 80032f8:	461a      	mov	r2, r3
 80032fa:	6db9      	ldr	r1, [r7, #88]	; 0x58
 80032fc:	460b      	mov	r3, r1
 80032fe:	00db      	lsls	r3, r3, #3
 8003300:	440b      	add	r3, r1
 8003302:	011b      	lsls	r3, r3, #4
 8003304:	4413      	add	r3, r2
 8003306:	3328      	adds	r3, #40	; 0x28
 8003308:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 800330a:	4413      	add	r3, r2
 800330c:	633b      	str	r3, [r7, #48]	; 0x30
	sfi = ((ScaleFactorInfo *)(mp3DecInfo->ScaleFactorInfoPS));
 800330e:	68fb      	ldr	r3, [r7, #12]
 8003310:	689b      	ldr	r3, [r3, #8]
 8003312:	62fb      	str	r3, [r7, #44]	; 0x2c
	hi = (HuffmanInfo*)(mp3DecInfo->HuffmanInfoPS);
 8003314:	68fb      	ldr	r3, [r7, #12]
 8003316:	68db      	ldr	r3, [r3, #12]
 8003318:	62bb      	str	r3, [r7, #40]	; 0x28

	if (huffBlockBits < 0)
 800331a:	683b      	ldr	r3, [r7, #0]
 800331c:	2b00      	cmp	r3, #0
 800331e:	da02      	bge.n	8003326 <xmp3fixpt_DecodeHuffman+0x82>
		return -1;
 8003320:	f04f 33ff 	mov.w	r3, #4294967295
 8003324:	e123      	b.n	800356e <xmp3fixpt_DecodeHuffman+0x2ca>

	/* figure out region boundaries (the first 2*bigVals coefficients divided into 3 regions) */
	if (sis->winSwitchFlag && sis->blockType == 2) {
 8003326:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8003328:	691b      	ldr	r3, [r3, #16]
 800332a:	2b00      	cmp	r3, #0
 800332c:	d041      	beq.n	80033b2 <xmp3fixpt_DecodeHuffman+0x10e>
 800332e:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8003330:	695b      	ldr	r3, [r3, #20]
 8003332:	2b02      	cmp	r3, #2
 8003334:	d13d      	bne.n	80033b2 <xmp3fixpt_DecodeHuffman+0x10e>
		if (sis->mixedBlock == 0) {
 8003336:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8003338:	699b      	ldr	r3, [r3, #24]
 800333a:	2b00      	cmp	r3, #0
 800333c:	d114      	bne.n	8003368 <xmp3fixpt_DecodeHuffman+0xc4>
			r1Start = fh->sfBand->s[(sis->region0Count + 1)/3] * 3;
 800333e:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8003340:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8003342:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8003344:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8003346:	3301      	adds	r3, #1
 8003348:	498b      	ldr	r1, [pc, #556]	; (8003578 <xmp3fixpt_DecodeHuffman+0x2d4>)
 800334a:	fb81 0103 	smull	r0, r1, r1, r3
 800334e:	17db      	asrs	r3, r3, #31
 8003350:	1acb      	subs	r3, r1, r3
 8003352:	3314      	adds	r3, #20
 8003354:	005b      	lsls	r3, r3, #1
 8003356:	4413      	add	r3, r2
 8003358:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
 800335c:	461a      	mov	r2, r3
 800335e:	4613      	mov	r3, r2
 8003360:	005b      	lsls	r3, r3, #1
 8003362:	4413      	add	r3, r2
 8003364:	64fb      	str	r3, [r7, #76]	; 0x4c
 8003366:	e020      	b.n	80033aa <xmp3fixpt_DecodeHuffman+0x106>
		} else {
			if (fh->ver == MPEG1) {
 8003368:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800336a:	781b      	ldrb	r3, [r3, #0]
 800336c:	2b00      	cmp	r3, #0
 800336e:	d108      	bne.n	8003382 <xmp3fixpt_DecodeHuffman+0xde>
				r1Start = fh->sfBand->l[sis->region0Count + 1];
 8003370:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8003372:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8003374:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 8003376:	6b52      	ldr	r2, [r2, #52]	; 0x34
 8003378:	3201      	adds	r2, #1
 800337a:	f933 3012 	ldrsh.w	r3, [r3, r2, lsl #1]
 800337e:	64fb      	str	r3, [r7, #76]	; 0x4c
 8003380:	e013      	b.n	80033aa <xmp3fixpt_DecodeHuffman+0x106>
			} else {
				/* see MPEG2 spec for explanation */
				w = fh->sfBand->s[4] - fh->sfBand->s[3];
 8003382:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8003384:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8003386:	f9b3 3036 	ldrsh.w	r3, [r3, #54]	; 0x36
 800338a:	461a      	mov	r2, r3
 800338c:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800338e:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8003390:	f9b3 3034 	ldrsh.w	r3, [r3, #52]	; 0x34
 8003394:	1ad3      	subs	r3, r2, r3
 8003396:	627b      	str	r3, [r7, #36]	; 0x24
				r1Start = fh->sfBand->l[6] + 2*w;
 8003398:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800339a:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 800339c:	f9b3 300c 	ldrsh.w	r3, [r3, #12]
 80033a0:	461a      	mov	r2, r3
 80033a2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80033a4:	005b      	lsls	r3, r3, #1
 80033a6:	4413      	add	r3, r2
 80033a8:	64fb      	str	r3, [r7, #76]	; 0x4c
			}
		}
		r2Start = MAX_NSAMP;	/* short blocks don't have region 2 */
 80033aa:	f44f 7310 	mov.w	r3, #576	; 0x240
 80033ae:	64bb      	str	r3, [r7, #72]	; 0x48
 80033b0:	e013      	b.n	80033da <xmp3fixpt_DecodeHuffman+0x136>
	} else {
		r1Start = fh->sfBand->l[sis->region0Count + 1];
 80033b2:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 80033b4:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 80033b6:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 80033b8:	6b52      	ldr	r2, [r2, #52]	; 0x34
 80033ba:	3201      	adds	r2, #1
 80033bc:	f933 3012 	ldrsh.w	r3, [r3, r2, lsl #1]
 80033c0:	64fb      	str	r3, [r7, #76]	; 0x4c
		r2Start = fh->sfBand->l[sis->region0Count + 1 + sis->region1Count + 1];
 80033c2:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 80033c4:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 80033c6:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 80033c8:	6b52      	ldr	r2, [r2, #52]	; 0x34
 80033ca:	1c51      	adds	r1, r2, #1
 80033cc:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 80033ce:	6b92      	ldr	r2, [r2, #56]	; 0x38
 80033d0:	440a      	add	r2, r1
 80033d2:	3201      	adds	r2, #1
 80033d4:	f933 3012 	ldrsh.w	r3, [r3, r2, lsl #1]
 80033d8:	64bb      	str	r3, [r7, #72]	; 0x48
	}

	/* offset rEnd index by 1 so first region = rEnd[1] - rEnd[0], etc. */
	rEnd[3] = MIN(MAX_NSAMP, 2 * sis->nBigvals);
 80033da:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80033dc:	685b      	ldr	r3, [r3, #4]
 80033de:	005b      	lsls	r3, r3, #1
 80033e0:	f5b3 7f10 	cmp.w	r3, #576	; 0x240
 80033e4:	bfa8      	it	ge
 80033e6:	f44f 7310 	movge.w	r3, #576	; 0x240
 80033ea:	61fb      	str	r3, [r7, #28]
	rEnd[2] = MIN(r2Start, rEnd[3]);
 80033ec:	69fa      	ldr	r2, [r7, #28]
 80033ee:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 80033f0:	4293      	cmp	r3, r2
 80033f2:	bfa8      	it	ge
 80033f4:	4613      	movge	r3, r2
 80033f6:	61bb      	str	r3, [r7, #24]
	rEnd[1] = MIN(r1Start, rEnd[3]);
 80033f8:	69fa      	ldr	r2, [r7, #28]
 80033fa:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 80033fc:	4293      	cmp	r3, r2
 80033fe:	bfa8      	it	ge
 8003400:	4613      	movge	r3, r2
 8003402:	617b      	str	r3, [r7, #20]
	rEnd[0] = 0;
 8003404:	2300      	movs	r3, #0
 8003406:	613b      	str	r3, [r7, #16]

	/* rounds up to first all-zero pair (we don't check last pair for (x,y) == (non-zero, zero)) */
	hi->nonZeroBound[ch] = rEnd[3];
 8003408:	69f9      	ldr	r1, [r7, #28]
 800340a:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800340c:	6dfa      	ldr	r2, [r7, #92]	; 0x5c
 800340e:	f502 6290 	add.w	r2, r2, #1152	; 0x480
 8003412:	f843 1022 	str.w	r1, [r3, r2, lsl #2]

	/* decode Huffman pairs (rEnd[i] are always even numbers) */
	bitsLeft = huffBlockBits;
 8003416:	683b      	ldr	r3, [r7, #0]
 8003418:	643b      	str	r3, [r7, #64]	; 0x40
	for (i = 0; i < 3; i++) {
 800341a:	2300      	movs	r3, #0
 800341c:	647b      	str	r3, [r7, #68]	; 0x44
 800341e:	e050      	b.n	80034c2 <xmp3fixpt_DecodeHuffman+0x21e>
		bitsUsed = DecodeHuffmanPairs(hi->huffDecBuf[ch] + rEnd[i], rEnd[i+1] - rEnd[i], sis->tableSelect[i], bitsLeft, buf, *bitOffset);
 8003420:	6dfa      	ldr	r2, [r7, #92]	; 0x5c
 8003422:	4613      	mov	r3, r2
 8003424:	00db      	lsls	r3, r3, #3
 8003426:	4413      	add	r3, r2
 8003428:	021b      	lsls	r3, r3, #8
 800342a:	6aba      	ldr	r2, [r7, #40]	; 0x28
 800342c:	441a      	add	r2, r3
 800342e:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8003430:	009b      	lsls	r3, r3, #2
 8003432:	f107 0150 	add.w	r1, r7, #80	; 0x50
 8003436:	440b      	add	r3, r1
 8003438:	f853 3c40 	ldr.w	r3, [r3, #-64]
 800343c:	009b      	lsls	r3, r3, #2
 800343e:	18d0      	adds	r0, r2, r3
 8003440:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8003442:	3301      	adds	r3, #1
 8003444:	009b      	lsls	r3, r3, #2
 8003446:	f107 0250 	add.w	r2, r7, #80	; 0x50
 800344a:	4413      	add	r3, r2
 800344c:	f853 2c40 	ldr.w	r2, [r3, #-64]
 8003450:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8003452:	009b      	lsls	r3, r3, #2
 8003454:	f107 0150 	add.w	r1, r7, #80	; 0x50
 8003458:	440b      	add	r3, r1
 800345a:	f853 3c40 	ldr.w	r3, [r3, #-64]
 800345e:	1ad1      	subs	r1, r2, r3
 8003460:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 8003462:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8003464:	3306      	adds	r3, #6
 8003466:	009b      	lsls	r3, r3, #2
 8003468:	4413      	add	r3, r2
 800346a:	685a      	ldr	r2, [r3, #4]
 800346c:	687b      	ldr	r3, [r7, #4]
 800346e:	681b      	ldr	r3, [r3, #0]
 8003470:	9301      	str	r3, [sp, #4]
 8003472:	68bb      	ldr	r3, [r7, #8]
 8003474:	9300      	str	r3, [sp, #0]
 8003476:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8003478:	f7ff faec 	bl	8002a54 <DecodeHuffmanPairs>
 800347c:	6238      	str	r0, [r7, #32]
		if (bitsUsed < 0 || bitsUsed > bitsLeft)	/* error - overran end of bitstream */
 800347e:	6a3b      	ldr	r3, [r7, #32]
 8003480:	2b00      	cmp	r3, #0
 8003482:	db03      	blt.n	800348c <xmp3fixpt_DecodeHuffman+0x1e8>
 8003484:	6a3a      	ldr	r2, [r7, #32]
 8003486:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8003488:	429a      	cmp	r2, r3
 800348a:	dd02      	ble.n	8003492 <xmp3fixpt_DecodeHuffman+0x1ee>
			return -1;
 800348c:	f04f 33ff 	mov.w	r3, #4294967295
 8003490:	e06d      	b.n	800356e <xmp3fixpt_DecodeHuffman+0x2ca>

		/* update bitstream position */
		buf += (bitsUsed + *bitOffset) >> 3;
 8003492:	687b      	ldr	r3, [r7, #4]
 8003494:	681a      	ldr	r2, [r3, #0]
 8003496:	6a3b      	ldr	r3, [r7, #32]
 8003498:	4413      	add	r3, r2
 800349a:	10db      	asrs	r3, r3, #3
 800349c:	461a      	mov	r2, r3
 800349e:	68bb      	ldr	r3, [r7, #8]
 80034a0:	4413      	add	r3, r2
 80034a2:	60bb      	str	r3, [r7, #8]
		*bitOffset = (bitsUsed + *bitOffset) & 0x07;
 80034a4:	687b      	ldr	r3, [r7, #4]
 80034a6:	681a      	ldr	r2, [r3, #0]
 80034a8:	6a3b      	ldr	r3, [r7, #32]
 80034aa:	4413      	add	r3, r2
 80034ac:	f003 0207 	and.w	r2, r3, #7
 80034b0:	687b      	ldr	r3, [r7, #4]
 80034b2:	601a      	str	r2, [r3, #0]
		bitsLeft -= bitsUsed;
 80034b4:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 80034b6:	6a3b      	ldr	r3, [r7, #32]
 80034b8:	1ad3      	subs	r3, r2, r3
 80034ba:	643b      	str	r3, [r7, #64]	; 0x40
	for (i = 0; i < 3; i++) {
 80034bc:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 80034be:	3301      	adds	r3, #1
 80034c0:	647b      	str	r3, [r7, #68]	; 0x44
 80034c2:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 80034c4:	2b02      	cmp	r3, #2
 80034c6:	ddab      	ble.n	8003420 <xmp3fixpt_DecodeHuffman+0x17c>
	}

	/* decode Huffman quads (if any) */
	hi->nonZeroBound[ch] += DecodeHuffmanQuads(hi->huffDecBuf[ch] + rEnd[3], MAX_NSAMP - rEnd[3], sis->count1TableSelect, bitsLeft, buf, *bitOffset);
 80034c8:	6dfa      	ldr	r2, [r7, #92]	; 0x5c
 80034ca:	4613      	mov	r3, r2
 80034cc:	00db      	lsls	r3, r3, #3
 80034ce:	4413      	add	r3, r2
 80034d0:	021b      	lsls	r3, r3, #8
 80034d2:	6aba      	ldr	r2, [r7, #40]	; 0x28
 80034d4:	441a      	add	r2, r3
 80034d6:	69fb      	ldr	r3, [r7, #28]
 80034d8:	009b      	lsls	r3, r3, #2
 80034da:	18d0      	adds	r0, r2, r3
 80034dc:	69fb      	ldr	r3, [r7, #28]
 80034de:	f5c3 7110 	rsb	r1, r3, #576	; 0x240
 80034e2:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80034e4:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 80034e6:	687b      	ldr	r3, [r7, #4]
 80034e8:	681b      	ldr	r3, [r3, #0]
 80034ea:	9301      	str	r3, [sp, #4]
 80034ec:	68bb      	ldr	r3, [r7, #8]
 80034ee:	9300      	str	r3, [sp, #0]
 80034f0:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 80034f2:	f7ff fd9a 	bl	800302a <DecodeHuffmanQuads>
 80034f6:	4601      	mov	r1, r0
 80034f8:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80034fa:	6dfa      	ldr	r2, [r7, #92]	; 0x5c
 80034fc:	f502 6290 	add.w	r2, r2, #1152	; 0x480
 8003500:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8003504:	4419      	add	r1, r3
 8003506:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8003508:	6dfa      	ldr	r2, [r7, #92]	; 0x5c
 800350a:	f502 6290 	add.w	r2, r2, #1152	; 0x480
 800350e:	f843 1022 	str.w	r1, [r3, r2, lsl #2]

	ASSERT(hi->nonZeroBound[ch] <= MAX_NSAMP);
	for (i = hi->nonZeroBound[ch]; i < MAX_NSAMP; i++)
 8003512:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8003514:	6dfa      	ldr	r2, [r7, #92]	; 0x5c
 8003516:	f502 6290 	add.w	r2, r2, #1152	; 0x480
 800351a:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 800351e:	647b      	str	r3, [r7, #68]	; 0x44
 8003520:	e00d      	b.n	800353e <xmp3fixpt_DecodeHuffman+0x29a>
		hi->huffDecBuf[ch][i] = 0;
 8003522:	6ab9      	ldr	r1, [r7, #40]	; 0x28
 8003524:	6dfa      	ldr	r2, [r7, #92]	; 0x5c
 8003526:	4613      	mov	r3, r2
 8003528:	00db      	lsls	r3, r3, #3
 800352a:	4413      	add	r3, r2
 800352c:	019b      	lsls	r3, r3, #6
 800352e:	6c7a      	ldr	r2, [r7, #68]	; 0x44
 8003530:	4413      	add	r3, r2
 8003532:	2200      	movs	r2, #0
 8003534:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
	for (i = hi->nonZeroBound[ch]; i < MAX_NSAMP; i++)
 8003538:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800353a:	3301      	adds	r3, #1
 800353c:	647b      	str	r3, [r7, #68]	; 0x44
 800353e:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8003540:	f5b3 7f10 	cmp.w	r3, #576	; 0x240
 8003544:	dbed      	blt.n	8003522 <xmp3fixpt_DecodeHuffman+0x27e>
	
	/* If bits used for 576 samples < huffBlockBits, then the extras are considered
	 *  to be stuffing bits (throw away, but need to return correct bitstream position) 
	 */
	buf += (bitsLeft + *bitOffset) >> 3;
 8003546:	687b      	ldr	r3, [r7, #4]
 8003548:	681a      	ldr	r2, [r3, #0]
 800354a:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800354c:	4413      	add	r3, r2
 800354e:	10db      	asrs	r3, r3, #3
 8003550:	461a      	mov	r2, r3
 8003552:	68bb      	ldr	r3, [r7, #8]
 8003554:	4413      	add	r3, r2
 8003556:	60bb      	str	r3, [r7, #8]
	*bitOffset = (bitsLeft + *bitOffset) & 0x07;
 8003558:	687b      	ldr	r3, [r7, #4]
 800355a:	681a      	ldr	r2, [r3, #0]
 800355c:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800355e:	4413      	add	r3, r2
 8003560:	f003 0207 	and.w	r2, r3, #7
 8003564:	687b      	ldr	r3, [r7, #4]
 8003566:	601a      	str	r2, [r3, #0]
	
	return (buf - startBuf);
 8003568:	68ba      	ldr	r2, [r7, #8]
 800356a:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800356c:	1ad3      	subs	r3, r2, r3
}
 800356e:	4618      	mov	r0, r3
 8003570:	3750      	adds	r7, #80	; 0x50
 8003572:	46bd      	mov	sp, r7
 8003574:	bd80      	pop	{r7, pc}
 8003576:	bf00      	nop
 8003578:	55555556 	.word	0x55555556

0800357c <MULSHIFT32>:
{
 800357c:	b480      	push	{r7}
 800357e:	b085      	sub	sp, #20
 8003580:	af00      	add	r7, sp, #0
 8003582:	6078      	str	r0, [r7, #4]
 8003584:	6039      	str	r1, [r7, #0]
	__asm__ volatile ("smull %0,%1,%2,%3" : "=&r" (zlow), "=r" (y) : "r" (x), "1" (y) : "cc");
 8003586:	6879      	ldr	r1, [r7, #4]
 8003588:	683b      	ldr	r3, [r7, #0]
 800358a:	fb81 2303 	smull	r2, r3, r1, r3
 800358e:	60fa      	str	r2, [r7, #12]
 8003590:	603b      	str	r3, [r7, #0]
	return y;
 8003592:	683b      	ldr	r3, [r7, #0]
}
 8003594:	4618      	mov	r0, r3
 8003596:	3714      	adds	r7, #20
 8003598:	46bd      	mov	sp, r7
 800359a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800359e:	4770      	bx	lr

080035a0 <FASTABS>:
{
 80035a0:	b480      	push	{r7}
 80035a2:	b085      	sub	sp, #20
 80035a4:	af00      	add	r7, sp, #0
 80035a6:	6078      	str	r0, [r7, #4]
	sign = x >> (sizeof(int) * 8 - 1);
 80035a8:	687b      	ldr	r3, [r7, #4]
 80035aa:	17db      	asrs	r3, r3, #31
 80035ac:	60fb      	str	r3, [r7, #12]
	x ^= sign;
 80035ae:	687a      	ldr	r2, [r7, #4]
 80035b0:	68fb      	ldr	r3, [r7, #12]
 80035b2:	4053      	eors	r3, r2
 80035b4:	607b      	str	r3, [r7, #4]
	x -= sign;
 80035b6:	687a      	ldr	r2, [r7, #4]
 80035b8:	68fb      	ldr	r3, [r7, #12]
 80035ba:	1ad3      	subs	r3, r2, r3
 80035bc:	607b      	str	r3, [r7, #4]
	return x;
 80035be:	687b      	ldr	r3, [r7, #4]
}
 80035c0:	4618      	mov	r0, r3
 80035c2:	3714      	adds	r7, #20
 80035c4:	46bd      	mov	sp, r7
 80035c6:	f85d 7b04 	ldr.w	r7, [sp], #4
 80035ca:	4770      	bx	lr

080035cc <CLZ>:
{
 80035cc:	b480      	push	{r7}
 80035ce:	b085      	sub	sp, #20
 80035d0:	af00      	add	r7, sp, #0
 80035d2:	6078      	str	r0, [r7, #4]
	__asm__ ("clz %0, %1" : "=r" (numZeros) : "r" (x) : "cc");
 80035d4:	687b      	ldr	r3, [r7, #4]
 80035d6:	fab3 f383 	clz	r3, r3
 80035da:	60fb      	str	r3, [r7, #12]
	return numZeros;
 80035dc:	68fb      	ldr	r3, [r7, #12]
}
 80035de:	4618      	mov	r0, r3
 80035e0:	3714      	adds	r7, #20
 80035e2:	46bd      	mov	sp, r7
 80035e4:	f85d 7b04 	ldr.w	r7, [sp], #4
 80035e8:	4770      	bx	lr

080035ea <AntiAlias>:
 *              assume at least 1 guard bit in x[] to avoid overflow
 *                (should be guaranteed from dequant, and max gain from stproc * max 
 *                 gain from AntiAlias < 2.0)
 **************************************************************************************/
static void AntiAlias(int *x, int nBfly)
{
 80035ea:	b5b0      	push	{r4, r5, r7, lr}
 80035ec:	b088      	sub	sp, #32
 80035ee:	af00      	add	r7, sp, #0
 80035f0:	6078      	str	r0, [r7, #4]
 80035f2:	6039      	str	r1, [r7, #0]
	int k, a0, b0, c0, c1;
	const int *c;

	/* csa = Q31 */
	for (k = nBfly; k > 0; k--) {
 80035f4:	683b      	ldr	r3, [r7, #0]
 80035f6:	61fb      	str	r3, [r7, #28]
 80035f8:	e19e      	b.n	8003938 <AntiAlias+0x34e>
		c = csa[0];
 80035fa:	4ba3      	ldr	r3, [pc, #652]	; (8003888 <AntiAlias+0x29e>)
 80035fc:	61bb      	str	r3, [r7, #24]
		x += 18;
 80035fe:	687b      	ldr	r3, [r7, #4]
 8003600:	3348      	adds	r3, #72	; 0x48
 8003602:	607b      	str	r3, [r7, #4]

		a0 = x[-1];			c0 = *c;	c++;	b0 = x[0];		c1 = *c;	c++;
 8003604:	687b      	ldr	r3, [r7, #4]
 8003606:	f853 3c04 	ldr.w	r3, [r3, #-4]
 800360a:	617b      	str	r3, [r7, #20]
 800360c:	69bb      	ldr	r3, [r7, #24]
 800360e:	681b      	ldr	r3, [r3, #0]
 8003610:	613b      	str	r3, [r7, #16]
 8003612:	69bb      	ldr	r3, [r7, #24]
 8003614:	3304      	adds	r3, #4
 8003616:	61bb      	str	r3, [r7, #24]
 8003618:	687b      	ldr	r3, [r7, #4]
 800361a:	681b      	ldr	r3, [r3, #0]
 800361c:	60fb      	str	r3, [r7, #12]
 800361e:	69bb      	ldr	r3, [r7, #24]
 8003620:	681b      	ldr	r3, [r3, #0]
 8003622:	60bb      	str	r3, [r7, #8]
 8003624:	69bb      	ldr	r3, [r7, #24]
 8003626:	3304      	adds	r3, #4
 8003628:	61bb      	str	r3, [r7, #24]
		x[-1] = (MULSHIFT32(c0, a0) - MULSHIFT32(c1, b0)) << 1;	
 800362a:	687b      	ldr	r3, [r7, #4]
 800362c:	1f1c      	subs	r4, r3, #4
 800362e:	6979      	ldr	r1, [r7, #20]
 8003630:	6938      	ldr	r0, [r7, #16]
 8003632:	f7ff ffa3 	bl	800357c <MULSHIFT32>
 8003636:	4605      	mov	r5, r0
 8003638:	68f9      	ldr	r1, [r7, #12]
 800363a:	68b8      	ldr	r0, [r7, #8]
 800363c:	f7ff ff9e 	bl	800357c <MULSHIFT32>
 8003640:	4603      	mov	r3, r0
 8003642:	1aeb      	subs	r3, r5, r3
 8003644:	005b      	lsls	r3, r3, #1
 8003646:	6023      	str	r3, [r4, #0]
		x[0] =  (MULSHIFT32(c0, b0) + MULSHIFT32(c1, a0)) << 1;
 8003648:	68f9      	ldr	r1, [r7, #12]
 800364a:	6938      	ldr	r0, [r7, #16]
 800364c:	f7ff ff96 	bl	800357c <MULSHIFT32>
 8003650:	4604      	mov	r4, r0
 8003652:	6979      	ldr	r1, [r7, #20]
 8003654:	68b8      	ldr	r0, [r7, #8]
 8003656:	f7ff ff91 	bl	800357c <MULSHIFT32>
 800365a:	4603      	mov	r3, r0
 800365c:	4423      	add	r3, r4
 800365e:	005a      	lsls	r2, r3, #1
 8003660:	687b      	ldr	r3, [r7, #4]
 8003662:	601a      	str	r2, [r3, #0]

		a0 = x[-2];			c0 = *c;	c++;	b0 = x[1];		c1 = *c;	c++;
 8003664:	687b      	ldr	r3, [r7, #4]
 8003666:	f853 3c08 	ldr.w	r3, [r3, #-8]
 800366a:	617b      	str	r3, [r7, #20]
 800366c:	69bb      	ldr	r3, [r7, #24]
 800366e:	681b      	ldr	r3, [r3, #0]
 8003670:	613b      	str	r3, [r7, #16]
 8003672:	69bb      	ldr	r3, [r7, #24]
 8003674:	3304      	adds	r3, #4
 8003676:	61bb      	str	r3, [r7, #24]
 8003678:	687b      	ldr	r3, [r7, #4]
 800367a:	685b      	ldr	r3, [r3, #4]
 800367c:	60fb      	str	r3, [r7, #12]
 800367e:	69bb      	ldr	r3, [r7, #24]
 8003680:	681b      	ldr	r3, [r3, #0]
 8003682:	60bb      	str	r3, [r7, #8]
 8003684:	69bb      	ldr	r3, [r7, #24]
 8003686:	3304      	adds	r3, #4
 8003688:	61bb      	str	r3, [r7, #24]
		x[-2] = (MULSHIFT32(c0, a0) - MULSHIFT32(c1, b0)) << 1;	
 800368a:	687b      	ldr	r3, [r7, #4]
 800368c:	f1a3 0408 	sub.w	r4, r3, #8
 8003690:	6979      	ldr	r1, [r7, #20]
 8003692:	6938      	ldr	r0, [r7, #16]
 8003694:	f7ff ff72 	bl	800357c <MULSHIFT32>
 8003698:	4605      	mov	r5, r0
 800369a:	68f9      	ldr	r1, [r7, #12]
 800369c:	68b8      	ldr	r0, [r7, #8]
 800369e:	f7ff ff6d 	bl	800357c <MULSHIFT32>
 80036a2:	4603      	mov	r3, r0
 80036a4:	1aeb      	subs	r3, r5, r3
 80036a6:	005b      	lsls	r3, r3, #1
 80036a8:	6023      	str	r3, [r4, #0]
		x[1] =  (MULSHIFT32(c0, b0) + MULSHIFT32(c1, a0)) << 1;
 80036aa:	687b      	ldr	r3, [r7, #4]
 80036ac:	1d1c      	adds	r4, r3, #4
 80036ae:	68f9      	ldr	r1, [r7, #12]
 80036b0:	6938      	ldr	r0, [r7, #16]
 80036b2:	f7ff ff63 	bl	800357c <MULSHIFT32>
 80036b6:	4605      	mov	r5, r0
 80036b8:	6979      	ldr	r1, [r7, #20]
 80036ba:	68b8      	ldr	r0, [r7, #8]
 80036bc:	f7ff ff5e 	bl	800357c <MULSHIFT32>
 80036c0:	4603      	mov	r3, r0
 80036c2:	442b      	add	r3, r5
 80036c4:	005b      	lsls	r3, r3, #1
 80036c6:	6023      	str	r3, [r4, #0]
		
		a0 = x[-3];			c0 = *c;	c++;	b0 = x[2];		c1 = *c;	c++;
 80036c8:	687b      	ldr	r3, [r7, #4]
 80036ca:	f853 3c0c 	ldr.w	r3, [r3, #-12]
 80036ce:	617b      	str	r3, [r7, #20]
 80036d0:	69bb      	ldr	r3, [r7, #24]
 80036d2:	681b      	ldr	r3, [r3, #0]
 80036d4:	613b      	str	r3, [r7, #16]
 80036d6:	69bb      	ldr	r3, [r7, #24]
 80036d8:	3304      	adds	r3, #4
 80036da:	61bb      	str	r3, [r7, #24]
 80036dc:	687b      	ldr	r3, [r7, #4]
 80036de:	689b      	ldr	r3, [r3, #8]
 80036e0:	60fb      	str	r3, [r7, #12]
 80036e2:	69bb      	ldr	r3, [r7, #24]
 80036e4:	681b      	ldr	r3, [r3, #0]
 80036e6:	60bb      	str	r3, [r7, #8]
 80036e8:	69bb      	ldr	r3, [r7, #24]
 80036ea:	3304      	adds	r3, #4
 80036ec:	61bb      	str	r3, [r7, #24]
		x[-3] = (MULSHIFT32(c0, a0) - MULSHIFT32(c1, b0)) << 1;	
 80036ee:	687b      	ldr	r3, [r7, #4]
 80036f0:	f1a3 040c 	sub.w	r4, r3, #12
 80036f4:	6979      	ldr	r1, [r7, #20]
 80036f6:	6938      	ldr	r0, [r7, #16]
 80036f8:	f7ff ff40 	bl	800357c <MULSHIFT32>
 80036fc:	4605      	mov	r5, r0
 80036fe:	68f9      	ldr	r1, [r7, #12]
 8003700:	68b8      	ldr	r0, [r7, #8]
 8003702:	f7ff ff3b 	bl	800357c <MULSHIFT32>
 8003706:	4603      	mov	r3, r0
 8003708:	1aeb      	subs	r3, r5, r3
 800370a:	005b      	lsls	r3, r3, #1
 800370c:	6023      	str	r3, [r4, #0]
		x[2] =  (MULSHIFT32(c0, b0) + MULSHIFT32(c1, a0)) << 1;
 800370e:	687b      	ldr	r3, [r7, #4]
 8003710:	f103 0408 	add.w	r4, r3, #8
 8003714:	68f9      	ldr	r1, [r7, #12]
 8003716:	6938      	ldr	r0, [r7, #16]
 8003718:	f7ff ff30 	bl	800357c <MULSHIFT32>
 800371c:	4605      	mov	r5, r0
 800371e:	6979      	ldr	r1, [r7, #20]
 8003720:	68b8      	ldr	r0, [r7, #8]
 8003722:	f7ff ff2b 	bl	800357c <MULSHIFT32>
 8003726:	4603      	mov	r3, r0
 8003728:	442b      	add	r3, r5
 800372a:	005b      	lsls	r3, r3, #1
 800372c:	6023      	str	r3, [r4, #0]

		a0 = x[-4];			c0 = *c;	c++;	b0 = x[3];		c1 = *c;	c++;
 800372e:	687b      	ldr	r3, [r7, #4]
 8003730:	f853 3c10 	ldr.w	r3, [r3, #-16]
 8003734:	617b      	str	r3, [r7, #20]
 8003736:	69bb      	ldr	r3, [r7, #24]
 8003738:	681b      	ldr	r3, [r3, #0]
 800373a:	613b      	str	r3, [r7, #16]
 800373c:	69bb      	ldr	r3, [r7, #24]
 800373e:	3304      	adds	r3, #4
 8003740:	61bb      	str	r3, [r7, #24]
 8003742:	687b      	ldr	r3, [r7, #4]
 8003744:	68db      	ldr	r3, [r3, #12]
 8003746:	60fb      	str	r3, [r7, #12]
 8003748:	69bb      	ldr	r3, [r7, #24]
 800374a:	681b      	ldr	r3, [r3, #0]
 800374c:	60bb      	str	r3, [r7, #8]
 800374e:	69bb      	ldr	r3, [r7, #24]
 8003750:	3304      	adds	r3, #4
 8003752:	61bb      	str	r3, [r7, #24]
		x[-4] = (MULSHIFT32(c0, a0) - MULSHIFT32(c1, b0)) << 1;	
 8003754:	687b      	ldr	r3, [r7, #4]
 8003756:	f1a3 0410 	sub.w	r4, r3, #16
 800375a:	6979      	ldr	r1, [r7, #20]
 800375c:	6938      	ldr	r0, [r7, #16]
 800375e:	f7ff ff0d 	bl	800357c <MULSHIFT32>
 8003762:	4605      	mov	r5, r0
 8003764:	68f9      	ldr	r1, [r7, #12]
 8003766:	68b8      	ldr	r0, [r7, #8]
 8003768:	f7ff ff08 	bl	800357c <MULSHIFT32>
 800376c:	4603      	mov	r3, r0
 800376e:	1aeb      	subs	r3, r5, r3
 8003770:	005b      	lsls	r3, r3, #1
 8003772:	6023      	str	r3, [r4, #0]
		x[3] =  (MULSHIFT32(c0, b0) + MULSHIFT32(c1, a0)) << 1;
 8003774:	687b      	ldr	r3, [r7, #4]
 8003776:	f103 040c 	add.w	r4, r3, #12
 800377a:	68f9      	ldr	r1, [r7, #12]
 800377c:	6938      	ldr	r0, [r7, #16]
 800377e:	f7ff fefd 	bl	800357c <MULSHIFT32>
 8003782:	4605      	mov	r5, r0
 8003784:	6979      	ldr	r1, [r7, #20]
 8003786:	68b8      	ldr	r0, [r7, #8]
 8003788:	f7ff fef8 	bl	800357c <MULSHIFT32>
 800378c:	4603      	mov	r3, r0
 800378e:	442b      	add	r3, r5
 8003790:	005b      	lsls	r3, r3, #1
 8003792:	6023      	str	r3, [r4, #0]

		a0 = x[-5];			c0 = *c;	c++;	b0 = x[4];		c1 = *c;	c++;
 8003794:	687b      	ldr	r3, [r7, #4]
 8003796:	f853 3c14 	ldr.w	r3, [r3, #-20]
 800379a:	617b      	str	r3, [r7, #20]
 800379c:	69bb      	ldr	r3, [r7, #24]
 800379e:	681b      	ldr	r3, [r3, #0]
 80037a0:	613b      	str	r3, [r7, #16]
 80037a2:	69bb      	ldr	r3, [r7, #24]
 80037a4:	3304      	adds	r3, #4
 80037a6:	61bb      	str	r3, [r7, #24]
 80037a8:	687b      	ldr	r3, [r7, #4]
 80037aa:	691b      	ldr	r3, [r3, #16]
 80037ac:	60fb      	str	r3, [r7, #12]
 80037ae:	69bb      	ldr	r3, [r7, #24]
 80037b0:	681b      	ldr	r3, [r3, #0]
 80037b2:	60bb      	str	r3, [r7, #8]
 80037b4:	69bb      	ldr	r3, [r7, #24]
 80037b6:	3304      	adds	r3, #4
 80037b8:	61bb      	str	r3, [r7, #24]
		x[-5] = (MULSHIFT32(c0, a0) - MULSHIFT32(c1, b0)) << 1;	
 80037ba:	687b      	ldr	r3, [r7, #4]
 80037bc:	f1a3 0414 	sub.w	r4, r3, #20
 80037c0:	6979      	ldr	r1, [r7, #20]
 80037c2:	6938      	ldr	r0, [r7, #16]
 80037c4:	f7ff feda 	bl	800357c <MULSHIFT32>
 80037c8:	4605      	mov	r5, r0
 80037ca:	68f9      	ldr	r1, [r7, #12]
 80037cc:	68b8      	ldr	r0, [r7, #8]
 80037ce:	f7ff fed5 	bl	800357c <MULSHIFT32>
 80037d2:	4603      	mov	r3, r0
 80037d4:	1aeb      	subs	r3, r5, r3
 80037d6:	005b      	lsls	r3, r3, #1
 80037d8:	6023      	str	r3, [r4, #0]
		x[4] =  (MULSHIFT32(c0, b0) + MULSHIFT32(c1, a0)) << 1;
 80037da:	687b      	ldr	r3, [r7, #4]
 80037dc:	f103 0410 	add.w	r4, r3, #16
 80037e0:	68f9      	ldr	r1, [r7, #12]
 80037e2:	6938      	ldr	r0, [r7, #16]
 80037e4:	f7ff feca 	bl	800357c <MULSHIFT32>
 80037e8:	4605      	mov	r5, r0
 80037ea:	6979      	ldr	r1, [r7, #20]
 80037ec:	68b8      	ldr	r0, [r7, #8]
 80037ee:	f7ff fec5 	bl	800357c <MULSHIFT32>
 80037f2:	4603      	mov	r3, r0
 80037f4:	442b      	add	r3, r5
 80037f6:	005b      	lsls	r3, r3, #1
 80037f8:	6023      	str	r3, [r4, #0]

		a0 = x[-6];			c0 = *c;	c++;	b0 = x[5];		c1 = *c;	c++;
 80037fa:	687b      	ldr	r3, [r7, #4]
 80037fc:	f853 3c18 	ldr.w	r3, [r3, #-24]
 8003800:	617b      	str	r3, [r7, #20]
 8003802:	69bb      	ldr	r3, [r7, #24]
 8003804:	681b      	ldr	r3, [r3, #0]
 8003806:	613b      	str	r3, [r7, #16]
 8003808:	69bb      	ldr	r3, [r7, #24]
 800380a:	3304      	adds	r3, #4
 800380c:	61bb      	str	r3, [r7, #24]
 800380e:	687b      	ldr	r3, [r7, #4]
 8003810:	695b      	ldr	r3, [r3, #20]
 8003812:	60fb      	str	r3, [r7, #12]
 8003814:	69bb      	ldr	r3, [r7, #24]
 8003816:	681b      	ldr	r3, [r3, #0]
 8003818:	60bb      	str	r3, [r7, #8]
 800381a:	69bb      	ldr	r3, [r7, #24]
 800381c:	3304      	adds	r3, #4
 800381e:	61bb      	str	r3, [r7, #24]
		x[-6] = (MULSHIFT32(c0, a0) - MULSHIFT32(c1, b0)) << 1;	
 8003820:	687b      	ldr	r3, [r7, #4]
 8003822:	f1a3 0418 	sub.w	r4, r3, #24
 8003826:	6979      	ldr	r1, [r7, #20]
 8003828:	6938      	ldr	r0, [r7, #16]
 800382a:	f7ff fea7 	bl	800357c <MULSHIFT32>
 800382e:	4605      	mov	r5, r0
 8003830:	68f9      	ldr	r1, [r7, #12]
 8003832:	68b8      	ldr	r0, [r7, #8]
 8003834:	f7ff fea2 	bl	800357c <MULSHIFT32>
 8003838:	4603      	mov	r3, r0
 800383a:	1aeb      	subs	r3, r5, r3
 800383c:	005b      	lsls	r3, r3, #1
 800383e:	6023      	str	r3, [r4, #0]
		x[5] =  (MULSHIFT32(c0, b0) + MULSHIFT32(c1, a0)) << 1;
 8003840:	687b      	ldr	r3, [r7, #4]
 8003842:	f103 0414 	add.w	r4, r3, #20
 8003846:	68f9      	ldr	r1, [r7, #12]
 8003848:	6938      	ldr	r0, [r7, #16]
 800384a:	f7ff fe97 	bl	800357c <MULSHIFT32>
 800384e:	4605      	mov	r5, r0
 8003850:	6979      	ldr	r1, [r7, #20]
 8003852:	68b8      	ldr	r0, [r7, #8]
 8003854:	f7ff fe92 	bl	800357c <MULSHIFT32>
 8003858:	4603      	mov	r3, r0
 800385a:	442b      	add	r3, r5
 800385c:	005b      	lsls	r3, r3, #1
 800385e:	6023      	str	r3, [r4, #0]

		a0 = x[-7];			c0 = *c;	c++;	b0 = x[6];		c1 = *c;	c++;
 8003860:	687b      	ldr	r3, [r7, #4]
 8003862:	f853 3c1c 	ldr.w	r3, [r3, #-28]
 8003866:	617b      	str	r3, [r7, #20]
 8003868:	69bb      	ldr	r3, [r7, #24]
 800386a:	681b      	ldr	r3, [r3, #0]
 800386c:	613b      	str	r3, [r7, #16]
 800386e:	69bb      	ldr	r3, [r7, #24]
 8003870:	3304      	adds	r3, #4
 8003872:	61bb      	str	r3, [r7, #24]
 8003874:	687b      	ldr	r3, [r7, #4]
 8003876:	699b      	ldr	r3, [r3, #24]
 8003878:	60fb      	str	r3, [r7, #12]
 800387a:	69bb      	ldr	r3, [r7, #24]
 800387c:	681b      	ldr	r3, [r3, #0]
 800387e:	60bb      	str	r3, [r7, #8]
 8003880:	69bb      	ldr	r3, [r7, #24]
 8003882:	3304      	adds	r3, #4
 8003884:	61bb      	str	r3, [r7, #24]
 8003886:	e001      	b.n	800388c <AntiAlias+0x2a2>
 8003888:	0801a5ec 	.word	0x0801a5ec
		x[-7] = (MULSHIFT32(c0, a0) - MULSHIFT32(c1, b0)) << 1;	
 800388c:	687b      	ldr	r3, [r7, #4]
 800388e:	f1a3 041c 	sub.w	r4, r3, #28
 8003892:	6979      	ldr	r1, [r7, #20]
 8003894:	6938      	ldr	r0, [r7, #16]
 8003896:	f7ff fe71 	bl	800357c <MULSHIFT32>
 800389a:	4605      	mov	r5, r0
 800389c:	68f9      	ldr	r1, [r7, #12]
 800389e:	68b8      	ldr	r0, [r7, #8]
 80038a0:	f7ff fe6c 	bl	800357c <MULSHIFT32>
 80038a4:	4603      	mov	r3, r0
 80038a6:	1aeb      	subs	r3, r5, r3
 80038a8:	005b      	lsls	r3, r3, #1
 80038aa:	6023      	str	r3, [r4, #0]
		x[6] =  (MULSHIFT32(c0, b0) + MULSHIFT32(c1, a0)) << 1;
 80038ac:	687b      	ldr	r3, [r7, #4]
 80038ae:	f103 0418 	add.w	r4, r3, #24
 80038b2:	68f9      	ldr	r1, [r7, #12]
 80038b4:	6938      	ldr	r0, [r7, #16]
 80038b6:	f7ff fe61 	bl	800357c <MULSHIFT32>
 80038ba:	4605      	mov	r5, r0
 80038bc:	6979      	ldr	r1, [r7, #20]
 80038be:	68b8      	ldr	r0, [r7, #8]
 80038c0:	f7ff fe5c 	bl	800357c <MULSHIFT32>
 80038c4:	4603      	mov	r3, r0
 80038c6:	442b      	add	r3, r5
 80038c8:	005b      	lsls	r3, r3, #1
 80038ca:	6023      	str	r3, [r4, #0]

		a0 = x[-8];			c0 = *c;	c++;	b0 = x[7];		c1 = *c;	c++;
 80038cc:	687b      	ldr	r3, [r7, #4]
 80038ce:	f853 3c20 	ldr.w	r3, [r3, #-32]
 80038d2:	617b      	str	r3, [r7, #20]
 80038d4:	69bb      	ldr	r3, [r7, #24]
 80038d6:	681b      	ldr	r3, [r3, #0]
 80038d8:	613b      	str	r3, [r7, #16]
 80038da:	69bb      	ldr	r3, [r7, #24]
 80038dc:	3304      	adds	r3, #4
 80038de:	61bb      	str	r3, [r7, #24]
 80038e0:	687b      	ldr	r3, [r7, #4]
 80038e2:	69db      	ldr	r3, [r3, #28]
 80038e4:	60fb      	str	r3, [r7, #12]
 80038e6:	69bb      	ldr	r3, [r7, #24]
 80038e8:	681b      	ldr	r3, [r3, #0]
 80038ea:	60bb      	str	r3, [r7, #8]
 80038ec:	69bb      	ldr	r3, [r7, #24]
 80038ee:	3304      	adds	r3, #4
 80038f0:	61bb      	str	r3, [r7, #24]
		x[-8] = (MULSHIFT32(c0, a0) - MULSHIFT32(c1, b0)) << 1;	
 80038f2:	687b      	ldr	r3, [r7, #4]
 80038f4:	f1a3 0420 	sub.w	r4, r3, #32
 80038f8:	6979      	ldr	r1, [r7, #20]
 80038fa:	6938      	ldr	r0, [r7, #16]
 80038fc:	f7ff fe3e 	bl	800357c <MULSHIFT32>
 8003900:	4605      	mov	r5, r0
 8003902:	68f9      	ldr	r1, [r7, #12]
 8003904:	68b8      	ldr	r0, [r7, #8]
 8003906:	f7ff fe39 	bl	800357c <MULSHIFT32>
 800390a:	4603      	mov	r3, r0
 800390c:	1aeb      	subs	r3, r5, r3
 800390e:	005b      	lsls	r3, r3, #1
 8003910:	6023      	str	r3, [r4, #0]
		x[7] =  (MULSHIFT32(c0, b0) + MULSHIFT32(c1, a0)) << 1;
 8003912:	687b      	ldr	r3, [r7, #4]
 8003914:	f103 041c 	add.w	r4, r3, #28
 8003918:	68f9      	ldr	r1, [r7, #12]
 800391a:	6938      	ldr	r0, [r7, #16]
 800391c:	f7ff fe2e 	bl	800357c <MULSHIFT32>
 8003920:	4605      	mov	r5, r0
 8003922:	6979      	ldr	r1, [r7, #20]
 8003924:	68b8      	ldr	r0, [r7, #8]
 8003926:	f7ff fe29 	bl	800357c <MULSHIFT32>
 800392a:	4603      	mov	r3, r0
 800392c:	442b      	add	r3, r5
 800392e:	005b      	lsls	r3, r3, #1
 8003930:	6023      	str	r3, [r4, #0]
	for (k = nBfly; k > 0; k--) {
 8003932:	69fb      	ldr	r3, [r7, #28]
 8003934:	3b01      	subs	r3, #1
 8003936:	61fb      	str	r3, [r7, #28]
 8003938:	69fb      	ldr	r3, [r7, #28]
 800393a:	2b00      	cmp	r3, #0
 800393c:	f73f ae5d 	bgt.w	80035fa <AntiAlias+0x10>
	}
}
 8003940:	bf00      	nop
 8003942:	3720      	adds	r7, #32
 8003944:	46bd      	mov	sp, r7
 8003946:	bdb0      	pop	{r4, r5, r7, pc}

08003948 <WinPrevious>:
 * Notes:       produces 9 output samples from 18 input samples via symmetry
 *              all blocks gain at least 1 guard bit via window (long blocks get extra
 *                sign bit, short blocks can have one addition but max gain < 1.0)
 **************************************************************************************/
static void WinPrevious(int *xPrev, int *xPrevWin, int btPrev)
{
 8003948:	b5f0      	push	{r4, r5, r6, r7, lr}
 800394a:	b08f      	sub	sp, #60	; 0x3c
 800394c:	af00      	add	r7, sp, #0
 800394e:	60f8      	str	r0, [r7, #12]
 8003950:	60b9      	str	r1, [r7, #8]
 8003952:	607a      	str	r2, [r7, #4]
	int i, x, *xp, *xpwLo, *xpwHi, wLo, wHi;
	const int *wpLo, *wpHi;

	xp = xPrev;
 8003954:	68fb      	ldr	r3, [r7, #12]
 8003956:	633b      	str	r3, [r7, #48]	; 0x30
	/* mapping (see IMDCT12x3): xPrev[0-2] = sum[6-8], xPrev[3-8] = sum[12-17] */
	if (btPrev == 2) {
 8003958:	687b      	ldr	r3, [r7, #4]
 800395a:	2b02      	cmp	r3, #2
 800395c:	f040 8118 	bne.w	8003b90 <WinPrevious+0x248>
		/* this could be reordered for minimum loads/stores */
		wpLo = imdctWin[btPrev];
 8003960:	687a      	ldr	r2, [r7, #4]
 8003962:	4613      	mov	r3, r2
 8003964:	00db      	lsls	r3, r3, #3
 8003966:	4413      	add	r3, r2
 8003968:	011b      	lsls	r3, r3, #4
 800396a:	4aa9      	ldr	r2, [pc, #676]	; (8003c10 <WinPrevious+0x2c8>)
 800396c:	4413      	add	r3, r2
 800396e:	627b      	str	r3, [r7, #36]	; 0x24
		xPrevWin[ 0] = MULSHIFT32(wpLo[ 6], xPrev[2]) + MULSHIFT32(wpLo[0], xPrev[6]);
 8003970:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8003972:	3318      	adds	r3, #24
 8003974:	681a      	ldr	r2, [r3, #0]
 8003976:	68fb      	ldr	r3, [r7, #12]
 8003978:	3308      	adds	r3, #8
 800397a:	681b      	ldr	r3, [r3, #0]
 800397c:	4619      	mov	r1, r3
 800397e:	4610      	mov	r0, r2
 8003980:	f7ff fdfc 	bl	800357c <MULSHIFT32>
 8003984:	4604      	mov	r4, r0
 8003986:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8003988:	681a      	ldr	r2, [r3, #0]
 800398a:	68fb      	ldr	r3, [r7, #12]
 800398c:	3318      	adds	r3, #24
 800398e:	681b      	ldr	r3, [r3, #0]
 8003990:	4619      	mov	r1, r3
 8003992:	4610      	mov	r0, r2
 8003994:	f7ff fdf2 	bl	800357c <MULSHIFT32>
 8003998:	4603      	mov	r3, r0
 800399a:	18e2      	adds	r2, r4, r3
 800399c:	68bb      	ldr	r3, [r7, #8]
 800399e:	601a      	str	r2, [r3, #0]
		xPrevWin[ 1] = MULSHIFT32(wpLo[ 7], xPrev[1]) + MULSHIFT32(wpLo[1], xPrev[7]);
 80039a0:	68bb      	ldr	r3, [r7, #8]
 80039a2:	1d1c      	adds	r4, r3, #4
 80039a4:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80039a6:	331c      	adds	r3, #28
 80039a8:	681a      	ldr	r2, [r3, #0]
 80039aa:	68fb      	ldr	r3, [r7, #12]
 80039ac:	3304      	adds	r3, #4
 80039ae:	681b      	ldr	r3, [r3, #0]
 80039b0:	4619      	mov	r1, r3
 80039b2:	4610      	mov	r0, r2
 80039b4:	f7ff fde2 	bl	800357c <MULSHIFT32>
 80039b8:	4605      	mov	r5, r0
 80039ba:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80039bc:	3304      	adds	r3, #4
 80039be:	681a      	ldr	r2, [r3, #0]
 80039c0:	68fb      	ldr	r3, [r7, #12]
 80039c2:	331c      	adds	r3, #28
 80039c4:	681b      	ldr	r3, [r3, #0]
 80039c6:	4619      	mov	r1, r3
 80039c8:	4610      	mov	r0, r2
 80039ca:	f7ff fdd7 	bl	800357c <MULSHIFT32>
 80039ce:	4603      	mov	r3, r0
 80039d0:	442b      	add	r3, r5
 80039d2:	6023      	str	r3, [r4, #0]
		xPrevWin[ 2] = MULSHIFT32(wpLo[ 8], xPrev[0]) + MULSHIFT32(wpLo[2], xPrev[8]);
 80039d4:	68bb      	ldr	r3, [r7, #8]
 80039d6:	f103 0408 	add.w	r4, r3, #8
 80039da:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80039dc:	3320      	adds	r3, #32
 80039de:	681a      	ldr	r2, [r3, #0]
 80039e0:	68fb      	ldr	r3, [r7, #12]
 80039e2:	681b      	ldr	r3, [r3, #0]
 80039e4:	4619      	mov	r1, r3
 80039e6:	4610      	mov	r0, r2
 80039e8:	f7ff fdc8 	bl	800357c <MULSHIFT32>
 80039ec:	4605      	mov	r5, r0
 80039ee:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80039f0:	3308      	adds	r3, #8
 80039f2:	681a      	ldr	r2, [r3, #0]
 80039f4:	68fb      	ldr	r3, [r7, #12]
 80039f6:	3320      	adds	r3, #32
 80039f8:	681b      	ldr	r3, [r3, #0]
 80039fa:	4619      	mov	r1, r3
 80039fc:	4610      	mov	r0, r2
 80039fe:	f7ff fdbd 	bl	800357c <MULSHIFT32>
 8003a02:	4603      	mov	r3, r0
 8003a04:	442b      	add	r3, r5
 8003a06:	6023      	str	r3, [r4, #0]
		xPrevWin[ 3] = MULSHIFT32(wpLo[ 9], xPrev[0]) + MULSHIFT32(wpLo[3], xPrev[8]);
 8003a08:	68bb      	ldr	r3, [r7, #8]
 8003a0a:	f103 040c 	add.w	r4, r3, #12
 8003a0e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8003a10:	3324      	adds	r3, #36	; 0x24
 8003a12:	681a      	ldr	r2, [r3, #0]
 8003a14:	68fb      	ldr	r3, [r7, #12]
 8003a16:	681b      	ldr	r3, [r3, #0]
 8003a18:	4619      	mov	r1, r3
 8003a1a:	4610      	mov	r0, r2
 8003a1c:	f7ff fdae 	bl	800357c <MULSHIFT32>
 8003a20:	4605      	mov	r5, r0
 8003a22:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8003a24:	330c      	adds	r3, #12
 8003a26:	681a      	ldr	r2, [r3, #0]
 8003a28:	68fb      	ldr	r3, [r7, #12]
 8003a2a:	3320      	adds	r3, #32
 8003a2c:	681b      	ldr	r3, [r3, #0]
 8003a2e:	4619      	mov	r1, r3
 8003a30:	4610      	mov	r0, r2
 8003a32:	f7ff fda3 	bl	800357c <MULSHIFT32>
 8003a36:	4603      	mov	r3, r0
 8003a38:	442b      	add	r3, r5
 8003a3a:	6023      	str	r3, [r4, #0]
		xPrevWin[ 4] = MULSHIFT32(wpLo[10], xPrev[1]) + MULSHIFT32(wpLo[4], xPrev[7]);
 8003a3c:	68bb      	ldr	r3, [r7, #8]
 8003a3e:	f103 0410 	add.w	r4, r3, #16
 8003a42:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8003a44:	3328      	adds	r3, #40	; 0x28
 8003a46:	681a      	ldr	r2, [r3, #0]
 8003a48:	68fb      	ldr	r3, [r7, #12]
 8003a4a:	3304      	adds	r3, #4
 8003a4c:	681b      	ldr	r3, [r3, #0]
 8003a4e:	4619      	mov	r1, r3
 8003a50:	4610      	mov	r0, r2
 8003a52:	f7ff fd93 	bl	800357c <MULSHIFT32>
 8003a56:	4605      	mov	r5, r0
 8003a58:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8003a5a:	3310      	adds	r3, #16
 8003a5c:	681a      	ldr	r2, [r3, #0]
 8003a5e:	68fb      	ldr	r3, [r7, #12]
 8003a60:	331c      	adds	r3, #28
 8003a62:	681b      	ldr	r3, [r3, #0]
 8003a64:	4619      	mov	r1, r3
 8003a66:	4610      	mov	r0, r2
 8003a68:	f7ff fd88 	bl	800357c <MULSHIFT32>
 8003a6c:	4603      	mov	r3, r0
 8003a6e:	442b      	add	r3, r5
 8003a70:	6023      	str	r3, [r4, #0]
		xPrevWin[ 5] = MULSHIFT32(wpLo[11], xPrev[2]) + MULSHIFT32(wpLo[5], xPrev[6]);
 8003a72:	68bb      	ldr	r3, [r7, #8]
 8003a74:	f103 0414 	add.w	r4, r3, #20
 8003a78:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8003a7a:	332c      	adds	r3, #44	; 0x2c
 8003a7c:	681a      	ldr	r2, [r3, #0]
 8003a7e:	68fb      	ldr	r3, [r7, #12]
 8003a80:	3308      	adds	r3, #8
 8003a82:	681b      	ldr	r3, [r3, #0]
 8003a84:	4619      	mov	r1, r3
 8003a86:	4610      	mov	r0, r2
 8003a88:	f7ff fd78 	bl	800357c <MULSHIFT32>
 8003a8c:	4605      	mov	r5, r0
 8003a8e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8003a90:	3314      	adds	r3, #20
 8003a92:	681a      	ldr	r2, [r3, #0]
 8003a94:	68fb      	ldr	r3, [r7, #12]
 8003a96:	3318      	adds	r3, #24
 8003a98:	681b      	ldr	r3, [r3, #0]
 8003a9a:	4619      	mov	r1, r3
 8003a9c:	4610      	mov	r0, r2
 8003a9e:	f7ff fd6d 	bl	800357c <MULSHIFT32>
 8003aa2:	4603      	mov	r3, r0
 8003aa4:	442b      	add	r3, r5
 8003aa6:	6023      	str	r3, [r4, #0]
		xPrevWin[ 6] = MULSHIFT32(wpLo[ 6], xPrev[5]);
 8003aa8:	68bb      	ldr	r3, [r7, #8]
 8003aaa:	f103 0418 	add.w	r4, r3, #24
 8003aae:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8003ab0:	3318      	adds	r3, #24
 8003ab2:	681a      	ldr	r2, [r3, #0]
 8003ab4:	68fb      	ldr	r3, [r7, #12]
 8003ab6:	3314      	adds	r3, #20
 8003ab8:	681b      	ldr	r3, [r3, #0]
 8003aba:	4619      	mov	r1, r3
 8003abc:	4610      	mov	r0, r2
 8003abe:	f7ff fd5d 	bl	800357c <MULSHIFT32>
 8003ac2:	4603      	mov	r3, r0
 8003ac4:	6023      	str	r3, [r4, #0]
		xPrevWin[ 7] = MULSHIFT32(wpLo[ 7], xPrev[4]);
 8003ac6:	68bb      	ldr	r3, [r7, #8]
 8003ac8:	f103 041c 	add.w	r4, r3, #28
 8003acc:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8003ace:	331c      	adds	r3, #28
 8003ad0:	681a      	ldr	r2, [r3, #0]
 8003ad2:	68fb      	ldr	r3, [r7, #12]
 8003ad4:	3310      	adds	r3, #16
 8003ad6:	681b      	ldr	r3, [r3, #0]
 8003ad8:	4619      	mov	r1, r3
 8003ada:	4610      	mov	r0, r2
 8003adc:	f7ff fd4e 	bl	800357c <MULSHIFT32>
 8003ae0:	4603      	mov	r3, r0
 8003ae2:	6023      	str	r3, [r4, #0]
		xPrevWin[ 8] = MULSHIFT32(wpLo[ 8], xPrev[3]);
 8003ae4:	68bb      	ldr	r3, [r7, #8]
 8003ae6:	f103 0420 	add.w	r4, r3, #32
 8003aea:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8003aec:	3320      	adds	r3, #32
 8003aee:	681a      	ldr	r2, [r3, #0]
 8003af0:	68fb      	ldr	r3, [r7, #12]
 8003af2:	330c      	adds	r3, #12
 8003af4:	681b      	ldr	r3, [r3, #0]
 8003af6:	4619      	mov	r1, r3
 8003af8:	4610      	mov	r0, r2
 8003afa:	f7ff fd3f 	bl	800357c <MULSHIFT32>
 8003afe:	4603      	mov	r3, r0
 8003b00:	6023      	str	r3, [r4, #0]
		xPrevWin[ 9] = MULSHIFT32(wpLo[ 9], xPrev[3]);
 8003b02:	68bb      	ldr	r3, [r7, #8]
 8003b04:	f103 0424 	add.w	r4, r3, #36	; 0x24
 8003b08:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8003b0a:	3324      	adds	r3, #36	; 0x24
 8003b0c:	681a      	ldr	r2, [r3, #0]
 8003b0e:	68fb      	ldr	r3, [r7, #12]
 8003b10:	330c      	adds	r3, #12
 8003b12:	681b      	ldr	r3, [r3, #0]
 8003b14:	4619      	mov	r1, r3
 8003b16:	4610      	mov	r0, r2
 8003b18:	f7ff fd30 	bl	800357c <MULSHIFT32>
 8003b1c:	4603      	mov	r3, r0
 8003b1e:	6023      	str	r3, [r4, #0]
		xPrevWin[10] = MULSHIFT32(wpLo[10], xPrev[4]);
 8003b20:	68bb      	ldr	r3, [r7, #8]
 8003b22:	f103 0428 	add.w	r4, r3, #40	; 0x28
 8003b26:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8003b28:	3328      	adds	r3, #40	; 0x28
 8003b2a:	681a      	ldr	r2, [r3, #0]
 8003b2c:	68fb      	ldr	r3, [r7, #12]
 8003b2e:	3310      	adds	r3, #16
 8003b30:	681b      	ldr	r3, [r3, #0]
 8003b32:	4619      	mov	r1, r3
 8003b34:	4610      	mov	r0, r2
 8003b36:	f7ff fd21 	bl	800357c <MULSHIFT32>
 8003b3a:	4603      	mov	r3, r0
 8003b3c:	6023      	str	r3, [r4, #0]
		xPrevWin[11] = MULSHIFT32(wpLo[11], xPrev[5]);
 8003b3e:	68bb      	ldr	r3, [r7, #8]
 8003b40:	f103 042c 	add.w	r4, r3, #44	; 0x2c
 8003b44:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8003b46:	332c      	adds	r3, #44	; 0x2c
 8003b48:	681a      	ldr	r2, [r3, #0]
 8003b4a:	68fb      	ldr	r3, [r7, #12]
 8003b4c:	3314      	adds	r3, #20
 8003b4e:	681b      	ldr	r3, [r3, #0]
 8003b50:	4619      	mov	r1, r3
 8003b52:	4610      	mov	r0, r2
 8003b54:	f7ff fd12 	bl	800357c <MULSHIFT32>
 8003b58:	4603      	mov	r3, r0
 8003b5a:	6023      	str	r3, [r4, #0]
		xPrevWin[12] = xPrevWin[13] = xPrevWin[14] = xPrevWin[15] = xPrevWin[16] = xPrevWin[17] = 0;
 8003b5c:	68bb      	ldr	r3, [r7, #8]
 8003b5e:	f103 0530 	add.w	r5, r3, #48	; 0x30
 8003b62:	68bb      	ldr	r3, [r7, #8]
 8003b64:	3334      	adds	r3, #52	; 0x34
 8003b66:	68ba      	ldr	r2, [r7, #8]
 8003b68:	3238      	adds	r2, #56	; 0x38
 8003b6a:	68b9      	ldr	r1, [r7, #8]
 8003b6c:	313c      	adds	r1, #60	; 0x3c
 8003b6e:	68b8      	ldr	r0, [r7, #8]
 8003b70:	3040      	adds	r0, #64	; 0x40
 8003b72:	68bc      	ldr	r4, [r7, #8]
 8003b74:	3444      	adds	r4, #68	; 0x44
 8003b76:	2600      	movs	r6, #0
 8003b78:	6026      	str	r6, [r4, #0]
 8003b7a:	6824      	ldr	r4, [r4, #0]
 8003b7c:	6004      	str	r4, [r0, #0]
 8003b7e:	6800      	ldr	r0, [r0, #0]
 8003b80:	6008      	str	r0, [r1, #0]
 8003b82:	6809      	ldr	r1, [r1, #0]
 8003b84:	6011      	str	r1, [r2, #0]
 8003b86:	6812      	ldr	r2, [r2, #0]
 8003b88:	601a      	str	r2, [r3, #0]
 8003b8a:	681b      	ldr	r3, [r3, #0]
 8003b8c:	602b      	str	r3, [r5, #0]
			x = *xp++;	wLo = *wpLo++;	wHi = *wpHi--;
			*xpwLo++ = MULSHIFT32(wLo, x);
			*xpwHi-- = MULSHIFT32(wHi, x);
		}
	}
}
 8003b8e:	e03a      	b.n	8003c06 <WinPrevious+0x2be>
		wpLo = imdctWin[btPrev] + 18;
 8003b90:	687a      	ldr	r2, [r7, #4]
 8003b92:	4613      	mov	r3, r2
 8003b94:	00db      	lsls	r3, r3, #3
 8003b96:	4413      	add	r3, r2
 8003b98:	011b      	lsls	r3, r3, #4
 8003b9a:	4a1d      	ldr	r2, [pc, #116]	; (8003c10 <WinPrevious+0x2c8>)
 8003b9c:	4413      	add	r3, r2
 8003b9e:	3348      	adds	r3, #72	; 0x48
 8003ba0:	627b      	str	r3, [r7, #36]	; 0x24
		wpHi = wpLo + 17;
 8003ba2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8003ba4:	3344      	adds	r3, #68	; 0x44
 8003ba6:	623b      	str	r3, [r7, #32]
		xpwLo = xPrevWin;
 8003ba8:	68bb      	ldr	r3, [r7, #8]
 8003baa:	62fb      	str	r3, [r7, #44]	; 0x2c
		xpwHi = xPrevWin + 17;
 8003bac:	68bb      	ldr	r3, [r7, #8]
 8003bae:	3344      	adds	r3, #68	; 0x44
 8003bb0:	62bb      	str	r3, [r7, #40]	; 0x28
		for (i = 9; i > 0; i--) {
 8003bb2:	2309      	movs	r3, #9
 8003bb4:	637b      	str	r3, [r7, #52]	; 0x34
 8003bb6:	e023      	b.n	8003c00 <WinPrevious+0x2b8>
			x = *xp++;	wLo = *wpLo++;	wHi = *wpHi--;
 8003bb8:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8003bba:	1d1a      	adds	r2, r3, #4
 8003bbc:	633a      	str	r2, [r7, #48]	; 0x30
 8003bbe:	681b      	ldr	r3, [r3, #0]
 8003bc0:	61fb      	str	r3, [r7, #28]
 8003bc2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8003bc4:	1d1a      	adds	r2, r3, #4
 8003bc6:	627a      	str	r2, [r7, #36]	; 0x24
 8003bc8:	681b      	ldr	r3, [r3, #0]
 8003bca:	61bb      	str	r3, [r7, #24]
 8003bcc:	6a3b      	ldr	r3, [r7, #32]
 8003bce:	1f1a      	subs	r2, r3, #4
 8003bd0:	623a      	str	r2, [r7, #32]
 8003bd2:	681b      	ldr	r3, [r3, #0]
 8003bd4:	617b      	str	r3, [r7, #20]
			*xpwLo++ = MULSHIFT32(wLo, x);
 8003bd6:	6afc      	ldr	r4, [r7, #44]	; 0x2c
 8003bd8:	1d23      	adds	r3, r4, #4
 8003bda:	62fb      	str	r3, [r7, #44]	; 0x2c
 8003bdc:	69f9      	ldr	r1, [r7, #28]
 8003bde:	69b8      	ldr	r0, [r7, #24]
 8003be0:	f7ff fccc 	bl	800357c <MULSHIFT32>
 8003be4:	4603      	mov	r3, r0
 8003be6:	6023      	str	r3, [r4, #0]
			*xpwHi-- = MULSHIFT32(wHi, x);
 8003be8:	6abc      	ldr	r4, [r7, #40]	; 0x28
 8003bea:	1f23      	subs	r3, r4, #4
 8003bec:	62bb      	str	r3, [r7, #40]	; 0x28
 8003bee:	69f9      	ldr	r1, [r7, #28]
 8003bf0:	6978      	ldr	r0, [r7, #20]
 8003bf2:	f7ff fcc3 	bl	800357c <MULSHIFT32>
 8003bf6:	4603      	mov	r3, r0
 8003bf8:	6023      	str	r3, [r4, #0]
		for (i = 9; i > 0; i--) {
 8003bfa:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8003bfc:	3b01      	subs	r3, #1
 8003bfe:	637b      	str	r3, [r7, #52]	; 0x34
 8003c00:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8003c02:	2b00      	cmp	r3, #0
 8003c04:	dcd8      	bgt.n	8003bb8 <WinPrevious+0x270>
}
 8003c06:	bf00      	nop
 8003c08:	373c      	adds	r7, #60	; 0x3c
 8003c0a:	46bd      	mov	sp, r7
 8003c0c:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8003c0e:	bf00      	nop
 8003c10:	0801a25c 	.word	0x0801a25c

08003c14 <FreqInvertRescale>:
 *              rescaled (as necessary) previous samples
 *
 * Return:      updated mOut (from new outputs y)
 **************************************************************************************/
static int FreqInvertRescale(int *y, int *xPrev, int blockIdx, int es)
{
 8003c14:	b580      	push	{r7, lr}
 8003c16:	b096      	sub	sp, #88	; 0x58
 8003c18:	af00      	add	r7, sp, #0
 8003c1a:	60f8      	str	r0, [r7, #12]
 8003c1c:	60b9      	str	r1, [r7, #8]
 8003c1e:	607a      	str	r2, [r7, #4]
 8003c20:	603b      	str	r3, [r7, #0]
	int i, d, mOut;
	int y0, y1, y2, y3, y4, y5, y6, y7, y8;

	if (es == 0) {
 8003c22:	683b      	ldr	r3, [r7, #0]
 8003c24:	2b00      	cmp	r3, #0
 8003c26:	f040 8096 	bne.w	8003d56 <FreqInvertRescale+0x142>
		/* fast case - frequency invert only (no rescaling) - can fuse into overlap-add for speed, if desired */
		if (blockIdx & 0x01) {
 8003c2a:	687b      	ldr	r3, [r7, #4]
 8003c2c:	f003 0301 	and.w	r3, r3, #1
 8003c30:	2b00      	cmp	r3, #0
 8003c32:	f000 808e 	beq.w	8003d52 <FreqInvertRescale+0x13e>
			y += NBANDS;
 8003c36:	68fb      	ldr	r3, [r7, #12]
 8003c38:	3380      	adds	r3, #128	; 0x80
 8003c3a:	60fb      	str	r3, [r7, #12]
			y0 = *y;	y += 2*NBANDS;
 8003c3c:	68fb      	ldr	r3, [r7, #12]
 8003c3e:	681b      	ldr	r3, [r3, #0]
 8003c40:	64bb      	str	r3, [r7, #72]	; 0x48
 8003c42:	68fb      	ldr	r3, [r7, #12]
 8003c44:	f503 7380 	add.w	r3, r3, #256	; 0x100
 8003c48:	60fb      	str	r3, [r7, #12]
			y1 = *y;	y += 2*NBANDS;
 8003c4a:	68fb      	ldr	r3, [r7, #12]
 8003c4c:	681b      	ldr	r3, [r3, #0]
 8003c4e:	647b      	str	r3, [r7, #68]	; 0x44
 8003c50:	68fb      	ldr	r3, [r7, #12]
 8003c52:	f503 7380 	add.w	r3, r3, #256	; 0x100
 8003c56:	60fb      	str	r3, [r7, #12]
			y2 = *y;	y += 2*NBANDS;
 8003c58:	68fb      	ldr	r3, [r7, #12]
 8003c5a:	681b      	ldr	r3, [r3, #0]
 8003c5c:	643b      	str	r3, [r7, #64]	; 0x40
 8003c5e:	68fb      	ldr	r3, [r7, #12]
 8003c60:	f503 7380 	add.w	r3, r3, #256	; 0x100
 8003c64:	60fb      	str	r3, [r7, #12]
			y3 = *y;	y += 2*NBANDS;
 8003c66:	68fb      	ldr	r3, [r7, #12]
 8003c68:	681b      	ldr	r3, [r3, #0]
 8003c6a:	63fb      	str	r3, [r7, #60]	; 0x3c
 8003c6c:	68fb      	ldr	r3, [r7, #12]
 8003c6e:	f503 7380 	add.w	r3, r3, #256	; 0x100
 8003c72:	60fb      	str	r3, [r7, #12]
			y4 = *y;	y += 2*NBANDS;
 8003c74:	68fb      	ldr	r3, [r7, #12]
 8003c76:	681b      	ldr	r3, [r3, #0]
 8003c78:	63bb      	str	r3, [r7, #56]	; 0x38
 8003c7a:	68fb      	ldr	r3, [r7, #12]
 8003c7c:	f503 7380 	add.w	r3, r3, #256	; 0x100
 8003c80:	60fb      	str	r3, [r7, #12]
			y5 = *y;	y += 2*NBANDS;
 8003c82:	68fb      	ldr	r3, [r7, #12]
 8003c84:	681b      	ldr	r3, [r3, #0]
 8003c86:	637b      	str	r3, [r7, #52]	; 0x34
 8003c88:	68fb      	ldr	r3, [r7, #12]
 8003c8a:	f503 7380 	add.w	r3, r3, #256	; 0x100
 8003c8e:	60fb      	str	r3, [r7, #12]
			y6 = *y;	y += 2*NBANDS;
 8003c90:	68fb      	ldr	r3, [r7, #12]
 8003c92:	681b      	ldr	r3, [r3, #0]
 8003c94:	633b      	str	r3, [r7, #48]	; 0x30
 8003c96:	68fb      	ldr	r3, [r7, #12]
 8003c98:	f503 7380 	add.w	r3, r3, #256	; 0x100
 8003c9c:	60fb      	str	r3, [r7, #12]
			y7 = *y;	y += 2*NBANDS;
 8003c9e:	68fb      	ldr	r3, [r7, #12]
 8003ca0:	681b      	ldr	r3, [r3, #0]
 8003ca2:	62fb      	str	r3, [r7, #44]	; 0x2c
 8003ca4:	68fb      	ldr	r3, [r7, #12]
 8003ca6:	f503 7380 	add.w	r3, r3, #256	; 0x100
 8003caa:	60fb      	str	r3, [r7, #12]
			y8 = *y;	y += 2*NBANDS;
 8003cac:	68fb      	ldr	r3, [r7, #12]
 8003cae:	681b      	ldr	r3, [r3, #0]
 8003cb0:	62bb      	str	r3, [r7, #40]	; 0x28
 8003cb2:	68fb      	ldr	r3, [r7, #12]
 8003cb4:	f503 7380 	add.w	r3, r3, #256	; 0x100
 8003cb8:	60fb      	str	r3, [r7, #12]

			y -= 18*NBANDS;
 8003cba:	68fb      	ldr	r3, [r7, #12]
 8003cbc:	f5a3 6310 	sub.w	r3, r3, #2304	; 0x900
 8003cc0:	60fb      	str	r3, [r7, #12]
			*y = -y0;	y += 2*NBANDS;
 8003cc2:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8003cc4:	425a      	negs	r2, r3
 8003cc6:	68fb      	ldr	r3, [r7, #12]
 8003cc8:	601a      	str	r2, [r3, #0]
 8003cca:	68fb      	ldr	r3, [r7, #12]
 8003ccc:	f503 7380 	add.w	r3, r3, #256	; 0x100
 8003cd0:	60fb      	str	r3, [r7, #12]
			*y = -y1;	y += 2*NBANDS;
 8003cd2:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8003cd4:	425a      	negs	r2, r3
 8003cd6:	68fb      	ldr	r3, [r7, #12]
 8003cd8:	601a      	str	r2, [r3, #0]
 8003cda:	68fb      	ldr	r3, [r7, #12]
 8003cdc:	f503 7380 	add.w	r3, r3, #256	; 0x100
 8003ce0:	60fb      	str	r3, [r7, #12]
			*y = -y2;	y += 2*NBANDS;
 8003ce2:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8003ce4:	425a      	negs	r2, r3
 8003ce6:	68fb      	ldr	r3, [r7, #12]
 8003ce8:	601a      	str	r2, [r3, #0]
 8003cea:	68fb      	ldr	r3, [r7, #12]
 8003cec:	f503 7380 	add.w	r3, r3, #256	; 0x100
 8003cf0:	60fb      	str	r3, [r7, #12]
			*y = -y3;	y += 2*NBANDS;
 8003cf2:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8003cf4:	425a      	negs	r2, r3
 8003cf6:	68fb      	ldr	r3, [r7, #12]
 8003cf8:	601a      	str	r2, [r3, #0]
 8003cfa:	68fb      	ldr	r3, [r7, #12]
 8003cfc:	f503 7380 	add.w	r3, r3, #256	; 0x100
 8003d00:	60fb      	str	r3, [r7, #12]
			*y = -y4;	y += 2*NBANDS;
 8003d02:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8003d04:	425a      	negs	r2, r3
 8003d06:	68fb      	ldr	r3, [r7, #12]
 8003d08:	601a      	str	r2, [r3, #0]
 8003d0a:	68fb      	ldr	r3, [r7, #12]
 8003d0c:	f503 7380 	add.w	r3, r3, #256	; 0x100
 8003d10:	60fb      	str	r3, [r7, #12]
			*y = -y5;	y += 2*NBANDS;
 8003d12:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8003d14:	425a      	negs	r2, r3
 8003d16:	68fb      	ldr	r3, [r7, #12]
 8003d18:	601a      	str	r2, [r3, #0]
 8003d1a:	68fb      	ldr	r3, [r7, #12]
 8003d1c:	f503 7380 	add.w	r3, r3, #256	; 0x100
 8003d20:	60fb      	str	r3, [r7, #12]
			*y = -y6;	y += 2*NBANDS;
 8003d22:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8003d24:	425a      	negs	r2, r3
 8003d26:	68fb      	ldr	r3, [r7, #12]
 8003d28:	601a      	str	r2, [r3, #0]
 8003d2a:	68fb      	ldr	r3, [r7, #12]
 8003d2c:	f503 7380 	add.w	r3, r3, #256	; 0x100
 8003d30:	60fb      	str	r3, [r7, #12]
			*y = -y7;	y += 2*NBANDS;
 8003d32:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8003d34:	425a      	negs	r2, r3
 8003d36:	68fb      	ldr	r3, [r7, #12]
 8003d38:	601a      	str	r2, [r3, #0]
 8003d3a:	68fb      	ldr	r3, [r7, #12]
 8003d3c:	f503 7380 	add.w	r3, r3, #256	; 0x100
 8003d40:	60fb      	str	r3, [r7, #12]
			*y = -y8;	y += 2*NBANDS;
 8003d42:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8003d44:	425a      	negs	r2, r3
 8003d46:	68fb      	ldr	r3, [r7, #12]
 8003d48:	601a      	str	r2, [r3, #0]
 8003d4a:	68fb      	ldr	r3, [r7, #12]
 8003d4c:	f503 7380 	add.w	r3, r3, #256	; 0x100
 8003d50:	60fb      	str	r3, [r7, #12]
		}
		return 0;
 8003d52:	2300      	movs	r3, #0
 8003d54:	e0ff      	b.n	8003f56 <FreqInvertRescale+0x342>
	} else {
		/* undo pre-IMDCT scaling, clipping if necessary */
		mOut = 0;
 8003d56:	2300      	movs	r3, #0
 8003d58:	64fb      	str	r3, [r7, #76]	; 0x4c
		if (blockIdx & 0x01) {
 8003d5a:	687b      	ldr	r3, [r7, #4]
 8003d5c:	f003 0301 	and.w	r3, r3, #1
 8003d60:	2b00      	cmp	r3, #0
 8003d62:	d07c      	beq.n	8003e5e <FreqInvertRescale+0x24a>
			/* frequency invert */
			for (i = 0; i < 18; i+=2) {
 8003d64:	2300      	movs	r3, #0
 8003d66:	657b      	str	r3, [r7, #84]	; 0x54
 8003d68:	e075      	b.n	8003e56 <FreqInvertRescale+0x242>
				d = *y;		CLIP_2N(d, 31 - es);	*y = d << es;	mOut |= FASTABS(*y);	y += NBANDS;
 8003d6a:	68fb      	ldr	r3, [r7, #12]
 8003d6c:	681b      	ldr	r3, [r3, #0]
 8003d6e:	653b      	str	r3, [r7, #80]	; 0x50
 8003d70:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8003d72:	17db      	asrs	r3, r3, #31
 8003d74:	627b      	str	r3, [r7, #36]	; 0x24
 8003d76:	683b      	ldr	r3, [r7, #0]
 8003d78:	f1c3 031f 	rsb	r3, r3, #31
 8003d7c:	6d3a      	ldr	r2, [r7, #80]	; 0x50
 8003d7e:	411a      	asrs	r2, r3
 8003d80:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8003d82:	429a      	cmp	r2, r3
 8003d84:	d009      	beq.n	8003d9a <FreqInvertRescale+0x186>
 8003d86:	683b      	ldr	r3, [r7, #0]
 8003d88:	f1c3 031f 	rsb	r3, r3, #31
 8003d8c:	2201      	movs	r2, #1
 8003d8e:	fa02 f303 	lsl.w	r3, r2, r3
 8003d92:	1e5a      	subs	r2, r3, #1
 8003d94:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8003d96:	4053      	eors	r3, r2
 8003d98:	653b      	str	r3, [r7, #80]	; 0x50
 8003d9a:	6d3a      	ldr	r2, [r7, #80]	; 0x50
 8003d9c:	683b      	ldr	r3, [r7, #0]
 8003d9e:	409a      	lsls	r2, r3
 8003da0:	68fb      	ldr	r3, [r7, #12]
 8003da2:	601a      	str	r2, [r3, #0]
 8003da4:	68fb      	ldr	r3, [r7, #12]
 8003da6:	681b      	ldr	r3, [r3, #0]
 8003da8:	4618      	mov	r0, r3
 8003daa:	f7ff fbf9 	bl	80035a0 <FASTABS>
 8003dae:	4602      	mov	r2, r0
 8003db0:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8003db2:	4313      	orrs	r3, r2
 8003db4:	64fb      	str	r3, [r7, #76]	; 0x4c
 8003db6:	68fb      	ldr	r3, [r7, #12]
 8003db8:	3380      	adds	r3, #128	; 0x80
 8003dba:	60fb      	str	r3, [r7, #12]
				d = -*y;	CLIP_2N(d, 31 - es);	*y = d << es;	mOut |= FASTABS(*y);	y += NBANDS;
 8003dbc:	68fb      	ldr	r3, [r7, #12]
 8003dbe:	681b      	ldr	r3, [r3, #0]
 8003dc0:	425b      	negs	r3, r3
 8003dc2:	653b      	str	r3, [r7, #80]	; 0x50
 8003dc4:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8003dc6:	17db      	asrs	r3, r3, #31
 8003dc8:	623b      	str	r3, [r7, #32]
 8003dca:	683b      	ldr	r3, [r7, #0]
 8003dcc:	f1c3 031f 	rsb	r3, r3, #31
 8003dd0:	6d3a      	ldr	r2, [r7, #80]	; 0x50
 8003dd2:	411a      	asrs	r2, r3
 8003dd4:	6a3b      	ldr	r3, [r7, #32]
 8003dd6:	429a      	cmp	r2, r3
 8003dd8:	d009      	beq.n	8003dee <FreqInvertRescale+0x1da>
 8003dda:	683b      	ldr	r3, [r7, #0]
 8003ddc:	f1c3 031f 	rsb	r3, r3, #31
 8003de0:	2201      	movs	r2, #1
 8003de2:	fa02 f303 	lsl.w	r3, r2, r3
 8003de6:	1e5a      	subs	r2, r3, #1
 8003de8:	6a3b      	ldr	r3, [r7, #32]
 8003dea:	4053      	eors	r3, r2
 8003dec:	653b      	str	r3, [r7, #80]	; 0x50
 8003dee:	6d3a      	ldr	r2, [r7, #80]	; 0x50
 8003df0:	683b      	ldr	r3, [r7, #0]
 8003df2:	409a      	lsls	r2, r3
 8003df4:	68fb      	ldr	r3, [r7, #12]
 8003df6:	601a      	str	r2, [r3, #0]
 8003df8:	68fb      	ldr	r3, [r7, #12]
 8003dfa:	681b      	ldr	r3, [r3, #0]
 8003dfc:	4618      	mov	r0, r3
 8003dfe:	f7ff fbcf 	bl	80035a0 <FASTABS>
 8003e02:	4602      	mov	r2, r0
 8003e04:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8003e06:	4313      	orrs	r3, r2
 8003e08:	64fb      	str	r3, [r7, #76]	; 0x4c
 8003e0a:	68fb      	ldr	r3, [r7, #12]
 8003e0c:	3380      	adds	r3, #128	; 0x80
 8003e0e:	60fb      	str	r3, [r7, #12]
				d = *xPrev;	CLIP_2N(d, 31 - es);	*xPrev++ = d << es;
 8003e10:	68bb      	ldr	r3, [r7, #8]
 8003e12:	681b      	ldr	r3, [r3, #0]
 8003e14:	653b      	str	r3, [r7, #80]	; 0x50
 8003e16:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8003e18:	17db      	asrs	r3, r3, #31
 8003e1a:	61fb      	str	r3, [r7, #28]
 8003e1c:	683b      	ldr	r3, [r7, #0]
 8003e1e:	f1c3 031f 	rsb	r3, r3, #31
 8003e22:	6d3a      	ldr	r2, [r7, #80]	; 0x50
 8003e24:	411a      	asrs	r2, r3
 8003e26:	69fb      	ldr	r3, [r7, #28]
 8003e28:	429a      	cmp	r2, r3
 8003e2a:	d009      	beq.n	8003e40 <FreqInvertRescale+0x22c>
 8003e2c:	683b      	ldr	r3, [r7, #0]
 8003e2e:	f1c3 031f 	rsb	r3, r3, #31
 8003e32:	2201      	movs	r2, #1
 8003e34:	fa02 f303 	lsl.w	r3, r2, r3
 8003e38:	1e5a      	subs	r2, r3, #1
 8003e3a:	69fb      	ldr	r3, [r7, #28]
 8003e3c:	4053      	eors	r3, r2
 8003e3e:	653b      	str	r3, [r7, #80]	; 0x50
 8003e40:	68bb      	ldr	r3, [r7, #8]
 8003e42:	1d1a      	adds	r2, r3, #4
 8003e44:	60ba      	str	r2, [r7, #8]
 8003e46:	6d39      	ldr	r1, [r7, #80]	; 0x50
 8003e48:	683a      	ldr	r2, [r7, #0]
 8003e4a:	fa01 f202 	lsl.w	r2, r1, r2
 8003e4e:	601a      	str	r2, [r3, #0]
			for (i = 0; i < 18; i+=2) {
 8003e50:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8003e52:	3302      	adds	r3, #2
 8003e54:	657b      	str	r3, [r7, #84]	; 0x54
 8003e56:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8003e58:	2b11      	cmp	r3, #17
 8003e5a:	dd86      	ble.n	8003d6a <FreqInvertRescale+0x156>
 8003e5c:	e07a      	b.n	8003f54 <FreqInvertRescale+0x340>
			}
		} else {
			for (i = 0; i < 18; i+=2) {
 8003e5e:	2300      	movs	r3, #0
 8003e60:	657b      	str	r3, [r7, #84]	; 0x54
 8003e62:	e074      	b.n	8003f4e <FreqInvertRescale+0x33a>
				d = *y;		CLIP_2N(d, 31 - es);	*y = d << es;	mOut |= FASTABS(*y);	y += NBANDS;
 8003e64:	68fb      	ldr	r3, [r7, #12]
 8003e66:	681b      	ldr	r3, [r3, #0]
 8003e68:	653b      	str	r3, [r7, #80]	; 0x50
 8003e6a:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8003e6c:	17db      	asrs	r3, r3, #31
 8003e6e:	61bb      	str	r3, [r7, #24]
 8003e70:	683b      	ldr	r3, [r7, #0]
 8003e72:	f1c3 031f 	rsb	r3, r3, #31
 8003e76:	6d3a      	ldr	r2, [r7, #80]	; 0x50
 8003e78:	411a      	asrs	r2, r3
 8003e7a:	69bb      	ldr	r3, [r7, #24]
 8003e7c:	429a      	cmp	r2, r3
 8003e7e:	d009      	beq.n	8003e94 <FreqInvertRescale+0x280>
 8003e80:	683b      	ldr	r3, [r7, #0]
 8003e82:	f1c3 031f 	rsb	r3, r3, #31
 8003e86:	2201      	movs	r2, #1
 8003e88:	fa02 f303 	lsl.w	r3, r2, r3
 8003e8c:	1e5a      	subs	r2, r3, #1
 8003e8e:	69bb      	ldr	r3, [r7, #24]
 8003e90:	4053      	eors	r3, r2
 8003e92:	653b      	str	r3, [r7, #80]	; 0x50
 8003e94:	6d3a      	ldr	r2, [r7, #80]	; 0x50
 8003e96:	683b      	ldr	r3, [r7, #0]
 8003e98:	409a      	lsls	r2, r3
 8003e9a:	68fb      	ldr	r3, [r7, #12]
 8003e9c:	601a      	str	r2, [r3, #0]
 8003e9e:	68fb      	ldr	r3, [r7, #12]
 8003ea0:	681b      	ldr	r3, [r3, #0]
 8003ea2:	4618      	mov	r0, r3
 8003ea4:	f7ff fb7c 	bl	80035a0 <FASTABS>
 8003ea8:	4602      	mov	r2, r0
 8003eaa:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8003eac:	4313      	orrs	r3, r2
 8003eae:	64fb      	str	r3, [r7, #76]	; 0x4c
 8003eb0:	68fb      	ldr	r3, [r7, #12]
 8003eb2:	3380      	adds	r3, #128	; 0x80
 8003eb4:	60fb      	str	r3, [r7, #12]
				d = *y;		CLIP_2N(d, 31 - es);	*y = d << es;	mOut |= FASTABS(*y);	y += NBANDS;
 8003eb6:	68fb      	ldr	r3, [r7, #12]
 8003eb8:	681b      	ldr	r3, [r3, #0]
 8003eba:	653b      	str	r3, [r7, #80]	; 0x50
 8003ebc:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8003ebe:	17db      	asrs	r3, r3, #31
 8003ec0:	617b      	str	r3, [r7, #20]
 8003ec2:	683b      	ldr	r3, [r7, #0]
 8003ec4:	f1c3 031f 	rsb	r3, r3, #31
 8003ec8:	6d3a      	ldr	r2, [r7, #80]	; 0x50
 8003eca:	411a      	asrs	r2, r3
 8003ecc:	697b      	ldr	r3, [r7, #20]
 8003ece:	429a      	cmp	r2, r3
 8003ed0:	d009      	beq.n	8003ee6 <FreqInvertRescale+0x2d2>
 8003ed2:	683b      	ldr	r3, [r7, #0]
 8003ed4:	f1c3 031f 	rsb	r3, r3, #31
 8003ed8:	2201      	movs	r2, #1
 8003eda:	fa02 f303 	lsl.w	r3, r2, r3
 8003ede:	1e5a      	subs	r2, r3, #1
 8003ee0:	697b      	ldr	r3, [r7, #20]
 8003ee2:	4053      	eors	r3, r2
 8003ee4:	653b      	str	r3, [r7, #80]	; 0x50
 8003ee6:	6d3a      	ldr	r2, [r7, #80]	; 0x50
 8003ee8:	683b      	ldr	r3, [r7, #0]
 8003eea:	409a      	lsls	r2, r3
 8003eec:	68fb      	ldr	r3, [r7, #12]
 8003eee:	601a      	str	r2, [r3, #0]
 8003ef0:	68fb      	ldr	r3, [r7, #12]
 8003ef2:	681b      	ldr	r3, [r3, #0]
 8003ef4:	4618      	mov	r0, r3
 8003ef6:	f7ff fb53 	bl	80035a0 <FASTABS>
 8003efa:	4602      	mov	r2, r0
 8003efc:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8003efe:	4313      	orrs	r3, r2
 8003f00:	64fb      	str	r3, [r7, #76]	; 0x4c
 8003f02:	68fb      	ldr	r3, [r7, #12]
 8003f04:	3380      	adds	r3, #128	; 0x80
 8003f06:	60fb      	str	r3, [r7, #12]
				d = *xPrev;	CLIP_2N(d, 31 - es);	*xPrev++ = d << es;
 8003f08:	68bb      	ldr	r3, [r7, #8]
 8003f0a:	681b      	ldr	r3, [r3, #0]
 8003f0c:	653b      	str	r3, [r7, #80]	; 0x50
 8003f0e:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8003f10:	17db      	asrs	r3, r3, #31
 8003f12:	613b      	str	r3, [r7, #16]
 8003f14:	683b      	ldr	r3, [r7, #0]
 8003f16:	f1c3 031f 	rsb	r3, r3, #31
 8003f1a:	6d3a      	ldr	r2, [r7, #80]	; 0x50
 8003f1c:	411a      	asrs	r2, r3
 8003f1e:	693b      	ldr	r3, [r7, #16]
 8003f20:	429a      	cmp	r2, r3
 8003f22:	d009      	beq.n	8003f38 <FreqInvertRescale+0x324>
 8003f24:	683b      	ldr	r3, [r7, #0]
 8003f26:	f1c3 031f 	rsb	r3, r3, #31
 8003f2a:	2201      	movs	r2, #1
 8003f2c:	fa02 f303 	lsl.w	r3, r2, r3
 8003f30:	1e5a      	subs	r2, r3, #1
 8003f32:	693b      	ldr	r3, [r7, #16]
 8003f34:	4053      	eors	r3, r2
 8003f36:	653b      	str	r3, [r7, #80]	; 0x50
 8003f38:	68bb      	ldr	r3, [r7, #8]
 8003f3a:	1d1a      	adds	r2, r3, #4
 8003f3c:	60ba      	str	r2, [r7, #8]
 8003f3e:	6d39      	ldr	r1, [r7, #80]	; 0x50
 8003f40:	683a      	ldr	r2, [r7, #0]
 8003f42:	fa01 f202 	lsl.w	r2, r1, r2
 8003f46:	601a      	str	r2, [r3, #0]
			for (i = 0; i < 18; i+=2) {
 8003f48:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8003f4a:	3302      	adds	r3, #2
 8003f4c:	657b      	str	r3, [r7, #84]	; 0x54
 8003f4e:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8003f50:	2b11      	cmp	r3, #17
 8003f52:	dd87      	ble.n	8003e64 <FreqInvertRescale+0x250>
			}
		}
		return mOut;
 8003f54:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
	}
}
 8003f56:	4618      	mov	r0, r3
 8003f58:	3758      	adds	r7, #88	; 0x58
 8003f5a:	46bd      	mov	sp, r7
 8003f5c:	bd80      	pop	{r7, pc}

08003f5e <idct9>:
	0x7f834ed0, 0x7ba3751d, 0x7401e4c1, 0x68d9f964, 0x5a82799a, 0x496af3e2, 0x36185aee, 0x2120fb83, 0x0b27eb5c, 
};

/* require at least 3 guard bits in x[] to ensure no overflow */
static __inline void idct9(int *x)
{
 8003f5e:	b580      	push	{r7, lr}
 8003f60:	b0b0      	sub	sp, #192	; 0xc0
 8003f62:	af00      	add	r7, sp, #0
 8003f64:	6078      	str	r0, [r7, #4]
	int a10, a11, a12, a13, a14, a15, a16, a17, a18;
	int a19, a20, a21, a22, a23, a24, a25, a26, a27;
	int m1, m3, m5, m6, m7, m8, m9, m10, m11, m12;
	int x0, x1, x2, x3, x4, x5, x6, x7, x8;

	x0 = x[0]; x1 = x[1]; x2 = x[2]; x3 = x[3]; x4 = x[4];
 8003f66:	687b      	ldr	r3, [r7, #4]
 8003f68:	681b      	ldr	r3, [r3, #0]
 8003f6a:	f8c7 30bc 	str.w	r3, [r7, #188]	; 0xbc
 8003f6e:	687b      	ldr	r3, [r7, #4]
 8003f70:	685b      	ldr	r3, [r3, #4]
 8003f72:	f8c7 30b8 	str.w	r3, [r7, #184]	; 0xb8
 8003f76:	687b      	ldr	r3, [r7, #4]
 8003f78:	689b      	ldr	r3, [r3, #8]
 8003f7a:	f8c7 30b4 	str.w	r3, [r7, #180]	; 0xb4
 8003f7e:	687b      	ldr	r3, [r7, #4]
 8003f80:	68db      	ldr	r3, [r3, #12]
 8003f82:	f8c7 30b0 	str.w	r3, [r7, #176]	; 0xb0
 8003f86:	687b      	ldr	r3, [r7, #4]
 8003f88:	691b      	ldr	r3, [r3, #16]
 8003f8a:	f8c7 30ac 	str.w	r3, [r7, #172]	; 0xac
	x5 = x[5]; x6 = x[6]; x7 = x[7]; x8 = x[8];
 8003f8e:	687b      	ldr	r3, [r7, #4]
 8003f90:	695b      	ldr	r3, [r3, #20]
 8003f92:	f8c7 30a8 	str.w	r3, [r7, #168]	; 0xa8
 8003f96:	687b      	ldr	r3, [r7, #4]
 8003f98:	699b      	ldr	r3, [r3, #24]
 8003f9a:	f8c7 30a4 	str.w	r3, [r7, #164]	; 0xa4
 8003f9e:	687b      	ldr	r3, [r7, #4]
 8003fa0:	69db      	ldr	r3, [r3, #28]
 8003fa2:	f8c7 30a0 	str.w	r3, [r7, #160]	; 0xa0
 8003fa6:	687b      	ldr	r3, [r7, #4]
 8003fa8:	6a1b      	ldr	r3, [r3, #32]
 8003faa:	f8c7 309c 	str.w	r3, [r7, #156]	; 0x9c

	a1 = x0 - x6;
 8003fae:	f8d7 20bc 	ldr.w	r2, [r7, #188]	; 0xbc
 8003fb2:	f8d7 30a4 	ldr.w	r3, [r7, #164]	; 0xa4
 8003fb6:	1ad3      	subs	r3, r2, r3
 8003fb8:	f8c7 3098 	str.w	r3, [r7, #152]	; 0x98
	a2 = x1 - x5;
 8003fbc:	f8d7 20b8 	ldr.w	r2, [r7, #184]	; 0xb8
 8003fc0:	f8d7 30a8 	ldr.w	r3, [r7, #168]	; 0xa8
 8003fc4:	1ad3      	subs	r3, r2, r3
 8003fc6:	f8c7 3094 	str.w	r3, [r7, #148]	; 0x94
	a3 = x1 + x5;
 8003fca:	f8d7 20b8 	ldr.w	r2, [r7, #184]	; 0xb8
 8003fce:	f8d7 30a8 	ldr.w	r3, [r7, #168]	; 0xa8
 8003fd2:	4413      	add	r3, r2
 8003fd4:	f8c7 3090 	str.w	r3, [r7, #144]	; 0x90
	a4 = x2 - x4;
 8003fd8:	f8d7 20b4 	ldr.w	r2, [r7, #180]	; 0xb4
 8003fdc:	f8d7 30ac 	ldr.w	r3, [r7, #172]	; 0xac
 8003fe0:	1ad3      	subs	r3, r2, r3
 8003fe2:	f8c7 308c 	str.w	r3, [r7, #140]	; 0x8c
	a5 = x2 + x4;
 8003fe6:	f8d7 20b4 	ldr.w	r2, [r7, #180]	; 0xb4
 8003fea:	f8d7 30ac 	ldr.w	r3, [r7, #172]	; 0xac
 8003fee:	4413      	add	r3, r2
 8003ff0:	f8c7 3088 	str.w	r3, [r7, #136]	; 0x88
	a6 = x2 + x8;
 8003ff4:	f8d7 20b4 	ldr.w	r2, [r7, #180]	; 0xb4
 8003ff8:	f8d7 309c 	ldr.w	r3, [r7, #156]	; 0x9c
 8003ffc:	4413      	add	r3, r2
 8003ffe:	f8c7 3084 	str.w	r3, [r7, #132]	; 0x84
	a7 = x1 + x7;
 8004002:	f8d7 20b8 	ldr.w	r2, [r7, #184]	; 0xb8
 8004006:	f8d7 30a0 	ldr.w	r3, [r7, #160]	; 0xa0
 800400a:	4413      	add	r3, r2
 800400c:	f8c7 3080 	str.w	r3, [r7, #128]	; 0x80

	a8 = a6 - a5;		/* ie x[8] - x[4] */
 8004010:	f8d7 2084 	ldr.w	r2, [r7, #132]	; 0x84
 8004014:	f8d7 3088 	ldr.w	r3, [r7, #136]	; 0x88
 8004018:	1ad3      	subs	r3, r2, r3
 800401a:	67fb      	str	r3, [r7, #124]	; 0x7c
	a9 = a3 - a7;		/* ie x[5] - x[7] */
 800401c:	f8d7 2090 	ldr.w	r2, [r7, #144]	; 0x90
 8004020:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
 8004024:	1ad3      	subs	r3, r2, r3
 8004026:	67bb      	str	r3, [r7, #120]	; 0x78
	a10 = a2 - x7;		/* ie x[1] - x[5] - x[7] */
 8004028:	f8d7 2094 	ldr.w	r2, [r7, #148]	; 0x94
 800402c:	f8d7 30a0 	ldr.w	r3, [r7, #160]	; 0xa0
 8004030:	1ad3      	subs	r3, r2, r3
 8004032:	677b      	str	r3, [r7, #116]	; 0x74
	a11 = a4 - x8;		/* ie x[2] - x[4] - x[8] */
 8004034:	f8d7 208c 	ldr.w	r2, [r7, #140]	; 0x8c
 8004038:	f8d7 309c 	ldr.w	r3, [r7, #156]	; 0x9c
 800403c:	1ad3      	subs	r3, r2, r3
 800403e:	673b      	str	r3, [r7, #112]	; 0x70

	/* do the << 1 as constant shifts where mX is actually used (free, no stall or extra inst.) */
	m1 =  MULSHIFT32(c9_0, x3);
 8004040:	4b78      	ldr	r3, [pc, #480]	; (8004224 <idct9+0x2c6>)
 8004042:	f8d7 10b0 	ldr.w	r1, [r7, #176]	; 0xb0
 8004046:	4618      	mov	r0, r3
 8004048:	f7ff fa98 	bl	800357c <MULSHIFT32>
 800404c:	66f8      	str	r0, [r7, #108]	; 0x6c
	m3 =  MULSHIFT32(c9_0, a10);
 800404e:	4b75      	ldr	r3, [pc, #468]	; (8004224 <idct9+0x2c6>)
 8004050:	6f79      	ldr	r1, [r7, #116]	; 0x74
 8004052:	4618      	mov	r0, r3
 8004054:	f7ff fa92 	bl	800357c <MULSHIFT32>
 8004058:	66b8      	str	r0, [r7, #104]	; 0x68
	m5 =  MULSHIFT32(c9_1, a5);
 800405a:	4b73      	ldr	r3, [pc, #460]	; (8004228 <idct9+0x2ca>)
 800405c:	f8d7 1088 	ldr.w	r1, [r7, #136]	; 0x88
 8004060:	4618      	mov	r0, r3
 8004062:	f7ff fa8b 	bl	800357c <MULSHIFT32>
 8004066:	6678      	str	r0, [r7, #100]	; 0x64
	m6 =  MULSHIFT32(c9_2, a6);
 8004068:	4b70      	ldr	r3, [pc, #448]	; (800422c <idct9+0x2ce>)
 800406a:	f8d7 1084 	ldr.w	r1, [r7, #132]	; 0x84
 800406e:	4618      	mov	r0, r3
 8004070:	f7ff fa84 	bl	800357c <MULSHIFT32>
 8004074:	6638      	str	r0, [r7, #96]	; 0x60
	m7 =  MULSHIFT32(c9_1, a8);
 8004076:	4b6c      	ldr	r3, [pc, #432]	; (8004228 <idct9+0x2ca>)
 8004078:	6ff9      	ldr	r1, [r7, #124]	; 0x7c
 800407a:	4618      	mov	r0, r3
 800407c:	f7ff fa7e 	bl	800357c <MULSHIFT32>
 8004080:	65f8      	str	r0, [r7, #92]	; 0x5c
	m8 =  MULSHIFT32(c9_2, a5);
 8004082:	4b6a      	ldr	r3, [pc, #424]	; (800422c <idct9+0x2ce>)
 8004084:	f8d7 1088 	ldr.w	r1, [r7, #136]	; 0x88
 8004088:	4618      	mov	r0, r3
 800408a:	f7ff fa77 	bl	800357c <MULSHIFT32>
 800408e:	65b8      	str	r0, [r7, #88]	; 0x58
	m9 =  MULSHIFT32(c9_3, a9);
 8004090:	4b67      	ldr	r3, [pc, #412]	; (8004230 <idct9+0x2d2>)
 8004092:	6fb9      	ldr	r1, [r7, #120]	; 0x78
 8004094:	4618      	mov	r0, r3
 8004096:	f7ff fa71 	bl	800357c <MULSHIFT32>
 800409a:	6578      	str	r0, [r7, #84]	; 0x54
	m10 = MULSHIFT32(c9_4, a7);
 800409c:	4b65      	ldr	r3, [pc, #404]	; (8004234 <idct9+0x2d6>)
 800409e:	f8d7 1080 	ldr.w	r1, [r7, #128]	; 0x80
 80040a2:	4618      	mov	r0, r3
 80040a4:	f7ff fa6a 	bl	800357c <MULSHIFT32>
 80040a8:	6538      	str	r0, [r7, #80]	; 0x50
	m11 = MULSHIFT32(c9_3, a3);
 80040aa:	4b61      	ldr	r3, [pc, #388]	; (8004230 <idct9+0x2d2>)
 80040ac:	f8d7 1090 	ldr.w	r1, [r7, #144]	; 0x90
 80040b0:	4618      	mov	r0, r3
 80040b2:	f7ff fa63 	bl	800357c <MULSHIFT32>
 80040b6:	64f8      	str	r0, [r7, #76]	; 0x4c
	m12 = MULSHIFT32(c9_4, a9);
 80040b8:	4b5e      	ldr	r3, [pc, #376]	; (8004234 <idct9+0x2d6>)
 80040ba:	6fb9      	ldr	r1, [r7, #120]	; 0x78
 80040bc:	4618      	mov	r0, r3
 80040be:	f7ff fa5d 	bl	800357c <MULSHIFT32>
 80040c2:	64b8      	str	r0, [r7, #72]	; 0x48

	a12 = x[0] +  (x[6] >> 1);
 80040c4:	687b      	ldr	r3, [r7, #4]
 80040c6:	681a      	ldr	r2, [r3, #0]
 80040c8:	687b      	ldr	r3, [r7, #4]
 80040ca:	3318      	adds	r3, #24
 80040cc:	681b      	ldr	r3, [r3, #0]
 80040ce:	105b      	asrs	r3, r3, #1
 80040d0:	4413      	add	r3, r2
 80040d2:	647b      	str	r3, [r7, #68]	; 0x44
	a13 = a12  +  (  m1 << 1);
 80040d4:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 80040d6:	005a      	lsls	r2, r3, #1
 80040d8:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 80040da:	4413      	add	r3, r2
 80040dc:	643b      	str	r3, [r7, #64]	; 0x40
	a14 = a12  -  (  m1 << 1);
 80040de:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 80040e0:	005b      	lsls	r3, r3, #1
 80040e2:	6c7a      	ldr	r2, [r7, #68]	; 0x44
 80040e4:	1ad3      	subs	r3, r2, r3
 80040e6:	63fb      	str	r3, [r7, #60]	; 0x3c
	a15 = a1   +  ( a11 >> 1);
 80040e8:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 80040ea:	105a      	asrs	r2, r3, #1
 80040ec:	f8d7 3098 	ldr.w	r3, [r7, #152]	; 0x98
 80040f0:	4413      	add	r3, r2
 80040f2:	63bb      	str	r3, [r7, #56]	; 0x38
	a16 = ( m5 << 1) + (m6 << 1);
 80040f4:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 80040f6:	005a      	lsls	r2, r3, #1
 80040f8:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 80040fa:	005b      	lsls	r3, r3, #1
 80040fc:	4413      	add	r3, r2
 80040fe:	637b      	str	r3, [r7, #52]	; 0x34
	a17 = ( m7 << 1) - (m8 << 1);
 8004100:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 8004102:	005a      	lsls	r2, r3, #1
 8004104:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8004106:	005b      	lsls	r3, r3, #1
 8004108:	1ad3      	subs	r3, r2, r3
 800410a:	633b      	str	r3, [r7, #48]	; 0x30
	a18 = a16 + a17;
 800410c:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 800410e:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8004110:	4413      	add	r3, r2
 8004112:	62fb      	str	r3, [r7, #44]	; 0x2c
	a19 = ( m9 << 1) + (m10 << 1);
 8004114:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8004116:	005a      	lsls	r2, r3, #1
 8004118:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 800411a:	005b      	lsls	r3, r3, #1
 800411c:	4413      	add	r3, r2
 800411e:	62bb      	str	r3, [r7, #40]	; 0x28
	a20 = (m11 << 1) - (m12 << 1);
 8004120:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8004122:	005a      	lsls	r2, r3, #1
 8004124:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8004126:	005b      	lsls	r3, r3, #1
 8004128:	1ad3      	subs	r3, r2, r3
 800412a:	627b      	str	r3, [r7, #36]	; 0x24

	a21 = a20 - a19;
 800412c:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 800412e:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8004130:	1ad3      	subs	r3, r2, r3
 8004132:	623b      	str	r3, [r7, #32]
	a22 = a13 + a16;
 8004134:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 8004136:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8004138:	4413      	add	r3, r2
 800413a:	61fb      	str	r3, [r7, #28]
	a23 = a14 + a16;
 800413c:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 800413e:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8004140:	4413      	add	r3, r2
 8004142:	61bb      	str	r3, [r7, #24]
	a24 = a14 + a17;
 8004144:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 8004146:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8004148:	4413      	add	r3, r2
 800414a:	617b      	str	r3, [r7, #20]
	a25 = a13 + a17;
 800414c:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 800414e:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8004150:	4413      	add	r3, r2
 8004152:	613b      	str	r3, [r7, #16]
	a26 = a14 - a18;
 8004154:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 8004156:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8004158:	1ad3      	subs	r3, r2, r3
 800415a:	60fb      	str	r3, [r7, #12]
	a27 = a13 - a18;
 800415c:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 800415e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8004160:	1ad3      	subs	r3, r2, r3
 8004162:	60bb      	str	r3, [r7, #8]

	x0 = a22 + a19;			x[0] = x0;
 8004164:	69fa      	ldr	r2, [r7, #28]
 8004166:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8004168:	4413      	add	r3, r2
 800416a:	f8c7 30bc 	str.w	r3, [r7, #188]	; 0xbc
 800416e:	687b      	ldr	r3, [r7, #4]
 8004170:	f8d7 20bc 	ldr.w	r2, [r7, #188]	; 0xbc
 8004174:	601a      	str	r2, [r3, #0]
	x1 = a15 + (m3 << 1);	x[1] = x1;
 8004176:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 8004178:	005a      	lsls	r2, r3, #1
 800417a:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800417c:	4413      	add	r3, r2
 800417e:	f8c7 30b8 	str.w	r3, [r7, #184]	; 0xb8
 8004182:	687b      	ldr	r3, [r7, #4]
 8004184:	3304      	adds	r3, #4
 8004186:	f8d7 20b8 	ldr.w	r2, [r7, #184]	; 0xb8
 800418a:	601a      	str	r2, [r3, #0]
	x2 = a24 + a20;			x[2] = x2;
 800418c:	697a      	ldr	r2, [r7, #20]
 800418e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8004190:	4413      	add	r3, r2
 8004192:	f8c7 30b4 	str.w	r3, [r7, #180]	; 0xb4
 8004196:	687b      	ldr	r3, [r7, #4]
 8004198:	3308      	adds	r3, #8
 800419a:	f8d7 20b4 	ldr.w	r2, [r7, #180]	; 0xb4
 800419e:	601a      	str	r2, [r3, #0]
	x3 = a26 - a21;			x[3] = x3;
 80041a0:	68fa      	ldr	r2, [r7, #12]
 80041a2:	6a3b      	ldr	r3, [r7, #32]
 80041a4:	1ad3      	subs	r3, r2, r3
 80041a6:	f8c7 30b0 	str.w	r3, [r7, #176]	; 0xb0
 80041aa:	687b      	ldr	r3, [r7, #4]
 80041ac:	330c      	adds	r3, #12
 80041ae:	f8d7 20b0 	ldr.w	r2, [r7, #176]	; 0xb0
 80041b2:	601a      	str	r2, [r3, #0]
	x4 = a1 - a11;			x[4] = x4;
 80041b4:	f8d7 2098 	ldr.w	r2, [r7, #152]	; 0x98
 80041b8:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 80041ba:	1ad3      	subs	r3, r2, r3
 80041bc:	f8c7 30ac 	str.w	r3, [r7, #172]	; 0xac
 80041c0:	687b      	ldr	r3, [r7, #4]
 80041c2:	3310      	adds	r3, #16
 80041c4:	f8d7 20ac 	ldr.w	r2, [r7, #172]	; 0xac
 80041c8:	601a      	str	r2, [r3, #0]
	x5 = a27 + a21;			x[5] = x5;
 80041ca:	68ba      	ldr	r2, [r7, #8]
 80041cc:	6a3b      	ldr	r3, [r7, #32]
 80041ce:	4413      	add	r3, r2
 80041d0:	f8c7 30a8 	str.w	r3, [r7, #168]	; 0xa8
 80041d4:	687b      	ldr	r3, [r7, #4]
 80041d6:	3314      	adds	r3, #20
 80041d8:	f8d7 20a8 	ldr.w	r2, [r7, #168]	; 0xa8
 80041dc:	601a      	str	r2, [r3, #0]
	x6 = a25 - a20;			x[6] = x6;
 80041de:	693a      	ldr	r2, [r7, #16]
 80041e0:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80041e2:	1ad3      	subs	r3, r2, r3
 80041e4:	f8c7 30a4 	str.w	r3, [r7, #164]	; 0xa4
 80041e8:	687b      	ldr	r3, [r7, #4]
 80041ea:	3318      	adds	r3, #24
 80041ec:	f8d7 20a4 	ldr.w	r2, [r7, #164]	; 0xa4
 80041f0:	601a      	str	r2, [r3, #0]
	x7 = a15 - (m3 << 1);	x[7] = x7;
 80041f2:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 80041f4:	005b      	lsls	r3, r3, #1
 80041f6:	6bba      	ldr	r2, [r7, #56]	; 0x38
 80041f8:	1ad3      	subs	r3, r2, r3
 80041fa:	f8c7 30a0 	str.w	r3, [r7, #160]	; 0xa0
 80041fe:	687b      	ldr	r3, [r7, #4]
 8004200:	331c      	adds	r3, #28
 8004202:	f8d7 20a0 	ldr.w	r2, [r7, #160]	; 0xa0
 8004206:	601a      	str	r2, [r3, #0]
	x8 = a23 - a19;			x[8] = x8;
 8004208:	69ba      	ldr	r2, [r7, #24]
 800420a:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800420c:	1ad3      	subs	r3, r2, r3
 800420e:	f8c7 309c 	str.w	r3, [r7, #156]	; 0x9c
 8004212:	687b      	ldr	r3, [r7, #4]
 8004214:	3320      	adds	r3, #32
 8004216:	f8d7 209c 	ldr.w	r2, [r7, #156]	; 0x9c
 800421a:	601a      	str	r2, [r3, #0]
}
 800421c:	bf00      	nop
 800421e:	37c0      	adds	r7, #192	; 0xc0
 8004220:	46bd      	mov	sp, r7
 8004222:	bd80      	pop	{r7, pc}
 8004224:	6ed9eba1 	.word	0x6ed9eba1
 8004228:	620dbe8b 	.word	0x620dbe8b
 800422c:	163a1a7e 	.word	0x163a1a7e
 8004230:	5246dd49 	.word	0x5246dd49
 8004234:	7e0e2e32 	.word	0x7e0e2e32

08004238 <IMDCT36>:
 *
 * TODO:        optimize for ARM (reorder window coefs, ARM-style pointers in C, 
 *                inline asm may or may not be helpful)
 **************************************************************************************/
static int IMDCT36(int *xCurr, int *xPrev, int *y, int btCurr, int btPrev, int blockIdx, int gb)
{
 8004238:	b590      	push	{r4, r7, lr}
 800423a:	b0b9      	sub	sp, #228	; 0xe4
 800423c:	af00      	add	r7, sp, #0
 800423e:	60f8      	str	r0, [r7, #12]
 8004240:	60b9      	str	r1, [r7, #8]
 8004242:	607a      	str	r2, [r7, #4]
 8004244:	603b      	str	r3, [r7, #0]
	int i, es, xBuf[18], xPrevWin[18];
	int acc1, acc2, s, d, t, mOut;
	int xo, xe, c, *xp, yLo, yHi;
	const int *cp, *wp;

	acc1 = acc2 = 0;
 8004246:	2300      	movs	r3, #0
 8004248:	f8c7 30d0 	str.w	r3, [r7, #208]	; 0xd0
 800424c:	f8d7 30d0 	ldr.w	r3, [r7, #208]	; 0xd0
 8004250:	f8c7 30d4 	str.w	r3, [r7, #212]	; 0xd4
	xCurr += 17;
 8004254:	68fb      	ldr	r3, [r7, #12]
 8004256:	3344      	adds	r3, #68	; 0x44
 8004258:	60fb      	str	r3, [r7, #12]

	/* 7 gb is always adequate for antialias + accumulator loop + idct9 */
	if (gb < 7) {
 800425a:	f8d7 30f8 	ldr.w	r3, [r7, #248]	; 0xf8
 800425e:	2b06      	cmp	r3, #6
 8004260:	dc57      	bgt.n	8004312 <IMDCT36+0xda>
		/* rarely triggered - 5% to 10% of the time on normal clips (with Q25 input) */
		es = 7 - gb;
 8004262:	f8d7 30f8 	ldr.w	r3, [r7, #248]	; 0xf8
 8004266:	f1c3 0307 	rsb	r3, r3, #7
 800426a:	f8c7 30d8 	str.w	r3, [r7, #216]	; 0xd8
		for (i = 8; i >= 0; i--) {	
 800426e:	2308      	movs	r3, #8
 8004270:	f8c7 30dc 	str.w	r3, [r7, #220]	; 0xdc
 8004274:	e048      	b.n	8004308 <IMDCT36+0xd0>
			acc1 = ((*xCurr--) >> es) - acc1;
 8004276:	68fb      	ldr	r3, [r7, #12]
 8004278:	1f1a      	subs	r2, r3, #4
 800427a:	60fa      	str	r2, [r7, #12]
 800427c:	681a      	ldr	r2, [r3, #0]
 800427e:	f8d7 30d8 	ldr.w	r3, [r7, #216]	; 0xd8
 8004282:	411a      	asrs	r2, r3
 8004284:	f8d7 30d4 	ldr.w	r3, [r7, #212]	; 0xd4
 8004288:	1ad3      	subs	r3, r2, r3
 800428a:	f8c7 30d4 	str.w	r3, [r7, #212]	; 0xd4
			acc2 = acc1 - acc2;
 800428e:	f8d7 20d4 	ldr.w	r2, [r7, #212]	; 0xd4
 8004292:	f8d7 30d0 	ldr.w	r3, [r7, #208]	; 0xd0
 8004296:	1ad3      	subs	r3, r2, r3
 8004298:	f8c7 30d0 	str.w	r3, [r7, #208]	; 0xd0
			acc1 = ((*xCurr--) >> es) - acc1;
 800429c:	68fb      	ldr	r3, [r7, #12]
 800429e:	1f1a      	subs	r2, r3, #4
 80042a0:	60fa      	str	r2, [r7, #12]
 80042a2:	681a      	ldr	r2, [r3, #0]
 80042a4:	f8d7 30d8 	ldr.w	r3, [r7, #216]	; 0xd8
 80042a8:	411a      	asrs	r2, r3
 80042aa:	f8d7 30d4 	ldr.w	r3, [r7, #212]	; 0xd4
 80042ae:	1ad3      	subs	r3, r2, r3
 80042b0:	f8c7 30d4 	str.w	r3, [r7, #212]	; 0xd4
			xBuf[i+9] = acc2;	/* odd */
 80042b4:	f8d7 30dc 	ldr.w	r3, [r7, #220]	; 0xdc
 80042b8:	3309      	adds	r3, #9
 80042ba:	009b      	lsls	r3, r3, #2
 80042bc:	f107 02e0 	add.w	r2, r7, #224	; 0xe0
 80042c0:	4413      	add	r3, r2
 80042c2:	f8d7 20d0 	ldr.w	r2, [r7, #208]	; 0xd0
 80042c6:	f843 2c88 	str.w	r2, [r3, #-136]
			xBuf[i+0] = acc1;	/* even */
 80042ca:	f8d7 30dc 	ldr.w	r3, [r7, #220]	; 0xdc
 80042ce:	009b      	lsls	r3, r3, #2
 80042d0:	f107 02e0 	add.w	r2, r7, #224	; 0xe0
 80042d4:	4413      	add	r3, r2
 80042d6:	f8d7 20d4 	ldr.w	r2, [r7, #212]	; 0xd4
 80042da:	f843 2c88 	str.w	r2, [r3, #-136]
			xPrev[i] >>= es;
 80042de:	f8d7 30dc 	ldr.w	r3, [r7, #220]	; 0xdc
 80042e2:	009b      	lsls	r3, r3, #2
 80042e4:	68ba      	ldr	r2, [r7, #8]
 80042e6:	4413      	add	r3, r2
 80042e8:	f8d7 20dc 	ldr.w	r2, [r7, #220]	; 0xdc
 80042ec:	0092      	lsls	r2, r2, #2
 80042ee:	68b9      	ldr	r1, [r7, #8]
 80042f0:	440a      	add	r2, r1
 80042f2:	6811      	ldr	r1, [r2, #0]
 80042f4:	f8d7 20d8 	ldr.w	r2, [r7, #216]	; 0xd8
 80042f8:	fa41 f202 	asr.w	r2, r1, r2
 80042fc:	601a      	str	r2, [r3, #0]
		for (i = 8; i >= 0; i--) {	
 80042fe:	f8d7 30dc 	ldr.w	r3, [r7, #220]	; 0xdc
 8004302:	3b01      	subs	r3, #1
 8004304:	f8c7 30dc 	str.w	r3, [r7, #220]	; 0xdc
 8004308:	f8d7 30dc 	ldr.w	r3, [r7, #220]	; 0xdc
 800430c:	2b00      	cmp	r3, #0
 800430e:	dab2      	bge.n	8004276 <IMDCT36+0x3e>
 8004310:	e03d      	b.n	800438e <IMDCT36+0x156>
		}
	} else {
		es = 0;
 8004312:	2300      	movs	r3, #0
 8004314:	f8c7 30d8 	str.w	r3, [r7, #216]	; 0xd8
		/* max gain = 18, assume adequate guard bits */
		for (i = 8; i >= 0; i--) {	
 8004318:	2308      	movs	r3, #8
 800431a:	f8c7 30dc 	str.w	r3, [r7, #220]	; 0xdc
 800431e:	e032      	b.n	8004386 <IMDCT36+0x14e>
			acc1 = (*xCurr--) - acc1;
 8004320:	68fb      	ldr	r3, [r7, #12]
 8004322:	1f1a      	subs	r2, r3, #4
 8004324:	60fa      	str	r2, [r7, #12]
 8004326:	681a      	ldr	r2, [r3, #0]
 8004328:	f8d7 30d4 	ldr.w	r3, [r7, #212]	; 0xd4
 800432c:	1ad3      	subs	r3, r2, r3
 800432e:	f8c7 30d4 	str.w	r3, [r7, #212]	; 0xd4
			acc2 = acc1 - acc2;
 8004332:	f8d7 20d4 	ldr.w	r2, [r7, #212]	; 0xd4
 8004336:	f8d7 30d0 	ldr.w	r3, [r7, #208]	; 0xd0
 800433a:	1ad3      	subs	r3, r2, r3
 800433c:	f8c7 30d0 	str.w	r3, [r7, #208]	; 0xd0
			acc1 = (*xCurr--) - acc1;
 8004340:	68fb      	ldr	r3, [r7, #12]
 8004342:	1f1a      	subs	r2, r3, #4
 8004344:	60fa      	str	r2, [r7, #12]
 8004346:	681a      	ldr	r2, [r3, #0]
 8004348:	f8d7 30d4 	ldr.w	r3, [r7, #212]	; 0xd4
 800434c:	1ad3      	subs	r3, r2, r3
 800434e:	f8c7 30d4 	str.w	r3, [r7, #212]	; 0xd4
			xBuf[i+9] = acc2;	/* odd */
 8004352:	f8d7 30dc 	ldr.w	r3, [r7, #220]	; 0xdc
 8004356:	3309      	adds	r3, #9
 8004358:	009b      	lsls	r3, r3, #2
 800435a:	f107 02e0 	add.w	r2, r7, #224	; 0xe0
 800435e:	4413      	add	r3, r2
 8004360:	f8d7 20d0 	ldr.w	r2, [r7, #208]	; 0xd0
 8004364:	f843 2c88 	str.w	r2, [r3, #-136]
			xBuf[i+0] = acc1;	/* even */
 8004368:	f8d7 30dc 	ldr.w	r3, [r7, #220]	; 0xdc
 800436c:	009b      	lsls	r3, r3, #2
 800436e:	f107 02e0 	add.w	r2, r7, #224	; 0xe0
 8004372:	4413      	add	r3, r2
 8004374:	f8d7 20d4 	ldr.w	r2, [r7, #212]	; 0xd4
 8004378:	f843 2c88 	str.w	r2, [r3, #-136]
		for (i = 8; i >= 0; i--) {	
 800437c:	f8d7 30dc 	ldr.w	r3, [r7, #220]	; 0xdc
 8004380:	3b01      	subs	r3, #1
 8004382:	f8c7 30dc 	str.w	r3, [r7, #220]	; 0xdc
 8004386:	f8d7 30dc 	ldr.w	r3, [r7, #220]	; 0xdc
 800438a:	2b00      	cmp	r3, #0
 800438c:	dac8      	bge.n	8004320 <IMDCT36+0xe8>
		}
	}
	/* xEven[0] and xOdd[0] scaled by 0.5 */
	xBuf[9] >>= 1;
 800438e:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
 8004390:	105b      	asrs	r3, r3, #1
 8004392:	67fb      	str	r3, [r7, #124]	; 0x7c
	xBuf[0] >>= 1;
 8004394:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8004396:	105b      	asrs	r3, r3, #1
 8004398:	65bb      	str	r3, [r7, #88]	; 0x58

	/* do 9-point IDCT on even and odd */
	idct9(xBuf+0);	/* even */
 800439a:	f107 0358 	add.w	r3, r7, #88	; 0x58
 800439e:	4618      	mov	r0, r3
 80043a0:	f7ff fddd 	bl	8003f5e <idct9>
	idct9(xBuf+9);	/* odd */
 80043a4:	f107 0358 	add.w	r3, r7, #88	; 0x58
 80043a8:	3324      	adds	r3, #36	; 0x24
 80043aa:	4618      	mov	r0, r3
 80043ac:	f7ff fdd7 	bl	8003f5e <idct9>

	xp = xBuf + 8;
 80043b0:	f107 0358 	add.w	r3, r7, #88	; 0x58
 80043b4:	3320      	adds	r3, #32
 80043b6:	f8c7 30c8 	str.w	r3, [r7, #200]	; 0xc8
	cp = c18 + 8;
 80043ba:	4bb8      	ldr	r3, [pc, #736]	; (800469c <IMDCT36+0x464>)
 80043bc:	f8c7 30c4 	str.w	r3, [r7, #196]	; 0xc4
	mOut = 0;
 80043c0:	2300      	movs	r3, #0
 80043c2:	f8c7 30cc 	str.w	r3, [r7, #204]	; 0xcc
	if (btPrev == 0 && btCurr == 0) {
 80043c6:	f8d7 30f0 	ldr.w	r3, [r7, #240]	; 0xf0
 80043ca:	2b00      	cmp	r3, #0
 80043cc:	f040 80a0 	bne.w	8004510 <IMDCT36+0x2d8>
 80043d0:	683b      	ldr	r3, [r7, #0]
 80043d2:	2b00      	cmp	r3, #0
 80043d4:	f040 809c 	bne.w	8004510 <IMDCT36+0x2d8>
		/* fast path - use symmetry of sin window to reduce windowing multiplies to 18 (N/2) */
		wp = fastWin36;
 80043d8:	4bb1      	ldr	r3, [pc, #708]	; (80046a0 <IMDCT36+0x468>)
 80043da:	f8c7 30c0 	str.w	r3, [r7, #192]	; 0xc0
		for (i = 0; i < 9; i++) {
 80043de:	2300      	movs	r3, #0
 80043e0:	f8c7 30dc 	str.w	r3, [r7, #220]	; 0xdc
 80043e4:	e08e      	b.n	8004504 <IMDCT36+0x2cc>
			/* do ARM-style pointer arithmetic (i still needed for y[] indexing - compiler spills if 2 y pointers) */
			c = *cp--;	xo = *(xp + 9);		xe = *xp--;
 80043e6:	f8d7 30c4 	ldr.w	r3, [r7, #196]	; 0xc4
 80043ea:	1f1a      	subs	r2, r3, #4
 80043ec:	f8c7 20c4 	str.w	r2, [r7, #196]	; 0xc4
 80043f0:	681b      	ldr	r3, [r3, #0]
 80043f2:	f8c7 30bc 	str.w	r3, [r7, #188]	; 0xbc
 80043f6:	f8d7 30c8 	ldr.w	r3, [r7, #200]	; 0xc8
 80043fa:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80043fc:	f8c7 30b8 	str.w	r3, [r7, #184]	; 0xb8
 8004400:	f8d7 30c8 	ldr.w	r3, [r7, #200]	; 0xc8
 8004404:	1f1a      	subs	r2, r3, #4
 8004406:	f8c7 20c8 	str.w	r2, [r7, #200]	; 0xc8
 800440a:	681b      	ldr	r3, [r3, #0]
 800440c:	f8c7 30b4 	str.w	r3, [r7, #180]	; 0xb4
			/* gain 2 int bits here */
			xo = MULSHIFT32(c, xo);			/* 2*c18*xOdd (mul by 2 implicit in scaling)  */
 8004410:	f8d7 10b8 	ldr.w	r1, [r7, #184]	; 0xb8
 8004414:	f8d7 00bc 	ldr.w	r0, [r7, #188]	; 0xbc
 8004418:	f7ff f8b0 	bl	800357c <MULSHIFT32>
 800441c:	f8c7 00b8 	str.w	r0, [r7, #184]	; 0xb8
			xe >>= 2;
 8004420:	f8d7 30b4 	ldr.w	r3, [r7, #180]	; 0xb4
 8004424:	109b      	asrs	r3, r3, #2
 8004426:	f8c7 30b4 	str.w	r3, [r7, #180]	; 0xb4

			s = -(*xPrev);		/* sum from last block (always at least 2 guard bits) */
 800442a:	68bb      	ldr	r3, [r7, #8]
 800442c:	681b      	ldr	r3, [r3, #0]
 800442e:	425b      	negs	r3, r3
 8004430:	f8c7 30b0 	str.w	r3, [r7, #176]	; 0xb0
			d = -(xe - xo);		/* gain 2 int bits, don't shift xo (effective << 1 to eat sign bit, << 1 for mul by 2) */
 8004434:	f8d7 20b8 	ldr.w	r2, [r7, #184]	; 0xb8
 8004438:	f8d7 30b4 	ldr.w	r3, [r7, #180]	; 0xb4
 800443c:	1ad3      	subs	r3, r2, r3
 800443e:	f8c7 30ac 	str.w	r3, [r7, #172]	; 0xac
			(*xPrev++) = xe + xo;			/* symmetry - xPrev[i] = xPrev[17-i] for long blocks */
 8004442:	68bb      	ldr	r3, [r7, #8]
 8004444:	1d1a      	adds	r2, r3, #4
 8004446:	60ba      	str	r2, [r7, #8]
 8004448:	f8d7 10b4 	ldr.w	r1, [r7, #180]	; 0xb4
 800444c:	f8d7 20b8 	ldr.w	r2, [r7, #184]	; 0xb8
 8004450:	440a      	add	r2, r1
 8004452:	601a      	str	r2, [r3, #0]
			t = s - d;
 8004454:	f8d7 20b0 	ldr.w	r2, [r7, #176]	; 0xb0
 8004458:	f8d7 30ac 	ldr.w	r3, [r7, #172]	; 0xac
 800445c:	1ad3      	subs	r3, r2, r3
 800445e:	f8c7 30a8 	str.w	r3, [r7, #168]	; 0xa8

			yLo = (d + (MULSHIFT32(t, *wp++) << 2));
 8004462:	f8d7 30c0 	ldr.w	r3, [r7, #192]	; 0xc0
 8004466:	1d1a      	adds	r2, r3, #4
 8004468:	f8c7 20c0 	str.w	r2, [r7, #192]	; 0xc0
 800446c:	681b      	ldr	r3, [r3, #0]
 800446e:	4619      	mov	r1, r3
 8004470:	f8d7 00a8 	ldr.w	r0, [r7, #168]	; 0xa8
 8004474:	f7ff f882 	bl	800357c <MULSHIFT32>
 8004478:	4603      	mov	r3, r0
 800447a:	009a      	lsls	r2, r3, #2
 800447c:	f8d7 30ac 	ldr.w	r3, [r7, #172]	; 0xac
 8004480:	4413      	add	r3, r2
 8004482:	f8c7 30a4 	str.w	r3, [r7, #164]	; 0xa4
			yHi = (s + (MULSHIFT32(t, *wp++) << 2));
 8004486:	f8d7 30c0 	ldr.w	r3, [r7, #192]	; 0xc0
 800448a:	1d1a      	adds	r2, r3, #4
 800448c:	f8c7 20c0 	str.w	r2, [r7, #192]	; 0xc0
 8004490:	681b      	ldr	r3, [r3, #0]
 8004492:	4619      	mov	r1, r3
 8004494:	f8d7 00a8 	ldr.w	r0, [r7, #168]	; 0xa8
 8004498:	f7ff f870 	bl	800357c <MULSHIFT32>
 800449c:	4603      	mov	r3, r0
 800449e:	009a      	lsls	r2, r3, #2
 80044a0:	f8d7 30b0 	ldr.w	r3, [r7, #176]	; 0xb0
 80044a4:	4413      	add	r3, r2
 80044a6:	f8c7 30a0 	str.w	r3, [r7, #160]	; 0xa0
			y[(i)*NBANDS]    = 	yLo;
 80044aa:	f8d7 30dc 	ldr.w	r3, [r7, #220]	; 0xdc
 80044ae:	01db      	lsls	r3, r3, #7
 80044b0:	461a      	mov	r2, r3
 80044b2:	687b      	ldr	r3, [r7, #4]
 80044b4:	4413      	add	r3, r2
 80044b6:	f8d7 20a4 	ldr.w	r2, [r7, #164]	; 0xa4
 80044ba:	601a      	str	r2, [r3, #0]
			y[(17-i)*NBANDS] =  yHi;
 80044bc:	f8d7 30dc 	ldr.w	r3, [r7, #220]	; 0xdc
 80044c0:	f1c3 0311 	rsb	r3, r3, #17
 80044c4:	01db      	lsls	r3, r3, #7
 80044c6:	461a      	mov	r2, r3
 80044c8:	687b      	ldr	r3, [r7, #4]
 80044ca:	4413      	add	r3, r2
 80044cc:	f8d7 20a0 	ldr.w	r2, [r7, #160]	; 0xa0
 80044d0:	601a      	str	r2, [r3, #0]
			mOut |= FASTABS(yLo);
 80044d2:	f8d7 00a4 	ldr.w	r0, [r7, #164]	; 0xa4
 80044d6:	f7ff f863 	bl	80035a0 <FASTABS>
 80044da:	4602      	mov	r2, r0
 80044dc:	f8d7 30cc 	ldr.w	r3, [r7, #204]	; 0xcc
 80044e0:	4313      	orrs	r3, r2
 80044e2:	f8c7 30cc 	str.w	r3, [r7, #204]	; 0xcc
			mOut |= FASTABS(yHi);
 80044e6:	f8d7 00a0 	ldr.w	r0, [r7, #160]	; 0xa0
 80044ea:	f7ff f859 	bl	80035a0 <FASTABS>
 80044ee:	4602      	mov	r2, r0
 80044f0:	f8d7 30cc 	ldr.w	r3, [r7, #204]	; 0xcc
 80044f4:	4313      	orrs	r3, r2
 80044f6:	f8c7 30cc 	str.w	r3, [r7, #204]	; 0xcc
		for (i = 0; i < 9; i++) {
 80044fa:	f8d7 30dc 	ldr.w	r3, [r7, #220]	; 0xdc
 80044fe:	3301      	adds	r3, #1
 8004500:	f8c7 30dc 	str.w	r3, [r7, #220]	; 0xdc
 8004504:	f8d7 30dc 	ldr.w	r3, [r7, #220]	; 0xdc
 8004508:	2b08      	cmp	r3, #8
 800450a:	f77f af6c 	ble.w	80043e6 <IMDCT36+0x1ae>
	if (btPrev == 0 && btCurr == 0) {
 800450e:	e0ae      	b.n	800466e <IMDCT36+0x436>
		}
	} else {
		/* slower method - either prev or curr is using window type != 0 so do full 36-point window 
		 * output xPrevWin has at least 3 guard bits (xPrev has 2, gain 1 in WinPrevious)
		 */
		WinPrevious(xPrev, xPrevWin, btPrev);
 8004510:	f107 0310 	add.w	r3, r7, #16
 8004514:	f8d7 20f0 	ldr.w	r2, [r7, #240]	; 0xf0
 8004518:	4619      	mov	r1, r3
 800451a:	68b8      	ldr	r0, [r7, #8]
 800451c:	f7ff fa14 	bl	8003948 <WinPrevious>

		wp = imdctWin[btCurr];
 8004520:	683a      	ldr	r2, [r7, #0]
 8004522:	4613      	mov	r3, r2
 8004524:	00db      	lsls	r3, r3, #3
 8004526:	4413      	add	r3, r2
 8004528:	011b      	lsls	r3, r3, #4
 800452a:	4a5e      	ldr	r2, [pc, #376]	; (80046a4 <IMDCT36+0x46c>)
 800452c:	4413      	add	r3, r2
 800452e:	f8c7 30c0 	str.w	r3, [r7, #192]	; 0xc0
		for (i = 0; i < 9; i++) {
 8004532:	2300      	movs	r3, #0
 8004534:	f8c7 30dc 	str.w	r3, [r7, #220]	; 0xdc
 8004538:	e094      	b.n	8004664 <IMDCT36+0x42c>
			c = *cp--;	xo = *(xp + 9);		xe = *xp--;
 800453a:	f8d7 30c4 	ldr.w	r3, [r7, #196]	; 0xc4
 800453e:	1f1a      	subs	r2, r3, #4
 8004540:	f8c7 20c4 	str.w	r2, [r7, #196]	; 0xc4
 8004544:	681b      	ldr	r3, [r3, #0]
 8004546:	f8c7 30bc 	str.w	r3, [r7, #188]	; 0xbc
 800454a:	f8d7 30c8 	ldr.w	r3, [r7, #200]	; 0xc8
 800454e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8004550:	f8c7 30b8 	str.w	r3, [r7, #184]	; 0xb8
 8004554:	f8d7 30c8 	ldr.w	r3, [r7, #200]	; 0xc8
 8004558:	1f1a      	subs	r2, r3, #4
 800455a:	f8c7 20c8 	str.w	r2, [r7, #200]	; 0xc8
 800455e:	681b      	ldr	r3, [r3, #0]
 8004560:	f8c7 30b4 	str.w	r3, [r7, #180]	; 0xb4
			/* gain 2 int bits here */
			xo = MULSHIFT32(c, xo);			/* 2*c18*xOdd (mul by 2 implicit in scaling)  */
 8004564:	f8d7 10b8 	ldr.w	r1, [r7, #184]	; 0xb8
 8004568:	f8d7 00bc 	ldr.w	r0, [r7, #188]	; 0xbc
 800456c:	f7ff f806 	bl	800357c <MULSHIFT32>
 8004570:	f8c7 00b8 	str.w	r0, [r7, #184]	; 0xb8
			xe >>= 2;
 8004574:	f8d7 30b4 	ldr.w	r3, [r7, #180]	; 0xb4
 8004578:	109b      	asrs	r3, r3, #2
 800457a:	f8c7 30b4 	str.w	r3, [r7, #180]	; 0xb4

			d = xe - xo;
 800457e:	f8d7 20b4 	ldr.w	r2, [r7, #180]	; 0xb4
 8004582:	f8d7 30b8 	ldr.w	r3, [r7, #184]	; 0xb8
 8004586:	1ad3      	subs	r3, r2, r3
 8004588:	f8c7 30ac 	str.w	r3, [r7, #172]	; 0xac
			(*xPrev++) = xe + xo;	/* symmetry - xPrev[i] = xPrev[17-i] for long blocks */
 800458c:	68bb      	ldr	r3, [r7, #8]
 800458e:	1d1a      	adds	r2, r3, #4
 8004590:	60ba      	str	r2, [r7, #8]
 8004592:	f8d7 10b4 	ldr.w	r1, [r7, #180]	; 0xb4
 8004596:	f8d7 20b8 	ldr.w	r2, [r7, #184]	; 0xb8
 800459a:	440a      	add	r2, r1
 800459c:	601a      	str	r2, [r3, #0]
			
			yLo = (xPrevWin[i]    + MULSHIFT32(d, wp[i])) << 2;
 800459e:	f8d7 30dc 	ldr.w	r3, [r7, #220]	; 0xdc
 80045a2:	009b      	lsls	r3, r3, #2
 80045a4:	f107 02e0 	add.w	r2, r7, #224	; 0xe0
 80045a8:	4413      	add	r3, r2
 80045aa:	f853 4cd0 	ldr.w	r4, [r3, #-208]
 80045ae:	f8d7 30dc 	ldr.w	r3, [r7, #220]	; 0xdc
 80045b2:	009b      	lsls	r3, r3, #2
 80045b4:	f8d7 20c0 	ldr.w	r2, [r7, #192]	; 0xc0
 80045b8:	4413      	add	r3, r2
 80045ba:	681b      	ldr	r3, [r3, #0]
 80045bc:	4619      	mov	r1, r3
 80045be:	f8d7 00ac 	ldr.w	r0, [r7, #172]	; 0xac
 80045c2:	f7fe ffdb 	bl	800357c <MULSHIFT32>
 80045c6:	4603      	mov	r3, r0
 80045c8:	4423      	add	r3, r4
 80045ca:	009b      	lsls	r3, r3, #2
 80045cc:	f8c7 30a4 	str.w	r3, [r7, #164]	; 0xa4
			yHi = (xPrevWin[17-i] + MULSHIFT32(d, wp[17-i])) << 2;
 80045d0:	f8d7 30dc 	ldr.w	r3, [r7, #220]	; 0xdc
 80045d4:	f1c3 0311 	rsb	r3, r3, #17
 80045d8:	009b      	lsls	r3, r3, #2
 80045da:	f107 02e0 	add.w	r2, r7, #224	; 0xe0
 80045de:	4413      	add	r3, r2
 80045e0:	f853 4cd0 	ldr.w	r4, [r3, #-208]
 80045e4:	f8d7 30dc 	ldr.w	r3, [r7, #220]	; 0xdc
 80045e8:	f1c3 0311 	rsb	r3, r3, #17
 80045ec:	009b      	lsls	r3, r3, #2
 80045ee:	f8d7 20c0 	ldr.w	r2, [r7, #192]	; 0xc0
 80045f2:	4413      	add	r3, r2
 80045f4:	681b      	ldr	r3, [r3, #0]
 80045f6:	4619      	mov	r1, r3
 80045f8:	f8d7 00ac 	ldr.w	r0, [r7, #172]	; 0xac
 80045fc:	f7fe ffbe 	bl	800357c <MULSHIFT32>
 8004600:	4603      	mov	r3, r0
 8004602:	4423      	add	r3, r4
 8004604:	009b      	lsls	r3, r3, #2
 8004606:	f8c7 30a0 	str.w	r3, [r7, #160]	; 0xa0
			y[(i)*NBANDS]    = yLo;
 800460a:	f8d7 30dc 	ldr.w	r3, [r7, #220]	; 0xdc
 800460e:	01db      	lsls	r3, r3, #7
 8004610:	461a      	mov	r2, r3
 8004612:	687b      	ldr	r3, [r7, #4]
 8004614:	4413      	add	r3, r2
 8004616:	f8d7 20a4 	ldr.w	r2, [r7, #164]	; 0xa4
 800461a:	601a      	str	r2, [r3, #0]
			y[(17-i)*NBANDS] = yHi;
 800461c:	f8d7 30dc 	ldr.w	r3, [r7, #220]	; 0xdc
 8004620:	f1c3 0311 	rsb	r3, r3, #17
 8004624:	01db      	lsls	r3, r3, #7
 8004626:	461a      	mov	r2, r3
 8004628:	687b      	ldr	r3, [r7, #4]
 800462a:	4413      	add	r3, r2
 800462c:	f8d7 20a0 	ldr.w	r2, [r7, #160]	; 0xa0
 8004630:	601a      	str	r2, [r3, #0]
			mOut |= FASTABS(yLo);
 8004632:	f8d7 00a4 	ldr.w	r0, [r7, #164]	; 0xa4
 8004636:	f7fe ffb3 	bl	80035a0 <FASTABS>
 800463a:	4602      	mov	r2, r0
 800463c:	f8d7 30cc 	ldr.w	r3, [r7, #204]	; 0xcc
 8004640:	4313      	orrs	r3, r2
 8004642:	f8c7 30cc 	str.w	r3, [r7, #204]	; 0xcc
			mOut |= FASTABS(yHi);
 8004646:	f8d7 00a0 	ldr.w	r0, [r7, #160]	; 0xa0
 800464a:	f7fe ffa9 	bl	80035a0 <FASTABS>
 800464e:	4602      	mov	r2, r0
 8004650:	f8d7 30cc 	ldr.w	r3, [r7, #204]	; 0xcc
 8004654:	4313      	orrs	r3, r2
 8004656:	f8c7 30cc 	str.w	r3, [r7, #204]	; 0xcc
		for (i = 0; i < 9; i++) {
 800465a:	f8d7 30dc 	ldr.w	r3, [r7, #220]	; 0xdc
 800465e:	3301      	adds	r3, #1
 8004660:	f8c7 30dc 	str.w	r3, [r7, #220]	; 0xdc
 8004664:	f8d7 30dc 	ldr.w	r3, [r7, #220]	; 0xdc
 8004668:	2b08      	cmp	r3, #8
 800466a:	f77f af66 	ble.w	800453a <IMDCT36+0x302>
		}
	}

	xPrev -= 9;
 800466e:	68bb      	ldr	r3, [r7, #8]
 8004670:	3b24      	subs	r3, #36	; 0x24
 8004672:	60bb      	str	r3, [r7, #8]
	mOut |= FreqInvertRescale(y, xPrev, blockIdx, es);
 8004674:	f8d7 30d8 	ldr.w	r3, [r7, #216]	; 0xd8
 8004678:	f8d7 20f4 	ldr.w	r2, [r7, #244]	; 0xf4
 800467c:	68b9      	ldr	r1, [r7, #8]
 800467e:	6878      	ldr	r0, [r7, #4]
 8004680:	f7ff fac8 	bl	8003c14 <FreqInvertRescale>
 8004684:	4602      	mov	r2, r0
 8004686:	f8d7 30cc 	ldr.w	r3, [r7, #204]	; 0xcc
 800468a:	4313      	orrs	r3, r2
 800468c:	f8c7 30cc 	str.w	r3, [r7, #204]	; 0xcc

	return mOut;
 8004690:	f8d7 30cc 	ldr.w	r3, [r7, #204]	; 0xcc
}
 8004694:	4618      	mov	r0, r3
 8004696:	37e4      	adds	r7, #228	; 0xe4
 8004698:	46bd      	mov	sp, r7
 800469a:	bd90      	pop	{r4, r7, pc}
 800469c:	0801a198 	.word	0x0801a198
 80046a0:	0801a19c 	.word	0x0801a19c
 80046a4:	0801a25c 	.word	0x0801a25c

080046a8 <imdct12>:

/* 12-point inverse DCT, used in IMDCT12x3() 
 * 4 input guard bits will ensure no overflow
 */
static __inline void imdct12 (int *x, int *out)
{
 80046a8:	b580      	push	{r7, lr}
 80046aa:	b08c      	sub	sp, #48	; 0x30
 80046ac:	af00      	add	r7, sp, #0
 80046ae:	6078      	str	r0, [r7, #4]
 80046b0:	6039      	str	r1, [r7, #0]
	int a0, a1, a2;
	int x0, x1, x2, x3, x4, x5;

	x0 = *x;	x+=3;	x1 = *x;	x+=3;
 80046b2:	687b      	ldr	r3, [r7, #4]
 80046b4:	681b      	ldr	r3, [r3, #0]
 80046b6:	62fb      	str	r3, [r7, #44]	; 0x2c
 80046b8:	687b      	ldr	r3, [r7, #4]
 80046ba:	330c      	adds	r3, #12
 80046bc:	607b      	str	r3, [r7, #4]
 80046be:	687b      	ldr	r3, [r7, #4]
 80046c0:	681b      	ldr	r3, [r3, #0]
 80046c2:	62bb      	str	r3, [r7, #40]	; 0x28
 80046c4:	687b      	ldr	r3, [r7, #4]
 80046c6:	330c      	adds	r3, #12
 80046c8:	607b      	str	r3, [r7, #4]
	x2 = *x;	x+=3;	x3 = *x;	x+=3;
 80046ca:	687b      	ldr	r3, [r7, #4]
 80046cc:	681b      	ldr	r3, [r3, #0]
 80046ce:	627b      	str	r3, [r7, #36]	; 0x24
 80046d0:	687b      	ldr	r3, [r7, #4]
 80046d2:	330c      	adds	r3, #12
 80046d4:	607b      	str	r3, [r7, #4]
 80046d6:	687b      	ldr	r3, [r7, #4]
 80046d8:	681b      	ldr	r3, [r3, #0]
 80046da:	623b      	str	r3, [r7, #32]
 80046dc:	687b      	ldr	r3, [r7, #4]
 80046de:	330c      	adds	r3, #12
 80046e0:	607b      	str	r3, [r7, #4]
	x4 = *x;	x+=3;	x5 = *x;	x+=3;
 80046e2:	687b      	ldr	r3, [r7, #4]
 80046e4:	681b      	ldr	r3, [r3, #0]
 80046e6:	61fb      	str	r3, [r7, #28]
 80046e8:	687b      	ldr	r3, [r7, #4]
 80046ea:	330c      	adds	r3, #12
 80046ec:	607b      	str	r3, [r7, #4]
 80046ee:	687b      	ldr	r3, [r7, #4]
 80046f0:	681b      	ldr	r3, [r3, #0]
 80046f2:	61bb      	str	r3, [r7, #24]
 80046f4:	687b      	ldr	r3, [r7, #4]
 80046f6:	330c      	adds	r3, #12
 80046f8:	607b      	str	r3, [r7, #4]

	x4 -= x5;
 80046fa:	69fa      	ldr	r2, [r7, #28]
 80046fc:	69bb      	ldr	r3, [r7, #24]
 80046fe:	1ad3      	subs	r3, r2, r3
 8004700:	61fb      	str	r3, [r7, #28]
	x3 -= x4;
 8004702:	6a3a      	ldr	r2, [r7, #32]
 8004704:	69fb      	ldr	r3, [r7, #28]
 8004706:	1ad3      	subs	r3, r2, r3
 8004708:	623b      	str	r3, [r7, #32]
	x2 -= x3;
 800470a:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 800470c:	6a3b      	ldr	r3, [r7, #32]
 800470e:	1ad3      	subs	r3, r2, r3
 8004710:	627b      	str	r3, [r7, #36]	; 0x24
	x3 -= x5;
 8004712:	6a3a      	ldr	r2, [r7, #32]
 8004714:	69bb      	ldr	r3, [r7, #24]
 8004716:	1ad3      	subs	r3, r2, r3
 8004718:	623b      	str	r3, [r7, #32]
	x1 -= x2;
 800471a:	6aba      	ldr	r2, [r7, #40]	; 0x28
 800471c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800471e:	1ad3      	subs	r3, r2, r3
 8004720:	62bb      	str	r3, [r7, #40]	; 0x28
	x0 -= x1;
 8004722:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8004724:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8004726:	1ad3      	subs	r3, r2, r3
 8004728:	62fb      	str	r3, [r7, #44]	; 0x2c
	x1 -= x3;
 800472a:	6aba      	ldr	r2, [r7, #40]	; 0x28
 800472c:	6a3b      	ldr	r3, [r7, #32]
 800472e:	1ad3      	subs	r3, r2, r3
 8004730:	62bb      	str	r3, [r7, #40]	; 0x28

	x0 >>= 1;
 8004732:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8004734:	105b      	asrs	r3, r3, #1
 8004736:	62fb      	str	r3, [r7, #44]	; 0x2c
	x1 >>= 1;
 8004738:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800473a:	105b      	asrs	r3, r3, #1
 800473c:	62bb      	str	r3, [r7, #40]	; 0x28

	a0 = MULSHIFT32(c3_0, x2) << 1;
 800473e:	4b3c      	ldr	r3, [pc, #240]	; (8004830 <imdct12+0x188>)
 8004740:	6a79      	ldr	r1, [r7, #36]	; 0x24
 8004742:	4618      	mov	r0, r3
 8004744:	f7fe ff1a 	bl	800357c <MULSHIFT32>
 8004748:	4603      	mov	r3, r0
 800474a:	005b      	lsls	r3, r3, #1
 800474c:	617b      	str	r3, [r7, #20]
	a1 = x0 + (x4 >> 1);
 800474e:	69fb      	ldr	r3, [r7, #28]
 8004750:	105a      	asrs	r2, r3, #1
 8004752:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8004754:	4413      	add	r3, r2
 8004756:	613b      	str	r3, [r7, #16]
	a2 = x0 - x4;
 8004758:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 800475a:	69fb      	ldr	r3, [r7, #28]
 800475c:	1ad3      	subs	r3, r2, r3
 800475e:	60fb      	str	r3, [r7, #12]
	x0 = a1 + a0;
 8004760:	693a      	ldr	r2, [r7, #16]
 8004762:	697b      	ldr	r3, [r7, #20]
 8004764:	4413      	add	r3, r2
 8004766:	62fb      	str	r3, [r7, #44]	; 0x2c
	x2 = a2;
 8004768:	68fb      	ldr	r3, [r7, #12]
 800476a:	627b      	str	r3, [r7, #36]	; 0x24
	x4 = a1 - a0;
 800476c:	693a      	ldr	r2, [r7, #16]
 800476e:	697b      	ldr	r3, [r7, #20]
 8004770:	1ad3      	subs	r3, r2, r3
 8004772:	61fb      	str	r3, [r7, #28]

	a0 = MULSHIFT32(c3_0, x3) << 1;
 8004774:	4b2e      	ldr	r3, [pc, #184]	; (8004830 <imdct12+0x188>)
 8004776:	6a39      	ldr	r1, [r7, #32]
 8004778:	4618      	mov	r0, r3
 800477a:	f7fe feff 	bl	800357c <MULSHIFT32>
 800477e:	4603      	mov	r3, r0
 8004780:	005b      	lsls	r3, r3, #1
 8004782:	617b      	str	r3, [r7, #20]
	a1 = x1 + (x5 >> 1);
 8004784:	69bb      	ldr	r3, [r7, #24]
 8004786:	105a      	asrs	r2, r3, #1
 8004788:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800478a:	4413      	add	r3, r2
 800478c:	613b      	str	r3, [r7, #16]
	a2 = x1 - x5;
 800478e:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8004790:	69bb      	ldr	r3, [r7, #24]
 8004792:	1ad3      	subs	r3, r2, r3
 8004794:	60fb      	str	r3, [r7, #12]

	/* cos window odd samples, mul by 2, eat sign bit */
	x1 = MULSHIFT32(c6[0], a1 + a0) << 2;			
 8004796:	4827      	ldr	r0, [pc, #156]	; (8004834 <imdct12+0x18c>)
 8004798:	693a      	ldr	r2, [r7, #16]
 800479a:	697b      	ldr	r3, [r7, #20]
 800479c:	4413      	add	r3, r2
 800479e:	4619      	mov	r1, r3
 80047a0:	f7fe feec 	bl	800357c <MULSHIFT32>
 80047a4:	4603      	mov	r3, r0
 80047a6:	009b      	lsls	r3, r3, #2
 80047a8:	62bb      	str	r3, [r7, #40]	; 0x28
	x3 = MULSHIFT32(c6[1], a2) << 2;
 80047aa:	4b23      	ldr	r3, [pc, #140]	; (8004838 <imdct12+0x190>)
 80047ac:	68f9      	ldr	r1, [r7, #12]
 80047ae:	4618      	mov	r0, r3
 80047b0:	f7fe fee4 	bl	800357c <MULSHIFT32>
 80047b4:	4603      	mov	r3, r0
 80047b6:	009b      	lsls	r3, r3, #2
 80047b8:	623b      	str	r3, [r7, #32]
	x5 = MULSHIFT32(c6[2], a1 - a0) << 2;
 80047ba:	4820      	ldr	r0, [pc, #128]	; (800483c <imdct12+0x194>)
 80047bc:	693a      	ldr	r2, [r7, #16]
 80047be:	697b      	ldr	r3, [r7, #20]
 80047c0:	1ad3      	subs	r3, r2, r3
 80047c2:	4619      	mov	r1, r3
 80047c4:	f7fe feda 	bl	800357c <MULSHIFT32>
 80047c8:	4603      	mov	r3, r0
 80047ca:	009b      	lsls	r3, r3, #2
 80047cc:	61bb      	str	r3, [r7, #24]

	*out = x0 + x1;	out++;
 80047ce:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 80047d0:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80047d2:	441a      	add	r2, r3
 80047d4:	683b      	ldr	r3, [r7, #0]
 80047d6:	601a      	str	r2, [r3, #0]
 80047d8:	683b      	ldr	r3, [r7, #0]
 80047da:	3304      	adds	r3, #4
 80047dc:	603b      	str	r3, [r7, #0]
	*out = x2 + x3;	out++;
 80047de:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 80047e0:	6a3b      	ldr	r3, [r7, #32]
 80047e2:	441a      	add	r2, r3
 80047e4:	683b      	ldr	r3, [r7, #0]
 80047e6:	601a      	str	r2, [r3, #0]
 80047e8:	683b      	ldr	r3, [r7, #0]
 80047ea:	3304      	adds	r3, #4
 80047ec:	603b      	str	r3, [r7, #0]
	*out = x4 + x5;	out++;
 80047ee:	69fa      	ldr	r2, [r7, #28]
 80047f0:	69bb      	ldr	r3, [r7, #24]
 80047f2:	441a      	add	r2, r3
 80047f4:	683b      	ldr	r3, [r7, #0]
 80047f6:	601a      	str	r2, [r3, #0]
 80047f8:	683b      	ldr	r3, [r7, #0]
 80047fa:	3304      	adds	r3, #4
 80047fc:	603b      	str	r3, [r7, #0]
	*out = x4 - x5;	out++;
 80047fe:	69fa      	ldr	r2, [r7, #28]
 8004800:	69bb      	ldr	r3, [r7, #24]
 8004802:	1ad2      	subs	r2, r2, r3
 8004804:	683b      	ldr	r3, [r7, #0]
 8004806:	601a      	str	r2, [r3, #0]
 8004808:	683b      	ldr	r3, [r7, #0]
 800480a:	3304      	adds	r3, #4
 800480c:	603b      	str	r3, [r7, #0]
	*out = x2 - x3;	out++;
 800480e:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8004810:	6a3b      	ldr	r3, [r7, #32]
 8004812:	1ad2      	subs	r2, r2, r3
 8004814:	683b      	ldr	r3, [r7, #0]
 8004816:	601a      	str	r2, [r3, #0]
 8004818:	683b      	ldr	r3, [r7, #0]
 800481a:	3304      	adds	r3, #4
 800481c:	603b      	str	r3, [r7, #0]
	*out = x0 - x1;
 800481e:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8004820:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8004822:	1ad2      	subs	r2, r2, r3
 8004824:	683b      	ldr	r3, [r7, #0]
 8004826:	601a      	str	r2, [r3, #0]
}
 8004828:	bf00      	nop
 800482a:	3730      	adds	r7, #48	; 0x30
 800482c:	46bd      	mov	sp, r7
 800482e:	bd80      	pop	{r7, pc}
 8004830:	6ed9eba1 	.word	0x6ed9eba1
 8004834:	7ba3751d 	.word	0x7ba3751d
 8004838:	5a82799a 	.word	0x5a82799a
 800483c:	2120fb83 	.word	0x2120fb83

08004840 <IMDCT12x3>:
 * Return:      mOut (OR of abs(y) for all y calculated here)
 *
 * TODO:        optimize for ARM
 **************************************************************************************/
static int IMDCT12x3(int *xCurr, int *xPrev, int *y, int btPrev, int blockIdx, int gb)
{
 8004840:	b5b0      	push	{r4, r5, r7, lr}
 8004842:	b0ae      	sub	sp, #184	; 0xb8
 8004844:	af00      	add	r7, sp, #0
 8004846:	60f8      	str	r0, [r7, #12]
 8004848:	60b9      	str	r1, [r7, #8]
 800484a:	607a      	str	r2, [r7, #4]
 800484c:	603b      	str	r3, [r7, #0]
	int i, es, mOut, yLo, xBuf[18], xPrevWin[18];	/* need temp buffer for reordering short blocks */
	const int *wp;

	es = 0;
 800484e:	2300      	movs	r3, #0
 8004850:	f8c7 30b0 	str.w	r3, [r7, #176]	; 0xb0
	/* 7 gb is always adequate for accumulator loop + idct12 + window + overlap */
	if (gb < 7) {
 8004854:	f8d7 30cc 	ldr.w	r3, [r7, #204]	; 0xcc
 8004858:	2b06      	cmp	r3, #6
 800485a:	dc40      	bgt.n	80048de <IMDCT12x3+0x9e>
		es = 7 - gb;
 800485c:	f8d7 30cc 	ldr.w	r3, [r7, #204]	; 0xcc
 8004860:	f1c3 0307 	rsb	r3, r3, #7
 8004864:	f8c7 30b0 	str.w	r3, [r7, #176]	; 0xb0
		for (i = 0; i < 18; i+=2) {
 8004868:	2300      	movs	r3, #0
 800486a:	f8c7 30b4 	str.w	r3, [r7, #180]	; 0xb4
 800486e:	e02f      	b.n	80048d0 <IMDCT12x3+0x90>
			xCurr[i+0] >>= es;
 8004870:	f8d7 30b4 	ldr.w	r3, [r7, #180]	; 0xb4
 8004874:	009b      	lsls	r3, r3, #2
 8004876:	68fa      	ldr	r2, [r7, #12]
 8004878:	4413      	add	r3, r2
 800487a:	f8d7 20b4 	ldr.w	r2, [r7, #180]	; 0xb4
 800487e:	0092      	lsls	r2, r2, #2
 8004880:	68f9      	ldr	r1, [r7, #12]
 8004882:	440a      	add	r2, r1
 8004884:	6811      	ldr	r1, [r2, #0]
 8004886:	f8d7 20b0 	ldr.w	r2, [r7, #176]	; 0xb0
 800488a:	fa41 f202 	asr.w	r2, r1, r2
 800488e:	601a      	str	r2, [r3, #0]
			xCurr[i+1] >>= es;
 8004890:	f8d7 30b4 	ldr.w	r3, [r7, #180]	; 0xb4
 8004894:	3301      	adds	r3, #1
 8004896:	009b      	lsls	r3, r3, #2
 8004898:	68fa      	ldr	r2, [r7, #12]
 800489a:	4413      	add	r3, r2
 800489c:	f8d7 20b4 	ldr.w	r2, [r7, #180]	; 0xb4
 80048a0:	3201      	adds	r2, #1
 80048a2:	0092      	lsls	r2, r2, #2
 80048a4:	68f9      	ldr	r1, [r7, #12]
 80048a6:	440a      	add	r2, r1
 80048a8:	6811      	ldr	r1, [r2, #0]
 80048aa:	f8d7 20b0 	ldr.w	r2, [r7, #176]	; 0xb0
 80048ae:	fa41 f202 	asr.w	r2, r1, r2
 80048b2:	601a      	str	r2, [r3, #0]
			*xPrev++ >>= es;
 80048b4:	68bb      	ldr	r3, [r7, #8]
 80048b6:	1d1a      	adds	r2, r3, #4
 80048b8:	60ba      	str	r2, [r7, #8]
 80048ba:	6819      	ldr	r1, [r3, #0]
 80048bc:	f8d7 20b0 	ldr.w	r2, [r7, #176]	; 0xb0
 80048c0:	fa41 f202 	asr.w	r2, r1, r2
 80048c4:	601a      	str	r2, [r3, #0]
		for (i = 0; i < 18; i+=2) {
 80048c6:	f8d7 30b4 	ldr.w	r3, [r7, #180]	; 0xb4
 80048ca:	3302      	adds	r3, #2
 80048cc:	f8c7 30b4 	str.w	r3, [r7, #180]	; 0xb4
 80048d0:	f8d7 30b4 	ldr.w	r3, [r7, #180]	; 0xb4
 80048d4:	2b11      	cmp	r3, #17
 80048d6:	ddcb      	ble.n	8004870 <IMDCT12x3+0x30>
		}
		xPrev -= 9;
 80048d8:	68bb      	ldr	r3, [r7, #8]
 80048da:	3b24      	subs	r3, #36	; 0x24
 80048dc:	60bb      	str	r3, [r7, #8]
	}

	/* requires 4 input guard bits for each imdct12 */
	imdct12(xCurr + 0, xBuf + 0);
 80048de:	f107 035c 	add.w	r3, r7, #92	; 0x5c
 80048e2:	4619      	mov	r1, r3
 80048e4:	68f8      	ldr	r0, [r7, #12]
 80048e6:	f7ff fedf 	bl	80046a8 <imdct12>
	imdct12(xCurr + 1, xBuf + 6);
 80048ea:	68fb      	ldr	r3, [r7, #12]
 80048ec:	1d1a      	adds	r2, r3, #4
 80048ee:	f107 035c 	add.w	r3, r7, #92	; 0x5c
 80048f2:	3318      	adds	r3, #24
 80048f4:	4619      	mov	r1, r3
 80048f6:	4610      	mov	r0, r2
 80048f8:	f7ff fed6 	bl	80046a8 <imdct12>
	imdct12(xCurr + 2, xBuf + 12);
 80048fc:	68fb      	ldr	r3, [r7, #12]
 80048fe:	f103 0208 	add.w	r2, r3, #8
 8004902:	f107 035c 	add.w	r3, r7, #92	; 0x5c
 8004906:	3330      	adds	r3, #48	; 0x30
 8004908:	4619      	mov	r1, r3
 800490a:	4610      	mov	r0, r2
 800490c:	f7ff fecc 	bl	80046a8 <imdct12>

	/* window previous from last time */
	WinPrevious(xPrev, xPrevWin, btPrev);
 8004910:	f107 0314 	add.w	r3, r7, #20
 8004914:	683a      	ldr	r2, [r7, #0]
 8004916:	4619      	mov	r1, r3
 8004918:	68b8      	ldr	r0, [r7, #8]
 800491a:	f7ff f815 	bl	8003948 <WinPrevious>

	/* could unroll this for speed, minimum loads (short blocks usually rare, so doesn't make much overall difference) 
	 * xPrevWin[i] << 2 still has 1 gb always, max gain of windowed xBuf stuff also < 1.0 and gain the sign bit
	 * so y calculations won't overflow
	 */
	wp = imdctWin[2];
 800491e:	4bd3      	ldr	r3, [pc, #844]	; (8004c6c <IMDCT12x3+0x42c>)
 8004920:	f8c7 30a8 	str.w	r3, [r7, #168]	; 0xa8
	mOut = 0;
 8004924:	2300      	movs	r3, #0
 8004926:	f8c7 30ac 	str.w	r3, [r7, #172]	; 0xac
	for (i = 0; i < 3; i++) {
 800492a:	2300      	movs	r3, #0
 800492c:	f8c7 30b4 	str.w	r3, [r7, #180]	; 0xb4
 8004930:	e14c      	b.n	8004bcc <IMDCT12x3+0x38c>
		yLo = (xPrevWin[ 0+i] << 2);
 8004932:	f8d7 30b4 	ldr.w	r3, [r7, #180]	; 0xb4
 8004936:	009b      	lsls	r3, r3, #2
 8004938:	f107 02b8 	add.w	r2, r7, #184	; 0xb8
 800493c:	4413      	add	r3, r2
 800493e:	f853 3ca4 	ldr.w	r3, [r3, #-164]
 8004942:	009b      	lsls	r3, r3, #2
 8004944:	f8c7 30a4 	str.w	r3, [r7, #164]	; 0xa4
		mOut |= FASTABS(yLo);	y[( 0+i)*NBANDS] = yLo;
 8004948:	f8d7 00a4 	ldr.w	r0, [r7, #164]	; 0xa4
 800494c:	f7fe fe28 	bl	80035a0 <FASTABS>
 8004950:	4602      	mov	r2, r0
 8004952:	f8d7 30ac 	ldr.w	r3, [r7, #172]	; 0xac
 8004956:	4313      	orrs	r3, r2
 8004958:	f8c7 30ac 	str.w	r3, [r7, #172]	; 0xac
 800495c:	f8d7 30b4 	ldr.w	r3, [r7, #180]	; 0xb4
 8004960:	01db      	lsls	r3, r3, #7
 8004962:	461a      	mov	r2, r3
 8004964:	687b      	ldr	r3, [r7, #4]
 8004966:	4413      	add	r3, r2
 8004968:	f8d7 20a4 	ldr.w	r2, [r7, #164]	; 0xa4
 800496c:	601a      	str	r2, [r3, #0]
		yLo = (xPrevWin[ 3+i] << 2);
 800496e:	f8d7 30b4 	ldr.w	r3, [r7, #180]	; 0xb4
 8004972:	3303      	adds	r3, #3
 8004974:	009b      	lsls	r3, r3, #2
 8004976:	f107 02b8 	add.w	r2, r7, #184	; 0xb8
 800497a:	4413      	add	r3, r2
 800497c:	f853 3ca4 	ldr.w	r3, [r3, #-164]
 8004980:	009b      	lsls	r3, r3, #2
 8004982:	f8c7 30a4 	str.w	r3, [r7, #164]	; 0xa4
		mOut |= FASTABS(yLo);	y[( 3+i)*NBANDS] = yLo;
 8004986:	f8d7 00a4 	ldr.w	r0, [r7, #164]	; 0xa4
 800498a:	f7fe fe09 	bl	80035a0 <FASTABS>
 800498e:	4602      	mov	r2, r0
 8004990:	f8d7 30ac 	ldr.w	r3, [r7, #172]	; 0xac
 8004994:	4313      	orrs	r3, r2
 8004996:	f8c7 30ac 	str.w	r3, [r7, #172]	; 0xac
 800499a:	f8d7 30b4 	ldr.w	r3, [r7, #180]	; 0xb4
 800499e:	3303      	adds	r3, #3
 80049a0:	01db      	lsls	r3, r3, #7
 80049a2:	461a      	mov	r2, r3
 80049a4:	687b      	ldr	r3, [r7, #4]
 80049a6:	4413      	add	r3, r2
 80049a8:	f8d7 20a4 	ldr.w	r2, [r7, #164]	; 0xa4
 80049ac:	601a      	str	r2, [r3, #0]
		yLo = (xPrevWin[ 6+i] << 2) + (MULSHIFT32(wp[0+i], xBuf[3+i]));	
 80049ae:	f8d7 30b4 	ldr.w	r3, [r7, #180]	; 0xb4
 80049b2:	3306      	adds	r3, #6
 80049b4:	009b      	lsls	r3, r3, #2
 80049b6:	f107 02b8 	add.w	r2, r7, #184	; 0xb8
 80049ba:	4413      	add	r3, r2
 80049bc:	f853 3ca4 	ldr.w	r3, [r3, #-164]
 80049c0:	009c      	lsls	r4, r3, #2
 80049c2:	f8d7 30b4 	ldr.w	r3, [r7, #180]	; 0xb4
 80049c6:	009b      	lsls	r3, r3, #2
 80049c8:	f8d7 20a8 	ldr.w	r2, [r7, #168]	; 0xa8
 80049cc:	4413      	add	r3, r2
 80049ce:	681a      	ldr	r2, [r3, #0]
 80049d0:	f8d7 30b4 	ldr.w	r3, [r7, #180]	; 0xb4
 80049d4:	3303      	adds	r3, #3
 80049d6:	009b      	lsls	r3, r3, #2
 80049d8:	f107 01b8 	add.w	r1, r7, #184	; 0xb8
 80049dc:	440b      	add	r3, r1
 80049de:	f853 3c5c 	ldr.w	r3, [r3, #-92]
 80049e2:	4619      	mov	r1, r3
 80049e4:	4610      	mov	r0, r2
 80049e6:	f7fe fdc9 	bl	800357c <MULSHIFT32>
 80049ea:	4603      	mov	r3, r0
 80049ec:	4423      	add	r3, r4
 80049ee:	f8c7 30a4 	str.w	r3, [r7, #164]	; 0xa4
		mOut |= FASTABS(yLo);	y[( 6+i)*NBANDS] = yLo;
 80049f2:	f8d7 00a4 	ldr.w	r0, [r7, #164]	; 0xa4
 80049f6:	f7fe fdd3 	bl	80035a0 <FASTABS>
 80049fa:	4602      	mov	r2, r0
 80049fc:	f8d7 30ac 	ldr.w	r3, [r7, #172]	; 0xac
 8004a00:	4313      	orrs	r3, r2
 8004a02:	f8c7 30ac 	str.w	r3, [r7, #172]	; 0xac
 8004a06:	f8d7 30b4 	ldr.w	r3, [r7, #180]	; 0xb4
 8004a0a:	3306      	adds	r3, #6
 8004a0c:	01db      	lsls	r3, r3, #7
 8004a0e:	461a      	mov	r2, r3
 8004a10:	687b      	ldr	r3, [r7, #4]
 8004a12:	4413      	add	r3, r2
 8004a14:	f8d7 20a4 	ldr.w	r2, [r7, #164]	; 0xa4
 8004a18:	601a      	str	r2, [r3, #0]
		yLo = (xPrevWin[ 9+i] << 2) + (MULSHIFT32(wp[3+i], xBuf[5-i]));	
 8004a1a:	f8d7 30b4 	ldr.w	r3, [r7, #180]	; 0xb4
 8004a1e:	3309      	adds	r3, #9
 8004a20:	009b      	lsls	r3, r3, #2
 8004a22:	f107 02b8 	add.w	r2, r7, #184	; 0xb8
 8004a26:	4413      	add	r3, r2
 8004a28:	f853 3ca4 	ldr.w	r3, [r3, #-164]
 8004a2c:	009c      	lsls	r4, r3, #2
 8004a2e:	f8d7 30b4 	ldr.w	r3, [r7, #180]	; 0xb4
 8004a32:	3303      	adds	r3, #3
 8004a34:	009b      	lsls	r3, r3, #2
 8004a36:	f8d7 20a8 	ldr.w	r2, [r7, #168]	; 0xa8
 8004a3a:	4413      	add	r3, r2
 8004a3c:	681a      	ldr	r2, [r3, #0]
 8004a3e:	f8d7 30b4 	ldr.w	r3, [r7, #180]	; 0xb4
 8004a42:	f1c3 0305 	rsb	r3, r3, #5
 8004a46:	009b      	lsls	r3, r3, #2
 8004a48:	f107 01b8 	add.w	r1, r7, #184	; 0xb8
 8004a4c:	440b      	add	r3, r1
 8004a4e:	f853 3c5c 	ldr.w	r3, [r3, #-92]
 8004a52:	4619      	mov	r1, r3
 8004a54:	4610      	mov	r0, r2
 8004a56:	f7fe fd91 	bl	800357c <MULSHIFT32>
 8004a5a:	4603      	mov	r3, r0
 8004a5c:	4423      	add	r3, r4
 8004a5e:	f8c7 30a4 	str.w	r3, [r7, #164]	; 0xa4
		mOut |= FASTABS(yLo);	y[( 9+i)*NBANDS] = yLo;
 8004a62:	f8d7 00a4 	ldr.w	r0, [r7, #164]	; 0xa4
 8004a66:	f7fe fd9b 	bl	80035a0 <FASTABS>
 8004a6a:	4602      	mov	r2, r0
 8004a6c:	f8d7 30ac 	ldr.w	r3, [r7, #172]	; 0xac
 8004a70:	4313      	orrs	r3, r2
 8004a72:	f8c7 30ac 	str.w	r3, [r7, #172]	; 0xac
 8004a76:	f8d7 30b4 	ldr.w	r3, [r7, #180]	; 0xb4
 8004a7a:	3309      	adds	r3, #9
 8004a7c:	01db      	lsls	r3, r3, #7
 8004a7e:	461a      	mov	r2, r3
 8004a80:	687b      	ldr	r3, [r7, #4]
 8004a82:	4413      	add	r3, r2
 8004a84:	f8d7 20a4 	ldr.w	r2, [r7, #164]	; 0xa4
 8004a88:	601a      	str	r2, [r3, #0]
		yLo = (xPrevWin[12+i] << 2) + (MULSHIFT32(wp[6+i], xBuf[2-i]) + MULSHIFT32(wp[0+i], xBuf[(6+3)+i]));	
 8004a8a:	f8d7 30b4 	ldr.w	r3, [r7, #180]	; 0xb4
 8004a8e:	330c      	adds	r3, #12
 8004a90:	009b      	lsls	r3, r3, #2
 8004a92:	f107 02b8 	add.w	r2, r7, #184	; 0xb8
 8004a96:	4413      	add	r3, r2
 8004a98:	f853 3ca4 	ldr.w	r3, [r3, #-164]
 8004a9c:	009c      	lsls	r4, r3, #2
 8004a9e:	f8d7 30b4 	ldr.w	r3, [r7, #180]	; 0xb4
 8004aa2:	3306      	adds	r3, #6
 8004aa4:	009b      	lsls	r3, r3, #2
 8004aa6:	f8d7 20a8 	ldr.w	r2, [r7, #168]	; 0xa8
 8004aaa:	4413      	add	r3, r2
 8004aac:	681a      	ldr	r2, [r3, #0]
 8004aae:	f8d7 30b4 	ldr.w	r3, [r7, #180]	; 0xb4
 8004ab2:	f1c3 0302 	rsb	r3, r3, #2
 8004ab6:	009b      	lsls	r3, r3, #2
 8004ab8:	f107 01b8 	add.w	r1, r7, #184	; 0xb8
 8004abc:	440b      	add	r3, r1
 8004abe:	f853 3c5c 	ldr.w	r3, [r3, #-92]
 8004ac2:	4619      	mov	r1, r3
 8004ac4:	4610      	mov	r0, r2
 8004ac6:	f7fe fd59 	bl	800357c <MULSHIFT32>
 8004aca:	4605      	mov	r5, r0
 8004acc:	f8d7 30b4 	ldr.w	r3, [r7, #180]	; 0xb4
 8004ad0:	009b      	lsls	r3, r3, #2
 8004ad2:	f8d7 20a8 	ldr.w	r2, [r7, #168]	; 0xa8
 8004ad6:	4413      	add	r3, r2
 8004ad8:	681a      	ldr	r2, [r3, #0]
 8004ada:	f8d7 30b4 	ldr.w	r3, [r7, #180]	; 0xb4
 8004ade:	3309      	adds	r3, #9
 8004ae0:	009b      	lsls	r3, r3, #2
 8004ae2:	f107 01b8 	add.w	r1, r7, #184	; 0xb8
 8004ae6:	440b      	add	r3, r1
 8004ae8:	f853 3c5c 	ldr.w	r3, [r3, #-92]
 8004aec:	4619      	mov	r1, r3
 8004aee:	4610      	mov	r0, r2
 8004af0:	f7fe fd44 	bl	800357c <MULSHIFT32>
 8004af4:	4603      	mov	r3, r0
 8004af6:	442b      	add	r3, r5
 8004af8:	4423      	add	r3, r4
 8004afa:	f8c7 30a4 	str.w	r3, [r7, #164]	; 0xa4
		mOut |= FASTABS(yLo);	y[(12+i)*NBANDS] = yLo;
 8004afe:	f8d7 00a4 	ldr.w	r0, [r7, #164]	; 0xa4
 8004b02:	f7fe fd4d 	bl	80035a0 <FASTABS>
 8004b06:	4602      	mov	r2, r0
 8004b08:	f8d7 30ac 	ldr.w	r3, [r7, #172]	; 0xac
 8004b0c:	4313      	orrs	r3, r2
 8004b0e:	f8c7 30ac 	str.w	r3, [r7, #172]	; 0xac
 8004b12:	f8d7 30b4 	ldr.w	r3, [r7, #180]	; 0xb4
 8004b16:	330c      	adds	r3, #12
 8004b18:	01db      	lsls	r3, r3, #7
 8004b1a:	461a      	mov	r2, r3
 8004b1c:	687b      	ldr	r3, [r7, #4]
 8004b1e:	4413      	add	r3, r2
 8004b20:	f8d7 20a4 	ldr.w	r2, [r7, #164]	; 0xa4
 8004b24:	601a      	str	r2, [r3, #0]
		yLo = (xPrevWin[15+i] << 2) + (MULSHIFT32(wp[9+i], xBuf[0+i]) + MULSHIFT32(wp[3+i], xBuf[(6+5)-i]));	
 8004b26:	f8d7 30b4 	ldr.w	r3, [r7, #180]	; 0xb4
 8004b2a:	330f      	adds	r3, #15
 8004b2c:	009b      	lsls	r3, r3, #2
 8004b2e:	f107 02b8 	add.w	r2, r7, #184	; 0xb8
 8004b32:	4413      	add	r3, r2
 8004b34:	f853 3ca4 	ldr.w	r3, [r3, #-164]
 8004b38:	009c      	lsls	r4, r3, #2
 8004b3a:	f8d7 30b4 	ldr.w	r3, [r7, #180]	; 0xb4
 8004b3e:	3309      	adds	r3, #9
 8004b40:	009b      	lsls	r3, r3, #2
 8004b42:	f8d7 20a8 	ldr.w	r2, [r7, #168]	; 0xa8
 8004b46:	4413      	add	r3, r2
 8004b48:	681a      	ldr	r2, [r3, #0]
 8004b4a:	f8d7 30b4 	ldr.w	r3, [r7, #180]	; 0xb4
 8004b4e:	009b      	lsls	r3, r3, #2
 8004b50:	f107 01b8 	add.w	r1, r7, #184	; 0xb8
 8004b54:	440b      	add	r3, r1
 8004b56:	f853 3c5c 	ldr.w	r3, [r3, #-92]
 8004b5a:	4619      	mov	r1, r3
 8004b5c:	4610      	mov	r0, r2
 8004b5e:	f7fe fd0d 	bl	800357c <MULSHIFT32>
 8004b62:	4605      	mov	r5, r0
 8004b64:	f8d7 30b4 	ldr.w	r3, [r7, #180]	; 0xb4
 8004b68:	3303      	adds	r3, #3
 8004b6a:	009b      	lsls	r3, r3, #2
 8004b6c:	f8d7 20a8 	ldr.w	r2, [r7, #168]	; 0xa8
 8004b70:	4413      	add	r3, r2
 8004b72:	681a      	ldr	r2, [r3, #0]
 8004b74:	f8d7 30b4 	ldr.w	r3, [r7, #180]	; 0xb4
 8004b78:	f1c3 030b 	rsb	r3, r3, #11
 8004b7c:	009b      	lsls	r3, r3, #2
 8004b7e:	f107 01b8 	add.w	r1, r7, #184	; 0xb8
 8004b82:	440b      	add	r3, r1
 8004b84:	f853 3c5c 	ldr.w	r3, [r3, #-92]
 8004b88:	4619      	mov	r1, r3
 8004b8a:	4610      	mov	r0, r2
 8004b8c:	f7fe fcf6 	bl	800357c <MULSHIFT32>
 8004b90:	4603      	mov	r3, r0
 8004b92:	442b      	add	r3, r5
 8004b94:	4423      	add	r3, r4
 8004b96:	f8c7 30a4 	str.w	r3, [r7, #164]	; 0xa4
		mOut |= FASTABS(yLo);	y[(15+i)*NBANDS] = yLo;
 8004b9a:	f8d7 00a4 	ldr.w	r0, [r7, #164]	; 0xa4
 8004b9e:	f7fe fcff 	bl	80035a0 <FASTABS>
 8004ba2:	4602      	mov	r2, r0
 8004ba4:	f8d7 30ac 	ldr.w	r3, [r7, #172]	; 0xac
 8004ba8:	4313      	orrs	r3, r2
 8004baa:	f8c7 30ac 	str.w	r3, [r7, #172]	; 0xac
 8004bae:	f8d7 30b4 	ldr.w	r3, [r7, #180]	; 0xb4
 8004bb2:	330f      	adds	r3, #15
 8004bb4:	01db      	lsls	r3, r3, #7
 8004bb6:	461a      	mov	r2, r3
 8004bb8:	687b      	ldr	r3, [r7, #4]
 8004bba:	4413      	add	r3, r2
 8004bbc:	f8d7 20a4 	ldr.w	r2, [r7, #164]	; 0xa4
 8004bc0:	601a      	str	r2, [r3, #0]
	for (i = 0; i < 3; i++) {
 8004bc2:	f8d7 30b4 	ldr.w	r3, [r7, #180]	; 0xb4
 8004bc6:	3301      	adds	r3, #1
 8004bc8:	f8c7 30b4 	str.w	r3, [r7, #180]	; 0xb4
 8004bcc:	f8d7 30b4 	ldr.w	r3, [r7, #180]	; 0xb4
 8004bd0:	2b02      	cmp	r3, #2
 8004bd2:	f77f aeae 	ble.w	8004932 <IMDCT12x3+0xf2>
	}

	/* save previous (unwindowed) for overlap - only need samples 6-8, 12-17 */
	for (i = 6; i < 9; i++)
 8004bd6:	2306      	movs	r3, #6
 8004bd8:	f8c7 30b4 	str.w	r3, [r7, #180]	; 0xb4
 8004bdc:	e011      	b.n	8004c02 <IMDCT12x3+0x3c2>
		*xPrev++ = xBuf[i] >> 2;
 8004bde:	68ba      	ldr	r2, [r7, #8]
 8004be0:	1d13      	adds	r3, r2, #4
 8004be2:	60bb      	str	r3, [r7, #8]
 8004be4:	f8d7 30b4 	ldr.w	r3, [r7, #180]	; 0xb4
 8004be8:	009b      	lsls	r3, r3, #2
 8004bea:	f107 01b8 	add.w	r1, r7, #184	; 0xb8
 8004bee:	440b      	add	r3, r1
 8004bf0:	f853 3c5c 	ldr.w	r3, [r3, #-92]
 8004bf4:	109b      	asrs	r3, r3, #2
 8004bf6:	6013      	str	r3, [r2, #0]
	for (i = 6; i < 9; i++)
 8004bf8:	f8d7 30b4 	ldr.w	r3, [r7, #180]	; 0xb4
 8004bfc:	3301      	adds	r3, #1
 8004bfe:	f8c7 30b4 	str.w	r3, [r7, #180]	; 0xb4
 8004c02:	f8d7 30b4 	ldr.w	r3, [r7, #180]	; 0xb4
 8004c06:	2b08      	cmp	r3, #8
 8004c08:	dde9      	ble.n	8004bde <IMDCT12x3+0x39e>
	for (i = 12; i < 18; i++)
 8004c0a:	230c      	movs	r3, #12
 8004c0c:	f8c7 30b4 	str.w	r3, [r7, #180]	; 0xb4
 8004c10:	e011      	b.n	8004c36 <IMDCT12x3+0x3f6>
		*xPrev++ = xBuf[i] >> 2;
 8004c12:	68ba      	ldr	r2, [r7, #8]
 8004c14:	1d13      	adds	r3, r2, #4
 8004c16:	60bb      	str	r3, [r7, #8]
 8004c18:	f8d7 30b4 	ldr.w	r3, [r7, #180]	; 0xb4
 8004c1c:	009b      	lsls	r3, r3, #2
 8004c1e:	f107 01b8 	add.w	r1, r7, #184	; 0xb8
 8004c22:	440b      	add	r3, r1
 8004c24:	f853 3c5c 	ldr.w	r3, [r3, #-92]
 8004c28:	109b      	asrs	r3, r3, #2
 8004c2a:	6013      	str	r3, [r2, #0]
	for (i = 12; i < 18; i++)
 8004c2c:	f8d7 30b4 	ldr.w	r3, [r7, #180]	; 0xb4
 8004c30:	3301      	adds	r3, #1
 8004c32:	f8c7 30b4 	str.w	r3, [r7, #180]	; 0xb4
 8004c36:	f8d7 30b4 	ldr.w	r3, [r7, #180]	; 0xb4
 8004c3a:	2b11      	cmp	r3, #17
 8004c3c:	dde9      	ble.n	8004c12 <IMDCT12x3+0x3d2>

	xPrev -= 9;
 8004c3e:	68bb      	ldr	r3, [r7, #8]
 8004c40:	3b24      	subs	r3, #36	; 0x24
 8004c42:	60bb      	str	r3, [r7, #8]
	mOut |= FreqInvertRescale(y, xPrev, blockIdx, es);
 8004c44:	f8d7 30b0 	ldr.w	r3, [r7, #176]	; 0xb0
 8004c48:	f8d7 20c8 	ldr.w	r2, [r7, #200]	; 0xc8
 8004c4c:	68b9      	ldr	r1, [r7, #8]
 8004c4e:	6878      	ldr	r0, [r7, #4]
 8004c50:	f7fe ffe0 	bl	8003c14 <FreqInvertRescale>
 8004c54:	4602      	mov	r2, r0
 8004c56:	f8d7 30ac 	ldr.w	r3, [r7, #172]	; 0xac
 8004c5a:	4313      	orrs	r3, r2
 8004c5c:	f8c7 30ac 	str.w	r3, [r7, #172]	; 0xac

	return mOut;
 8004c60:	f8d7 30ac 	ldr.w	r3, [r7, #172]	; 0xac
}
 8004c64:	4618      	mov	r0, r3
 8004c66:	37b8      	adds	r7, #184	; 0xb8
 8004c68:	46bd      	mov	sp, r7
 8004c6a:	bdb0      	pop	{r4, r5, r7, pc}
 8004c6c:	0801a37c 	.word	0x0801a37c

08004c70 <HybridTransform>:
 *                (including overlap-add)
 *
 * TODO:        examine mixedBlock/winSwitch logic carefully (test he_mode.bit)
 **************************************************************************************/
static int HybridTransform(int *xCurr, int *xPrev, int y[BLOCK_SIZE][NBANDS], SideInfoSub *sis, BlockCount *bc)
{
 8004c70:	b580      	push	{r7, lr}
 8004c72:	b0a4      	sub	sp, #144	; 0x90
 8004c74:	af04      	add	r7, sp, #16
 8004c76:	60f8      	str	r0, [r7, #12]
 8004c78:	60b9      	str	r1, [r7, #8]
 8004c7a:	607a      	str	r2, [r7, #4]
 8004c7c:	603b      	str	r3, [r7, #0]

	ASSERT(bc->nBlocksLong  <= NBANDS);
	ASSERT(bc->nBlocksTotal <= NBANDS);
	ASSERT(bc->nBlocksPrev  <= NBANDS);

	mOut = 0;
 8004c7e:	2300      	movs	r3, #0
 8004c80:	667b      	str	r3, [r7, #100]	; 0x64

	/* do long blocks, if any */
	for(i = 0; i < bc->nBlocksLong; i++) {
 8004c82:	2300      	movs	r3, #0
 8004c84:	677b      	str	r3, [r7, #116]	; 0x74
 8004c86:	e038      	b.n	8004cfa <HybridTransform+0x8a>
		/* currWinIdx picks the right window for long blocks (if mixed, long blocks use window type 0) */
		currWinIdx = sis->blockType;
 8004c88:	683b      	ldr	r3, [r7, #0]
 8004c8a:	695b      	ldr	r3, [r3, #20]
 8004c8c:	67fb      	str	r3, [r7, #124]	; 0x7c
		if (sis->mixedBlock && i < bc->currWinSwitch) 
 8004c8e:	683b      	ldr	r3, [r7, #0]
 8004c90:	699b      	ldr	r3, [r3, #24]
 8004c92:	2b00      	cmp	r3, #0
 8004c94:	d007      	beq.n	8004ca6 <HybridTransform+0x36>
 8004c96:	f8d7 3088 	ldr.w	r3, [r7, #136]	; 0x88
 8004c9a:	695a      	ldr	r2, [r3, #20]
 8004c9c:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 8004c9e:	429a      	cmp	r2, r3
 8004ca0:	dd01      	ble.n	8004ca6 <HybridTransform+0x36>
			currWinIdx = 0;
 8004ca2:	2300      	movs	r3, #0
 8004ca4:	67fb      	str	r3, [r7, #124]	; 0x7c

		prevWinIdx = bc->prevType;
 8004ca6:	f8d7 3088 	ldr.w	r3, [r7, #136]	; 0x88
 8004caa:	68db      	ldr	r3, [r3, #12]
 8004cac:	67bb      	str	r3, [r7, #120]	; 0x78
		if (i < bc->prevWinSwitch)
 8004cae:	f8d7 3088 	ldr.w	r3, [r7, #136]	; 0x88
 8004cb2:	691a      	ldr	r2, [r3, #16]
 8004cb4:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 8004cb6:	429a      	cmp	r2, r3
 8004cb8:	dd01      	ble.n	8004cbe <HybridTransform+0x4e>
			 prevWinIdx = 0;
 8004cba:	2300      	movs	r3, #0
 8004cbc:	67bb      	str	r3, [r7, #120]	; 0x78

		/* do 36-point IMDCT, including windowing and overlap-add */
		mOut |= IMDCT36(xCurr, xPrev, &(y[0][i]), currWinIdx, prevWinIdx, i, bc->gbIn);
 8004cbe:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 8004cc0:	009b      	lsls	r3, r3, #2
 8004cc2:	687a      	ldr	r2, [r7, #4]
 8004cc4:	441a      	add	r2, r3
 8004cc6:	f8d7 3088 	ldr.w	r3, [r7, #136]	; 0x88
 8004cca:	699b      	ldr	r3, [r3, #24]
 8004ccc:	9302      	str	r3, [sp, #8]
 8004cce:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 8004cd0:	9301      	str	r3, [sp, #4]
 8004cd2:	6fbb      	ldr	r3, [r7, #120]	; 0x78
 8004cd4:	9300      	str	r3, [sp, #0]
 8004cd6:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
 8004cd8:	68b9      	ldr	r1, [r7, #8]
 8004cda:	68f8      	ldr	r0, [r7, #12]
 8004cdc:	f7ff faac 	bl	8004238 <IMDCT36>
 8004ce0:	4602      	mov	r2, r0
 8004ce2:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8004ce4:	4313      	orrs	r3, r2
 8004ce6:	667b      	str	r3, [r7, #100]	; 0x64
		xCurr += 18;
 8004ce8:	68fb      	ldr	r3, [r7, #12]
 8004cea:	3348      	adds	r3, #72	; 0x48
 8004cec:	60fb      	str	r3, [r7, #12]
		xPrev += 9;
 8004cee:	68bb      	ldr	r3, [r7, #8]
 8004cf0:	3324      	adds	r3, #36	; 0x24
 8004cf2:	60bb      	str	r3, [r7, #8]
	for(i = 0; i < bc->nBlocksLong; i++) {
 8004cf4:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 8004cf6:	3301      	adds	r3, #1
 8004cf8:	677b      	str	r3, [r7, #116]	; 0x74
 8004cfa:	f8d7 3088 	ldr.w	r3, [r7, #136]	; 0x88
 8004cfe:	681a      	ldr	r2, [r3, #0]
 8004d00:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 8004d02:	429a      	cmp	r2, r3
 8004d04:	dcc0      	bgt.n	8004c88 <HybridTransform+0x18>
	}

	/* do short blocks (if any) */
	for (   ; i < bc->nBlocksTotal; i++) {
 8004d06:	e027      	b.n	8004d58 <HybridTransform+0xe8>
		ASSERT(sis->blockType == 2);

		prevWinIdx = bc->prevType;
 8004d08:	f8d7 3088 	ldr.w	r3, [r7, #136]	; 0x88
 8004d0c:	68db      	ldr	r3, [r3, #12]
 8004d0e:	67bb      	str	r3, [r7, #120]	; 0x78
		if (i < bc->prevWinSwitch)
 8004d10:	f8d7 3088 	ldr.w	r3, [r7, #136]	; 0x88
 8004d14:	691a      	ldr	r2, [r3, #16]
 8004d16:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 8004d18:	429a      	cmp	r2, r3
 8004d1a:	dd01      	ble.n	8004d20 <HybridTransform+0xb0>
			 prevWinIdx = 0;
 8004d1c:	2300      	movs	r3, #0
 8004d1e:	67bb      	str	r3, [r7, #120]	; 0x78
		
		mOut |= IMDCT12x3(xCurr, xPrev, &(y[0][i]), prevWinIdx, i, bc->gbIn);
 8004d20:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 8004d22:	009b      	lsls	r3, r3, #2
 8004d24:	687a      	ldr	r2, [r7, #4]
 8004d26:	441a      	add	r2, r3
 8004d28:	f8d7 3088 	ldr.w	r3, [r7, #136]	; 0x88
 8004d2c:	699b      	ldr	r3, [r3, #24]
 8004d2e:	9301      	str	r3, [sp, #4]
 8004d30:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 8004d32:	9300      	str	r3, [sp, #0]
 8004d34:	6fbb      	ldr	r3, [r7, #120]	; 0x78
 8004d36:	68b9      	ldr	r1, [r7, #8]
 8004d38:	68f8      	ldr	r0, [r7, #12]
 8004d3a:	f7ff fd81 	bl	8004840 <IMDCT12x3>
 8004d3e:	4602      	mov	r2, r0
 8004d40:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8004d42:	4313      	orrs	r3, r2
 8004d44:	667b      	str	r3, [r7, #100]	; 0x64
		xCurr += 18;
 8004d46:	68fb      	ldr	r3, [r7, #12]
 8004d48:	3348      	adds	r3, #72	; 0x48
 8004d4a:	60fb      	str	r3, [r7, #12]
		xPrev += 9;
 8004d4c:	68bb      	ldr	r3, [r7, #8]
 8004d4e:	3324      	adds	r3, #36	; 0x24
 8004d50:	60bb      	str	r3, [r7, #8]
	for (   ; i < bc->nBlocksTotal; i++) {
 8004d52:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 8004d54:	3301      	adds	r3, #1
 8004d56:	677b      	str	r3, [r7, #116]	; 0x74
 8004d58:	f8d7 3088 	ldr.w	r3, [r7, #136]	; 0x88
 8004d5c:	685a      	ldr	r2, [r3, #4]
 8004d5e:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 8004d60:	429a      	cmp	r2, r3
 8004d62:	dcd1      	bgt.n	8004d08 <HybridTransform+0x98>
	}
	nBlocksOut = i;
 8004d64:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 8004d66:	66fb      	str	r3, [r7, #108]	; 0x6c
	
	/* window and overlap prev if prev longer that current */
	for (   ; i < bc->nBlocksPrev; i++) {
 8004d68:	e077      	b.n	8004e5a <HybridTransform+0x1ea>
		prevWinIdx = bc->prevType;
 8004d6a:	f8d7 3088 	ldr.w	r3, [r7, #136]	; 0x88
 8004d6e:	68db      	ldr	r3, [r3, #12]
 8004d70:	67bb      	str	r3, [r7, #120]	; 0x78
		if (i < bc->prevWinSwitch)
 8004d72:	f8d7 3088 	ldr.w	r3, [r7, #136]	; 0x88
 8004d76:	691a      	ldr	r2, [r3, #16]
 8004d78:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 8004d7a:	429a      	cmp	r2, r3
 8004d7c:	dd01      	ble.n	8004d82 <HybridTransform+0x112>
			 prevWinIdx = 0;
 8004d7e:	2300      	movs	r3, #0
 8004d80:	67bb      	str	r3, [r7, #120]	; 0x78
		WinPrevious(xPrev, xPrevWin, prevWinIdx);
 8004d82:	f107 0314 	add.w	r3, r7, #20
 8004d86:	6fba      	ldr	r2, [r7, #120]	; 0x78
 8004d88:	4619      	mov	r1, r3
 8004d8a:	68b8      	ldr	r0, [r7, #8]
 8004d8c:	f7fe fddc 	bl	8003948 <WinPrevious>

		nonZero = 0;
 8004d90:	2300      	movs	r3, #0
 8004d92:	66bb      	str	r3, [r7, #104]	; 0x68
		fiBit = i << 31;
 8004d94:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 8004d96:	07db      	lsls	r3, r3, #31
 8004d98:	663b      	str	r3, [r7, #96]	; 0x60
		for (j = 0; j < 9; j++) {
 8004d9a:	2300      	movs	r3, #0
 8004d9c:	673b      	str	r3, [r7, #112]	; 0x70
 8004d9e:	e04e      	b.n	8004e3e <HybridTransform+0x1ce>
			xp = xPrevWin[2*j+0] << 2;	/* << 2 temp for scaling */
 8004da0:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 8004da2:	005b      	lsls	r3, r3, #1
 8004da4:	009b      	lsls	r3, r3, #2
 8004da6:	f107 0280 	add.w	r2, r7, #128	; 0x80
 8004daa:	4413      	add	r3, r2
 8004dac:	f853 3c6c 	ldr.w	r3, [r3, #-108]
 8004db0:	009b      	lsls	r3, r3, #2
 8004db2:	65fb      	str	r3, [r7, #92]	; 0x5c
			nonZero |= xp;
 8004db4:	6eba      	ldr	r2, [r7, #104]	; 0x68
 8004db6:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 8004db8:	4313      	orrs	r3, r2
 8004dba:	66bb      	str	r3, [r7, #104]	; 0x68
			y[2*j+0][i] = xp;
 8004dbc:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 8004dbe:	021b      	lsls	r3, r3, #8
 8004dc0:	461a      	mov	r2, r3
 8004dc2:	687b      	ldr	r3, [r7, #4]
 8004dc4:	4413      	add	r3, r2
 8004dc6:	6f7a      	ldr	r2, [r7, #116]	; 0x74
 8004dc8:	6df9      	ldr	r1, [r7, #92]	; 0x5c
 8004dca:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
			mOut |= FASTABS(xp);
 8004dce:	6df8      	ldr	r0, [r7, #92]	; 0x5c
 8004dd0:	f7fe fbe6 	bl	80035a0 <FASTABS>
 8004dd4:	4602      	mov	r2, r0
 8004dd6:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8004dd8:	4313      	orrs	r3, r2
 8004dda:	667b      	str	r3, [r7, #100]	; 0x64

			/* frequency inversion on odd blocks/odd samples (flip sign if i odd, j odd) */
			xp = xPrevWin[2*j+1] << 2;
 8004ddc:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 8004dde:	005b      	lsls	r3, r3, #1
 8004de0:	3301      	adds	r3, #1
 8004de2:	009b      	lsls	r3, r3, #2
 8004de4:	f107 0280 	add.w	r2, r7, #128	; 0x80
 8004de8:	4413      	add	r3, r2
 8004dea:	f853 3c6c 	ldr.w	r3, [r3, #-108]
 8004dee:	009b      	lsls	r3, r3, #2
 8004df0:	65fb      	str	r3, [r7, #92]	; 0x5c
			xp = (xp ^ (fiBit >> 31)) + (i & 0x01);	
 8004df2:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 8004df4:	17da      	asrs	r2, r3, #31
 8004df6:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 8004df8:	405a      	eors	r2, r3
 8004dfa:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 8004dfc:	f003 0301 	and.w	r3, r3, #1
 8004e00:	4413      	add	r3, r2
 8004e02:	65fb      	str	r3, [r7, #92]	; 0x5c
			nonZero |= xp;
 8004e04:	6eba      	ldr	r2, [r7, #104]	; 0x68
 8004e06:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 8004e08:	4313      	orrs	r3, r2
 8004e0a:	66bb      	str	r3, [r7, #104]	; 0x68
			y[2*j+1][i] = xp;
 8004e0c:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 8004e0e:	021b      	lsls	r3, r3, #8
 8004e10:	3380      	adds	r3, #128	; 0x80
 8004e12:	687a      	ldr	r2, [r7, #4]
 8004e14:	4413      	add	r3, r2
 8004e16:	6f7a      	ldr	r2, [r7, #116]	; 0x74
 8004e18:	6df9      	ldr	r1, [r7, #92]	; 0x5c
 8004e1a:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
			mOut |= FASTABS(xp);
 8004e1e:	6df8      	ldr	r0, [r7, #92]	; 0x5c
 8004e20:	f7fe fbbe 	bl	80035a0 <FASTABS>
 8004e24:	4602      	mov	r2, r0
 8004e26:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8004e28:	4313      	orrs	r3, r2
 8004e2a:	667b      	str	r3, [r7, #100]	; 0x64

			xPrev[j] = 0;
 8004e2c:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 8004e2e:	009b      	lsls	r3, r3, #2
 8004e30:	68ba      	ldr	r2, [r7, #8]
 8004e32:	4413      	add	r3, r2
 8004e34:	2200      	movs	r2, #0
 8004e36:	601a      	str	r2, [r3, #0]
		for (j = 0; j < 9; j++) {
 8004e38:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 8004e3a:	3301      	adds	r3, #1
 8004e3c:	673b      	str	r3, [r7, #112]	; 0x70
 8004e3e:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 8004e40:	2b08      	cmp	r3, #8
 8004e42:	ddad      	ble.n	8004da0 <HybridTransform+0x130>
		}
		xPrev += 9;
 8004e44:	68bb      	ldr	r3, [r7, #8]
 8004e46:	3324      	adds	r3, #36	; 0x24
 8004e48:	60bb      	str	r3, [r7, #8]
		if (nonZero)
 8004e4a:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 8004e4c:	2b00      	cmp	r3, #0
 8004e4e:	d001      	beq.n	8004e54 <HybridTransform+0x1e4>
			nBlocksOut = i;
 8004e50:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 8004e52:	66fb      	str	r3, [r7, #108]	; 0x6c
	for (   ; i < bc->nBlocksPrev; i++) {
 8004e54:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 8004e56:	3301      	adds	r3, #1
 8004e58:	677b      	str	r3, [r7, #116]	; 0x74
 8004e5a:	f8d7 3088 	ldr.w	r3, [r7, #136]	; 0x88
 8004e5e:	689a      	ldr	r2, [r3, #8]
 8004e60:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 8004e62:	429a      	cmp	r2, r3
 8004e64:	dc81      	bgt.n	8004d6a <HybridTransform+0xfa>
	}
	
	/* clear rest of blocks */
	for (   ; i < 32; i++) {
 8004e66:	e013      	b.n	8004e90 <HybridTransform+0x220>
		for (j = 0; j < 18; j++) 
 8004e68:	2300      	movs	r3, #0
 8004e6a:	673b      	str	r3, [r7, #112]	; 0x70
 8004e6c:	e00a      	b.n	8004e84 <HybridTransform+0x214>
			y[j][i] = 0;
 8004e6e:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 8004e70:	01db      	lsls	r3, r3, #7
 8004e72:	687a      	ldr	r2, [r7, #4]
 8004e74:	4413      	add	r3, r2
 8004e76:	6f7a      	ldr	r2, [r7, #116]	; 0x74
 8004e78:	2100      	movs	r1, #0
 8004e7a:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
		for (j = 0; j < 18; j++) 
 8004e7e:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 8004e80:	3301      	adds	r3, #1
 8004e82:	673b      	str	r3, [r7, #112]	; 0x70
 8004e84:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 8004e86:	2b11      	cmp	r3, #17
 8004e88:	ddf1      	ble.n	8004e6e <HybridTransform+0x1fe>
	for (   ; i < 32; i++) {
 8004e8a:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 8004e8c:	3301      	adds	r3, #1
 8004e8e:	677b      	str	r3, [r7, #116]	; 0x74
 8004e90:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 8004e92:	2b1f      	cmp	r3, #31
 8004e94:	dde8      	ble.n	8004e68 <HybridTransform+0x1f8>
	}

	bc->gbOut = CLZ(mOut) - 1;
 8004e96:	6e78      	ldr	r0, [r7, #100]	; 0x64
 8004e98:	f7fe fb98 	bl	80035cc <CLZ>
 8004e9c:	4603      	mov	r3, r0
 8004e9e:	1e5a      	subs	r2, r3, #1
 8004ea0:	f8d7 3088 	ldr.w	r3, [r7, #136]	; 0x88
 8004ea4:	61da      	str	r2, [r3, #28]

	return nBlocksOut;
 8004ea6:	6efb      	ldr	r3, [r7, #108]	; 0x6c
}
 8004ea8:	4618      	mov	r0, r3
 8004eaa:	3780      	adds	r7, #128	; 0x80
 8004eac:	46bd      	mov	sp, r7
 8004eae:	bd80      	pop	{r7, pc}

08004eb0 <xmp3fixpt_IMDCT>:
 *              updated hi->nonZeroBound index for this channel
 *
 * Return:      0 on success,  -1 if null input pointers
 **************************************************************************************/
int IMDCT(MP3DecInfo *mp3DecInfo, int gr, int ch)
{
 8004eb0:	b5b0      	push	{r4, r5, r7, lr}
 8004eb2:	b094      	sub	sp, #80	; 0x50
 8004eb4:	af02      	add	r7, sp, #8
 8004eb6:	60f8      	str	r0, [r7, #12]
 8004eb8:	60b9      	str	r1, [r7, #8]
 8004eba:	607a      	str	r2, [r7, #4]
	HuffmanInfo *hi;
	IMDCTInfo *mi;
	BlockCount bc;

	/* validate pointers */
	if (!mp3DecInfo || !mp3DecInfo->FrameHeaderPS || !mp3DecInfo->SideInfoPS || 
 8004ebc:	68fb      	ldr	r3, [r7, #12]
 8004ebe:	2b00      	cmp	r3, #0
 8004ec0:	d00f      	beq.n	8004ee2 <xmp3fixpt_IMDCT+0x32>
 8004ec2:	68fb      	ldr	r3, [r7, #12]
 8004ec4:	681b      	ldr	r3, [r3, #0]
 8004ec6:	2b00      	cmp	r3, #0
 8004ec8:	d00b      	beq.n	8004ee2 <xmp3fixpt_IMDCT+0x32>
 8004eca:	68fb      	ldr	r3, [r7, #12]
 8004ecc:	685b      	ldr	r3, [r3, #4]
 8004ece:	2b00      	cmp	r3, #0
 8004ed0:	d007      	beq.n	8004ee2 <xmp3fixpt_IMDCT+0x32>
		!mp3DecInfo->HuffmanInfoPS || !mp3DecInfo->IMDCTInfoPS)
 8004ed2:	68fb      	ldr	r3, [r7, #12]
 8004ed4:	68db      	ldr	r3, [r3, #12]
	if (!mp3DecInfo || !mp3DecInfo->FrameHeaderPS || !mp3DecInfo->SideInfoPS || 
 8004ed6:	2b00      	cmp	r3, #0
 8004ed8:	d003      	beq.n	8004ee2 <xmp3fixpt_IMDCT+0x32>
		!mp3DecInfo->HuffmanInfoPS || !mp3DecInfo->IMDCTInfoPS)
 8004eda:	68fb      	ldr	r3, [r7, #12]
 8004edc:	695b      	ldr	r3, [r3, #20]
 8004ede:	2b00      	cmp	r3, #0
 8004ee0:	d102      	bne.n	8004ee8 <xmp3fixpt_IMDCT+0x38>
		return -1;
 8004ee2:	f04f 33ff 	mov.w	r3, #4294967295
 8004ee6:	e130      	b.n	800514a <xmp3fixpt_IMDCT+0x29a>

	/* si is an array of up to 4 structs, stored as gr0ch0, gr0ch1, gr1ch0, gr1ch1 */
	fh = (FrameHeader *)(mp3DecInfo->FrameHeaderPS);
 8004ee8:	68fb      	ldr	r3, [r7, #12]
 8004eea:	681b      	ldr	r3, [r3, #0]
 8004eec:	643b      	str	r3, [r7, #64]	; 0x40
	si = (SideInfo *)(mp3DecInfo->SideInfoPS);
 8004eee:	68fb      	ldr	r3, [r7, #12]
 8004ef0:	685b      	ldr	r3, [r3, #4]
 8004ef2:	63fb      	str	r3, [r7, #60]	; 0x3c
	hi = (HuffmanInfo*)(mp3DecInfo->HuffmanInfoPS);
 8004ef4:	68fb      	ldr	r3, [r7, #12]
 8004ef6:	68db      	ldr	r3, [r3, #12]
 8004ef8:	63bb      	str	r3, [r7, #56]	; 0x38
	mi = (IMDCTInfo *)(mp3DecInfo->IMDCTInfoPS);
 8004efa:	68fb      	ldr	r3, [r7, #12]
 8004efc:	695b      	ldr	r3, [r3, #20]
 8004efe:	637b      	str	r3, [r7, #52]	; 0x34
	/* anti-aliasing done on whole long blocks only
	 * for mixed blocks, nBfly always 1, except 3 for 8 kHz MPEG 2.5 (see sfBandTab) 
     *   nLongBlocks = number of blocks with (possibly) non-zero power 
	 *   nBfly = number of butterflies to do (nLongBlocks - 1, unless no long blocks)
	 */
	blockCutoff = fh->sfBand->l[(fh->ver == MPEG1 ? 8 : 6)] / 18;	/* same as 3* num short sfb's in spec */
 8004f00:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8004f02:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8004f04:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 8004f06:	7812      	ldrb	r2, [r2, #0]
 8004f08:	2a00      	cmp	r2, #0
 8004f0a:	d101      	bne.n	8004f10 <xmp3fixpt_IMDCT+0x60>
 8004f0c:	2208      	movs	r2, #8
 8004f0e:	e000      	b.n	8004f12 <xmp3fixpt_IMDCT+0x62>
 8004f10:	2206      	movs	r2, #6
 8004f12:	f933 3012 	ldrsh.w	r3, [r3, r2, lsl #1]
 8004f16:	4a8f      	ldr	r2, [pc, #572]	; (8005154 <xmp3fixpt_IMDCT+0x2a4>)
 8004f18:	fb82 1203 	smull	r1, r2, r2, r3
 8004f1c:	1092      	asrs	r2, r2, #2
 8004f1e:	17db      	asrs	r3, r3, #31
 8004f20:	1ad3      	subs	r3, r2, r3
 8004f22:	b21b      	sxth	r3, r3
 8004f24:	633b      	str	r3, [r7, #48]	; 0x30
	if (si->sis[gr][ch].blockType != 2) {
 8004f26:	6bf8      	ldr	r0, [r7, #60]	; 0x3c
 8004f28:	687b      	ldr	r3, [r7, #4]
 8004f2a:	68b9      	ldr	r1, [r7, #8]
 8004f2c:	461a      	mov	r2, r3
 8004f2e:	00d2      	lsls	r2, r2, #3
 8004f30:	441a      	add	r2, r3
 8004f32:	00d3      	lsls	r3, r2, #3
 8004f34:	461a      	mov	r2, r3
 8004f36:	460b      	mov	r3, r1
 8004f38:	00db      	lsls	r3, r3, #3
 8004f3a:	440b      	add	r3, r1
 8004f3c:	011b      	lsls	r3, r3, #4
 8004f3e:	4413      	add	r3, r2
 8004f40:	4403      	add	r3, r0
 8004f42:	333c      	adds	r3, #60	; 0x3c
 8004f44:	681b      	ldr	r3, [r3, #0]
 8004f46:	2b02      	cmp	r3, #2
 8004f48:	d015      	beq.n	8004f76 <xmp3fixpt_IMDCT+0xc6>
		/* all long transforms */
		bc.nBlocksLong = MIN((hi->nonZeroBound[ch] + 7) / 18 + 1, 32);	
 8004f4a:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8004f4c:	687a      	ldr	r2, [r7, #4]
 8004f4e:	f502 6290 	add.w	r2, r2, #1152	; 0x480
 8004f52:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8004f56:	3307      	adds	r3, #7
 8004f58:	4a7e      	ldr	r2, [pc, #504]	; (8005154 <xmp3fixpt_IMDCT+0x2a4>)
 8004f5a:	fb82 1203 	smull	r1, r2, r2, r3
 8004f5e:	1092      	asrs	r2, r2, #2
 8004f60:	17db      	asrs	r3, r3, #31
 8004f62:	1ad3      	subs	r3, r2, r3
 8004f64:	3301      	adds	r3, #1
 8004f66:	2b20      	cmp	r3, #32
 8004f68:	bfa8      	it	ge
 8004f6a:	2320      	movge	r3, #32
 8004f6c:	613b      	str	r3, [r7, #16]
		nBfly = bc.nBlocksLong - 1;
 8004f6e:	693b      	ldr	r3, [r7, #16]
 8004f70:	3b01      	subs	r3, #1
 8004f72:	647b      	str	r3, [r7, #68]	; 0x44
 8004f74:	e02d      	b.n	8004fd2 <xmp3fixpt_IMDCT+0x122>
	} else if (si->sis[gr][ch].blockType == 2 && si->sis[gr][ch].mixedBlock) {
 8004f76:	6bf8      	ldr	r0, [r7, #60]	; 0x3c
 8004f78:	687b      	ldr	r3, [r7, #4]
 8004f7a:	68b9      	ldr	r1, [r7, #8]
 8004f7c:	461a      	mov	r2, r3
 8004f7e:	00d2      	lsls	r2, r2, #3
 8004f80:	441a      	add	r2, r3
 8004f82:	00d3      	lsls	r3, r2, #3
 8004f84:	461a      	mov	r2, r3
 8004f86:	460b      	mov	r3, r1
 8004f88:	00db      	lsls	r3, r3, #3
 8004f8a:	440b      	add	r3, r1
 8004f8c:	011b      	lsls	r3, r3, #4
 8004f8e:	4413      	add	r3, r2
 8004f90:	4403      	add	r3, r0
 8004f92:	333c      	adds	r3, #60	; 0x3c
 8004f94:	681b      	ldr	r3, [r3, #0]
 8004f96:	2b02      	cmp	r3, #2
 8004f98:	d117      	bne.n	8004fca <xmp3fixpt_IMDCT+0x11a>
 8004f9a:	6bf8      	ldr	r0, [r7, #60]	; 0x3c
 8004f9c:	687b      	ldr	r3, [r7, #4]
 8004f9e:	68b9      	ldr	r1, [r7, #8]
 8004fa0:	461a      	mov	r2, r3
 8004fa2:	00d2      	lsls	r2, r2, #3
 8004fa4:	441a      	add	r2, r3
 8004fa6:	00d3      	lsls	r3, r2, #3
 8004fa8:	461a      	mov	r2, r3
 8004faa:	460b      	mov	r3, r1
 8004fac:	00db      	lsls	r3, r3, #3
 8004fae:	440b      	add	r3, r1
 8004fb0:	011b      	lsls	r3, r3, #4
 8004fb2:	4413      	add	r3, r2
 8004fb4:	4403      	add	r3, r0
 8004fb6:	3340      	adds	r3, #64	; 0x40
 8004fb8:	681b      	ldr	r3, [r3, #0]
 8004fba:	2b00      	cmp	r3, #0
 8004fbc:	d005      	beq.n	8004fca <xmp3fixpt_IMDCT+0x11a>
		/* mixed block - long transforms until cutoff, then short transforms */
		bc.nBlocksLong = blockCutoff;	
 8004fbe:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8004fc0:	613b      	str	r3, [r7, #16]
		nBfly = bc.nBlocksLong - 1;
 8004fc2:	693b      	ldr	r3, [r7, #16]
 8004fc4:	3b01      	subs	r3, #1
 8004fc6:	647b      	str	r3, [r7, #68]	; 0x44
 8004fc8:	e003      	b.n	8004fd2 <xmp3fixpt_IMDCT+0x122>
	} else {
		/* all short transforms */
		bc.nBlocksLong = 0;
 8004fca:	2300      	movs	r3, #0
 8004fcc:	613b      	str	r3, [r7, #16]
		nBfly = 0;
 8004fce:	2300      	movs	r3, #0
 8004fd0:	647b      	str	r3, [r7, #68]	; 0x44
	}
 
	AntiAlias(hi->huffDecBuf[ch], nBfly);
 8004fd2:	687a      	ldr	r2, [r7, #4]
 8004fd4:	4613      	mov	r3, r2
 8004fd6:	00db      	lsls	r3, r3, #3
 8004fd8:	4413      	add	r3, r2
 8004fda:	021b      	lsls	r3, r3, #8
 8004fdc:	6bba      	ldr	r2, [r7, #56]	; 0x38
 8004fde:	4413      	add	r3, r2
 8004fe0:	6c79      	ldr	r1, [r7, #68]	; 0x44
 8004fe2:	4618      	mov	r0, r3
 8004fe4:	f7fe fb01 	bl	80035ea <AntiAlias>
	hi->nonZeroBound[ch] = MAX(hi->nonZeroBound[ch], (nBfly * 18) + 8);
 8004fe8:	6c7a      	ldr	r2, [r7, #68]	; 0x44
 8004fea:	4613      	mov	r3, r2
 8004fec:	00db      	lsls	r3, r3, #3
 8004fee:	4413      	add	r3, r2
 8004ff0:	005b      	lsls	r3, r3, #1
 8004ff2:	f103 0208 	add.w	r2, r3, #8
 8004ff6:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8004ff8:	6879      	ldr	r1, [r7, #4]
 8004ffa:	f501 6190 	add.w	r1, r1, #1152	; 0x480
 8004ffe:	f853 3021 	ldr.w	r3, [r3, r1, lsl #2]
 8005002:	429a      	cmp	r2, r3
 8005004:	bfb8      	it	lt
 8005006:	461a      	movlt	r2, r3
 8005008:	4611      	mov	r1, r2
 800500a:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800500c:	687a      	ldr	r2, [r7, #4]
 800500e:	f502 6290 	add.w	r2, r2, #1152	; 0x480
 8005012:	f843 1022 	str.w	r1, [r3, r2, lsl #2]

	ASSERT(hi->nonZeroBound[ch] <= MAX_NSAMP);

	/* for readability, use a struct instead of passing a million parameters to HybridTransform() */
	bc.nBlocksTotal = (hi->nonZeroBound[ch] + 17) / 18;
 8005016:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8005018:	687a      	ldr	r2, [r7, #4]
 800501a:	f502 6290 	add.w	r2, r2, #1152	; 0x480
 800501e:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8005022:	3311      	adds	r3, #17
 8005024:	4a4b      	ldr	r2, [pc, #300]	; (8005154 <xmp3fixpt_IMDCT+0x2a4>)
 8005026:	fb82 1203 	smull	r1, r2, r2, r3
 800502a:	1092      	asrs	r2, r2, #2
 800502c:	17db      	asrs	r3, r3, #31
 800502e:	1ad3      	subs	r3, r2, r3
 8005030:	617b      	str	r3, [r7, #20]
	bc.nBlocksPrev = mi->numPrevIMDCT[ch];
 8005032:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8005034:	687a      	ldr	r2, [r7, #4]
 8005036:	f502 62d8 	add.w	r2, r2, #1728	; 0x6c0
 800503a:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 800503e:	61bb      	str	r3, [r7, #24]
	bc.prevType = mi->prevType[ch];
 8005040:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8005042:	687a      	ldr	r2, [r7, #4]
 8005044:	f202 62c2 	addw	r2, r2, #1730	; 0x6c2
 8005048:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 800504c:	61fb      	str	r3, [r7, #28]
	bc.prevWinSwitch = mi->prevWinSwitch[ch];
 800504e:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8005050:	687a      	ldr	r2, [r7, #4]
 8005052:	f202 62c4 	addw	r2, r2, #1732	; 0x6c4
 8005056:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 800505a:	623b      	str	r3, [r7, #32]
	bc.currWinSwitch = (si->sis[gr][ch].mixedBlock ? blockCutoff : 0);	/* where WINDOW switches (not nec. transform) */
 800505c:	6bf8      	ldr	r0, [r7, #60]	; 0x3c
 800505e:	687b      	ldr	r3, [r7, #4]
 8005060:	68b9      	ldr	r1, [r7, #8]
 8005062:	461a      	mov	r2, r3
 8005064:	00d2      	lsls	r2, r2, #3
 8005066:	441a      	add	r2, r3
 8005068:	00d3      	lsls	r3, r2, #3
 800506a:	461a      	mov	r2, r3
 800506c:	460b      	mov	r3, r1
 800506e:	00db      	lsls	r3, r3, #3
 8005070:	440b      	add	r3, r1
 8005072:	011b      	lsls	r3, r3, #4
 8005074:	4413      	add	r3, r2
 8005076:	4403      	add	r3, r0
 8005078:	3340      	adds	r3, #64	; 0x40
 800507a:	681b      	ldr	r3, [r3, #0]
 800507c:	2b00      	cmp	r3, #0
 800507e:	d001      	beq.n	8005084 <xmp3fixpt_IMDCT+0x1d4>
 8005080:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8005082:	e000      	b.n	8005086 <xmp3fixpt_IMDCT+0x1d6>
 8005084:	2300      	movs	r3, #0
 8005086:	627b      	str	r3, [r7, #36]	; 0x24
	bc.gbIn = hi->gb[ch];
 8005088:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800508a:	687a      	ldr	r2, [r7, #4]
 800508c:	f202 4282 	addw	r2, r2, #1154	; 0x482
 8005090:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8005094:	62bb      	str	r3, [r7, #40]	; 0x28

	mi->numPrevIMDCT[ch] = HybridTransform(hi->huffDecBuf[ch], mi->overBuf[ch], mi->outBuf[ch], &si->sis[gr][ch], &bc);
 8005096:	687a      	ldr	r2, [r7, #4]
 8005098:	4613      	mov	r3, r2
 800509a:	00db      	lsls	r3, r3, #3
 800509c:	4413      	add	r3, r2
 800509e:	021b      	lsls	r3, r3, #8
 80050a0:	6bba      	ldr	r2, [r7, #56]	; 0x38
 80050a2:	18d0      	adds	r0, r2, r3
 80050a4:	687a      	ldr	r2, [r7, #4]
 80050a6:	4613      	mov	r3, r2
 80050a8:	00db      	lsls	r3, r3, #3
 80050aa:	4413      	add	r3, r2
 80050ac:	01db      	lsls	r3, r3, #7
 80050ae:	f503 5390 	add.w	r3, r3, #4608	; 0x1200
 80050b2:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 80050b4:	18d4      	adds	r4, r2, r3
 80050b6:	687a      	ldr	r2, [r7, #4]
 80050b8:	4613      	mov	r3, r2
 80050ba:	00db      	lsls	r3, r3, #3
 80050bc:	4413      	add	r3, r2
 80050be:	021b      	lsls	r3, r3, #8
 80050c0:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 80050c2:	18d5      	adds	r5, r2, r3
 80050c4:	687b      	ldr	r3, [r7, #4]
 80050c6:	461a      	mov	r2, r3
 80050c8:	00d2      	lsls	r2, r2, #3
 80050ca:	441a      	add	r2, r3
 80050cc:	00d3      	lsls	r3, r2, #3
 80050ce:	461a      	mov	r2, r3
 80050d0:	68b9      	ldr	r1, [r7, #8]
 80050d2:	460b      	mov	r3, r1
 80050d4:	00db      	lsls	r3, r3, #3
 80050d6:	440b      	add	r3, r1
 80050d8:	011b      	lsls	r3, r3, #4
 80050da:	4413      	add	r3, r2
 80050dc:	3328      	adds	r3, #40	; 0x28
 80050de:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 80050e0:	441a      	add	r2, r3
 80050e2:	f107 0310 	add.w	r3, r7, #16
 80050e6:	9300      	str	r3, [sp, #0]
 80050e8:	4613      	mov	r3, r2
 80050ea:	462a      	mov	r2, r5
 80050ec:	4621      	mov	r1, r4
 80050ee:	f7ff fdbf 	bl	8004c70 <HybridTransform>
 80050f2:	4601      	mov	r1, r0
 80050f4:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 80050f6:	687a      	ldr	r2, [r7, #4]
 80050f8:	f502 62d8 	add.w	r2, r2, #1728	; 0x6c0
 80050fc:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
	mi->prevType[ch] = si->sis[gr][ch].blockType;
 8005100:	6bf8      	ldr	r0, [r7, #60]	; 0x3c
 8005102:	687b      	ldr	r3, [r7, #4]
 8005104:	68b9      	ldr	r1, [r7, #8]
 8005106:	461a      	mov	r2, r3
 8005108:	00d2      	lsls	r2, r2, #3
 800510a:	441a      	add	r2, r3
 800510c:	00d3      	lsls	r3, r2, #3
 800510e:	461a      	mov	r2, r3
 8005110:	460b      	mov	r3, r1
 8005112:	00db      	lsls	r3, r3, #3
 8005114:	440b      	add	r3, r1
 8005116:	011b      	lsls	r3, r3, #4
 8005118:	4413      	add	r3, r2
 800511a:	4403      	add	r3, r0
 800511c:	333c      	adds	r3, #60	; 0x3c
 800511e:	6819      	ldr	r1, [r3, #0]
 8005120:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8005122:	687a      	ldr	r2, [r7, #4]
 8005124:	f202 62c2 	addw	r2, r2, #1730	; 0x6c2
 8005128:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
	mi->prevWinSwitch[ch] = bc.currWinSwitch;		/* 0 means not a mixed block (either all short or all long) */
 800512c:	6a79      	ldr	r1, [r7, #36]	; 0x24
 800512e:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8005130:	687a      	ldr	r2, [r7, #4]
 8005132:	f202 62c4 	addw	r2, r2, #1732	; 0x6c4
 8005136:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
	mi->gb[ch] = bc.gbOut;
 800513a:	6af9      	ldr	r1, [r7, #44]	; 0x2c
 800513c:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800513e:	687a      	ldr	r2, [r7, #4]
 8005140:	f202 62c6 	addw	r2, r2, #1734	; 0x6c6
 8005144:	f843 1022 	str.w	r1, [r3, r2, lsl #2]

	ASSERT(mi->numPrevIMDCT[ch] <= NBANDS);

	/* output has gained 2 int bits */
	return 0;
 8005148:	2300      	movs	r3, #0
}
 800514a:	4618      	mov	r0, r3
 800514c:	3748      	adds	r7, #72	; 0x48
 800514e:	46bd      	mov	sp, r7
 8005150:	bdb0      	pop	{r4, r5, r7, pc}
 8005152:	bf00      	nop
 8005154:	38e38e39 	.word	0x38e38e39

08005158 <MADD64>:
		signed int hi32;
	} r;
} U64;

static __inline Word64 MADD64(Word64 sum64, int x, int y)
{
 8005158:	b490      	push	{r4, r7}
 800515a:	b086      	sub	sp, #24
 800515c:	af00      	add	r7, sp, #0
 800515e:	e9c7 0102 	strd	r0, r1, [r7, #8]
 8005162:	607a      	str	r2, [r7, #4]
 8005164:	603b      	str	r3, [r7, #0]
	U64 u;
	u.w64 = sum64;
 8005166:	e9d7 3402 	ldrd	r3, r4, [r7, #8]
 800516a:	e9c7 3404 	strd	r3, r4, [r7, #16]

	__asm__ volatile ("smlal %0,%1,%2,%3" : "+&r" (u.r.lo32), "+&r" (u.r.hi32) : "r" (x), "r" (y) : "cc");
 800516e:	693a      	ldr	r2, [r7, #16]
 8005170:	697b      	ldr	r3, [r7, #20]
 8005172:	6879      	ldr	r1, [r7, #4]
 8005174:	6838      	ldr	r0, [r7, #0]
 8005176:	fbc1 2300 	smlal	r2, r3, r1, r0
 800517a:	613a      	str	r2, [r7, #16]
 800517c:	617b      	str	r3, [r7, #20]

	return u.w64;
 800517e:	e9d7 3404 	ldrd	r3, r4, [r7, #16]
}
 8005182:	4618      	mov	r0, r3
 8005184:	4621      	mov	r1, r4
 8005186:	3718      	adds	r7, #24
 8005188:	46bd      	mov	sp, r7
 800518a:	bc90      	pop	{r4, r7}
 800518c:	4770      	bx	lr

0800518e <SAR64>:
static __inline Word64 SAR64(Word64 x, int n)
{
 800518e:	b4f0      	push	{r4, r5, r6, r7}
 8005190:	b084      	sub	sp, #16
 8005192:	af00      	add	r7, sp, #0
 8005194:	e9c7 0102 	strd	r0, r1, [r7, #8]
 8005198:	607a      	str	r2, [r7, #4]
	return x >> n;
 800519a:	e9d7 1202 	ldrd	r1, r2, [r7, #8]
 800519e:	6878      	ldr	r0, [r7, #4]
 80051a0:	f1c0 0620 	rsb	r6, r0, #32
 80051a4:	f1b0 0520 	subs.w	r5, r0, #32
 80051a8:	fa21 f300 	lsr.w	r3, r1, r0
 80051ac:	fa02 f606 	lsl.w	r6, r2, r6
 80051b0:	ea43 0306 	orr.w	r3, r3, r6
 80051b4:	d402      	bmi.n	80051bc <SAR64+0x2e>
 80051b6:	fa42 f505 	asr.w	r5, r2, r5
 80051ba:	432b      	orrs	r3, r5
 80051bc:	fa42 f400 	asr.w	r4, r2, r0

}
 80051c0:	4618      	mov	r0, r3
 80051c2:	4621      	mov	r1, r4
 80051c4:	3710      	adds	r7, #16
 80051c6:	46bd      	mov	sp, r7
 80051c8:	bcf0      	pop	{r4, r5, r6, r7}
 80051ca:	4770      	bx	lr

080051cc <ClipToShort>:
 */
#define DEF_NFRACBITS	(DQ_FRACBITS_OUT - 2 - 2 - 15)	
#define CSHIFT	12	/* coefficients have 12 leading sign bits for early-terminating mulitplies */

static __inline short ClipToShort(int x, int fracBits)
{
 80051cc:	b480      	push	{r7}
 80051ce:	b085      	sub	sp, #20
 80051d0:	af00      	add	r7, sp, #0
 80051d2:	6078      	str	r0, [r7, #4]
 80051d4:	6039      	str	r1, [r7, #0]
	int sign;
	
	/* assumes you've already rounded (x += (1 << (fracBits-1))) */
	x >>= fracBits;
 80051d6:	687a      	ldr	r2, [r7, #4]
 80051d8:	683b      	ldr	r3, [r7, #0]
 80051da:	fa42 f303 	asr.w	r3, r2, r3
 80051de:	607b      	str	r3, [r7, #4]
	
	/* Ken's trick: clips to [-32768, 32767] */
	sign = x >> 31;
 80051e0:	687b      	ldr	r3, [r7, #4]
 80051e2:	17db      	asrs	r3, r3, #31
 80051e4:	60fb      	str	r3, [r7, #12]
	if (sign != (x >> 15))
 80051e6:	687b      	ldr	r3, [r7, #4]
 80051e8:	13da      	asrs	r2, r3, #15
 80051ea:	68fb      	ldr	r3, [r7, #12]
 80051ec:	429a      	cmp	r2, r3
 80051ee:	d005      	beq.n	80051fc <ClipToShort+0x30>
		x = sign ^ ((1 << 15) - 1);
 80051f0:	68fb      	ldr	r3, [r7, #12]
 80051f2:	f483 43ff 	eor.w	r3, r3, #32640	; 0x7f80
 80051f6:	f083 037f 	eor.w	r3, r3, #127	; 0x7f
 80051fa:	607b      	str	r3, [r7, #4]

	return (short)x;
 80051fc:	687b      	ldr	r3, [r7, #4]
 80051fe:	b21b      	sxth	r3, r3
}
 8005200:	4618      	mov	r0, r3
 8005202:	3714      	adds	r7, #20
 8005204:	46bd      	mov	sp, r7
 8005206:	f85d 7b04 	ldr.w	r7, [sp], #4
 800520a:	4770      	bx	lr

0800520c <xmp3fixpt_PolyphaseMono>:
 *
 * TODO:        add 32-bit version for platforms where 64-bit mul-acc is not supported
 *                (note max filter gain - see polyCoef[] comments)
 **************************************************************************************/
void PolyphaseMono(short *pcm, int *vbuf, const int *coefBase)
{	
 800520c:	b590      	push	{r4, r7, lr}
 800520e:	b093      	sub	sp, #76	; 0x4c
 8005210:	af00      	add	r7, sp, #0
 8005212:	60f8      	str	r0, [r7, #12]
 8005214:	60b9      	str	r1, [r7, #8]
 8005216:	607a      	str	r2, [r7, #4]
	const int *coef;
	int *vb1;
	int vLo, vHi, c1, c2;
	Word64 sum1L, sum2L, rndVal;

	rndVal = (Word64)( 1 << (DEF_NFRACBITS - 1 + (32 - CSHIFT)) );
 8005218:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
 800521c:	f04f 0400 	mov.w	r4, #0
 8005220:	e9c7 340c 	strd	r3, r4, [r7, #48]	; 0x30

	/* special case, output sample 0 */
	coef = coefBase;
 8005224:	687b      	ldr	r3, [r7, #4]
 8005226:	643b      	str	r3, [r7, #64]	; 0x40
	vb1 = vbuf;
 8005228:	68bb      	ldr	r3, [r7, #8]
 800522a:	63fb      	str	r3, [r7, #60]	; 0x3c
	sum1L = rndVal;
 800522c:	e9d7 340c 	ldrd	r3, r4, [r7, #48]	; 0x30
 8005230:	e9c7 340a 	strd	r3, r4, [r7, #40]	; 0x28

	MC0M(0)
 8005234:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8005236:	681b      	ldr	r3, [r3, #0]
 8005238:	627b      	str	r3, [r7, #36]	; 0x24
 800523a:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800523c:	3304      	adds	r3, #4
 800523e:	643b      	str	r3, [r7, #64]	; 0x40
 8005240:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8005242:	681b      	ldr	r3, [r3, #0]
 8005244:	623b      	str	r3, [r7, #32]
 8005246:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8005248:	3304      	adds	r3, #4
 800524a:	643b      	str	r3, [r7, #64]	; 0x40
 800524c:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800524e:	681b      	ldr	r3, [r3, #0]
 8005250:	61fb      	str	r3, [r7, #28]
 8005252:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8005254:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 8005256:	61bb      	str	r3, [r7, #24]
 8005258:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800525a:	69fa      	ldr	r2, [r7, #28]
 800525c:	e9d7 010a 	ldrd	r0, r1, [r7, #40]	; 0x28
 8005260:	f7ff ff7a 	bl	8005158 <MADD64>
 8005264:	e9c7 010a 	strd	r0, r1, [r7, #40]	; 0x28
 8005268:	6a3b      	ldr	r3, [r7, #32]
 800526a:	425b      	negs	r3, r3
 800526c:	69ba      	ldr	r2, [r7, #24]
 800526e:	e9d7 010a 	ldrd	r0, r1, [r7, #40]	; 0x28
 8005272:	f7ff ff71 	bl	8005158 <MADD64>
 8005276:	e9c7 010a 	strd	r0, r1, [r7, #40]	; 0x28
	MC0M(1)
 800527a:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800527c:	681b      	ldr	r3, [r3, #0]
 800527e:	627b      	str	r3, [r7, #36]	; 0x24
 8005280:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8005282:	3304      	adds	r3, #4
 8005284:	643b      	str	r3, [r7, #64]	; 0x40
 8005286:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8005288:	681b      	ldr	r3, [r3, #0]
 800528a:	623b      	str	r3, [r7, #32]
 800528c:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800528e:	3304      	adds	r3, #4
 8005290:	643b      	str	r3, [r7, #64]	; 0x40
 8005292:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8005294:	685b      	ldr	r3, [r3, #4]
 8005296:	61fb      	str	r3, [r7, #28]
 8005298:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800529a:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 800529c:	61bb      	str	r3, [r7, #24]
 800529e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80052a0:	69fa      	ldr	r2, [r7, #28]
 80052a2:	e9d7 010a 	ldrd	r0, r1, [r7, #40]	; 0x28
 80052a6:	f7ff ff57 	bl	8005158 <MADD64>
 80052aa:	e9c7 010a 	strd	r0, r1, [r7, #40]	; 0x28
 80052ae:	6a3b      	ldr	r3, [r7, #32]
 80052b0:	425b      	negs	r3, r3
 80052b2:	69ba      	ldr	r2, [r7, #24]
 80052b4:	e9d7 010a 	ldrd	r0, r1, [r7, #40]	; 0x28
 80052b8:	f7ff ff4e 	bl	8005158 <MADD64>
 80052bc:	e9c7 010a 	strd	r0, r1, [r7, #40]	; 0x28
	MC0M(2)
 80052c0:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 80052c2:	681b      	ldr	r3, [r3, #0]
 80052c4:	627b      	str	r3, [r7, #36]	; 0x24
 80052c6:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 80052c8:	3304      	adds	r3, #4
 80052ca:	643b      	str	r3, [r7, #64]	; 0x40
 80052cc:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 80052ce:	681b      	ldr	r3, [r3, #0]
 80052d0:	623b      	str	r3, [r7, #32]
 80052d2:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 80052d4:	3304      	adds	r3, #4
 80052d6:	643b      	str	r3, [r7, #64]	; 0x40
 80052d8:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 80052da:	689b      	ldr	r3, [r3, #8]
 80052dc:	61fb      	str	r3, [r7, #28]
 80052de:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 80052e0:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 80052e2:	61bb      	str	r3, [r7, #24]
 80052e4:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80052e6:	69fa      	ldr	r2, [r7, #28]
 80052e8:	e9d7 010a 	ldrd	r0, r1, [r7, #40]	; 0x28
 80052ec:	f7ff ff34 	bl	8005158 <MADD64>
 80052f0:	e9c7 010a 	strd	r0, r1, [r7, #40]	; 0x28
 80052f4:	6a3b      	ldr	r3, [r7, #32]
 80052f6:	425b      	negs	r3, r3
 80052f8:	69ba      	ldr	r2, [r7, #24]
 80052fa:	e9d7 010a 	ldrd	r0, r1, [r7, #40]	; 0x28
 80052fe:	f7ff ff2b 	bl	8005158 <MADD64>
 8005302:	e9c7 010a 	strd	r0, r1, [r7, #40]	; 0x28
	MC0M(3)
 8005306:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8005308:	681b      	ldr	r3, [r3, #0]
 800530a:	627b      	str	r3, [r7, #36]	; 0x24
 800530c:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800530e:	3304      	adds	r3, #4
 8005310:	643b      	str	r3, [r7, #64]	; 0x40
 8005312:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8005314:	681b      	ldr	r3, [r3, #0]
 8005316:	623b      	str	r3, [r7, #32]
 8005318:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800531a:	3304      	adds	r3, #4
 800531c:	643b      	str	r3, [r7, #64]	; 0x40
 800531e:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8005320:	68db      	ldr	r3, [r3, #12]
 8005322:	61fb      	str	r3, [r7, #28]
 8005324:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8005326:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 8005328:	61bb      	str	r3, [r7, #24]
 800532a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800532c:	69fa      	ldr	r2, [r7, #28]
 800532e:	e9d7 010a 	ldrd	r0, r1, [r7, #40]	; 0x28
 8005332:	f7ff ff11 	bl	8005158 <MADD64>
 8005336:	e9c7 010a 	strd	r0, r1, [r7, #40]	; 0x28
 800533a:	6a3b      	ldr	r3, [r7, #32]
 800533c:	425b      	negs	r3, r3
 800533e:	69ba      	ldr	r2, [r7, #24]
 8005340:	e9d7 010a 	ldrd	r0, r1, [r7, #40]	; 0x28
 8005344:	f7ff ff08 	bl	8005158 <MADD64>
 8005348:	e9c7 010a 	strd	r0, r1, [r7, #40]	; 0x28
	MC0M(4)
 800534c:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800534e:	681b      	ldr	r3, [r3, #0]
 8005350:	627b      	str	r3, [r7, #36]	; 0x24
 8005352:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8005354:	3304      	adds	r3, #4
 8005356:	643b      	str	r3, [r7, #64]	; 0x40
 8005358:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800535a:	681b      	ldr	r3, [r3, #0]
 800535c:	623b      	str	r3, [r7, #32]
 800535e:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8005360:	3304      	adds	r3, #4
 8005362:	643b      	str	r3, [r7, #64]	; 0x40
 8005364:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8005366:	691b      	ldr	r3, [r3, #16]
 8005368:	61fb      	str	r3, [r7, #28]
 800536a:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800536c:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 800536e:	61bb      	str	r3, [r7, #24]
 8005370:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8005372:	69fa      	ldr	r2, [r7, #28]
 8005374:	e9d7 010a 	ldrd	r0, r1, [r7, #40]	; 0x28
 8005378:	f7ff feee 	bl	8005158 <MADD64>
 800537c:	e9c7 010a 	strd	r0, r1, [r7, #40]	; 0x28
 8005380:	6a3b      	ldr	r3, [r7, #32]
 8005382:	425b      	negs	r3, r3
 8005384:	69ba      	ldr	r2, [r7, #24]
 8005386:	e9d7 010a 	ldrd	r0, r1, [r7, #40]	; 0x28
 800538a:	f7ff fee5 	bl	8005158 <MADD64>
 800538e:	e9c7 010a 	strd	r0, r1, [r7, #40]	; 0x28
	MC0M(5)
 8005392:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8005394:	681b      	ldr	r3, [r3, #0]
 8005396:	627b      	str	r3, [r7, #36]	; 0x24
 8005398:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800539a:	3304      	adds	r3, #4
 800539c:	643b      	str	r3, [r7, #64]	; 0x40
 800539e:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 80053a0:	681b      	ldr	r3, [r3, #0]
 80053a2:	623b      	str	r3, [r7, #32]
 80053a4:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 80053a6:	3304      	adds	r3, #4
 80053a8:	643b      	str	r3, [r7, #64]	; 0x40
 80053aa:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 80053ac:	695b      	ldr	r3, [r3, #20]
 80053ae:	61fb      	str	r3, [r7, #28]
 80053b0:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 80053b2:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 80053b4:	61bb      	str	r3, [r7, #24]
 80053b6:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80053b8:	69fa      	ldr	r2, [r7, #28]
 80053ba:	e9d7 010a 	ldrd	r0, r1, [r7, #40]	; 0x28
 80053be:	f7ff fecb 	bl	8005158 <MADD64>
 80053c2:	e9c7 010a 	strd	r0, r1, [r7, #40]	; 0x28
 80053c6:	6a3b      	ldr	r3, [r7, #32]
 80053c8:	425b      	negs	r3, r3
 80053ca:	69ba      	ldr	r2, [r7, #24]
 80053cc:	e9d7 010a 	ldrd	r0, r1, [r7, #40]	; 0x28
 80053d0:	f7ff fec2 	bl	8005158 <MADD64>
 80053d4:	e9c7 010a 	strd	r0, r1, [r7, #40]	; 0x28
	MC0M(6)
 80053d8:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 80053da:	681b      	ldr	r3, [r3, #0]
 80053dc:	627b      	str	r3, [r7, #36]	; 0x24
 80053de:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 80053e0:	3304      	adds	r3, #4
 80053e2:	643b      	str	r3, [r7, #64]	; 0x40
 80053e4:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 80053e6:	681b      	ldr	r3, [r3, #0]
 80053e8:	623b      	str	r3, [r7, #32]
 80053ea:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 80053ec:	3304      	adds	r3, #4
 80053ee:	643b      	str	r3, [r7, #64]	; 0x40
 80053f0:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 80053f2:	699b      	ldr	r3, [r3, #24]
 80053f4:	61fb      	str	r3, [r7, #28]
 80053f6:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 80053f8:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 80053fa:	61bb      	str	r3, [r7, #24]
 80053fc:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80053fe:	69fa      	ldr	r2, [r7, #28]
 8005400:	e9d7 010a 	ldrd	r0, r1, [r7, #40]	; 0x28
 8005404:	f7ff fea8 	bl	8005158 <MADD64>
 8005408:	e9c7 010a 	strd	r0, r1, [r7, #40]	; 0x28
 800540c:	6a3b      	ldr	r3, [r7, #32]
 800540e:	425b      	negs	r3, r3
 8005410:	69ba      	ldr	r2, [r7, #24]
 8005412:	e9d7 010a 	ldrd	r0, r1, [r7, #40]	; 0x28
 8005416:	f7ff fe9f 	bl	8005158 <MADD64>
 800541a:	e9c7 010a 	strd	r0, r1, [r7, #40]	; 0x28
	MC0M(7)
 800541e:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8005420:	681b      	ldr	r3, [r3, #0]
 8005422:	627b      	str	r3, [r7, #36]	; 0x24
 8005424:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8005426:	3304      	adds	r3, #4
 8005428:	643b      	str	r3, [r7, #64]	; 0x40
 800542a:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800542c:	681b      	ldr	r3, [r3, #0]
 800542e:	623b      	str	r3, [r7, #32]
 8005430:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8005432:	3304      	adds	r3, #4
 8005434:	643b      	str	r3, [r7, #64]	; 0x40
 8005436:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8005438:	69db      	ldr	r3, [r3, #28]
 800543a:	61fb      	str	r3, [r7, #28]
 800543c:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800543e:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8005440:	61bb      	str	r3, [r7, #24]
 8005442:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8005444:	69fa      	ldr	r2, [r7, #28]
 8005446:	e9d7 010a 	ldrd	r0, r1, [r7, #40]	; 0x28
 800544a:	f7ff fe85 	bl	8005158 <MADD64>
 800544e:	e9c7 010a 	strd	r0, r1, [r7, #40]	; 0x28
 8005452:	6a3b      	ldr	r3, [r7, #32]
 8005454:	425b      	negs	r3, r3
 8005456:	69ba      	ldr	r2, [r7, #24]
 8005458:	e9d7 010a 	ldrd	r0, r1, [r7, #40]	; 0x28
 800545c:	f7ff fe7c 	bl	8005158 <MADD64>
 8005460:	e9c7 010a 	strd	r0, r1, [r7, #40]	; 0x28

	*(pcm + 0) = ClipToShort((int)SAR64(sum1L, (32-CSHIFT)), DEF_NFRACBITS);
 8005464:	2214      	movs	r2, #20
 8005466:	e9d7 010a 	ldrd	r0, r1, [r7, #40]	; 0x28
 800546a:	f7ff fe90 	bl	800518e <SAR64>
 800546e:	4603      	mov	r3, r0
 8005470:	460c      	mov	r4, r1
 8005472:	2106      	movs	r1, #6
 8005474:	4618      	mov	r0, r3
 8005476:	f7ff fea9 	bl	80051cc <ClipToShort>
 800547a:	4603      	mov	r3, r0
 800547c:	461a      	mov	r2, r3
 800547e:	68fb      	ldr	r3, [r7, #12]
 8005480:	801a      	strh	r2, [r3, #0]

	/* special case, output sample 16 */
	coef = coefBase + 256;
 8005482:	687b      	ldr	r3, [r7, #4]
 8005484:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 8005488:	643b      	str	r3, [r7, #64]	; 0x40
	vb1 = vbuf + 64*16;
 800548a:	68bb      	ldr	r3, [r7, #8]
 800548c:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 8005490:	63fb      	str	r3, [r7, #60]	; 0x3c
	sum1L = rndVal;
 8005492:	e9d7 340c 	ldrd	r3, r4, [r7, #48]	; 0x30
 8005496:	e9c7 340a 	strd	r3, r4, [r7, #40]	; 0x28

	MC1M(0)
 800549a:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800549c:	681b      	ldr	r3, [r3, #0]
 800549e:	627b      	str	r3, [r7, #36]	; 0x24
 80054a0:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 80054a2:	3304      	adds	r3, #4
 80054a4:	643b      	str	r3, [r7, #64]	; 0x40
 80054a6:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 80054a8:	681b      	ldr	r3, [r3, #0]
 80054aa:	61fb      	str	r3, [r7, #28]
 80054ac:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80054ae:	69fa      	ldr	r2, [r7, #28]
 80054b0:	e9d7 010a 	ldrd	r0, r1, [r7, #40]	; 0x28
 80054b4:	f7ff fe50 	bl	8005158 <MADD64>
 80054b8:	e9c7 010a 	strd	r0, r1, [r7, #40]	; 0x28
	MC1M(1)
 80054bc:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 80054be:	681b      	ldr	r3, [r3, #0]
 80054c0:	627b      	str	r3, [r7, #36]	; 0x24
 80054c2:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 80054c4:	3304      	adds	r3, #4
 80054c6:	643b      	str	r3, [r7, #64]	; 0x40
 80054c8:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 80054ca:	685b      	ldr	r3, [r3, #4]
 80054cc:	61fb      	str	r3, [r7, #28]
 80054ce:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80054d0:	69fa      	ldr	r2, [r7, #28]
 80054d2:	e9d7 010a 	ldrd	r0, r1, [r7, #40]	; 0x28
 80054d6:	f7ff fe3f 	bl	8005158 <MADD64>
 80054da:	e9c7 010a 	strd	r0, r1, [r7, #40]	; 0x28
	MC1M(2)
 80054de:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 80054e0:	681b      	ldr	r3, [r3, #0]
 80054e2:	627b      	str	r3, [r7, #36]	; 0x24
 80054e4:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 80054e6:	3304      	adds	r3, #4
 80054e8:	643b      	str	r3, [r7, #64]	; 0x40
 80054ea:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 80054ec:	689b      	ldr	r3, [r3, #8]
 80054ee:	61fb      	str	r3, [r7, #28]
 80054f0:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80054f2:	69fa      	ldr	r2, [r7, #28]
 80054f4:	e9d7 010a 	ldrd	r0, r1, [r7, #40]	; 0x28
 80054f8:	f7ff fe2e 	bl	8005158 <MADD64>
 80054fc:	e9c7 010a 	strd	r0, r1, [r7, #40]	; 0x28
	MC1M(3)
 8005500:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8005502:	681b      	ldr	r3, [r3, #0]
 8005504:	627b      	str	r3, [r7, #36]	; 0x24
 8005506:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8005508:	3304      	adds	r3, #4
 800550a:	643b      	str	r3, [r7, #64]	; 0x40
 800550c:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800550e:	68db      	ldr	r3, [r3, #12]
 8005510:	61fb      	str	r3, [r7, #28]
 8005512:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8005514:	69fa      	ldr	r2, [r7, #28]
 8005516:	e9d7 010a 	ldrd	r0, r1, [r7, #40]	; 0x28
 800551a:	f7ff fe1d 	bl	8005158 <MADD64>
 800551e:	e9c7 010a 	strd	r0, r1, [r7, #40]	; 0x28
	MC1M(4)
 8005522:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8005524:	681b      	ldr	r3, [r3, #0]
 8005526:	627b      	str	r3, [r7, #36]	; 0x24
 8005528:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800552a:	3304      	adds	r3, #4
 800552c:	643b      	str	r3, [r7, #64]	; 0x40
 800552e:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8005530:	691b      	ldr	r3, [r3, #16]
 8005532:	61fb      	str	r3, [r7, #28]
 8005534:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8005536:	69fa      	ldr	r2, [r7, #28]
 8005538:	e9d7 010a 	ldrd	r0, r1, [r7, #40]	; 0x28
 800553c:	f7ff fe0c 	bl	8005158 <MADD64>
 8005540:	e9c7 010a 	strd	r0, r1, [r7, #40]	; 0x28
	MC1M(5)
 8005544:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8005546:	681b      	ldr	r3, [r3, #0]
 8005548:	627b      	str	r3, [r7, #36]	; 0x24
 800554a:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800554c:	3304      	adds	r3, #4
 800554e:	643b      	str	r3, [r7, #64]	; 0x40
 8005550:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8005552:	695b      	ldr	r3, [r3, #20]
 8005554:	61fb      	str	r3, [r7, #28]
 8005556:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8005558:	69fa      	ldr	r2, [r7, #28]
 800555a:	e9d7 010a 	ldrd	r0, r1, [r7, #40]	; 0x28
 800555e:	f7ff fdfb 	bl	8005158 <MADD64>
 8005562:	e9c7 010a 	strd	r0, r1, [r7, #40]	; 0x28
	MC1M(6)
 8005566:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8005568:	681b      	ldr	r3, [r3, #0]
 800556a:	627b      	str	r3, [r7, #36]	; 0x24
 800556c:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800556e:	3304      	adds	r3, #4
 8005570:	643b      	str	r3, [r7, #64]	; 0x40
 8005572:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8005574:	699b      	ldr	r3, [r3, #24]
 8005576:	61fb      	str	r3, [r7, #28]
 8005578:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800557a:	69fa      	ldr	r2, [r7, #28]
 800557c:	e9d7 010a 	ldrd	r0, r1, [r7, #40]	; 0x28
 8005580:	f7ff fdea 	bl	8005158 <MADD64>
 8005584:	e9c7 010a 	strd	r0, r1, [r7, #40]	; 0x28
	MC1M(7)
 8005588:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800558a:	681b      	ldr	r3, [r3, #0]
 800558c:	627b      	str	r3, [r7, #36]	; 0x24
 800558e:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8005590:	3304      	adds	r3, #4
 8005592:	643b      	str	r3, [r7, #64]	; 0x40
 8005594:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8005596:	69db      	ldr	r3, [r3, #28]
 8005598:	61fb      	str	r3, [r7, #28]
 800559a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800559c:	69fa      	ldr	r2, [r7, #28]
 800559e:	e9d7 010a 	ldrd	r0, r1, [r7, #40]	; 0x28
 80055a2:	f7ff fdd9 	bl	8005158 <MADD64>
 80055a6:	e9c7 010a 	strd	r0, r1, [r7, #40]	; 0x28

	*(pcm + 16) = ClipToShort((int)SAR64(sum1L, (32-CSHIFT)), DEF_NFRACBITS);
 80055aa:	68fb      	ldr	r3, [r7, #12]
 80055ac:	f103 0420 	add.w	r4, r3, #32
 80055b0:	2214      	movs	r2, #20
 80055b2:	e9d7 010a 	ldrd	r0, r1, [r7, #40]	; 0x28
 80055b6:	f7ff fdea 	bl	800518e <SAR64>
 80055ba:	4602      	mov	r2, r0
 80055bc:	460b      	mov	r3, r1
 80055be:	4613      	mov	r3, r2
 80055c0:	2106      	movs	r1, #6
 80055c2:	4618      	mov	r0, r3
 80055c4:	f7ff fe02 	bl	80051cc <ClipToShort>
 80055c8:	4603      	mov	r3, r0
 80055ca:	8023      	strh	r3, [r4, #0]

	/* main convolution loop: sum1L = samples 1, 2, 3, ... 15   sum2L = samples 31, 30, ... 17 */
	coef = coefBase + 16;
 80055cc:	687b      	ldr	r3, [r7, #4]
 80055ce:	3340      	adds	r3, #64	; 0x40
 80055d0:	643b      	str	r3, [r7, #64]	; 0x40
	vb1 = vbuf + 64;
 80055d2:	68bb      	ldr	r3, [r7, #8]
 80055d4:	f503 7380 	add.w	r3, r3, #256	; 0x100
 80055d8:	63fb      	str	r3, [r7, #60]	; 0x3c
	pcm++;
 80055da:	68fb      	ldr	r3, [r7, #12]
 80055dc:	3302      	adds	r3, #2
 80055de:	60fb      	str	r3, [r7, #12]

	/* right now, the compiler creates bad asm from this... */
	for (i = 15; i > 0; i--) {
 80055e0:	230f      	movs	r3, #15
 80055e2:	647b      	str	r3, [r7, #68]	; 0x44
 80055e4:	e1cb      	b.n	800597e <xmp3fixpt_PolyphaseMono+0x772>
		sum1L = sum2L = rndVal;
 80055e6:	e9d7 340c 	ldrd	r3, r4, [r7, #48]	; 0x30
 80055ea:	e9c7 3404 	strd	r3, r4, [r7, #16]
 80055ee:	e9d7 3404 	ldrd	r3, r4, [r7, #16]
 80055f2:	e9c7 340a 	strd	r3, r4, [r7, #40]	; 0x28

		MC2M(0)
 80055f6:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 80055f8:	681b      	ldr	r3, [r3, #0]
 80055fa:	627b      	str	r3, [r7, #36]	; 0x24
 80055fc:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 80055fe:	3304      	adds	r3, #4
 8005600:	643b      	str	r3, [r7, #64]	; 0x40
 8005602:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8005604:	681b      	ldr	r3, [r3, #0]
 8005606:	623b      	str	r3, [r7, #32]
 8005608:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800560a:	3304      	adds	r3, #4
 800560c:	643b      	str	r3, [r7, #64]	; 0x40
 800560e:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8005610:	681b      	ldr	r3, [r3, #0]
 8005612:	61fb      	str	r3, [r7, #28]
 8005614:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8005616:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 8005618:	61bb      	str	r3, [r7, #24]
 800561a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800561c:	69fa      	ldr	r2, [r7, #28]
 800561e:	e9d7 010a 	ldrd	r0, r1, [r7, #40]	; 0x28
 8005622:	f7ff fd99 	bl	8005158 <MADD64>
 8005626:	e9c7 010a 	strd	r0, r1, [r7, #40]	; 0x28
 800562a:	6a3b      	ldr	r3, [r7, #32]
 800562c:	69fa      	ldr	r2, [r7, #28]
 800562e:	e9d7 0104 	ldrd	r0, r1, [r7, #16]
 8005632:	f7ff fd91 	bl	8005158 <MADD64>
 8005636:	e9c7 0104 	strd	r0, r1, [r7, #16]
 800563a:	6a3b      	ldr	r3, [r7, #32]
 800563c:	425b      	negs	r3, r3
 800563e:	69ba      	ldr	r2, [r7, #24]
 8005640:	e9d7 010a 	ldrd	r0, r1, [r7, #40]	; 0x28
 8005644:	f7ff fd88 	bl	8005158 <MADD64>
 8005648:	e9c7 010a 	strd	r0, r1, [r7, #40]	; 0x28
 800564c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800564e:	69ba      	ldr	r2, [r7, #24]
 8005650:	e9d7 0104 	ldrd	r0, r1, [r7, #16]
 8005654:	f7ff fd80 	bl	8005158 <MADD64>
 8005658:	e9c7 0104 	strd	r0, r1, [r7, #16]
		MC2M(1)
 800565c:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800565e:	681b      	ldr	r3, [r3, #0]
 8005660:	627b      	str	r3, [r7, #36]	; 0x24
 8005662:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8005664:	3304      	adds	r3, #4
 8005666:	643b      	str	r3, [r7, #64]	; 0x40
 8005668:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800566a:	681b      	ldr	r3, [r3, #0]
 800566c:	623b      	str	r3, [r7, #32]
 800566e:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8005670:	3304      	adds	r3, #4
 8005672:	643b      	str	r3, [r7, #64]	; 0x40
 8005674:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8005676:	685b      	ldr	r3, [r3, #4]
 8005678:	61fb      	str	r3, [r7, #28]
 800567a:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800567c:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 800567e:	61bb      	str	r3, [r7, #24]
 8005680:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8005682:	69fa      	ldr	r2, [r7, #28]
 8005684:	e9d7 010a 	ldrd	r0, r1, [r7, #40]	; 0x28
 8005688:	f7ff fd66 	bl	8005158 <MADD64>
 800568c:	e9c7 010a 	strd	r0, r1, [r7, #40]	; 0x28
 8005690:	6a3b      	ldr	r3, [r7, #32]
 8005692:	69fa      	ldr	r2, [r7, #28]
 8005694:	e9d7 0104 	ldrd	r0, r1, [r7, #16]
 8005698:	f7ff fd5e 	bl	8005158 <MADD64>
 800569c:	e9c7 0104 	strd	r0, r1, [r7, #16]
 80056a0:	6a3b      	ldr	r3, [r7, #32]
 80056a2:	425b      	negs	r3, r3
 80056a4:	69ba      	ldr	r2, [r7, #24]
 80056a6:	e9d7 010a 	ldrd	r0, r1, [r7, #40]	; 0x28
 80056aa:	f7ff fd55 	bl	8005158 <MADD64>
 80056ae:	e9c7 010a 	strd	r0, r1, [r7, #40]	; 0x28
 80056b2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80056b4:	69ba      	ldr	r2, [r7, #24]
 80056b6:	e9d7 0104 	ldrd	r0, r1, [r7, #16]
 80056ba:	f7ff fd4d 	bl	8005158 <MADD64>
 80056be:	e9c7 0104 	strd	r0, r1, [r7, #16]
		MC2M(2)
 80056c2:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 80056c4:	681b      	ldr	r3, [r3, #0]
 80056c6:	627b      	str	r3, [r7, #36]	; 0x24
 80056c8:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 80056ca:	3304      	adds	r3, #4
 80056cc:	643b      	str	r3, [r7, #64]	; 0x40
 80056ce:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 80056d0:	681b      	ldr	r3, [r3, #0]
 80056d2:	623b      	str	r3, [r7, #32]
 80056d4:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 80056d6:	3304      	adds	r3, #4
 80056d8:	643b      	str	r3, [r7, #64]	; 0x40
 80056da:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 80056dc:	689b      	ldr	r3, [r3, #8]
 80056de:	61fb      	str	r3, [r7, #28]
 80056e0:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 80056e2:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 80056e4:	61bb      	str	r3, [r7, #24]
 80056e6:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80056e8:	69fa      	ldr	r2, [r7, #28]
 80056ea:	e9d7 010a 	ldrd	r0, r1, [r7, #40]	; 0x28
 80056ee:	f7ff fd33 	bl	8005158 <MADD64>
 80056f2:	e9c7 010a 	strd	r0, r1, [r7, #40]	; 0x28
 80056f6:	6a3b      	ldr	r3, [r7, #32]
 80056f8:	69fa      	ldr	r2, [r7, #28]
 80056fa:	e9d7 0104 	ldrd	r0, r1, [r7, #16]
 80056fe:	f7ff fd2b 	bl	8005158 <MADD64>
 8005702:	e9c7 0104 	strd	r0, r1, [r7, #16]
 8005706:	6a3b      	ldr	r3, [r7, #32]
 8005708:	425b      	negs	r3, r3
 800570a:	69ba      	ldr	r2, [r7, #24]
 800570c:	e9d7 010a 	ldrd	r0, r1, [r7, #40]	; 0x28
 8005710:	f7ff fd22 	bl	8005158 <MADD64>
 8005714:	e9c7 010a 	strd	r0, r1, [r7, #40]	; 0x28
 8005718:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800571a:	69ba      	ldr	r2, [r7, #24]
 800571c:	e9d7 0104 	ldrd	r0, r1, [r7, #16]
 8005720:	f7ff fd1a 	bl	8005158 <MADD64>
 8005724:	e9c7 0104 	strd	r0, r1, [r7, #16]
		MC2M(3)
 8005728:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800572a:	681b      	ldr	r3, [r3, #0]
 800572c:	627b      	str	r3, [r7, #36]	; 0x24
 800572e:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8005730:	3304      	adds	r3, #4
 8005732:	643b      	str	r3, [r7, #64]	; 0x40
 8005734:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8005736:	681b      	ldr	r3, [r3, #0]
 8005738:	623b      	str	r3, [r7, #32]
 800573a:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800573c:	3304      	adds	r3, #4
 800573e:	643b      	str	r3, [r7, #64]	; 0x40
 8005740:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8005742:	68db      	ldr	r3, [r3, #12]
 8005744:	61fb      	str	r3, [r7, #28]
 8005746:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8005748:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 800574a:	61bb      	str	r3, [r7, #24]
 800574c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800574e:	69fa      	ldr	r2, [r7, #28]
 8005750:	e9d7 010a 	ldrd	r0, r1, [r7, #40]	; 0x28
 8005754:	f7ff fd00 	bl	8005158 <MADD64>
 8005758:	e9c7 010a 	strd	r0, r1, [r7, #40]	; 0x28
 800575c:	6a3b      	ldr	r3, [r7, #32]
 800575e:	69fa      	ldr	r2, [r7, #28]
 8005760:	e9d7 0104 	ldrd	r0, r1, [r7, #16]
 8005764:	f7ff fcf8 	bl	8005158 <MADD64>
 8005768:	e9c7 0104 	strd	r0, r1, [r7, #16]
 800576c:	6a3b      	ldr	r3, [r7, #32]
 800576e:	425b      	negs	r3, r3
 8005770:	69ba      	ldr	r2, [r7, #24]
 8005772:	e9d7 010a 	ldrd	r0, r1, [r7, #40]	; 0x28
 8005776:	f7ff fcef 	bl	8005158 <MADD64>
 800577a:	e9c7 010a 	strd	r0, r1, [r7, #40]	; 0x28
 800577e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8005780:	69ba      	ldr	r2, [r7, #24]
 8005782:	e9d7 0104 	ldrd	r0, r1, [r7, #16]
 8005786:	f7ff fce7 	bl	8005158 <MADD64>
 800578a:	e9c7 0104 	strd	r0, r1, [r7, #16]
		MC2M(4)
 800578e:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8005790:	681b      	ldr	r3, [r3, #0]
 8005792:	627b      	str	r3, [r7, #36]	; 0x24
 8005794:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8005796:	3304      	adds	r3, #4
 8005798:	643b      	str	r3, [r7, #64]	; 0x40
 800579a:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800579c:	681b      	ldr	r3, [r3, #0]
 800579e:	623b      	str	r3, [r7, #32]
 80057a0:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 80057a2:	3304      	adds	r3, #4
 80057a4:	643b      	str	r3, [r7, #64]	; 0x40
 80057a6:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 80057a8:	691b      	ldr	r3, [r3, #16]
 80057aa:	61fb      	str	r3, [r7, #28]
 80057ac:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 80057ae:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 80057b0:	61bb      	str	r3, [r7, #24]
 80057b2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80057b4:	69fa      	ldr	r2, [r7, #28]
 80057b6:	e9d7 010a 	ldrd	r0, r1, [r7, #40]	; 0x28
 80057ba:	f7ff fccd 	bl	8005158 <MADD64>
 80057be:	e9c7 010a 	strd	r0, r1, [r7, #40]	; 0x28
 80057c2:	6a3b      	ldr	r3, [r7, #32]
 80057c4:	69fa      	ldr	r2, [r7, #28]
 80057c6:	e9d7 0104 	ldrd	r0, r1, [r7, #16]
 80057ca:	f7ff fcc5 	bl	8005158 <MADD64>
 80057ce:	e9c7 0104 	strd	r0, r1, [r7, #16]
 80057d2:	6a3b      	ldr	r3, [r7, #32]
 80057d4:	425b      	negs	r3, r3
 80057d6:	69ba      	ldr	r2, [r7, #24]
 80057d8:	e9d7 010a 	ldrd	r0, r1, [r7, #40]	; 0x28
 80057dc:	f7ff fcbc 	bl	8005158 <MADD64>
 80057e0:	e9c7 010a 	strd	r0, r1, [r7, #40]	; 0x28
 80057e4:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80057e6:	69ba      	ldr	r2, [r7, #24]
 80057e8:	e9d7 0104 	ldrd	r0, r1, [r7, #16]
 80057ec:	f7ff fcb4 	bl	8005158 <MADD64>
 80057f0:	e9c7 0104 	strd	r0, r1, [r7, #16]
		MC2M(5)
 80057f4:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 80057f6:	681b      	ldr	r3, [r3, #0]
 80057f8:	627b      	str	r3, [r7, #36]	; 0x24
 80057fa:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 80057fc:	3304      	adds	r3, #4
 80057fe:	643b      	str	r3, [r7, #64]	; 0x40
 8005800:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8005802:	681b      	ldr	r3, [r3, #0]
 8005804:	623b      	str	r3, [r7, #32]
 8005806:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8005808:	3304      	adds	r3, #4
 800580a:	643b      	str	r3, [r7, #64]	; 0x40
 800580c:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800580e:	695b      	ldr	r3, [r3, #20]
 8005810:	61fb      	str	r3, [r7, #28]
 8005812:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8005814:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8005816:	61bb      	str	r3, [r7, #24]
 8005818:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800581a:	69fa      	ldr	r2, [r7, #28]
 800581c:	e9d7 010a 	ldrd	r0, r1, [r7, #40]	; 0x28
 8005820:	f7ff fc9a 	bl	8005158 <MADD64>
 8005824:	e9c7 010a 	strd	r0, r1, [r7, #40]	; 0x28
 8005828:	6a3b      	ldr	r3, [r7, #32]
 800582a:	69fa      	ldr	r2, [r7, #28]
 800582c:	e9d7 0104 	ldrd	r0, r1, [r7, #16]
 8005830:	f7ff fc92 	bl	8005158 <MADD64>
 8005834:	e9c7 0104 	strd	r0, r1, [r7, #16]
 8005838:	6a3b      	ldr	r3, [r7, #32]
 800583a:	425b      	negs	r3, r3
 800583c:	69ba      	ldr	r2, [r7, #24]
 800583e:	e9d7 010a 	ldrd	r0, r1, [r7, #40]	; 0x28
 8005842:	f7ff fc89 	bl	8005158 <MADD64>
 8005846:	e9c7 010a 	strd	r0, r1, [r7, #40]	; 0x28
 800584a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800584c:	69ba      	ldr	r2, [r7, #24]
 800584e:	e9d7 0104 	ldrd	r0, r1, [r7, #16]
 8005852:	f7ff fc81 	bl	8005158 <MADD64>
 8005856:	e9c7 0104 	strd	r0, r1, [r7, #16]
		MC2M(6)
 800585a:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800585c:	681b      	ldr	r3, [r3, #0]
 800585e:	627b      	str	r3, [r7, #36]	; 0x24
 8005860:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8005862:	3304      	adds	r3, #4
 8005864:	643b      	str	r3, [r7, #64]	; 0x40
 8005866:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8005868:	681b      	ldr	r3, [r3, #0]
 800586a:	623b      	str	r3, [r7, #32]
 800586c:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800586e:	3304      	adds	r3, #4
 8005870:	643b      	str	r3, [r7, #64]	; 0x40
 8005872:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8005874:	699b      	ldr	r3, [r3, #24]
 8005876:	61fb      	str	r3, [r7, #28]
 8005878:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800587a:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800587c:	61bb      	str	r3, [r7, #24]
 800587e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8005880:	69fa      	ldr	r2, [r7, #28]
 8005882:	e9d7 010a 	ldrd	r0, r1, [r7, #40]	; 0x28
 8005886:	f7ff fc67 	bl	8005158 <MADD64>
 800588a:	e9c7 010a 	strd	r0, r1, [r7, #40]	; 0x28
 800588e:	6a3b      	ldr	r3, [r7, #32]
 8005890:	69fa      	ldr	r2, [r7, #28]
 8005892:	e9d7 0104 	ldrd	r0, r1, [r7, #16]
 8005896:	f7ff fc5f 	bl	8005158 <MADD64>
 800589a:	e9c7 0104 	strd	r0, r1, [r7, #16]
 800589e:	6a3b      	ldr	r3, [r7, #32]
 80058a0:	425b      	negs	r3, r3
 80058a2:	69ba      	ldr	r2, [r7, #24]
 80058a4:	e9d7 010a 	ldrd	r0, r1, [r7, #40]	; 0x28
 80058a8:	f7ff fc56 	bl	8005158 <MADD64>
 80058ac:	e9c7 010a 	strd	r0, r1, [r7, #40]	; 0x28
 80058b0:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80058b2:	69ba      	ldr	r2, [r7, #24]
 80058b4:	e9d7 0104 	ldrd	r0, r1, [r7, #16]
 80058b8:	f7ff fc4e 	bl	8005158 <MADD64>
 80058bc:	e9c7 0104 	strd	r0, r1, [r7, #16]
		MC2M(7)
 80058c0:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 80058c2:	681b      	ldr	r3, [r3, #0]
 80058c4:	627b      	str	r3, [r7, #36]	; 0x24
 80058c6:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 80058c8:	3304      	adds	r3, #4
 80058ca:	643b      	str	r3, [r7, #64]	; 0x40
 80058cc:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 80058ce:	681b      	ldr	r3, [r3, #0]
 80058d0:	623b      	str	r3, [r7, #32]
 80058d2:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 80058d4:	3304      	adds	r3, #4
 80058d6:	643b      	str	r3, [r7, #64]	; 0x40
 80058d8:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 80058da:	69db      	ldr	r3, [r3, #28]
 80058dc:	61fb      	str	r3, [r7, #28]
 80058de:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 80058e0:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 80058e2:	61bb      	str	r3, [r7, #24]
 80058e4:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80058e6:	69fa      	ldr	r2, [r7, #28]
 80058e8:	e9d7 010a 	ldrd	r0, r1, [r7, #40]	; 0x28
 80058ec:	f7ff fc34 	bl	8005158 <MADD64>
 80058f0:	e9c7 010a 	strd	r0, r1, [r7, #40]	; 0x28
 80058f4:	6a3b      	ldr	r3, [r7, #32]
 80058f6:	69fa      	ldr	r2, [r7, #28]
 80058f8:	e9d7 0104 	ldrd	r0, r1, [r7, #16]
 80058fc:	f7ff fc2c 	bl	8005158 <MADD64>
 8005900:	e9c7 0104 	strd	r0, r1, [r7, #16]
 8005904:	6a3b      	ldr	r3, [r7, #32]
 8005906:	425b      	negs	r3, r3
 8005908:	69ba      	ldr	r2, [r7, #24]
 800590a:	e9d7 010a 	ldrd	r0, r1, [r7, #40]	; 0x28
 800590e:	f7ff fc23 	bl	8005158 <MADD64>
 8005912:	e9c7 010a 	strd	r0, r1, [r7, #40]	; 0x28
 8005916:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8005918:	69ba      	ldr	r2, [r7, #24]
 800591a:	e9d7 0104 	ldrd	r0, r1, [r7, #16]
 800591e:	f7ff fc1b 	bl	8005158 <MADD64>
 8005922:	e9c7 0104 	strd	r0, r1, [r7, #16]

		vb1 += 64;
 8005926:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8005928:	f503 7380 	add.w	r3, r3, #256	; 0x100
 800592c:	63fb      	str	r3, [r7, #60]	; 0x3c
		*(pcm)       = ClipToShort((int)SAR64(sum1L, (32-CSHIFT)), DEF_NFRACBITS);
 800592e:	2214      	movs	r2, #20
 8005930:	e9d7 010a 	ldrd	r0, r1, [r7, #40]	; 0x28
 8005934:	f7ff fc2b 	bl	800518e <SAR64>
 8005938:	4603      	mov	r3, r0
 800593a:	460c      	mov	r4, r1
 800593c:	2106      	movs	r1, #6
 800593e:	4618      	mov	r0, r3
 8005940:	f7ff fc44 	bl	80051cc <ClipToShort>
 8005944:	4603      	mov	r3, r0
 8005946:	461a      	mov	r2, r3
 8005948:	68fb      	ldr	r3, [r7, #12]
 800594a:	801a      	strh	r2, [r3, #0]
		*(pcm + 2*i) = ClipToShort((int)SAR64(sum2L, (32-CSHIFT)), DEF_NFRACBITS);
 800594c:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800594e:	009b      	lsls	r3, r3, #2
 8005950:	461a      	mov	r2, r3
 8005952:	68fb      	ldr	r3, [r7, #12]
 8005954:	189c      	adds	r4, r3, r2
 8005956:	2214      	movs	r2, #20
 8005958:	e9d7 0104 	ldrd	r0, r1, [r7, #16]
 800595c:	f7ff fc17 	bl	800518e <SAR64>
 8005960:	4602      	mov	r2, r0
 8005962:	460b      	mov	r3, r1
 8005964:	4613      	mov	r3, r2
 8005966:	2106      	movs	r1, #6
 8005968:	4618      	mov	r0, r3
 800596a:	f7ff fc2f 	bl	80051cc <ClipToShort>
 800596e:	4603      	mov	r3, r0
 8005970:	8023      	strh	r3, [r4, #0]
		pcm++;
 8005972:	68fb      	ldr	r3, [r7, #12]
 8005974:	3302      	adds	r3, #2
 8005976:	60fb      	str	r3, [r7, #12]
	for (i = 15; i > 0; i--) {
 8005978:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800597a:	3b01      	subs	r3, #1
 800597c:	647b      	str	r3, [r7, #68]	; 0x44
 800597e:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8005980:	2b00      	cmp	r3, #0
 8005982:	f73f ae30 	bgt.w	80055e6 <xmp3fixpt_PolyphaseMono+0x3da>
	}
}
 8005986:	bf00      	nop
 8005988:	374c      	adds	r7, #76	; 0x4c
 800598a:	46bd      	mov	sp, r7
 800598c:	bd90      	pop	{r4, r7, pc}

0800598e <xmp3fixpt_PolyphaseStereo>:
 * Notes:       interleaves PCM samples LRLRLR...
 *
 * TODO:        add 32-bit version for platforms where 64-bit mul-acc is not supported
 **************************************************************************************/
void PolyphaseStereo(short *pcm, int *vbuf, const int *coefBase)
{
 800598e:	b590      	push	{r4, r7, lr}
 8005990:	b097      	sub	sp, #92	; 0x5c
 8005992:	af00      	add	r7, sp, #0
 8005994:	60f8      	str	r0, [r7, #12]
 8005996:	60b9      	str	r1, [r7, #8]
 8005998:	607a      	str	r2, [r7, #4]
	const int *coef;
	int *vb1;
	int vLo, vHi, c1, c2;
	Word64 sum1L, sum2L, sum1R, sum2R, rndVal;

	rndVal = (Word64)( 1 << (DEF_NFRACBITS - 1 + (32 - CSHIFT)) );
 800599a:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
 800599e:	f04f 0400 	mov.w	r4, #0
 80059a2:	e9c7 3410 	strd	r3, r4, [r7, #64]	; 0x40

	/* special case, output sample 0 */
	coef = coefBase;
 80059a6:	687b      	ldr	r3, [r7, #4]
 80059a8:	653b      	str	r3, [r7, #80]	; 0x50
	vb1 = vbuf;
 80059aa:	68bb      	ldr	r3, [r7, #8]
 80059ac:	64fb      	str	r3, [r7, #76]	; 0x4c
	sum1L = sum1R = rndVal;
 80059ae:	e9d7 3410 	ldrd	r3, r4, [r7, #64]	; 0x40
 80059b2:	e9c7 340e 	strd	r3, r4, [r7, #56]	; 0x38
 80059b6:	e9d7 340e 	ldrd	r3, r4, [r7, #56]	; 0x38
 80059ba:	e9c7 340c 	strd	r3, r4, [r7, #48]	; 0x30

	MC0S(0)
 80059be:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 80059c0:	681b      	ldr	r3, [r3, #0]
 80059c2:	62fb      	str	r3, [r7, #44]	; 0x2c
 80059c4:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 80059c6:	3304      	adds	r3, #4
 80059c8:	653b      	str	r3, [r7, #80]	; 0x50
 80059ca:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 80059cc:	681b      	ldr	r3, [r3, #0]
 80059ce:	62bb      	str	r3, [r7, #40]	; 0x28
 80059d0:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 80059d2:	3304      	adds	r3, #4
 80059d4:	653b      	str	r3, [r7, #80]	; 0x50
 80059d6:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 80059d8:	681b      	ldr	r3, [r3, #0]
 80059da:	627b      	str	r3, [r7, #36]	; 0x24
 80059dc:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 80059de:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 80059e0:	623b      	str	r3, [r7, #32]
 80059e2:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80059e4:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 80059e6:	e9d7 010c 	ldrd	r0, r1, [r7, #48]	; 0x30
 80059ea:	f7ff fbb5 	bl	8005158 <MADD64>
 80059ee:	e9c7 010c 	strd	r0, r1, [r7, #48]	; 0x30
 80059f2:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80059f4:	425b      	negs	r3, r3
 80059f6:	6a3a      	ldr	r2, [r7, #32]
 80059f8:	e9d7 010c 	ldrd	r0, r1, [r7, #48]	; 0x30
 80059fc:	f7ff fbac 	bl	8005158 <MADD64>
 8005a00:	e9c7 010c 	strd	r0, r1, [r7, #48]	; 0x30
 8005a04:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8005a06:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
 8005a0a:	627b      	str	r3, [r7, #36]	; 0x24
 8005a0c:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8005a0e:	f8d3 30dc 	ldr.w	r3, [r3, #220]	; 0xdc
 8005a12:	623b      	str	r3, [r7, #32]
 8005a14:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8005a16:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8005a18:	e9d7 010e 	ldrd	r0, r1, [r7, #56]	; 0x38
 8005a1c:	f7ff fb9c 	bl	8005158 <MADD64>
 8005a20:	e9c7 010e 	strd	r0, r1, [r7, #56]	; 0x38
 8005a24:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8005a26:	425b      	negs	r3, r3
 8005a28:	6a3a      	ldr	r2, [r7, #32]
 8005a2a:	e9d7 010e 	ldrd	r0, r1, [r7, #56]	; 0x38
 8005a2e:	f7ff fb93 	bl	8005158 <MADD64>
 8005a32:	e9c7 010e 	strd	r0, r1, [r7, #56]	; 0x38
	MC0S(1)
 8005a36:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8005a38:	681b      	ldr	r3, [r3, #0]
 8005a3a:	62fb      	str	r3, [r7, #44]	; 0x2c
 8005a3c:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8005a3e:	3304      	adds	r3, #4
 8005a40:	653b      	str	r3, [r7, #80]	; 0x50
 8005a42:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8005a44:	681b      	ldr	r3, [r3, #0]
 8005a46:	62bb      	str	r3, [r7, #40]	; 0x28
 8005a48:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8005a4a:	3304      	adds	r3, #4
 8005a4c:	653b      	str	r3, [r7, #80]	; 0x50
 8005a4e:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8005a50:	685b      	ldr	r3, [r3, #4]
 8005a52:	627b      	str	r3, [r7, #36]	; 0x24
 8005a54:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8005a56:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 8005a58:	623b      	str	r3, [r7, #32]
 8005a5a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8005a5c:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8005a5e:	e9d7 010c 	ldrd	r0, r1, [r7, #48]	; 0x30
 8005a62:	f7ff fb79 	bl	8005158 <MADD64>
 8005a66:	e9c7 010c 	strd	r0, r1, [r7, #48]	; 0x30
 8005a6a:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8005a6c:	425b      	negs	r3, r3
 8005a6e:	6a3a      	ldr	r2, [r7, #32]
 8005a70:	e9d7 010c 	ldrd	r0, r1, [r7, #48]	; 0x30
 8005a74:	f7ff fb70 	bl	8005158 <MADD64>
 8005a78:	e9c7 010c 	strd	r0, r1, [r7, #48]	; 0x30
 8005a7c:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8005a7e:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
 8005a82:	627b      	str	r3, [r7, #36]	; 0x24
 8005a84:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8005a86:	f8d3 30d8 	ldr.w	r3, [r3, #216]	; 0xd8
 8005a8a:	623b      	str	r3, [r7, #32]
 8005a8c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8005a8e:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8005a90:	e9d7 010e 	ldrd	r0, r1, [r7, #56]	; 0x38
 8005a94:	f7ff fb60 	bl	8005158 <MADD64>
 8005a98:	e9c7 010e 	strd	r0, r1, [r7, #56]	; 0x38
 8005a9c:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8005a9e:	425b      	negs	r3, r3
 8005aa0:	6a3a      	ldr	r2, [r7, #32]
 8005aa2:	e9d7 010e 	ldrd	r0, r1, [r7, #56]	; 0x38
 8005aa6:	f7ff fb57 	bl	8005158 <MADD64>
 8005aaa:	e9c7 010e 	strd	r0, r1, [r7, #56]	; 0x38
	MC0S(2)
 8005aae:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8005ab0:	681b      	ldr	r3, [r3, #0]
 8005ab2:	62fb      	str	r3, [r7, #44]	; 0x2c
 8005ab4:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8005ab6:	3304      	adds	r3, #4
 8005ab8:	653b      	str	r3, [r7, #80]	; 0x50
 8005aba:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8005abc:	681b      	ldr	r3, [r3, #0]
 8005abe:	62bb      	str	r3, [r7, #40]	; 0x28
 8005ac0:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8005ac2:	3304      	adds	r3, #4
 8005ac4:	653b      	str	r3, [r7, #80]	; 0x50
 8005ac6:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8005ac8:	689b      	ldr	r3, [r3, #8]
 8005aca:	627b      	str	r3, [r7, #36]	; 0x24
 8005acc:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8005ace:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8005ad0:	623b      	str	r3, [r7, #32]
 8005ad2:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8005ad4:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8005ad6:	e9d7 010c 	ldrd	r0, r1, [r7, #48]	; 0x30
 8005ada:	f7ff fb3d 	bl	8005158 <MADD64>
 8005ade:	e9c7 010c 	strd	r0, r1, [r7, #48]	; 0x30
 8005ae2:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8005ae4:	425b      	negs	r3, r3
 8005ae6:	6a3a      	ldr	r2, [r7, #32]
 8005ae8:	e9d7 010c 	ldrd	r0, r1, [r7, #48]	; 0x30
 8005aec:	f7ff fb34 	bl	8005158 <MADD64>
 8005af0:	e9c7 010c 	strd	r0, r1, [r7, #48]	; 0x30
 8005af4:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8005af6:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 8005afa:	627b      	str	r3, [r7, #36]	; 0x24
 8005afc:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8005afe:	f8d3 30d4 	ldr.w	r3, [r3, #212]	; 0xd4
 8005b02:	623b      	str	r3, [r7, #32]
 8005b04:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8005b06:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8005b08:	e9d7 010e 	ldrd	r0, r1, [r7, #56]	; 0x38
 8005b0c:	f7ff fb24 	bl	8005158 <MADD64>
 8005b10:	e9c7 010e 	strd	r0, r1, [r7, #56]	; 0x38
 8005b14:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8005b16:	425b      	negs	r3, r3
 8005b18:	6a3a      	ldr	r2, [r7, #32]
 8005b1a:	e9d7 010e 	ldrd	r0, r1, [r7, #56]	; 0x38
 8005b1e:	f7ff fb1b 	bl	8005158 <MADD64>
 8005b22:	e9c7 010e 	strd	r0, r1, [r7, #56]	; 0x38
	MC0S(3)
 8005b26:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8005b28:	681b      	ldr	r3, [r3, #0]
 8005b2a:	62fb      	str	r3, [r7, #44]	; 0x2c
 8005b2c:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8005b2e:	3304      	adds	r3, #4
 8005b30:	653b      	str	r3, [r7, #80]	; 0x50
 8005b32:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8005b34:	681b      	ldr	r3, [r3, #0]
 8005b36:	62bb      	str	r3, [r7, #40]	; 0x28
 8005b38:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8005b3a:	3304      	adds	r3, #4
 8005b3c:	653b      	str	r3, [r7, #80]	; 0x50
 8005b3e:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8005b40:	68db      	ldr	r3, [r3, #12]
 8005b42:	627b      	str	r3, [r7, #36]	; 0x24
 8005b44:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8005b46:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 8005b48:	623b      	str	r3, [r7, #32]
 8005b4a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8005b4c:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8005b4e:	e9d7 010c 	ldrd	r0, r1, [r7, #48]	; 0x30
 8005b52:	f7ff fb01 	bl	8005158 <MADD64>
 8005b56:	e9c7 010c 	strd	r0, r1, [r7, #48]	; 0x30
 8005b5a:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8005b5c:	425b      	negs	r3, r3
 8005b5e:	6a3a      	ldr	r2, [r7, #32]
 8005b60:	e9d7 010c 	ldrd	r0, r1, [r7, #48]	; 0x30
 8005b64:	f7ff faf8 	bl	8005158 <MADD64>
 8005b68:	e9c7 010c 	strd	r0, r1, [r7, #48]	; 0x30
 8005b6c:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8005b6e:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 8005b72:	627b      	str	r3, [r7, #36]	; 0x24
 8005b74:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8005b76:	f8d3 30d0 	ldr.w	r3, [r3, #208]	; 0xd0
 8005b7a:	623b      	str	r3, [r7, #32]
 8005b7c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8005b7e:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8005b80:	e9d7 010e 	ldrd	r0, r1, [r7, #56]	; 0x38
 8005b84:	f7ff fae8 	bl	8005158 <MADD64>
 8005b88:	e9c7 010e 	strd	r0, r1, [r7, #56]	; 0x38
 8005b8c:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8005b8e:	425b      	negs	r3, r3
 8005b90:	6a3a      	ldr	r2, [r7, #32]
 8005b92:	e9d7 010e 	ldrd	r0, r1, [r7, #56]	; 0x38
 8005b96:	f7ff fadf 	bl	8005158 <MADD64>
 8005b9a:	e9c7 010e 	strd	r0, r1, [r7, #56]	; 0x38
	MC0S(4)
 8005b9e:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8005ba0:	681b      	ldr	r3, [r3, #0]
 8005ba2:	62fb      	str	r3, [r7, #44]	; 0x2c
 8005ba4:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8005ba6:	3304      	adds	r3, #4
 8005ba8:	653b      	str	r3, [r7, #80]	; 0x50
 8005baa:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8005bac:	681b      	ldr	r3, [r3, #0]
 8005bae:	62bb      	str	r3, [r7, #40]	; 0x28
 8005bb0:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8005bb2:	3304      	adds	r3, #4
 8005bb4:	653b      	str	r3, [r7, #80]	; 0x50
 8005bb6:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8005bb8:	691b      	ldr	r3, [r3, #16]
 8005bba:	627b      	str	r3, [r7, #36]	; 0x24
 8005bbc:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8005bbe:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 8005bc0:	623b      	str	r3, [r7, #32]
 8005bc2:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8005bc4:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8005bc6:	e9d7 010c 	ldrd	r0, r1, [r7, #48]	; 0x30
 8005bca:	f7ff fac5 	bl	8005158 <MADD64>
 8005bce:	e9c7 010c 	strd	r0, r1, [r7, #48]	; 0x30
 8005bd2:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8005bd4:	425b      	negs	r3, r3
 8005bd6:	6a3a      	ldr	r2, [r7, #32]
 8005bd8:	e9d7 010c 	ldrd	r0, r1, [r7, #48]	; 0x30
 8005bdc:	f7ff fabc 	bl	8005158 <MADD64>
 8005be0:	e9c7 010c 	strd	r0, r1, [r7, #48]	; 0x30
 8005be4:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8005be6:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 8005bea:	627b      	str	r3, [r7, #36]	; 0x24
 8005bec:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8005bee:	f8d3 30cc 	ldr.w	r3, [r3, #204]	; 0xcc
 8005bf2:	623b      	str	r3, [r7, #32]
 8005bf4:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8005bf6:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8005bf8:	e9d7 010e 	ldrd	r0, r1, [r7, #56]	; 0x38
 8005bfc:	f7ff faac 	bl	8005158 <MADD64>
 8005c00:	e9c7 010e 	strd	r0, r1, [r7, #56]	; 0x38
 8005c04:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8005c06:	425b      	negs	r3, r3
 8005c08:	6a3a      	ldr	r2, [r7, #32]
 8005c0a:	e9d7 010e 	ldrd	r0, r1, [r7, #56]	; 0x38
 8005c0e:	f7ff faa3 	bl	8005158 <MADD64>
 8005c12:	e9c7 010e 	strd	r0, r1, [r7, #56]	; 0x38
	MC0S(5)
 8005c16:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8005c18:	681b      	ldr	r3, [r3, #0]
 8005c1a:	62fb      	str	r3, [r7, #44]	; 0x2c
 8005c1c:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8005c1e:	3304      	adds	r3, #4
 8005c20:	653b      	str	r3, [r7, #80]	; 0x50
 8005c22:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8005c24:	681b      	ldr	r3, [r3, #0]
 8005c26:	62bb      	str	r3, [r7, #40]	; 0x28
 8005c28:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8005c2a:	3304      	adds	r3, #4
 8005c2c:	653b      	str	r3, [r7, #80]	; 0x50
 8005c2e:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8005c30:	695b      	ldr	r3, [r3, #20]
 8005c32:	627b      	str	r3, [r7, #36]	; 0x24
 8005c34:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8005c36:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8005c38:	623b      	str	r3, [r7, #32]
 8005c3a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8005c3c:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8005c3e:	e9d7 010c 	ldrd	r0, r1, [r7, #48]	; 0x30
 8005c42:	f7ff fa89 	bl	8005158 <MADD64>
 8005c46:	e9c7 010c 	strd	r0, r1, [r7, #48]	; 0x30
 8005c4a:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8005c4c:	425b      	negs	r3, r3
 8005c4e:	6a3a      	ldr	r2, [r7, #32]
 8005c50:	e9d7 010c 	ldrd	r0, r1, [r7, #48]	; 0x30
 8005c54:	f7ff fa80 	bl	8005158 <MADD64>
 8005c58:	e9c7 010c 	strd	r0, r1, [r7, #48]	; 0x30
 8005c5c:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8005c5e:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
 8005c62:	627b      	str	r3, [r7, #36]	; 0x24
 8005c64:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8005c66:	f8d3 30c8 	ldr.w	r3, [r3, #200]	; 0xc8
 8005c6a:	623b      	str	r3, [r7, #32]
 8005c6c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8005c6e:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8005c70:	e9d7 010e 	ldrd	r0, r1, [r7, #56]	; 0x38
 8005c74:	f7ff fa70 	bl	8005158 <MADD64>
 8005c78:	e9c7 010e 	strd	r0, r1, [r7, #56]	; 0x38
 8005c7c:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8005c7e:	425b      	negs	r3, r3
 8005c80:	6a3a      	ldr	r2, [r7, #32]
 8005c82:	e9d7 010e 	ldrd	r0, r1, [r7, #56]	; 0x38
 8005c86:	f7ff fa67 	bl	8005158 <MADD64>
 8005c8a:	e9c7 010e 	strd	r0, r1, [r7, #56]	; 0x38
	MC0S(6)
 8005c8e:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8005c90:	681b      	ldr	r3, [r3, #0]
 8005c92:	62fb      	str	r3, [r7, #44]	; 0x2c
 8005c94:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8005c96:	3304      	adds	r3, #4
 8005c98:	653b      	str	r3, [r7, #80]	; 0x50
 8005c9a:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8005c9c:	681b      	ldr	r3, [r3, #0]
 8005c9e:	62bb      	str	r3, [r7, #40]	; 0x28
 8005ca0:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8005ca2:	3304      	adds	r3, #4
 8005ca4:	653b      	str	r3, [r7, #80]	; 0x50
 8005ca6:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8005ca8:	699b      	ldr	r3, [r3, #24]
 8005caa:	627b      	str	r3, [r7, #36]	; 0x24
 8005cac:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8005cae:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8005cb0:	623b      	str	r3, [r7, #32]
 8005cb2:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8005cb4:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8005cb6:	e9d7 010c 	ldrd	r0, r1, [r7, #48]	; 0x30
 8005cba:	f7ff fa4d 	bl	8005158 <MADD64>
 8005cbe:	e9c7 010c 	strd	r0, r1, [r7, #48]	; 0x30
 8005cc2:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8005cc4:	425b      	negs	r3, r3
 8005cc6:	6a3a      	ldr	r2, [r7, #32]
 8005cc8:	e9d7 010c 	ldrd	r0, r1, [r7, #48]	; 0x30
 8005ccc:	f7ff fa44 	bl	8005158 <MADD64>
 8005cd0:	e9c7 010c 	strd	r0, r1, [r7, #48]	; 0x30
 8005cd4:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8005cd6:	f8d3 3098 	ldr.w	r3, [r3, #152]	; 0x98
 8005cda:	627b      	str	r3, [r7, #36]	; 0x24
 8005cdc:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8005cde:	f8d3 30c4 	ldr.w	r3, [r3, #196]	; 0xc4
 8005ce2:	623b      	str	r3, [r7, #32]
 8005ce4:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8005ce6:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8005ce8:	e9d7 010e 	ldrd	r0, r1, [r7, #56]	; 0x38
 8005cec:	f7ff fa34 	bl	8005158 <MADD64>
 8005cf0:	e9c7 010e 	strd	r0, r1, [r7, #56]	; 0x38
 8005cf4:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8005cf6:	425b      	negs	r3, r3
 8005cf8:	6a3a      	ldr	r2, [r7, #32]
 8005cfa:	e9d7 010e 	ldrd	r0, r1, [r7, #56]	; 0x38
 8005cfe:	f7ff fa2b 	bl	8005158 <MADD64>
 8005d02:	e9c7 010e 	strd	r0, r1, [r7, #56]	; 0x38
	MC0S(7)
 8005d06:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8005d08:	681b      	ldr	r3, [r3, #0]
 8005d0a:	62fb      	str	r3, [r7, #44]	; 0x2c
 8005d0c:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8005d0e:	3304      	adds	r3, #4
 8005d10:	653b      	str	r3, [r7, #80]	; 0x50
 8005d12:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8005d14:	681b      	ldr	r3, [r3, #0]
 8005d16:	62bb      	str	r3, [r7, #40]	; 0x28
 8005d18:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8005d1a:	3304      	adds	r3, #4
 8005d1c:	653b      	str	r3, [r7, #80]	; 0x50
 8005d1e:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8005d20:	69db      	ldr	r3, [r3, #28]
 8005d22:	627b      	str	r3, [r7, #36]	; 0x24
 8005d24:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8005d26:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8005d28:	623b      	str	r3, [r7, #32]
 8005d2a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8005d2c:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8005d2e:	e9d7 010c 	ldrd	r0, r1, [r7, #48]	; 0x30
 8005d32:	f7ff fa11 	bl	8005158 <MADD64>
 8005d36:	e9c7 010c 	strd	r0, r1, [r7, #48]	; 0x30
 8005d3a:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8005d3c:	425b      	negs	r3, r3
 8005d3e:	6a3a      	ldr	r2, [r7, #32]
 8005d40:	e9d7 010c 	ldrd	r0, r1, [r7, #48]	; 0x30
 8005d44:	f7ff fa08 	bl	8005158 <MADD64>
 8005d48:	e9c7 010c 	strd	r0, r1, [r7, #48]	; 0x30
 8005d4c:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8005d4e:	f8d3 309c 	ldr.w	r3, [r3, #156]	; 0x9c
 8005d52:	627b      	str	r3, [r7, #36]	; 0x24
 8005d54:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8005d56:	f8d3 30c0 	ldr.w	r3, [r3, #192]	; 0xc0
 8005d5a:	623b      	str	r3, [r7, #32]
 8005d5c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8005d5e:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8005d60:	e9d7 010e 	ldrd	r0, r1, [r7, #56]	; 0x38
 8005d64:	f7ff f9f8 	bl	8005158 <MADD64>
 8005d68:	e9c7 010e 	strd	r0, r1, [r7, #56]	; 0x38
 8005d6c:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8005d6e:	425b      	negs	r3, r3
 8005d70:	6a3a      	ldr	r2, [r7, #32]
 8005d72:	e9d7 010e 	ldrd	r0, r1, [r7, #56]	; 0x38
 8005d76:	f7ff f9ef 	bl	8005158 <MADD64>
 8005d7a:	e9c7 010e 	strd	r0, r1, [r7, #56]	; 0x38

	*(pcm + 0) = ClipToShort((int)SAR64(sum1L, (32-CSHIFT)), DEF_NFRACBITS);
 8005d7e:	2214      	movs	r2, #20
 8005d80:	e9d7 010c 	ldrd	r0, r1, [r7, #48]	; 0x30
 8005d84:	f7ff fa03 	bl	800518e <SAR64>
 8005d88:	4603      	mov	r3, r0
 8005d8a:	460c      	mov	r4, r1
 8005d8c:	2106      	movs	r1, #6
 8005d8e:	4618      	mov	r0, r3
 8005d90:	f7ff fa1c 	bl	80051cc <ClipToShort>
 8005d94:	4603      	mov	r3, r0
 8005d96:	461a      	mov	r2, r3
 8005d98:	68fb      	ldr	r3, [r7, #12]
 8005d9a:	801a      	strh	r2, [r3, #0]
	*(pcm + 1) = ClipToShort((int)SAR64(sum1R, (32-CSHIFT)), DEF_NFRACBITS);
 8005d9c:	68fb      	ldr	r3, [r7, #12]
 8005d9e:	1c9c      	adds	r4, r3, #2
 8005da0:	2214      	movs	r2, #20
 8005da2:	e9d7 010e 	ldrd	r0, r1, [r7, #56]	; 0x38
 8005da6:	f7ff f9f2 	bl	800518e <SAR64>
 8005daa:	4602      	mov	r2, r0
 8005dac:	460b      	mov	r3, r1
 8005dae:	4613      	mov	r3, r2
 8005db0:	2106      	movs	r1, #6
 8005db2:	4618      	mov	r0, r3
 8005db4:	f7ff fa0a 	bl	80051cc <ClipToShort>
 8005db8:	4603      	mov	r3, r0
 8005dba:	8023      	strh	r3, [r4, #0]

	/* special case, output sample 16 */
	coef = coefBase + 256;
 8005dbc:	687b      	ldr	r3, [r7, #4]
 8005dbe:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 8005dc2:	653b      	str	r3, [r7, #80]	; 0x50
	vb1 = vbuf + 64*16;
 8005dc4:	68bb      	ldr	r3, [r7, #8]
 8005dc6:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 8005dca:	64fb      	str	r3, [r7, #76]	; 0x4c
	sum1L = sum1R = rndVal;
 8005dcc:	e9d7 3410 	ldrd	r3, r4, [r7, #64]	; 0x40
 8005dd0:	e9c7 340e 	strd	r3, r4, [r7, #56]	; 0x38
 8005dd4:	e9d7 340e 	ldrd	r3, r4, [r7, #56]	; 0x38
 8005dd8:	e9c7 340c 	strd	r3, r4, [r7, #48]	; 0x30

	MC1S(0)
 8005ddc:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8005dde:	681b      	ldr	r3, [r3, #0]
 8005de0:	62fb      	str	r3, [r7, #44]	; 0x2c
 8005de2:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8005de4:	3304      	adds	r3, #4
 8005de6:	653b      	str	r3, [r7, #80]	; 0x50
 8005de8:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8005dea:	681b      	ldr	r3, [r3, #0]
 8005dec:	627b      	str	r3, [r7, #36]	; 0x24
 8005dee:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8005df0:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8005df2:	e9d7 010c 	ldrd	r0, r1, [r7, #48]	; 0x30
 8005df6:	f7ff f9af 	bl	8005158 <MADD64>
 8005dfa:	e9c7 010c 	strd	r0, r1, [r7, #48]	; 0x30
 8005dfe:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8005e00:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
 8005e04:	627b      	str	r3, [r7, #36]	; 0x24
 8005e06:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8005e08:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8005e0a:	e9d7 010e 	ldrd	r0, r1, [r7, #56]	; 0x38
 8005e0e:	f7ff f9a3 	bl	8005158 <MADD64>
 8005e12:	e9c7 010e 	strd	r0, r1, [r7, #56]	; 0x38
	MC1S(1)
 8005e16:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8005e18:	681b      	ldr	r3, [r3, #0]
 8005e1a:	62fb      	str	r3, [r7, #44]	; 0x2c
 8005e1c:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8005e1e:	3304      	adds	r3, #4
 8005e20:	653b      	str	r3, [r7, #80]	; 0x50
 8005e22:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8005e24:	685b      	ldr	r3, [r3, #4]
 8005e26:	627b      	str	r3, [r7, #36]	; 0x24
 8005e28:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8005e2a:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8005e2c:	e9d7 010c 	ldrd	r0, r1, [r7, #48]	; 0x30
 8005e30:	f7ff f992 	bl	8005158 <MADD64>
 8005e34:	e9c7 010c 	strd	r0, r1, [r7, #48]	; 0x30
 8005e38:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8005e3a:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
 8005e3e:	627b      	str	r3, [r7, #36]	; 0x24
 8005e40:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8005e42:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8005e44:	e9d7 010e 	ldrd	r0, r1, [r7, #56]	; 0x38
 8005e48:	f7ff f986 	bl	8005158 <MADD64>
 8005e4c:	e9c7 010e 	strd	r0, r1, [r7, #56]	; 0x38
	MC1S(2)
 8005e50:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8005e52:	681b      	ldr	r3, [r3, #0]
 8005e54:	62fb      	str	r3, [r7, #44]	; 0x2c
 8005e56:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8005e58:	3304      	adds	r3, #4
 8005e5a:	653b      	str	r3, [r7, #80]	; 0x50
 8005e5c:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8005e5e:	689b      	ldr	r3, [r3, #8]
 8005e60:	627b      	str	r3, [r7, #36]	; 0x24
 8005e62:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8005e64:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8005e66:	e9d7 010c 	ldrd	r0, r1, [r7, #48]	; 0x30
 8005e6a:	f7ff f975 	bl	8005158 <MADD64>
 8005e6e:	e9c7 010c 	strd	r0, r1, [r7, #48]	; 0x30
 8005e72:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8005e74:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 8005e78:	627b      	str	r3, [r7, #36]	; 0x24
 8005e7a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8005e7c:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8005e7e:	e9d7 010e 	ldrd	r0, r1, [r7, #56]	; 0x38
 8005e82:	f7ff f969 	bl	8005158 <MADD64>
 8005e86:	e9c7 010e 	strd	r0, r1, [r7, #56]	; 0x38
	MC1S(3)
 8005e8a:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8005e8c:	681b      	ldr	r3, [r3, #0]
 8005e8e:	62fb      	str	r3, [r7, #44]	; 0x2c
 8005e90:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8005e92:	3304      	adds	r3, #4
 8005e94:	653b      	str	r3, [r7, #80]	; 0x50
 8005e96:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8005e98:	68db      	ldr	r3, [r3, #12]
 8005e9a:	627b      	str	r3, [r7, #36]	; 0x24
 8005e9c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8005e9e:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8005ea0:	e9d7 010c 	ldrd	r0, r1, [r7, #48]	; 0x30
 8005ea4:	f7ff f958 	bl	8005158 <MADD64>
 8005ea8:	e9c7 010c 	strd	r0, r1, [r7, #48]	; 0x30
 8005eac:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8005eae:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 8005eb2:	627b      	str	r3, [r7, #36]	; 0x24
 8005eb4:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8005eb6:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8005eb8:	e9d7 010e 	ldrd	r0, r1, [r7, #56]	; 0x38
 8005ebc:	f7ff f94c 	bl	8005158 <MADD64>
 8005ec0:	e9c7 010e 	strd	r0, r1, [r7, #56]	; 0x38
	MC1S(4)
 8005ec4:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8005ec6:	681b      	ldr	r3, [r3, #0]
 8005ec8:	62fb      	str	r3, [r7, #44]	; 0x2c
 8005eca:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8005ecc:	3304      	adds	r3, #4
 8005ece:	653b      	str	r3, [r7, #80]	; 0x50
 8005ed0:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8005ed2:	691b      	ldr	r3, [r3, #16]
 8005ed4:	627b      	str	r3, [r7, #36]	; 0x24
 8005ed6:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8005ed8:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8005eda:	e9d7 010c 	ldrd	r0, r1, [r7, #48]	; 0x30
 8005ede:	f7ff f93b 	bl	8005158 <MADD64>
 8005ee2:	e9c7 010c 	strd	r0, r1, [r7, #48]	; 0x30
 8005ee6:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8005ee8:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 8005eec:	627b      	str	r3, [r7, #36]	; 0x24
 8005eee:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8005ef0:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8005ef2:	e9d7 010e 	ldrd	r0, r1, [r7, #56]	; 0x38
 8005ef6:	f7ff f92f 	bl	8005158 <MADD64>
 8005efa:	e9c7 010e 	strd	r0, r1, [r7, #56]	; 0x38
	MC1S(5)
 8005efe:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8005f00:	681b      	ldr	r3, [r3, #0]
 8005f02:	62fb      	str	r3, [r7, #44]	; 0x2c
 8005f04:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8005f06:	3304      	adds	r3, #4
 8005f08:	653b      	str	r3, [r7, #80]	; 0x50
 8005f0a:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8005f0c:	695b      	ldr	r3, [r3, #20]
 8005f0e:	627b      	str	r3, [r7, #36]	; 0x24
 8005f10:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8005f12:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8005f14:	e9d7 010c 	ldrd	r0, r1, [r7, #48]	; 0x30
 8005f18:	f7ff f91e 	bl	8005158 <MADD64>
 8005f1c:	e9c7 010c 	strd	r0, r1, [r7, #48]	; 0x30
 8005f20:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8005f22:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
 8005f26:	627b      	str	r3, [r7, #36]	; 0x24
 8005f28:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8005f2a:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8005f2c:	e9d7 010e 	ldrd	r0, r1, [r7, #56]	; 0x38
 8005f30:	f7ff f912 	bl	8005158 <MADD64>
 8005f34:	e9c7 010e 	strd	r0, r1, [r7, #56]	; 0x38
	MC1S(6)
 8005f38:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8005f3a:	681b      	ldr	r3, [r3, #0]
 8005f3c:	62fb      	str	r3, [r7, #44]	; 0x2c
 8005f3e:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8005f40:	3304      	adds	r3, #4
 8005f42:	653b      	str	r3, [r7, #80]	; 0x50
 8005f44:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8005f46:	699b      	ldr	r3, [r3, #24]
 8005f48:	627b      	str	r3, [r7, #36]	; 0x24
 8005f4a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8005f4c:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8005f4e:	e9d7 010c 	ldrd	r0, r1, [r7, #48]	; 0x30
 8005f52:	f7ff f901 	bl	8005158 <MADD64>
 8005f56:	e9c7 010c 	strd	r0, r1, [r7, #48]	; 0x30
 8005f5a:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8005f5c:	f8d3 3098 	ldr.w	r3, [r3, #152]	; 0x98
 8005f60:	627b      	str	r3, [r7, #36]	; 0x24
 8005f62:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8005f64:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8005f66:	e9d7 010e 	ldrd	r0, r1, [r7, #56]	; 0x38
 8005f6a:	f7ff f8f5 	bl	8005158 <MADD64>
 8005f6e:	e9c7 010e 	strd	r0, r1, [r7, #56]	; 0x38
	MC1S(7)
 8005f72:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8005f74:	681b      	ldr	r3, [r3, #0]
 8005f76:	62fb      	str	r3, [r7, #44]	; 0x2c
 8005f78:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8005f7a:	3304      	adds	r3, #4
 8005f7c:	653b      	str	r3, [r7, #80]	; 0x50
 8005f7e:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8005f80:	69db      	ldr	r3, [r3, #28]
 8005f82:	627b      	str	r3, [r7, #36]	; 0x24
 8005f84:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8005f86:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8005f88:	e9d7 010c 	ldrd	r0, r1, [r7, #48]	; 0x30
 8005f8c:	f7ff f8e4 	bl	8005158 <MADD64>
 8005f90:	e9c7 010c 	strd	r0, r1, [r7, #48]	; 0x30
 8005f94:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8005f96:	f8d3 309c 	ldr.w	r3, [r3, #156]	; 0x9c
 8005f9a:	627b      	str	r3, [r7, #36]	; 0x24
 8005f9c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8005f9e:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8005fa0:	e9d7 010e 	ldrd	r0, r1, [r7, #56]	; 0x38
 8005fa4:	f7ff f8d8 	bl	8005158 <MADD64>
 8005fa8:	e9c7 010e 	strd	r0, r1, [r7, #56]	; 0x38

	*(pcm + 2*16 + 0) = ClipToShort((int)SAR64(sum1L, (32-CSHIFT)), DEF_NFRACBITS);
 8005fac:	68fb      	ldr	r3, [r7, #12]
 8005fae:	f103 0440 	add.w	r4, r3, #64	; 0x40
 8005fb2:	2214      	movs	r2, #20
 8005fb4:	e9d7 010c 	ldrd	r0, r1, [r7, #48]	; 0x30
 8005fb8:	f7ff f8e9 	bl	800518e <SAR64>
 8005fbc:	4602      	mov	r2, r0
 8005fbe:	460b      	mov	r3, r1
 8005fc0:	4613      	mov	r3, r2
 8005fc2:	2106      	movs	r1, #6
 8005fc4:	4618      	mov	r0, r3
 8005fc6:	f7ff f901 	bl	80051cc <ClipToShort>
 8005fca:	4603      	mov	r3, r0
 8005fcc:	8023      	strh	r3, [r4, #0]
	*(pcm + 2*16 + 1) = ClipToShort((int)SAR64(sum1R, (32-CSHIFT)), DEF_NFRACBITS);
 8005fce:	68fb      	ldr	r3, [r7, #12]
 8005fd0:	f103 0442 	add.w	r4, r3, #66	; 0x42
 8005fd4:	2214      	movs	r2, #20
 8005fd6:	e9d7 010e 	ldrd	r0, r1, [r7, #56]	; 0x38
 8005fda:	f7ff f8d8 	bl	800518e <SAR64>
 8005fde:	4602      	mov	r2, r0
 8005fe0:	460b      	mov	r3, r1
 8005fe2:	4613      	mov	r3, r2
 8005fe4:	2106      	movs	r1, #6
 8005fe6:	4618      	mov	r0, r3
 8005fe8:	f7ff f8f0 	bl	80051cc <ClipToShort>
 8005fec:	4603      	mov	r3, r0
 8005fee:	8023      	strh	r3, [r4, #0]

	/* main convolution loop: sum1L = samples 1, 2, 3, ... 15   sum2L = samples 31, 30, ... 17 */
	coef = coefBase + 16;
 8005ff0:	687b      	ldr	r3, [r7, #4]
 8005ff2:	3340      	adds	r3, #64	; 0x40
 8005ff4:	653b      	str	r3, [r7, #80]	; 0x50
	vb1 = vbuf + 64;
 8005ff6:	68bb      	ldr	r3, [r7, #8]
 8005ff8:	f503 7380 	add.w	r3, r3, #256	; 0x100
 8005ffc:	64fb      	str	r3, [r7, #76]	; 0x4c
	pcm += 2;
 8005ffe:	68fb      	ldr	r3, [r7, #12]
 8006000:	3304      	adds	r3, #4
 8006002:	60fb      	str	r3, [r7, #12]

	/* right now, the compiler creates bad asm from this... */
	for (i = 15; i > 0; i--) {
 8006004:	230f      	movs	r3, #15
 8006006:	657b      	str	r3, [r7, #84]	; 0x54
 8006008:	e33e      	b.n	8006688 <xmp3fixpt_PolyphaseStereo+0xcfa>
		sum1L = sum2L = rndVal;
 800600a:	e9d7 3410 	ldrd	r3, r4, [r7, #64]	; 0x40
 800600e:	e9c7 3406 	strd	r3, r4, [r7, #24]
 8006012:	e9d7 3406 	ldrd	r3, r4, [r7, #24]
 8006016:	e9c7 340c 	strd	r3, r4, [r7, #48]	; 0x30
		sum1R = sum2R = rndVal;
 800601a:	e9d7 3410 	ldrd	r3, r4, [r7, #64]	; 0x40
 800601e:	e9c7 3404 	strd	r3, r4, [r7, #16]
 8006022:	e9d7 3404 	ldrd	r3, r4, [r7, #16]
 8006026:	e9c7 340e 	strd	r3, r4, [r7, #56]	; 0x38

		MC2S(0)
 800602a:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 800602c:	681b      	ldr	r3, [r3, #0]
 800602e:	62fb      	str	r3, [r7, #44]	; 0x2c
 8006030:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8006032:	3304      	adds	r3, #4
 8006034:	653b      	str	r3, [r7, #80]	; 0x50
 8006036:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8006038:	681b      	ldr	r3, [r3, #0]
 800603a:	62bb      	str	r3, [r7, #40]	; 0x28
 800603c:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 800603e:	3304      	adds	r3, #4
 8006040:	653b      	str	r3, [r7, #80]	; 0x50
 8006042:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8006044:	681b      	ldr	r3, [r3, #0]
 8006046:	627b      	str	r3, [r7, #36]	; 0x24
 8006048:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800604a:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 800604c:	623b      	str	r3, [r7, #32]
 800604e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8006050:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8006052:	e9d7 010c 	ldrd	r0, r1, [r7, #48]	; 0x30
 8006056:	f7ff f87f 	bl	8005158 <MADD64>
 800605a:	e9c7 010c 	strd	r0, r1, [r7, #48]	; 0x30
 800605e:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8006060:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8006062:	e9d7 0106 	ldrd	r0, r1, [r7, #24]
 8006066:	f7ff f877 	bl	8005158 <MADD64>
 800606a:	e9c7 0106 	strd	r0, r1, [r7, #24]
 800606e:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8006070:	425b      	negs	r3, r3
 8006072:	6a3a      	ldr	r2, [r7, #32]
 8006074:	e9d7 010c 	ldrd	r0, r1, [r7, #48]	; 0x30
 8006078:	f7ff f86e 	bl	8005158 <MADD64>
 800607c:	e9c7 010c 	strd	r0, r1, [r7, #48]	; 0x30
 8006080:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8006082:	6a3a      	ldr	r2, [r7, #32]
 8006084:	e9d7 0106 	ldrd	r0, r1, [r7, #24]
 8006088:	f7ff f866 	bl	8005158 <MADD64>
 800608c:	e9c7 0106 	strd	r0, r1, [r7, #24]
 8006090:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8006092:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
 8006096:	627b      	str	r3, [r7, #36]	; 0x24
 8006098:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800609a:	f8d3 30dc 	ldr.w	r3, [r3, #220]	; 0xdc
 800609e:	623b      	str	r3, [r7, #32]
 80060a0:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80060a2:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 80060a4:	e9d7 010e 	ldrd	r0, r1, [r7, #56]	; 0x38
 80060a8:	f7ff f856 	bl	8005158 <MADD64>
 80060ac:	e9c7 010e 	strd	r0, r1, [r7, #56]	; 0x38
 80060b0:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80060b2:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 80060b4:	e9d7 0104 	ldrd	r0, r1, [r7, #16]
 80060b8:	f7ff f84e 	bl	8005158 <MADD64>
 80060bc:	e9c7 0104 	strd	r0, r1, [r7, #16]
 80060c0:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80060c2:	425b      	negs	r3, r3
 80060c4:	6a3a      	ldr	r2, [r7, #32]
 80060c6:	e9d7 010e 	ldrd	r0, r1, [r7, #56]	; 0x38
 80060ca:	f7ff f845 	bl	8005158 <MADD64>
 80060ce:	e9c7 010e 	strd	r0, r1, [r7, #56]	; 0x38
 80060d2:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80060d4:	6a3a      	ldr	r2, [r7, #32]
 80060d6:	e9d7 0104 	ldrd	r0, r1, [r7, #16]
 80060da:	f7ff f83d 	bl	8005158 <MADD64>
 80060de:	e9c7 0104 	strd	r0, r1, [r7, #16]
		MC2S(1)
 80060e2:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 80060e4:	681b      	ldr	r3, [r3, #0]
 80060e6:	62fb      	str	r3, [r7, #44]	; 0x2c
 80060e8:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 80060ea:	3304      	adds	r3, #4
 80060ec:	653b      	str	r3, [r7, #80]	; 0x50
 80060ee:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 80060f0:	681b      	ldr	r3, [r3, #0]
 80060f2:	62bb      	str	r3, [r7, #40]	; 0x28
 80060f4:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 80060f6:	3304      	adds	r3, #4
 80060f8:	653b      	str	r3, [r7, #80]	; 0x50
 80060fa:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 80060fc:	685b      	ldr	r3, [r3, #4]
 80060fe:	627b      	str	r3, [r7, #36]	; 0x24
 8006100:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8006102:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 8006104:	623b      	str	r3, [r7, #32]
 8006106:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8006108:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 800610a:	e9d7 010c 	ldrd	r0, r1, [r7, #48]	; 0x30
 800610e:	f7ff f823 	bl	8005158 <MADD64>
 8006112:	e9c7 010c 	strd	r0, r1, [r7, #48]	; 0x30
 8006116:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8006118:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 800611a:	e9d7 0106 	ldrd	r0, r1, [r7, #24]
 800611e:	f7ff f81b 	bl	8005158 <MADD64>
 8006122:	e9c7 0106 	strd	r0, r1, [r7, #24]
 8006126:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8006128:	425b      	negs	r3, r3
 800612a:	6a3a      	ldr	r2, [r7, #32]
 800612c:	e9d7 010c 	ldrd	r0, r1, [r7, #48]	; 0x30
 8006130:	f7ff f812 	bl	8005158 <MADD64>
 8006134:	e9c7 010c 	strd	r0, r1, [r7, #48]	; 0x30
 8006138:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800613a:	6a3a      	ldr	r2, [r7, #32]
 800613c:	e9d7 0106 	ldrd	r0, r1, [r7, #24]
 8006140:	f7ff f80a 	bl	8005158 <MADD64>
 8006144:	e9c7 0106 	strd	r0, r1, [r7, #24]
 8006148:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800614a:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
 800614e:	627b      	str	r3, [r7, #36]	; 0x24
 8006150:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8006152:	f8d3 30d8 	ldr.w	r3, [r3, #216]	; 0xd8
 8006156:	623b      	str	r3, [r7, #32]
 8006158:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800615a:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 800615c:	e9d7 010e 	ldrd	r0, r1, [r7, #56]	; 0x38
 8006160:	f7fe fffa 	bl	8005158 <MADD64>
 8006164:	e9c7 010e 	strd	r0, r1, [r7, #56]	; 0x38
 8006168:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800616a:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 800616c:	e9d7 0104 	ldrd	r0, r1, [r7, #16]
 8006170:	f7fe fff2 	bl	8005158 <MADD64>
 8006174:	e9c7 0104 	strd	r0, r1, [r7, #16]
 8006178:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800617a:	425b      	negs	r3, r3
 800617c:	6a3a      	ldr	r2, [r7, #32]
 800617e:	e9d7 010e 	ldrd	r0, r1, [r7, #56]	; 0x38
 8006182:	f7fe ffe9 	bl	8005158 <MADD64>
 8006186:	e9c7 010e 	strd	r0, r1, [r7, #56]	; 0x38
 800618a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800618c:	6a3a      	ldr	r2, [r7, #32]
 800618e:	e9d7 0104 	ldrd	r0, r1, [r7, #16]
 8006192:	f7fe ffe1 	bl	8005158 <MADD64>
 8006196:	e9c7 0104 	strd	r0, r1, [r7, #16]
		MC2S(2)
 800619a:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 800619c:	681b      	ldr	r3, [r3, #0]
 800619e:	62fb      	str	r3, [r7, #44]	; 0x2c
 80061a0:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 80061a2:	3304      	adds	r3, #4
 80061a4:	653b      	str	r3, [r7, #80]	; 0x50
 80061a6:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 80061a8:	681b      	ldr	r3, [r3, #0]
 80061aa:	62bb      	str	r3, [r7, #40]	; 0x28
 80061ac:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 80061ae:	3304      	adds	r3, #4
 80061b0:	653b      	str	r3, [r7, #80]	; 0x50
 80061b2:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 80061b4:	689b      	ldr	r3, [r3, #8]
 80061b6:	627b      	str	r3, [r7, #36]	; 0x24
 80061b8:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 80061ba:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 80061bc:	623b      	str	r3, [r7, #32]
 80061be:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80061c0:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 80061c2:	e9d7 010c 	ldrd	r0, r1, [r7, #48]	; 0x30
 80061c6:	f7fe ffc7 	bl	8005158 <MADD64>
 80061ca:	e9c7 010c 	strd	r0, r1, [r7, #48]	; 0x30
 80061ce:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80061d0:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 80061d2:	e9d7 0106 	ldrd	r0, r1, [r7, #24]
 80061d6:	f7fe ffbf 	bl	8005158 <MADD64>
 80061da:	e9c7 0106 	strd	r0, r1, [r7, #24]
 80061de:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80061e0:	425b      	negs	r3, r3
 80061e2:	6a3a      	ldr	r2, [r7, #32]
 80061e4:	e9d7 010c 	ldrd	r0, r1, [r7, #48]	; 0x30
 80061e8:	f7fe ffb6 	bl	8005158 <MADD64>
 80061ec:	e9c7 010c 	strd	r0, r1, [r7, #48]	; 0x30
 80061f0:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80061f2:	6a3a      	ldr	r2, [r7, #32]
 80061f4:	e9d7 0106 	ldrd	r0, r1, [r7, #24]
 80061f8:	f7fe ffae 	bl	8005158 <MADD64>
 80061fc:	e9c7 0106 	strd	r0, r1, [r7, #24]
 8006200:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8006202:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 8006206:	627b      	str	r3, [r7, #36]	; 0x24
 8006208:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800620a:	f8d3 30d4 	ldr.w	r3, [r3, #212]	; 0xd4
 800620e:	623b      	str	r3, [r7, #32]
 8006210:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8006212:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8006214:	e9d7 010e 	ldrd	r0, r1, [r7, #56]	; 0x38
 8006218:	f7fe ff9e 	bl	8005158 <MADD64>
 800621c:	e9c7 010e 	strd	r0, r1, [r7, #56]	; 0x38
 8006220:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8006222:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8006224:	e9d7 0104 	ldrd	r0, r1, [r7, #16]
 8006228:	f7fe ff96 	bl	8005158 <MADD64>
 800622c:	e9c7 0104 	strd	r0, r1, [r7, #16]
 8006230:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8006232:	425b      	negs	r3, r3
 8006234:	6a3a      	ldr	r2, [r7, #32]
 8006236:	e9d7 010e 	ldrd	r0, r1, [r7, #56]	; 0x38
 800623a:	f7fe ff8d 	bl	8005158 <MADD64>
 800623e:	e9c7 010e 	strd	r0, r1, [r7, #56]	; 0x38
 8006242:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8006244:	6a3a      	ldr	r2, [r7, #32]
 8006246:	e9d7 0104 	ldrd	r0, r1, [r7, #16]
 800624a:	f7fe ff85 	bl	8005158 <MADD64>
 800624e:	e9c7 0104 	strd	r0, r1, [r7, #16]
		MC2S(3)
 8006252:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8006254:	681b      	ldr	r3, [r3, #0]
 8006256:	62fb      	str	r3, [r7, #44]	; 0x2c
 8006258:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 800625a:	3304      	adds	r3, #4
 800625c:	653b      	str	r3, [r7, #80]	; 0x50
 800625e:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8006260:	681b      	ldr	r3, [r3, #0]
 8006262:	62bb      	str	r3, [r7, #40]	; 0x28
 8006264:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8006266:	3304      	adds	r3, #4
 8006268:	653b      	str	r3, [r7, #80]	; 0x50
 800626a:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800626c:	68db      	ldr	r3, [r3, #12]
 800626e:	627b      	str	r3, [r7, #36]	; 0x24
 8006270:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8006272:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 8006274:	623b      	str	r3, [r7, #32]
 8006276:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8006278:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 800627a:	e9d7 010c 	ldrd	r0, r1, [r7, #48]	; 0x30
 800627e:	f7fe ff6b 	bl	8005158 <MADD64>
 8006282:	e9c7 010c 	strd	r0, r1, [r7, #48]	; 0x30
 8006286:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8006288:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 800628a:	e9d7 0106 	ldrd	r0, r1, [r7, #24]
 800628e:	f7fe ff63 	bl	8005158 <MADD64>
 8006292:	e9c7 0106 	strd	r0, r1, [r7, #24]
 8006296:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8006298:	425b      	negs	r3, r3
 800629a:	6a3a      	ldr	r2, [r7, #32]
 800629c:	e9d7 010c 	ldrd	r0, r1, [r7, #48]	; 0x30
 80062a0:	f7fe ff5a 	bl	8005158 <MADD64>
 80062a4:	e9c7 010c 	strd	r0, r1, [r7, #48]	; 0x30
 80062a8:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80062aa:	6a3a      	ldr	r2, [r7, #32]
 80062ac:	e9d7 0106 	ldrd	r0, r1, [r7, #24]
 80062b0:	f7fe ff52 	bl	8005158 <MADD64>
 80062b4:	e9c7 0106 	strd	r0, r1, [r7, #24]
 80062b8:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 80062ba:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 80062be:	627b      	str	r3, [r7, #36]	; 0x24
 80062c0:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 80062c2:	f8d3 30d0 	ldr.w	r3, [r3, #208]	; 0xd0
 80062c6:	623b      	str	r3, [r7, #32]
 80062c8:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80062ca:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 80062cc:	e9d7 010e 	ldrd	r0, r1, [r7, #56]	; 0x38
 80062d0:	f7fe ff42 	bl	8005158 <MADD64>
 80062d4:	e9c7 010e 	strd	r0, r1, [r7, #56]	; 0x38
 80062d8:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80062da:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 80062dc:	e9d7 0104 	ldrd	r0, r1, [r7, #16]
 80062e0:	f7fe ff3a 	bl	8005158 <MADD64>
 80062e4:	e9c7 0104 	strd	r0, r1, [r7, #16]
 80062e8:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80062ea:	425b      	negs	r3, r3
 80062ec:	6a3a      	ldr	r2, [r7, #32]
 80062ee:	e9d7 010e 	ldrd	r0, r1, [r7, #56]	; 0x38
 80062f2:	f7fe ff31 	bl	8005158 <MADD64>
 80062f6:	e9c7 010e 	strd	r0, r1, [r7, #56]	; 0x38
 80062fa:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80062fc:	6a3a      	ldr	r2, [r7, #32]
 80062fe:	e9d7 0104 	ldrd	r0, r1, [r7, #16]
 8006302:	f7fe ff29 	bl	8005158 <MADD64>
 8006306:	e9c7 0104 	strd	r0, r1, [r7, #16]
		MC2S(4)
 800630a:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 800630c:	681b      	ldr	r3, [r3, #0]
 800630e:	62fb      	str	r3, [r7, #44]	; 0x2c
 8006310:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8006312:	3304      	adds	r3, #4
 8006314:	653b      	str	r3, [r7, #80]	; 0x50
 8006316:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8006318:	681b      	ldr	r3, [r3, #0]
 800631a:	62bb      	str	r3, [r7, #40]	; 0x28
 800631c:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 800631e:	3304      	adds	r3, #4
 8006320:	653b      	str	r3, [r7, #80]	; 0x50
 8006322:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8006324:	691b      	ldr	r3, [r3, #16]
 8006326:	627b      	str	r3, [r7, #36]	; 0x24
 8006328:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800632a:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 800632c:	623b      	str	r3, [r7, #32]
 800632e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8006330:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8006332:	e9d7 010c 	ldrd	r0, r1, [r7, #48]	; 0x30
 8006336:	f7fe ff0f 	bl	8005158 <MADD64>
 800633a:	e9c7 010c 	strd	r0, r1, [r7, #48]	; 0x30
 800633e:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8006340:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8006342:	e9d7 0106 	ldrd	r0, r1, [r7, #24]
 8006346:	f7fe ff07 	bl	8005158 <MADD64>
 800634a:	e9c7 0106 	strd	r0, r1, [r7, #24]
 800634e:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8006350:	425b      	negs	r3, r3
 8006352:	6a3a      	ldr	r2, [r7, #32]
 8006354:	e9d7 010c 	ldrd	r0, r1, [r7, #48]	; 0x30
 8006358:	f7fe fefe 	bl	8005158 <MADD64>
 800635c:	e9c7 010c 	strd	r0, r1, [r7, #48]	; 0x30
 8006360:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8006362:	6a3a      	ldr	r2, [r7, #32]
 8006364:	e9d7 0106 	ldrd	r0, r1, [r7, #24]
 8006368:	f7fe fef6 	bl	8005158 <MADD64>
 800636c:	e9c7 0106 	strd	r0, r1, [r7, #24]
 8006370:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8006372:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 8006376:	627b      	str	r3, [r7, #36]	; 0x24
 8006378:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800637a:	f8d3 30cc 	ldr.w	r3, [r3, #204]	; 0xcc
 800637e:	623b      	str	r3, [r7, #32]
 8006380:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8006382:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8006384:	e9d7 010e 	ldrd	r0, r1, [r7, #56]	; 0x38
 8006388:	f7fe fee6 	bl	8005158 <MADD64>
 800638c:	e9c7 010e 	strd	r0, r1, [r7, #56]	; 0x38
 8006390:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8006392:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8006394:	e9d7 0104 	ldrd	r0, r1, [r7, #16]
 8006398:	f7fe fede 	bl	8005158 <MADD64>
 800639c:	e9c7 0104 	strd	r0, r1, [r7, #16]
 80063a0:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80063a2:	425b      	negs	r3, r3
 80063a4:	6a3a      	ldr	r2, [r7, #32]
 80063a6:	e9d7 010e 	ldrd	r0, r1, [r7, #56]	; 0x38
 80063aa:	f7fe fed5 	bl	8005158 <MADD64>
 80063ae:	e9c7 010e 	strd	r0, r1, [r7, #56]	; 0x38
 80063b2:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80063b4:	6a3a      	ldr	r2, [r7, #32]
 80063b6:	e9d7 0104 	ldrd	r0, r1, [r7, #16]
 80063ba:	f7fe fecd 	bl	8005158 <MADD64>
 80063be:	e9c7 0104 	strd	r0, r1, [r7, #16]
		MC2S(5)
 80063c2:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 80063c4:	681b      	ldr	r3, [r3, #0]
 80063c6:	62fb      	str	r3, [r7, #44]	; 0x2c
 80063c8:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 80063ca:	3304      	adds	r3, #4
 80063cc:	653b      	str	r3, [r7, #80]	; 0x50
 80063ce:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 80063d0:	681b      	ldr	r3, [r3, #0]
 80063d2:	62bb      	str	r3, [r7, #40]	; 0x28
 80063d4:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 80063d6:	3304      	adds	r3, #4
 80063d8:	653b      	str	r3, [r7, #80]	; 0x50
 80063da:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 80063dc:	695b      	ldr	r3, [r3, #20]
 80063de:	627b      	str	r3, [r7, #36]	; 0x24
 80063e0:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 80063e2:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 80063e4:	623b      	str	r3, [r7, #32]
 80063e6:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80063e8:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 80063ea:	e9d7 010c 	ldrd	r0, r1, [r7, #48]	; 0x30
 80063ee:	f7fe feb3 	bl	8005158 <MADD64>
 80063f2:	e9c7 010c 	strd	r0, r1, [r7, #48]	; 0x30
 80063f6:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80063f8:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 80063fa:	e9d7 0106 	ldrd	r0, r1, [r7, #24]
 80063fe:	f7fe feab 	bl	8005158 <MADD64>
 8006402:	e9c7 0106 	strd	r0, r1, [r7, #24]
 8006406:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8006408:	425b      	negs	r3, r3
 800640a:	6a3a      	ldr	r2, [r7, #32]
 800640c:	e9d7 010c 	ldrd	r0, r1, [r7, #48]	; 0x30
 8006410:	f7fe fea2 	bl	8005158 <MADD64>
 8006414:	e9c7 010c 	strd	r0, r1, [r7, #48]	; 0x30
 8006418:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800641a:	6a3a      	ldr	r2, [r7, #32]
 800641c:	e9d7 0106 	ldrd	r0, r1, [r7, #24]
 8006420:	f7fe fe9a 	bl	8005158 <MADD64>
 8006424:	e9c7 0106 	strd	r0, r1, [r7, #24]
 8006428:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800642a:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
 800642e:	627b      	str	r3, [r7, #36]	; 0x24
 8006430:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8006432:	f8d3 30c8 	ldr.w	r3, [r3, #200]	; 0xc8
 8006436:	623b      	str	r3, [r7, #32]
 8006438:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800643a:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 800643c:	e9d7 010e 	ldrd	r0, r1, [r7, #56]	; 0x38
 8006440:	f7fe fe8a 	bl	8005158 <MADD64>
 8006444:	e9c7 010e 	strd	r0, r1, [r7, #56]	; 0x38
 8006448:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800644a:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 800644c:	e9d7 0104 	ldrd	r0, r1, [r7, #16]
 8006450:	f7fe fe82 	bl	8005158 <MADD64>
 8006454:	e9c7 0104 	strd	r0, r1, [r7, #16]
 8006458:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800645a:	425b      	negs	r3, r3
 800645c:	6a3a      	ldr	r2, [r7, #32]
 800645e:	e9d7 010e 	ldrd	r0, r1, [r7, #56]	; 0x38
 8006462:	f7fe fe79 	bl	8005158 <MADD64>
 8006466:	e9c7 010e 	strd	r0, r1, [r7, #56]	; 0x38
 800646a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800646c:	6a3a      	ldr	r2, [r7, #32]
 800646e:	e9d7 0104 	ldrd	r0, r1, [r7, #16]
 8006472:	f7fe fe71 	bl	8005158 <MADD64>
 8006476:	e9c7 0104 	strd	r0, r1, [r7, #16]
		MC2S(6)
 800647a:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 800647c:	681b      	ldr	r3, [r3, #0]
 800647e:	62fb      	str	r3, [r7, #44]	; 0x2c
 8006480:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8006482:	3304      	adds	r3, #4
 8006484:	653b      	str	r3, [r7, #80]	; 0x50
 8006486:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8006488:	681b      	ldr	r3, [r3, #0]
 800648a:	62bb      	str	r3, [r7, #40]	; 0x28
 800648c:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 800648e:	3304      	adds	r3, #4
 8006490:	653b      	str	r3, [r7, #80]	; 0x50
 8006492:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8006494:	699b      	ldr	r3, [r3, #24]
 8006496:	627b      	str	r3, [r7, #36]	; 0x24
 8006498:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800649a:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800649c:	623b      	str	r3, [r7, #32]
 800649e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80064a0:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 80064a2:	e9d7 010c 	ldrd	r0, r1, [r7, #48]	; 0x30
 80064a6:	f7fe fe57 	bl	8005158 <MADD64>
 80064aa:	e9c7 010c 	strd	r0, r1, [r7, #48]	; 0x30
 80064ae:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80064b0:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 80064b2:	e9d7 0106 	ldrd	r0, r1, [r7, #24]
 80064b6:	f7fe fe4f 	bl	8005158 <MADD64>
 80064ba:	e9c7 0106 	strd	r0, r1, [r7, #24]
 80064be:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80064c0:	425b      	negs	r3, r3
 80064c2:	6a3a      	ldr	r2, [r7, #32]
 80064c4:	e9d7 010c 	ldrd	r0, r1, [r7, #48]	; 0x30
 80064c8:	f7fe fe46 	bl	8005158 <MADD64>
 80064cc:	e9c7 010c 	strd	r0, r1, [r7, #48]	; 0x30
 80064d0:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80064d2:	6a3a      	ldr	r2, [r7, #32]
 80064d4:	e9d7 0106 	ldrd	r0, r1, [r7, #24]
 80064d8:	f7fe fe3e 	bl	8005158 <MADD64>
 80064dc:	e9c7 0106 	strd	r0, r1, [r7, #24]
 80064e0:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 80064e2:	f8d3 3098 	ldr.w	r3, [r3, #152]	; 0x98
 80064e6:	627b      	str	r3, [r7, #36]	; 0x24
 80064e8:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 80064ea:	f8d3 30c4 	ldr.w	r3, [r3, #196]	; 0xc4
 80064ee:	623b      	str	r3, [r7, #32]
 80064f0:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80064f2:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 80064f4:	e9d7 010e 	ldrd	r0, r1, [r7, #56]	; 0x38
 80064f8:	f7fe fe2e 	bl	8005158 <MADD64>
 80064fc:	e9c7 010e 	strd	r0, r1, [r7, #56]	; 0x38
 8006500:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8006502:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8006504:	e9d7 0104 	ldrd	r0, r1, [r7, #16]
 8006508:	f7fe fe26 	bl	8005158 <MADD64>
 800650c:	e9c7 0104 	strd	r0, r1, [r7, #16]
 8006510:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8006512:	425b      	negs	r3, r3
 8006514:	6a3a      	ldr	r2, [r7, #32]
 8006516:	e9d7 010e 	ldrd	r0, r1, [r7, #56]	; 0x38
 800651a:	f7fe fe1d 	bl	8005158 <MADD64>
 800651e:	e9c7 010e 	strd	r0, r1, [r7, #56]	; 0x38
 8006522:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8006524:	6a3a      	ldr	r2, [r7, #32]
 8006526:	e9d7 0104 	ldrd	r0, r1, [r7, #16]
 800652a:	f7fe fe15 	bl	8005158 <MADD64>
 800652e:	e9c7 0104 	strd	r0, r1, [r7, #16]
		MC2S(7)
 8006532:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8006534:	681b      	ldr	r3, [r3, #0]
 8006536:	62fb      	str	r3, [r7, #44]	; 0x2c
 8006538:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 800653a:	3304      	adds	r3, #4
 800653c:	653b      	str	r3, [r7, #80]	; 0x50
 800653e:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8006540:	681b      	ldr	r3, [r3, #0]
 8006542:	62bb      	str	r3, [r7, #40]	; 0x28
 8006544:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8006546:	3304      	adds	r3, #4
 8006548:	653b      	str	r3, [r7, #80]	; 0x50
 800654a:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800654c:	69db      	ldr	r3, [r3, #28]
 800654e:	627b      	str	r3, [r7, #36]	; 0x24
 8006550:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8006552:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8006554:	623b      	str	r3, [r7, #32]
 8006556:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8006558:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 800655a:	e9d7 010c 	ldrd	r0, r1, [r7, #48]	; 0x30
 800655e:	f7fe fdfb 	bl	8005158 <MADD64>
 8006562:	e9c7 010c 	strd	r0, r1, [r7, #48]	; 0x30
 8006566:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8006568:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 800656a:	e9d7 0106 	ldrd	r0, r1, [r7, #24]
 800656e:	f7fe fdf3 	bl	8005158 <MADD64>
 8006572:	e9c7 0106 	strd	r0, r1, [r7, #24]
 8006576:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8006578:	425b      	negs	r3, r3
 800657a:	6a3a      	ldr	r2, [r7, #32]
 800657c:	e9d7 010c 	ldrd	r0, r1, [r7, #48]	; 0x30
 8006580:	f7fe fdea 	bl	8005158 <MADD64>
 8006584:	e9c7 010c 	strd	r0, r1, [r7, #48]	; 0x30
 8006588:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800658a:	6a3a      	ldr	r2, [r7, #32]
 800658c:	e9d7 0106 	ldrd	r0, r1, [r7, #24]
 8006590:	f7fe fde2 	bl	8005158 <MADD64>
 8006594:	e9c7 0106 	strd	r0, r1, [r7, #24]
 8006598:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800659a:	f8d3 309c 	ldr.w	r3, [r3, #156]	; 0x9c
 800659e:	627b      	str	r3, [r7, #36]	; 0x24
 80065a0:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 80065a2:	f8d3 30c0 	ldr.w	r3, [r3, #192]	; 0xc0
 80065a6:	623b      	str	r3, [r7, #32]
 80065a8:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80065aa:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 80065ac:	e9d7 010e 	ldrd	r0, r1, [r7, #56]	; 0x38
 80065b0:	f7fe fdd2 	bl	8005158 <MADD64>
 80065b4:	e9c7 010e 	strd	r0, r1, [r7, #56]	; 0x38
 80065b8:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80065ba:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 80065bc:	e9d7 0104 	ldrd	r0, r1, [r7, #16]
 80065c0:	f7fe fdca 	bl	8005158 <MADD64>
 80065c4:	e9c7 0104 	strd	r0, r1, [r7, #16]
 80065c8:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80065ca:	425b      	negs	r3, r3
 80065cc:	6a3a      	ldr	r2, [r7, #32]
 80065ce:	e9d7 010e 	ldrd	r0, r1, [r7, #56]	; 0x38
 80065d2:	f7fe fdc1 	bl	8005158 <MADD64>
 80065d6:	e9c7 010e 	strd	r0, r1, [r7, #56]	; 0x38
 80065da:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80065dc:	6a3a      	ldr	r2, [r7, #32]
 80065de:	e9d7 0104 	ldrd	r0, r1, [r7, #16]
 80065e2:	f7fe fdb9 	bl	8005158 <MADD64>
 80065e6:	e9c7 0104 	strd	r0, r1, [r7, #16]

		vb1 += 64;
 80065ea:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 80065ec:	f503 7380 	add.w	r3, r3, #256	; 0x100
 80065f0:	64fb      	str	r3, [r7, #76]	; 0x4c
		*(pcm + 0)         = ClipToShort((int)SAR64(sum1L, (32-CSHIFT)), DEF_NFRACBITS);
 80065f2:	2214      	movs	r2, #20
 80065f4:	e9d7 010c 	ldrd	r0, r1, [r7, #48]	; 0x30
 80065f8:	f7fe fdc9 	bl	800518e <SAR64>
 80065fc:	4603      	mov	r3, r0
 80065fe:	460c      	mov	r4, r1
 8006600:	2106      	movs	r1, #6
 8006602:	4618      	mov	r0, r3
 8006604:	f7fe fde2 	bl	80051cc <ClipToShort>
 8006608:	4603      	mov	r3, r0
 800660a:	461a      	mov	r2, r3
 800660c:	68fb      	ldr	r3, [r7, #12]
 800660e:	801a      	strh	r2, [r3, #0]
		*(pcm + 1)         = ClipToShort((int)SAR64(sum1R, (32-CSHIFT)), DEF_NFRACBITS);
 8006610:	68fb      	ldr	r3, [r7, #12]
 8006612:	1c9c      	adds	r4, r3, #2
 8006614:	2214      	movs	r2, #20
 8006616:	e9d7 010e 	ldrd	r0, r1, [r7, #56]	; 0x38
 800661a:	f7fe fdb8 	bl	800518e <SAR64>
 800661e:	4602      	mov	r2, r0
 8006620:	460b      	mov	r3, r1
 8006622:	4613      	mov	r3, r2
 8006624:	2106      	movs	r1, #6
 8006626:	4618      	mov	r0, r3
 8006628:	f7fe fdd0 	bl	80051cc <ClipToShort>
 800662c:	4603      	mov	r3, r0
 800662e:	8023      	strh	r3, [r4, #0]
		*(pcm + 2*2*i + 0) = ClipToShort((int)SAR64(sum2L, (32-CSHIFT)), DEF_NFRACBITS);
 8006630:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8006632:	00db      	lsls	r3, r3, #3
 8006634:	461a      	mov	r2, r3
 8006636:	68fb      	ldr	r3, [r7, #12]
 8006638:	189c      	adds	r4, r3, r2
 800663a:	2214      	movs	r2, #20
 800663c:	e9d7 0106 	ldrd	r0, r1, [r7, #24]
 8006640:	f7fe fda5 	bl	800518e <SAR64>
 8006644:	4602      	mov	r2, r0
 8006646:	460b      	mov	r3, r1
 8006648:	4613      	mov	r3, r2
 800664a:	2106      	movs	r1, #6
 800664c:	4618      	mov	r0, r3
 800664e:	f7fe fdbd 	bl	80051cc <ClipToShort>
 8006652:	4603      	mov	r3, r0
 8006654:	8023      	strh	r3, [r4, #0]
		*(pcm + 2*2*i + 1) = ClipToShort((int)SAR64(sum2R, (32-CSHIFT)), DEF_NFRACBITS);
 8006656:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8006658:	00db      	lsls	r3, r3, #3
 800665a:	3302      	adds	r3, #2
 800665c:	68fa      	ldr	r2, [r7, #12]
 800665e:	18d4      	adds	r4, r2, r3
 8006660:	2214      	movs	r2, #20
 8006662:	e9d7 0104 	ldrd	r0, r1, [r7, #16]
 8006666:	f7fe fd92 	bl	800518e <SAR64>
 800666a:	4602      	mov	r2, r0
 800666c:	460b      	mov	r3, r1
 800666e:	4613      	mov	r3, r2
 8006670:	2106      	movs	r1, #6
 8006672:	4618      	mov	r0, r3
 8006674:	f7fe fdaa 	bl	80051cc <ClipToShort>
 8006678:	4603      	mov	r3, r0
 800667a:	8023      	strh	r3, [r4, #0]
		pcm += 2;
 800667c:	68fb      	ldr	r3, [r7, #12]
 800667e:	3304      	adds	r3, #4
 8006680:	60fb      	str	r3, [r7, #12]
	for (i = 15; i > 0; i--) {
 8006682:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8006684:	3b01      	subs	r3, #1
 8006686:	657b      	str	r3, [r7, #84]	; 0x54
 8006688:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 800668a:	2b00      	cmp	r3, #0
 800668c:	f73f acbd 	bgt.w	800600a <xmp3fixpt_PolyphaseStereo+0x67c>
	}
}
 8006690:	bf00      	nop
 8006692:	375c      	adds	r7, #92	; 0x5c
 8006694:	46bd      	mov	sp, r7
 8006696:	bd90      	pop	{r4, r7, pc}

08006698 <UnpackSFMPEG1>:
 *                so that we index through consectutive memory locations when unpacking 
 *                (make sure dequantizer follows same convention)
 *              Illegal Intensity Position = 7 (always) for MPEG1 scale factors
 **************************************************************************************/
static void UnpackSFMPEG1(BitStreamInfo *bsi, SideInfoSub *sis, ScaleFactorInfoSub *sfis, int *scfsi, int gr, ScaleFactorInfoSub *sfisGr0)
{
 8006698:	b580      	push	{r7, lr}
 800669a:	b088      	sub	sp, #32
 800669c:	af00      	add	r7, sp, #0
 800669e:	60f8      	str	r0, [r7, #12]
 80066a0:	60b9      	str	r1, [r7, #8]
 80066a2:	607a      	str	r2, [r7, #4]
 80066a4:	603b      	str	r3, [r7, #0]
	int sfb;
	int slen0, slen1;
	
	/* these can be 0, so make sure GetBits(bsi, 0) returns 0 (no >> 32 or anything) */
	slen0 = (int)SFLenTab[sis->sfCompress][0];
 80066a6:	68bb      	ldr	r3, [r7, #8]
 80066a8:	68db      	ldr	r3, [r3, #12]
 80066aa:	4aa7      	ldr	r2, [pc, #668]	; (8006948 <UnpackSFMPEG1+0x2b0>)
 80066ac:	f812 3013 	ldrb.w	r3, [r2, r3, lsl #1]
 80066b0:	61bb      	str	r3, [r7, #24]
	slen1 = (int)SFLenTab[sis->sfCompress][1];
 80066b2:	68bb      	ldr	r3, [r7, #8]
 80066b4:	68db      	ldr	r3, [r3, #12]
 80066b6:	4aa4      	ldr	r2, [pc, #656]	; (8006948 <UnpackSFMPEG1+0x2b0>)
 80066b8:	005b      	lsls	r3, r3, #1
 80066ba:	4413      	add	r3, r2
 80066bc:	785b      	ldrb	r3, [r3, #1]
 80066be:	617b      	str	r3, [r7, #20]
	
	if (sis->blockType == 2) {
 80066c0:	68bb      	ldr	r3, [r7, #8]
 80066c2:	695b      	ldr	r3, [r3, #20]
 80066c4:	2b02      	cmp	r3, #2
 80066c6:	f040 8096 	bne.w	80067f6 <UnpackSFMPEG1+0x15e>
		/* short block, type 2 (implies winSwitchFlag == 1) */
		if (sis->mixedBlock) {          
 80066ca:	68bb      	ldr	r3, [r7, #8]
 80066cc:	699b      	ldr	r3, [r3, #24]
 80066ce:	2b00      	cmp	r3, #0
 80066d0:	d016      	beq.n	8006700 <UnpackSFMPEG1+0x68>
			/* do long block portion */
			for (sfb = 0; sfb < 8; sfb++)
 80066d2:	2300      	movs	r3, #0
 80066d4:	61fb      	str	r3, [r7, #28]
 80066d6:	e00d      	b.n	80066f4 <UnpackSFMPEG1+0x5c>
				sfis->l[sfb] =    (char)GetBits(bsi, slen0);
 80066d8:	69b9      	ldr	r1, [r7, #24]
 80066da:	68f8      	ldr	r0, [r7, #12]
 80066dc:	f7fa f95f 	bl	800099e <xmp3fixpt_GetBits>
 80066e0:	4603      	mov	r3, r0
 80066e2:	b2d9      	uxtb	r1, r3
 80066e4:	687a      	ldr	r2, [r7, #4]
 80066e6:	69fb      	ldr	r3, [r7, #28]
 80066e8:	4413      	add	r3, r2
 80066ea:	460a      	mov	r2, r1
 80066ec:	701a      	strb	r2, [r3, #0]
			for (sfb = 0; sfb < 8; sfb++)
 80066ee:	69fb      	ldr	r3, [r7, #28]
 80066f0:	3301      	adds	r3, #1
 80066f2:	61fb      	str	r3, [r7, #28]
 80066f4:	69fb      	ldr	r3, [r7, #28]
 80066f6:	2b07      	cmp	r3, #7
 80066f8:	ddee      	ble.n	80066d8 <UnpackSFMPEG1+0x40>
			sfb = 3;
 80066fa:	2303      	movs	r3, #3
 80066fc:	61fb      	str	r3, [r7, #28]
 80066fe:	e032      	b.n	8006766 <UnpackSFMPEG1+0xce>
		} else {
			/* all short blocks */
			sfb = 0;
 8006700:	2300      	movs	r3, #0
 8006702:	61fb      	str	r3, [r7, #28]
		}

		for (      ; sfb < 6; sfb++) {
 8006704:	e02f      	b.n	8006766 <UnpackSFMPEG1+0xce>
			sfis->s[sfb][0] = (char)GetBits(bsi, slen0);
 8006706:	69b9      	ldr	r1, [r7, #24]
 8006708:	68f8      	ldr	r0, [r7, #12]
 800670a:	f7fa f948 	bl	800099e <xmp3fixpt_GetBits>
 800670e:	4603      	mov	r3, r0
 8006710:	b2d8      	uxtb	r0, r3
 8006712:	6879      	ldr	r1, [r7, #4]
 8006714:	69fa      	ldr	r2, [r7, #28]
 8006716:	4613      	mov	r3, r2
 8006718:	005b      	lsls	r3, r3, #1
 800671a:	4413      	add	r3, r2
 800671c:	440b      	add	r3, r1
 800671e:	3317      	adds	r3, #23
 8006720:	4602      	mov	r2, r0
 8006722:	701a      	strb	r2, [r3, #0]
			sfis->s[sfb][1] = (char)GetBits(bsi, slen0);
 8006724:	69b9      	ldr	r1, [r7, #24]
 8006726:	68f8      	ldr	r0, [r7, #12]
 8006728:	f7fa f939 	bl	800099e <xmp3fixpt_GetBits>
 800672c:	4603      	mov	r3, r0
 800672e:	b2d8      	uxtb	r0, r3
 8006730:	6879      	ldr	r1, [r7, #4]
 8006732:	69fa      	ldr	r2, [r7, #28]
 8006734:	4613      	mov	r3, r2
 8006736:	005b      	lsls	r3, r3, #1
 8006738:	4413      	add	r3, r2
 800673a:	440b      	add	r3, r1
 800673c:	3318      	adds	r3, #24
 800673e:	4602      	mov	r2, r0
 8006740:	701a      	strb	r2, [r3, #0]
			sfis->s[sfb][2] = (char)GetBits(bsi, slen0);
 8006742:	69b9      	ldr	r1, [r7, #24]
 8006744:	68f8      	ldr	r0, [r7, #12]
 8006746:	f7fa f92a 	bl	800099e <xmp3fixpt_GetBits>
 800674a:	4603      	mov	r3, r0
 800674c:	b2d8      	uxtb	r0, r3
 800674e:	6879      	ldr	r1, [r7, #4]
 8006750:	69fa      	ldr	r2, [r7, #28]
 8006752:	4613      	mov	r3, r2
 8006754:	005b      	lsls	r3, r3, #1
 8006756:	4413      	add	r3, r2
 8006758:	440b      	add	r3, r1
 800675a:	3319      	adds	r3, #25
 800675c:	4602      	mov	r2, r0
 800675e:	701a      	strb	r2, [r3, #0]
		for (      ; sfb < 6; sfb++) {
 8006760:	69fb      	ldr	r3, [r7, #28]
 8006762:	3301      	adds	r3, #1
 8006764:	61fb      	str	r3, [r7, #28]
 8006766:	69fb      	ldr	r3, [r7, #28]
 8006768:	2b05      	cmp	r3, #5
 800676a:	ddcc      	ble.n	8006706 <UnpackSFMPEG1+0x6e>
		}

		for (      ; sfb < 12; sfb++) {
 800676c:	e02f      	b.n	80067ce <UnpackSFMPEG1+0x136>
			sfis->s[sfb][0] = (char)GetBits(bsi, slen1);
 800676e:	6979      	ldr	r1, [r7, #20]
 8006770:	68f8      	ldr	r0, [r7, #12]
 8006772:	f7fa f914 	bl	800099e <xmp3fixpt_GetBits>
 8006776:	4603      	mov	r3, r0
 8006778:	b2d8      	uxtb	r0, r3
 800677a:	6879      	ldr	r1, [r7, #4]
 800677c:	69fa      	ldr	r2, [r7, #28]
 800677e:	4613      	mov	r3, r2
 8006780:	005b      	lsls	r3, r3, #1
 8006782:	4413      	add	r3, r2
 8006784:	440b      	add	r3, r1
 8006786:	3317      	adds	r3, #23
 8006788:	4602      	mov	r2, r0
 800678a:	701a      	strb	r2, [r3, #0]
			sfis->s[sfb][1] = (char)GetBits(bsi, slen1);
 800678c:	6979      	ldr	r1, [r7, #20]
 800678e:	68f8      	ldr	r0, [r7, #12]
 8006790:	f7fa f905 	bl	800099e <xmp3fixpt_GetBits>
 8006794:	4603      	mov	r3, r0
 8006796:	b2d8      	uxtb	r0, r3
 8006798:	6879      	ldr	r1, [r7, #4]
 800679a:	69fa      	ldr	r2, [r7, #28]
 800679c:	4613      	mov	r3, r2
 800679e:	005b      	lsls	r3, r3, #1
 80067a0:	4413      	add	r3, r2
 80067a2:	440b      	add	r3, r1
 80067a4:	3318      	adds	r3, #24
 80067a6:	4602      	mov	r2, r0
 80067a8:	701a      	strb	r2, [r3, #0]
			sfis->s[sfb][2] = (char)GetBits(bsi, slen1);
 80067aa:	6979      	ldr	r1, [r7, #20]
 80067ac:	68f8      	ldr	r0, [r7, #12]
 80067ae:	f7fa f8f6 	bl	800099e <xmp3fixpt_GetBits>
 80067b2:	4603      	mov	r3, r0
 80067b4:	b2d8      	uxtb	r0, r3
 80067b6:	6879      	ldr	r1, [r7, #4]
 80067b8:	69fa      	ldr	r2, [r7, #28]
 80067ba:	4613      	mov	r3, r2
 80067bc:	005b      	lsls	r3, r3, #1
 80067be:	4413      	add	r3, r2
 80067c0:	440b      	add	r3, r1
 80067c2:	3319      	adds	r3, #25
 80067c4:	4602      	mov	r2, r0
 80067c6:	701a      	strb	r2, [r3, #0]
		for (      ; sfb < 12; sfb++) {
 80067c8:	69fb      	ldr	r3, [r7, #28]
 80067ca:	3301      	adds	r3, #1
 80067cc:	61fb      	str	r3, [r7, #28]
 80067ce:	69fb      	ldr	r3, [r7, #28]
 80067d0:	2b0b      	cmp	r3, #11
 80067d2:	ddcc      	ble.n	800676e <UnpackSFMPEG1+0xd6>
		}

		/* last sf band not transmitted */
		sfis->s[12][0] = sfis->s[12][1] = sfis->s[12][2] = 0;
 80067d4:	687b      	ldr	r3, [r7, #4]
 80067d6:	2200      	movs	r2, #0
 80067d8:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d
 80067dc:	687b      	ldr	r3, [r7, #4]
 80067de:	f893 203d 	ldrb.w	r2, [r3, #61]	; 0x3d
 80067e2:	687b      	ldr	r3, [r7, #4]
 80067e4:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c
 80067e8:	687b      	ldr	r3, [r7, #4]
 80067ea:	f893 203c 	ldrb.w	r2, [r3, #60]	; 0x3c
 80067ee:	687b      	ldr	r3, [r7, #4]
 80067f0:	f883 203b 	strb.w	r2, [r3, #59]	; 0x3b
 80067f4:	e0d1      	b.n	800699a <UnpackSFMPEG1+0x302>
	} else {
		/* long blocks, type 0, 1, or 3 */
		if(gr == 0) {
 80067f6:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80067f8:	2b00      	cmp	r3, #0
 80067fa:	d128      	bne.n	800684e <UnpackSFMPEG1+0x1b6>
			/* first granule */
			for (sfb = 0;  sfb < 11; sfb++) 
 80067fc:	2300      	movs	r3, #0
 80067fe:	61fb      	str	r3, [r7, #28]
 8006800:	e00d      	b.n	800681e <UnpackSFMPEG1+0x186>
				sfis->l[sfb] = (char)GetBits(bsi, slen0);
 8006802:	69b9      	ldr	r1, [r7, #24]
 8006804:	68f8      	ldr	r0, [r7, #12]
 8006806:	f7fa f8ca 	bl	800099e <xmp3fixpt_GetBits>
 800680a:	4603      	mov	r3, r0
 800680c:	b2d9      	uxtb	r1, r3
 800680e:	687a      	ldr	r2, [r7, #4]
 8006810:	69fb      	ldr	r3, [r7, #28]
 8006812:	4413      	add	r3, r2
 8006814:	460a      	mov	r2, r1
 8006816:	701a      	strb	r2, [r3, #0]
			for (sfb = 0;  sfb < 11; sfb++) 
 8006818:	69fb      	ldr	r3, [r7, #28]
 800681a:	3301      	adds	r3, #1
 800681c:	61fb      	str	r3, [r7, #28]
 800681e:	69fb      	ldr	r3, [r7, #28]
 8006820:	2b0a      	cmp	r3, #10
 8006822:	ddee      	ble.n	8006802 <UnpackSFMPEG1+0x16a>
			for (sfb = 11; sfb < 21; sfb++) 
 8006824:	230b      	movs	r3, #11
 8006826:	61fb      	str	r3, [r7, #28]
 8006828:	e00d      	b.n	8006846 <UnpackSFMPEG1+0x1ae>
				sfis->l[sfb] = (char)GetBits(bsi, slen1);
 800682a:	6979      	ldr	r1, [r7, #20]
 800682c:	68f8      	ldr	r0, [r7, #12]
 800682e:	f7fa f8b6 	bl	800099e <xmp3fixpt_GetBits>
 8006832:	4603      	mov	r3, r0
 8006834:	b2d9      	uxtb	r1, r3
 8006836:	687a      	ldr	r2, [r7, #4]
 8006838:	69fb      	ldr	r3, [r7, #28]
 800683a:	4413      	add	r3, r2
 800683c:	460a      	mov	r2, r1
 800683e:	701a      	strb	r2, [r3, #0]
			for (sfb = 11; sfb < 21; sfb++) 
 8006840:	69fb      	ldr	r3, [r7, #28]
 8006842:	3301      	adds	r3, #1
 8006844:	61fb      	str	r3, [r7, #28]
 8006846:	69fb      	ldr	r3, [r7, #28]
 8006848:	2b14      	cmp	r3, #20
 800684a:	ddee      	ble.n	800682a <UnpackSFMPEG1+0x192>
			return;
 800684c:	e0a5      	b.n	800699a <UnpackSFMPEG1+0x302>
		} else {
			/* second granule
			 * scfsi: 0 = different scalefactors for each granule, 1 = copy sf's from granule 0 into granule 1 
			 * for block type == 2, scfsi is always 0
			 */
			sfb = 0;
 800684e:	2300      	movs	r3, #0
 8006850:	61fb      	str	r3, [r7, #28]
			if(scfsi[0])  for(  ; sfb < 6 ; sfb++) sfis->l[sfb] = sfisGr0->l[sfb];
 8006852:	683b      	ldr	r3, [r7, #0]
 8006854:	681b      	ldr	r3, [r3, #0]
 8006856:	2b00      	cmp	r3, #0
 8006858:	d01e      	beq.n	8006898 <UnpackSFMPEG1+0x200>
 800685a:	e00b      	b.n	8006874 <UnpackSFMPEG1+0x1dc>
 800685c:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 800685e:	69fb      	ldr	r3, [r7, #28]
 8006860:	4413      	add	r3, r2
 8006862:	7819      	ldrb	r1, [r3, #0]
 8006864:	687a      	ldr	r2, [r7, #4]
 8006866:	69fb      	ldr	r3, [r7, #28]
 8006868:	4413      	add	r3, r2
 800686a:	460a      	mov	r2, r1
 800686c:	701a      	strb	r2, [r3, #0]
 800686e:	69fb      	ldr	r3, [r7, #28]
 8006870:	3301      	adds	r3, #1
 8006872:	61fb      	str	r3, [r7, #28]
 8006874:	69fb      	ldr	r3, [r7, #28]
 8006876:	2b05      	cmp	r3, #5
 8006878:	ddf0      	ble.n	800685c <UnpackSFMPEG1+0x1c4>
 800687a:	e010      	b.n	800689e <UnpackSFMPEG1+0x206>
			else          for(  ; sfb < 6 ; sfb++) sfis->l[sfb] = (char)GetBits(bsi, slen0);
 800687c:	69b9      	ldr	r1, [r7, #24]
 800687e:	68f8      	ldr	r0, [r7, #12]
 8006880:	f7fa f88d 	bl	800099e <xmp3fixpt_GetBits>
 8006884:	4603      	mov	r3, r0
 8006886:	b2d9      	uxtb	r1, r3
 8006888:	687a      	ldr	r2, [r7, #4]
 800688a:	69fb      	ldr	r3, [r7, #28]
 800688c:	4413      	add	r3, r2
 800688e:	460a      	mov	r2, r1
 8006890:	701a      	strb	r2, [r3, #0]
 8006892:	69fb      	ldr	r3, [r7, #28]
 8006894:	3301      	adds	r3, #1
 8006896:	61fb      	str	r3, [r7, #28]
 8006898:	69fb      	ldr	r3, [r7, #28]
 800689a:	2b05      	cmp	r3, #5
 800689c:	ddee      	ble.n	800687c <UnpackSFMPEG1+0x1e4>
			if(scfsi[1])  for(  ; sfb <11 ; sfb++) sfis->l[sfb] = sfisGr0->l[sfb];
 800689e:	683b      	ldr	r3, [r7, #0]
 80068a0:	3304      	adds	r3, #4
 80068a2:	681b      	ldr	r3, [r3, #0]
 80068a4:	2b00      	cmp	r3, #0
 80068a6:	d01e      	beq.n	80068e6 <UnpackSFMPEG1+0x24e>
 80068a8:	e00b      	b.n	80068c2 <UnpackSFMPEG1+0x22a>
 80068aa:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 80068ac:	69fb      	ldr	r3, [r7, #28]
 80068ae:	4413      	add	r3, r2
 80068b0:	7819      	ldrb	r1, [r3, #0]
 80068b2:	687a      	ldr	r2, [r7, #4]
 80068b4:	69fb      	ldr	r3, [r7, #28]
 80068b6:	4413      	add	r3, r2
 80068b8:	460a      	mov	r2, r1
 80068ba:	701a      	strb	r2, [r3, #0]
 80068bc:	69fb      	ldr	r3, [r7, #28]
 80068be:	3301      	adds	r3, #1
 80068c0:	61fb      	str	r3, [r7, #28]
 80068c2:	69fb      	ldr	r3, [r7, #28]
 80068c4:	2b0a      	cmp	r3, #10
 80068c6:	ddf0      	ble.n	80068aa <UnpackSFMPEG1+0x212>
 80068c8:	e010      	b.n	80068ec <UnpackSFMPEG1+0x254>
			else          for(  ; sfb <11 ; sfb++) sfis->l[sfb] = (char)GetBits(bsi, slen0);
 80068ca:	69b9      	ldr	r1, [r7, #24]
 80068cc:	68f8      	ldr	r0, [r7, #12]
 80068ce:	f7fa f866 	bl	800099e <xmp3fixpt_GetBits>
 80068d2:	4603      	mov	r3, r0
 80068d4:	b2d9      	uxtb	r1, r3
 80068d6:	687a      	ldr	r2, [r7, #4]
 80068d8:	69fb      	ldr	r3, [r7, #28]
 80068da:	4413      	add	r3, r2
 80068dc:	460a      	mov	r2, r1
 80068de:	701a      	strb	r2, [r3, #0]
 80068e0:	69fb      	ldr	r3, [r7, #28]
 80068e2:	3301      	adds	r3, #1
 80068e4:	61fb      	str	r3, [r7, #28]
 80068e6:	69fb      	ldr	r3, [r7, #28]
 80068e8:	2b0a      	cmp	r3, #10
 80068ea:	ddee      	ble.n	80068ca <UnpackSFMPEG1+0x232>
			if(scfsi[2])  for(  ; sfb <16 ; sfb++) sfis->l[sfb] = sfisGr0->l[sfb];
 80068ec:	683b      	ldr	r3, [r7, #0]
 80068ee:	3308      	adds	r3, #8
 80068f0:	681b      	ldr	r3, [r3, #0]
 80068f2:	2b00      	cmp	r3, #0
 80068f4:	d01e      	beq.n	8006934 <UnpackSFMPEG1+0x29c>
 80068f6:	e00b      	b.n	8006910 <UnpackSFMPEG1+0x278>
 80068f8:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 80068fa:	69fb      	ldr	r3, [r7, #28]
 80068fc:	4413      	add	r3, r2
 80068fe:	7819      	ldrb	r1, [r3, #0]
 8006900:	687a      	ldr	r2, [r7, #4]
 8006902:	69fb      	ldr	r3, [r7, #28]
 8006904:	4413      	add	r3, r2
 8006906:	460a      	mov	r2, r1
 8006908:	701a      	strb	r2, [r3, #0]
 800690a:	69fb      	ldr	r3, [r7, #28]
 800690c:	3301      	adds	r3, #1
 800690e:	61fb      	str	r3, [r7, #28]
 8006910:	69fb      	ldr	r3, [r7, #28]
 8006912:	2b0f      	cmp	r3, #15
 8006914:	ddf0      	ble.n	80068f8 <UnpackSFMPEG1+0x260>
 8006916:	e010      	b.n	800693a <UnpackSFMPEG1+0x2a2>
			else          for(  ; sfb <16 ; sfb++) sfis->l[sfb] = (char)GetBits(bsi, slen1);
 8006918:	6979      	ldr	r1, [r7, #20]
 800691a:	68f8      	ldr	r0, [r7, #12]
 800691c:	f7fa f83f 	bl	800099e <xmp3fixpt_GetBits>
 8006920:	4603      	mov	r3, r0
 8006922:	b2d9      	uxtb	r1, r3
 8006924:	687a      	ldr	r2, [r7, #4]
 8006926:	69fb      	ldr	r3, [r7, #28]
 8006928:	4413      	add	r3, r2
 800692a:	460a      	mov	r2, r1
 800692c:	701a      	strb	r2, [r3, #0]
 800692e:	69fb      	ldr	r3, [r7, #28]
 8006930:	3301      	adds	r3, #1
 8006932:	61fb      	str	r3, [r7, #28]
 8006934:	69fb      	ldr	r3, [r7, #28]
 8006936:	2b0f      	cmp	r3, #15
 8006938:	ddee      	ble.n	8006918 <UnpackSFMPEG1+0x280>
			if(scfsi[3])  for(  ; sfb <21 ; sfb++) sfis->l[sfb] = sfisGr0->l[sfb];
 800693a:	683b      	ldr	r3, [r7, #0]
 800693c:	330c      	adds	r3, #12
 800693e:	681b      	ldr	r3, [r3, #0]
 8006940:	2b00      	cmp	r3, #0
 8006942:	d021      	beq.n	8006988 <UnpackSFMPEG1+0x2f0>
 8006944:	e00e      	b.n	8006964 <UnpackSFMPEG1+0x2cc>
 8006946:	bf00      	nop
 8006948:	0801a1f4 	.word	0x0801a1f4
 800694c:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 800694e:	69fb      	ldr	r3, [r7, #28]
 8006950:	4413      	add	r3, r2
 8006952:	7819      	ldrb	r1, [r3, #0]
 8006954:	687a      	ldr	r2, [r7, #4]
 8006956:	69fb      	ldr	r3, [r7, #28]
 8006958:	4413      	add	r3, r2
 800695a:	460a      	mov	r2, r1
 800695c:	701a      	strb	r2, [r3, #0]
 800695e:	69fb      	ldr	r3, [r7, #28]
 8006960:	3301      	adds	r3, #1
 8006962:	61fb      	str	r3, [r7, #28]
 8006964:	69fb      	ldr	r3, [r7, #28]
 8006966:	2b14      	cmp	r3, #20
 8006968:	ddf0      	ble.n	800694c <UnpackSFMPEG1+0x2b4>
 800696a:	e010      	b.n	800698e <UnpackSFMPEG1+0x2f6>
			else          for(  ; sfb <21 ; sfb++) sfis->l[sfb] = (char)GetBits(bsi, slen1);
 800696c:	6979      	ldr	r1, [r7, #20]
 800696e:	68f8      	ldr	r0, [r7, #12]
 8006970:	f7fa f815 	bl	800099e <xmp3fixpt_GetBits>
 8006974:	4603      	mov	r3, r0
 8006976:	b2d9      	uxtb	r1, r3
 8006978:	687a      	ldr	r2, [r7, #4]
 800697a:	69fb      	ldr	r3, [r7, #28]
 800697c:	4413      	add	r3, r2
 800697e:	460a      	mov	r2, r1
 8006980:	701a      	strb	r2, [r3, #0]
 8006982:	69fb      	ldr	r3, [r7, #28]
 8006984:	3301      	adds	r3, #1
 8006986:	61fb      	str	r3, [r7, #28]
 8006988:	69fb      	ldr	r3, [r7, #28]
 800698a:	2b14      	cmp	r3, #20
 800698c:	ddee      	ble.n	800696c <UnpackSFMPEG1+0x2d4>
		}
		/* last sf band not transmitted */
		sfis->l[21] = 0;
 800698e:	687b      	ldr	r3, [r7, #4]
 8006990:	2200      	movs	r2, #0
 8006992:	755a      	strb	r2, [r3, #21]
		sfis->l[22] = 0;
 8006994:	687b      	ldr	r3, [r7, #4]
 8006996:	2200      	movs	r2, #0
 8006998:	759a      	strb	r2, [r3, #22]
	}
}
 800699a:	3720      	adds	r7, #32
 800699c:	46bd      	mov	sp, r7
 800699e:	bd80      	pop	{r7, pc}

080069a0 <UnpackSFMPEG2>:
 *
 * TODO:        optimize the / and % stuff (only do one divide, get modulo x 
 *                with (x / m) * m, etc.)
 **************************************************************************************/
static void UnpackSFMPEG2(BitStreamInfo *bsi, SideInfoSub *sis, ScaleFactorInfoSub *sfis, int gr, int ch, int modeExt, ScaleFactorJS *sfjs)
{
 80069a0:	b580      	push	{r7, lr}
 80069a2:	b096      	sub	sp, #88	; 0x58
 80069a4:	af00      	add	r7, sp, #0
 80069a6:	60f8      	str	r0, [r7, #12]
 80069a8:	60b9      	str	r1, [r7, #8]
 80069aa:	607a      	str	r2, [r7, #4]
 80069ac:	603b      	str	r3, [r7, #0]

	int i, sfb, sfcIdx, btIdx, nrIdx, iipTest;
	int slen[4], nr[4];
	int sfCompress, preFlag, intensityScale;
	
	sfCompress = sis->sfCompress;
 80069ae:	68bb      	ldr	r3, [r7, #8]
 80069b0:	68db      	ldr	r3, [r3, #12]
 80069b2:	63bb      	str	r3, [r7, #56]	; 0x38
	preFlag = 0;
 80069b4:	2300      	movs	r3, #0
 80069b6:	643b      	str	r3, [r7, #64]	; 0x40
	intensityScale = 0;
 80069b8:	2300      	movs	r3, #0
 80069ba:	63fb      	str	r3, [r7, #60]	; 0x3c

	/* stereo mode bits (1 = on): bit 1 = mid-side on/off, bit 0 = intensity on/off */
	if (! ((modeExt & 0x01) && (ch == 1)) ) {
 80069bc:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 80069be:	f003 0301 	and.w	r3, r3, #1
 80069c2:	2b00      	cmp	r3, #0
 80069c4:	d002      	beq.n	80069cc <UnpackSFMPEG2+0x2c>
 80069c6:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 80069c8:	2b01      	cmp	r3, #1
 80069ca:	d073      	beq.n	8006ab4 <UnpackSFMPEG2+0x114>
		/* in other words: if ((modeExt & 0x01) == 0 || ch == 0) */
		if (sfCompress < 400) {
 80069cc:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 80069ce:	f5b3 7fc8 	cmp.w	r3, #400	; 0x190
 80069d2:	da21      	bge.n	8006a18 <UnpackSFMPEG2+0x78>
			/* max slen = floor[(399/16) / 5] = 4 */
			slen[0] = (sfCompress >> 4) / 5;
 80069d4:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 80069d6:	111b      	asrs	r3, r3, #4
 80069d8:	4aa7      	ldr	r2, [pc, #668]	; (8006c78 <UnpackSFMPEG2+0x2d8>)
 80069da:	fb82 1203 	smull	r1, r2, r2, r3
 80069de:	1052      	asrs	r2, r2, #1
 80069e0:	17db      	asrs	r3, r3, #31
 80069e2:	1ad3      	subs	r3, r2, r3
 80069e4:	627b      	str	r3, [r7, #36]	; 0x24
			slen[1]= (sfCompress >> 4) % 5;
 80069e6:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 80069e8:	1119      	asrs	r1, r3, #4
 80069ea:	4ba3      	ldr	r3, [pc, #652]	; (8006c78 <UnpackSFMPEG2+0x2d8>)
 80069ec:	fb83 2301 	smull	r2, r3, r3, r1
 80069f0:	105a      	asrs	r2, r3, #1
 80069f2:	17cb      	asrs	r3, r1, #31
 80069f4:	1ad2      	subs	r2, r2, r3
 80069f6:	4613      	mov	r3, r2
 80069f8:	009b      	lsls	r3, r3, #2
 80069fa:	4413      	add	r3, r2
 80069fc:	1aca      	subs	r2, r1, r3
 80069fe:	62ba      	str	r2, [r7, #40]	; 0x28
			slen[2]= (sfCompress & 0x0f) >> 2;
 8006a00:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8006a02:	109b      	asrs	r3, r3, #2
 8006a04:	f003 0303 	and.w	r3, r3, #3
 8006a08:	62fb      	str	r3, [r7, #44]	; 0x2c
			slen[3]= (sfCompress & 0x03);
 8006a0a:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8006a0c:	f003 0303 	and.w	r3, r3, #3
 8006a10:	633b      	str	r3, [r7, #48]	; 0x30
			sfcIdx = 0;
 8006a12:	2300      	movs	r3, #0
 8006a14:	64fb      	str	r3, [r7, #76]	; 0x4c
		if (sfCompress < 400) {
 8006a16:	e0c1      	b.n	8006b9c <UnpackSFMPEG2+0x1fc>
		} else if (sfCompress < 500) {
 8006a18:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8006a1a:	f5b3 7ffa 	cmp.w	r3, #500	; 0x1f4
 8006a1e:	da22      	bge.n	8006a66 <UnpackSFMPEG2+0xc6>
			/* max slen = floor[(99/4) / 5] = 4 */
			sfCompress -= 400;
 8006a20:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8006a22:	f5a3 73c8 	sub.w	r3, r3, #400	; 0x190
 8006a26:	63bb      	str	r3, [r7, #56]	; 0x38
			slen[0] = (sfCompress >> 2) / 5;
 8006a28:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8006a2a:	109b      	asrs	r3, r3, #2
 8006a2c:	4a92      	ldr	r2, [pc, #584]	; (8006c78 <UnpackSFMPEG2+0x2d8>)
 8006a2e:	fb82 1203 	smull	r1, r2, r2, r3
 8006a32:	1052      	asrs	r2, r2, #1
 8006a34:	17db      	asrs	r3, r3, #31
 8006a36:	1ad3      	subs	r3, r2, r3
 8006a38:	627b      	str	r3, [r7, #36]	; 0x24
			slen[1]= (sfCompress >> 2) % 5;
 8006a3a:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8006a3c:	1099      	asrs	r1, r3, #2
 8006a3e:	4b8e      	ldr	r3, [pc, #568]	; (8006c78 <UnpackSFMPEG2+0x2d8>)
 8006a40:	fb83 2301 	smull	r2, r3, r3, r1
 8006a44:	105a      	asrs	r2, r3, #1
 8006a46:	17cb      	asrs	r3, r1, #31
 8006a48:	1ad2      	subs	r2, r2, r3
 8006a4a:	4613      	mov	r3, r2
 8006a4c:	009b      	lsls	r3, r3, #2
 8006a4e:	4413      	add	r3, r2
 8006a50:	1aca      	subs	r2, r1, r3
 8006a52:	62ba      	str	r2, [r7, #40]	; 0x28
			slen[2]= (sfCompress & 0x03);
 8006a54:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8006a56:	f003 0303 	and.w	r3, r3, #3
 8006a5a:	62fb      	str	r3, [r7, #44]	; 0x2c
			slen[3]= 0;
 8006a5c:	2300      	movs	r3, #0
 8006a5e:	633b      	str	r3, [r7, #48]	; 0x30
			sfcIdx = 1;
 8006a60:	2301      	movs	r3, #1
 8006a62:	64fb      	str	r3, [r7, #76]	; 0x4c
		if (sfCompress < 400) {
 8006a64:	e09a      	b.n	8006b9c <UnpackSFMPEG2+0x1fc>
		} else {
			/* max slen = floor[11/3] = 3 (sfCompress = 9 bits in MPEG2) */
			sfCompress -= 500;
 8006a66:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8006a68:	f5a3 73fa 	sub.w	r3, r3, #500	; 0x1f4
 8006a6c:	63bb      	str	r3, [r7, #56]	; 0x38
			slen[0] = sfCompress / 3;
 8006a6e:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8006a70:	4a82      	ldr	r2, [pc, #520]	; (8006c7c <UnpackSFMPEG2+0x2dc>)
 8006a72:	fb82 1203 	smull	r1, r2, r2, r3
 8006a76:	17db      	asrs	r3, r3, #31
 8006a78:	1ad3      	subs	r3, r2, r3
 8006a7a:	627b      	str	r3, [r7, #36]	; 0x24
			slen[1] = sfCompress % 3;
 8006a7c:	6bb9      	ldr	r1, [r7, #56]	; 0x38
 8006a7e:	4b7f      	ldr	r3, [pc, #508]	; (8006c7c <UnpackSFMPEG2+0x2dc>)
 8006a80:	fb83 3201 	smull	r3, r2, r3, r1
 8006a84:	17cb      	asrs	r3, r1, #31
 8006a86:	1ad2      	subs	r2, r2, r3
 8006a88:	4613      	mov	r3, r2
 8006a8a:	005b      	lsls	r3, r3, #1
 8006a8c:	4413      	add	r3, r2
 8006a8e:	1aca      	subs	r2, r1, r3
 8006a90:	62ba      	str	r2, [r7, #40]	; 0x28
			slen[2] = slen[3] = 0;
 8006a92:	2300      	movs	r3, #0
 8006a94:	633b      	str	r3, [r7, #48]	; 0x30
 8006a96:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8006a98:	62fb      	str	r3, [r7, #44]	; 0x2c
			if (sis->mixedBlock) {
 8006a9a:	68bb      	ldr	r3, [r7, #8]
 8006a9c:	699b      	ldr	r3, [r3, #24]
 8006a9e:	2b00      	cmp	r3, #0
 8006aa0:	d003      	beq.n	8006aaa <UnpackSFMPEG2+0x10a>
				/* adjust for long/short mix logic (see comment above in NRTab[] definition) */
				slen[2] = slen[1];  
 8006aa2:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8006aa4:	62fb      	str	r3, [r7, #44]	; 0x2c
				slen[1] = slen[0];
 8006aa6:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8006aa8:	62bb      	str	r3, [r7, #40]	; 0x28
			}  
			preFlag = 1;
 8006aaa:	2301      	movs	r3, #1
 8006aac:	643b      	str	r3, [r7, #64]	; 0x40
			sfcIdx = 2;
 8006aae:	2302      	movs	r3, #2
 8006ab0:	64fb      	str	r3, [r7, #76]	; 0x4c
		if (sfCompress < 400) {
 8006ab2:	e073      	b.n	8006b9c <UnpackSFMPEG2+0x1fc>
		}
	} else {    
		/* intensity stereo ch = 1 (right) */
		intensityScale = sfCompress & 0x01;
 8006ab4:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8006ab6:	f003 0301 	and.w	r3, r3, #1
 8006aba:	63fb      	str	r3, [r7, #60]	; 0x3c
		sfCompress >>= 1;
 8006abc:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8006abe:	105b      	asrs	r3, r3, #1
 8006ac0:	63bb      	str	r3, [r7, #56]	; 0x38
		if (sfCompress < 180) {
 8006ac2:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8006ac4:	2bb3      	cmp	r3, #179	; 0xb3
 8006ac6:	dc35      	bgt.n	8006b34 <UnpackSFMPEG2+0x194>
			/* max slen = floor[35/6] = 5 (from mod 36) */
			slen[0] = (sfCompress / 36);
 8006ac8:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8006aca:	4a6d      	ldr	r2, [pc, #436]	; (8006c80 <UnpackSFMPEG2+0x2e0>)
 8006acc:	fb82 1203 	smull	r1, r2, r2, r3
 8006ad0:	10d2      	asrs	r2, r2, #3
 8006ad2:	17db      	asrs	r3, r3, #31
 8006ad4:	1ad3      	subs	r3, r2, r3
 8006ad6:	627b      	str	r3, [r7, #36]	; 0x24
			slen[1] = (sfCompress % 36) / 6;
 8006ad8:	6bb9      	ldr	r1, [r7, #56]	; 0x38
 8006ada:	4b69      	ldr	r3, [pc, #420]	; (8006c80 <UnpackSFMPEG2+0x2e0>)
 8006adc:	fb83 2301 	smull	r2, r3, r3, r1
 8006ae0:	10da      	asrs	r2, r3, #3
 8006ae2:	17cb      	asrs	r3, r1, #31
 8006ae4:	1ad2      	subs	r2, r2, r3
 8006ae6:	4613      	mov	r3, r2
 8006ae8:	00db      	lsls	r3, r3, #3
 8006aea:	4413      	add	r3, r2
 8006aec:	009b      	lsls	r3, r3, #2
 8006aee:	1aca      	subs	r2, r1, r3
 8006af0:	4b64      	ldr	r3, [pc, #400]	; (8006c84 <UnpackSFMPEG2+0x2e4>)
 8006af2:	fb83 3102 	smull	r3, r1, r3, r2
 8006af6:	17d3      	asrs	r3, r2, #31
 8006af8:	1acb      	subs	r3, r1, r3
 8006afa:	62bb      	str	r3, [r7, #40]	; 0x28
			slen[2] = (sfCompress % 36) % 6;
 8006afc:	6bb9      	ldr	r1, [r7, #56]	; 0x38
 8006afe:	4b60      	ldr	r3, [pc, #384]	; (8006c80 <UnpackSFMPEG2+0x2e0>)
 8006b00:	fb83 2301 	smull	r2, r3, r3, r1
 8006b04:	10da      	asrs	r2, r3, #3
 8006b06:	17cb      	asrs	r3, r1, #31
 8006b08:	1ad2      	subs	r2, r2, r3
 8006b0a:	4613      	mov	r3, r2
 8006b0c:	00db      	lsls	r3, r3, #3
 8006b0e:	4413      	add	r3, r2
 8006b10:	009b      	lsls	r3, r3, #2
 8006b12:	1aca      	subs	r2, r1, r3
 8006b14:	4b5b      	ldr	r3, [pc, #364]	; (8006c84 <UnpackSFMPEG2+0x2e4>)
 8006b16:	fb83 3102 	smull	r3, r1, r3, r2
 8006b1a:	17d3      	asrs	r3, r2, #31
 8006b1c:	1ac9      	subs	r1, r1, r3
 8006b1e:	460b      	mov	r3, r1
 8006b20:	005b      	lsls	r3, r3, #1
 8006b22:	440b      	add	r3, r1
 8006b24:	005b      	lsls	r3, r3, #1
 8006b26:	1ad1      	subs	r1, r2, r3
 8006b28:	62f9      	str	r1, [r7, #44]	; 0x2c
			slen[3] = 0;
 8006b2a:	2300      	movs	r3, #0
 8006b2c:	633b      	str	r3, [r7, #48]	; 0x30
			sfcIdx = 3;
 8006b2e:	2303      	movs	r3, #3
 8006b30:	64fb      	str	r3, [r7, #76]	; 0x4c
 8006b32:	e033      	b.n	8006b9c <UnpackSFMPEG2+0x1fc>
		} else if (sfCompress < 244) {
 8006b34:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8006b36:	2bf3      	cmp	r3, #243	; 0xf3
 8006b38:	dc15      	bgt.n	8006b66 <UnpackSFMPEG2+0x1c6>
			/* max slen = floor[63/16] = 3 */
			sfCompress -= 180;
 8006b3a:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8006b3c:	3bb4      	subs	r3, #180	; 0xb4
 8006b3e:	63bb      	str	r3, [r7, #56]	; 0x38
			slen[0] = (sfCompress & 0x3f) >> 4;
 8006b40:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8006b42:	111b      	asrs	r3, r3, #4
 8006b44:	f003 0303 	and.w	r3, r3, #3
 8006b48:	627b      	str	r3, [r7, #36]	; 0x24
			slen[1] = (sfCompress & 0x0f) >> 2;
 8006b4a:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8006b4c:	109b      	asrs	r3, r3, #2
 8006b4e:	f003 0303 	and.w	r3, r3, #3
 8006b52:	62bb      	str	r3, [r7, #40]	; 0x28
			slen[2] = (sfCompress & 0x03);
 8006b54:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8006b56:	f003 0303 	and.w	r3, r3, #3
 8006b5a:	62fb      	str	r3, [r7, #44]	; 0x2c
			slen[3] = 0;
 8006b5c:	2300      	movs	r3, #0
 8006b5e:	633b      	str	r3, [r7, #48]	; 0x30
			sfcIdx = 4;
 8006b60:	2304      	movs	r3, #4
 8006b62:	64fb      	str	r3, [r7, #76]	; 0x4c
 8006b64:	e01a      	b.n	8006b9c <UnpackSFMPEG2+0x1fc>
		} else {
			/* max slen = floor[11/3] = 3 (max sfCompress >> 1 = 511/2 = 255) */
			sfCompress -= 244;
 8006b66:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8006b68:	3bf4      	subs	r3, #244	; 0xf4
 8006b6a:	63bb      	str	r3, [r7, #56]	; 0x38
			slen[0] = (sfCompress / 3);
 8006b6c:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8006b6e:	4a43      	ldr	r2, [pc, #268]	; (8006c7c <UnpackSFMPEG2+0x2dc>)
 8006b70:	fb82 1203 	smull	r1, r2, r2, r3
 8006b74:	17db      	asrs	r3, r3, #31
 8006b76:	1ad3      	subs	r3, r2, r3
 8006b78:	627b      	str	r3, [r7, #36]	; 0x24
			slen[1] = (sfCompress % 3);
 8006b7a:	6bb9      	ldr	r1, [r7, #56]	; 0x38
 8006b7c:	4b3f      	ldr	r3, [pc, #252]	; (8006c7c <UnpackSFMPEG2+0x2dc>)
 8006b7e:	fb83 3201 	smull	r3, r2, r3, r1
 8006b82:	17cb      	asrs	r3, r1, #31
 8006b84:	1ad2      	subs	r2, r2, r3
 8006b86:	4613      	mov	r3, r2
 8006b88:	005b      	lsls	r3, r3, #1
 8006b8a:	4413      	add	r3, r2
 8006b8c:	1aca      	subs	r2, r1, r3
 8006b8e:	62ba      	str	r2, [r7, #40]	; 0x28
			slen[2] = slen[3] = 0;
 8006b90:	2300      	movs	r3, #0
 8006b92:	633b      	str	r3, [r7, #48]	; 0x30
 8006b94:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8006b96:	62fb      	str	r3, [r7, #44]	; 0x2c
			sfcIdx = 5;
 8006b98:	2305      	movs	r3, #5
 8006b9a:	64fb      	str	r3, [r7, #76]	; 0x4c
		}
	}
	
	/* set index based on block type: (0,1,3) --> 0, (2 non-mixed) --> 1, (2 mixed) ---> 2 */
	btIdx = 0;
 8006b9c:	2300      	movs	r3, #0
 8006b9e:	64bb      	str	r3, [r7, #72]	; 0x48
	if (sis->blockType == 2) 
 8006ba0:	68bb      	ldr	r3, [r7, #8]
 8006ba2:	695b      	ldr	r3, [r3, #20]
 8006ba4:	2b02      	cmp	r3, #2
 8006ba6:	d107      	bne.n	8006bb8 <UnpackSFMPEG2+0x218>
		btIdx = (sis->mixedBlock ? 2 : 1);
 8006ba8:	68bb      	ldr	r3, [r7, #8]
 8006baa:	699b      	ldr	r3, [r3, #24]
 8006bac:	2b00      	cmp	r3, #0
 8006bae:	d001      	beq.n	8006bb4 <UnpackSFMPEG2+0x214>
 8006bb0:	2302      	movs	r3, #2
 8006bb2:	e000      	b.n	8006bb6 <UnpackSFMPEG2+0x216>
 8006bb4:	2301      	movs	r3, #1
 8006bb6:	64bb      	str	r3, [r7, #72]	; 0x48
	for (i = 0; i < 4; i++)
 8006bb8:	2300      	movs	r3, #0
 8006bba:	657b      	str	r3, [r7, #84]	; 0x54
 8006bbc:	e016      	b.n	8006bec <UnpackSFMPEG2+0x24c>
		nr[i] = (int)NRTab[sfcIdx][btIdx][i];
 8006bbe:	4932      	ldr	r1, [pc, #200]	; (8006c88 <UnpackSFMPEG2+0x2e8>)
 8006bc0:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
 8006bc2:	4613      	mov	r3, r2
 8006bc4:	005b      	lsls	r3, r3, #1
 8006bc6:	4413      	add	r3, r2
 8006bc8:	6cba      	ldr	r2, [r7, #72]	; 0x48
 8006bca:	4413      	add	r3, r2
 8006bcc:	009b      	lsls	r3, r3, #2
 8006bce:	18ca      	adds	r2, r1, r3
 8006bd0:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8006bd2:	4413      	add	r3, r2
 8006bd4:	781b      	ldrb	r3, [r3, #0]
 8006bd6:	461a      	mov	r2, r3
 8006bd8:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8006bda:	009b      	lsls	r3, r3, #2
 8006bdc:	f107 0158 	add.w	r1, r7, #88	; 0x58
 8006be0:	440b      	add	r3, r1
 8006be2:	f843 2c44 	str.w	r2, [r3, #-68]
	for (i = 0; i < 4; i++)
 8006be6:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8006be8:	3301      	adds	r3, #1
 8006bea:	657b      	str	r3, [r7, #84]	; 0x54
 8006bec:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8006bee:	2b03      	cmp	r3, #3
 8006bf0:	dde5      	ble.n	8006bbe <UnpackSFMPEG2+0x21e>

	/* save intensity stereo scale factor info */
	if( (modeExt & 0x01) && (ch == 1) ) {
 8006bf2:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8006bf4:	f003 0301 	and.w	r3, r3, #1
 8006bf8:	2b00      	cmp	r3, #0
 8006bfa:	d027      	beq.n	8006c4c <UnpackSFMPEG2+0x2ac>
 8006bfc:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 8006bfe:	2b01      	cmp	r3, #1
 8006c00:	d124      	bne.n	8006c4c <UnpackSFMPEG2+0x2ac>
		for (i = 0; i < 4; i++) {
 8006c02:	2300      	movs	r3, #0
 8006c04:	657b      	str	r3, [r7, #84]	; 0x54
 8006c06:	e01b      	b.n	8006c40 <UnpackSFMPEG2+0x2a0>
			sfjs->slen[i] = slen[i];
 8006c08:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8006c0a:	009b      	lsls	r3, r3, #2
 8006c0c:	f107 0258 	add.w	r2, r7, #88	; 0x58
 8006c10:	4413      	add	r3, r2
 8006c12:	f853 2c34 	ldr.w	r2, [r3, #-52]
 8006c16:	6eb9      	ldr	r1, [r7, #104]	; 0x68
 8006c18:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8006c1a:	009b      	lsls	r3, r3, #2
 8006c1c:	440b      	add	r3, r1
 8006c1e:	605a      	str	r2, [r3, #4]
			sfjs->nr[i] = nr[i];
 8006c20:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8006c22:	009b      	lsls	r3, r3, #2
 8006c24:	f107 0258 	add.w	r2, r7, #88	; 0x58
 8006c28:	4413      	add	r3, r2
 8006c2a:	f853 2c44 	ldr.w	r2, [r3, #-68]
 8006c2e:	6eb9      	ldr	r1, [r7, #104]	; 0x68
 8006c30:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8006c32:	3304      	adds	r3, #4
 8006c34:	009b      	lsls	r3, r3, #2
 8006c36:	440b      	add	r3, r1
 8006c38:	605a      	str	r2, [r3, #4]
		for (i = 0; i < 4; i++) {
 8006c3a:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8006c3c:	3301      	adds	r3, #1
 8006c3e:	657b      	str	r3, [r7, #84]	; 0x54
 8006c40:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8006c42:	2b03      	cmp	r3, #3
 8006c44:	dde0      	ble.n	8006c08 <UnpackSFMPEG2+0x268>
		}
		sfjs->intensityScale = intensityScale;
 8006c46:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 8006c48:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 8006c4a:	601a      	str	r2, [r3, #0]
	}
	sis->preFlag = preFlag;
 8006c4c:	68bb      	ldr	r3, [r7, #8]
 8006c4e:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 8006c50:	63da      	str	r2, [r3, #60]	; 0x3c

	/* short blocks */
	if(sis->blockType == 2) {
 8006c52:	68bb      	ldr	r3, [r7, #8]
 8006c54:	695b      	ldr	r3, [r3, #20]
 8006c56:	2b02      	cmp	r3, #2
 8006c58:	f040 80ac 	bne.w	8006db4 <UnpackSFMPEG2+0x414>
		if(sis->mixedBlock) {
 8006c5c:	68bb      	ldr	r3, [r7, #8]
 8006c5e:	699b      	ldr	r3, [r3, #24]
 8006c60:	2b00      	cmp	r3, #0
 8006c62:	d02a      	beq.n	8006cba <UnpackSFMPEG2+0x31a>
			/* do long block portion */
			iipTest = (1 << slen[0]) - 1;
 8006c64:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8006c66:	2201      	movs	r2, #1
 8006c68:	fa02 f303 	lsl.w	r3, r2, r3
 8006c6c:	3b01      	subs	r3, #1
 8006c6e:	637b      	str	r3, [r7, #52]	; 0x34
			for (sfb=0; sfb < 6; sfb++) {
 8006c70:	2300      	movs	r3, #0
 8006c72:	653b      	str	r3, [r7, #80]	; 0x50
 8006c74:	e019      	b.n	8006caa <UnpackSFMPEG2+0x30a>
 8006c76:	bf00      	nop
 8006c78:	66666667 	.word	0x66666667
 8006c7c:	55555556 	.word	0x55555556
 8006c80:	38e38e39 	.word	0x38e38e39
 8006c84:	2aaaaaab 	.word	0x2aaaaaab
 8006c88:	0801a214 	.word	0x0801a214
				sfis->l[sfb] = (char)GetBits(bsi, slen[0]);
 8006c8c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8006c8e:	4619      	mov	r1, r3
 8006c90:	68f8      	ldr	r0, [r7, #12]
 8006c92:	f7f9 fe84 	bl	800099e <xmp3fixpt_GetBits>
 8006c96:	4603      	mov	r3, r0
 8006c98:	b2d9      	uxtb	r1, r3
 8006c9a:	687a      	ldr	r2, [r7, #4]
 8006c9c:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8006c9e:	4413      	add	r3, r2
 8006ca0:	460a      	mov	r2, r1
 8006ca2:	701a      	strb	r2, [r3, #0]
			for (sfb=0; sfb < 6; sfb++) {
 8006ca4:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8006ca6:	3301      	adds	r3, #1
 8006ca8:	653b      	str	r3, [r7, #80]	; 0x50
 8006caa:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8006cac:	2b05      	cmp	r3, #5
 8006cae:	dded      	ble.n	8006c8c <UnpackSFMPEG2+0x2ec>
			}
			sfb = 3;  /* start sfb for short */
 8006cb0:	2303      	movs	r3, #3
 8006cb2:	653b      	str	r3, [r7, #80]	; 0x50
			nrIdx = 1;
 8006cb4:	2301      	movs	r3, #1
 8006cb6:	647b      	str	r3, [r7, #68]	; 0x44
 8006cb8:	e068      	b.n	8006d8c <UnpackSFMPEG2+0x3ec>
		} else {      
			/* all short blocks, so start nr, sfb at 0 */
			sfb = 0;
 8006cba:	2300      	movs	r3, #0
 8006cbc:	653b      	str	r3, [r7, #80]	; 0x50
			nrIdx = 0;
 8006cbe:	2300      	movs	r3, #0
 8006cc0:	647b      	str	r3, [r7, #68]	; 0x44
		}

		/* remaining short blocks, sfb just keeps incrementing */
		for (    ; nrIdx <= 3; nrIdx++) {
 8006cc2:	e063      	b.n	8006d8c <UnpackSFMPEG2+0x3ec>
			iipTest = (1 << slen[nrIdx]) - 1;
 8006cc4:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8006cc6:	009b      	lsls	r3, r3, #2
 8006cc8:	f107 0258 	add.w	r2, r7, #88	; 0x58
 8006ccc:	4413      	add	r3, r2
 8006cce:	f853 3c34 	ldr.w	r3, [r3, #-52]
 8006cd2:	2201      	movs	r2, #1
 8006cd4:	fa02 f303 	lsl.w	r3, r2, r3
 8006cd8:	3b01      	subs	r3, #1
 8006cda:	637b      	str	r3, [r7, #52]	; 0x34
			for (i=0; i < nr[nrIdx]; i++, sfb++) {
 8006cdc:	2300      	movs	r3, #0
 8006cde:	657b      	str	r3, [r7, #84]	; 0x54
 8006ce0:	e047      	b.n	8006d72 <UnpackSFMPEG2+0x3d2>
				sfis->s[sfb][0] = (char)GetBits(bsi, slen[nrIdx]);
 8006ce2:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8006ce4:	009b      	lsls	r3, r3, #2
 8006ce6:	f107 0258 	add.w	r2, r7, #88	; 0x58
 8006cea:	4413      	add	r3, r2
 8006cec:	f853 3c34 	ldr.w	r3, [r3, #-52]
 8006cf0:	4619      	mov	r1, r3
 8006cf2:	68f8      	ldr	r0, [r7, #12]
 8006cf4:	f7f9 fe53 	bl	800099e <xmp3fixpt_GetBits>
 8006cf8:	4603      	mov	r3, r0
 8006cfa:	b2d8      	uxtb	r0, r3
 8006cfc:	6879      	ldr	r1, [r7, #4]
 8006cfe:	6d3a      	ldr	r2, [r7, #80]	; 0x50
 8006d00:	4613      	mov	r3, r2
 8006d02:	005b      	lsls	r3, r3, #1
 8006d04:	4413      	add	r3, r2
 8006d06:	440b      	add	r3, r1
 8006d08:	3317      	adds	r3, #23
 8006d0a:	4602      	mov	r2, r0
 8006d0c:	701a      	strb	r2, [r3, #0]
				sfis->s[sfb][1] = (char)GetBits(bsi, slen[nrIdx]);
 8006d0e:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8006d10:	009b      	lsls	r3, r3, #2
 8006d12:	f107 0258 	add.w	r2, r7, #88	; 0x58
 8006d16:	4413      	add	r3, r2
 8006d18:	f853 3c34 	ldr.w	r3, [r3, #-52]
 8006d1c:	4619      	mov	r1, r3
 8006d1e:	68f8      	ldr	r0, [r7, #12]
 8006d20:	f7f9 fe3d 	bl	800099e <xmp3fixpt_GetBits>
 8006d24:	4603      	mov	r3, r0
 8006d26:	b2d8      	uxtb	r0, r3
 8006d28:	6879      	ldr	r1, [r7, #4]
 8006d2a:	6d3a      	ldr	r2, [r7, #80]	; 0x50
 8006d2c:	4613      	mov	r3, r2
 8006d2e:	005b      	lsls	r3, r3, #1
 8006d30:	4413      	add	r3, r2
 8006d32:	440b      	add	r3, r1
 8006d34:	3318      	adds	r3, #24
 8006d36:	4602      	mov	r2, r0
 8006d38:	701a      	strb	r2, [r3, #0]
				sfis->s[sfb][2] = (char)GetBits(bsi, slen[nrIdx]);
 8006d3a:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8006d3c:	009b      	lsls	r3, r3, #2
 8006d3e:	f107 0258 	add.w	r2, r7, #88	; 0x58
 8006d42:	4413      	add	r3, r2
 8006d44:	f853 3c34 	ldr.w	r3, [r3, #-52]
 8006d48:	4619      	mov	r1, r3
 8006d4a:	68f8      	ldr	r0, [r7, #12]
 8006d4c:	f7f9 fe27 	bl	800099e <xmp3fixpt_GetBits>
 8006d50:	4603      	mov	r3, r0
 8006d52:	b2d8      	uxtb	r0, r3
 8006d54:	6879      	ldr	r1, [r7, #4]
 8006d56:	6d3a      	ldr	r2, [r7, #80]	; 0x50
 8006d58:	4613      	mov	r3, r2
 8006d5a:	005b      	lsls	r3, r3, #1
 8006d5c:	4413      	add	r3, r2
 8006d5e:	440b      	add	r3, r1
 8006d60:	3319      	adds	r3, #25
 8006d62:	4602      	mov	r2, r0
 8006d64:	701a      	strb	r2, [r3, #0]
			for (i=0; i < nr[nrIdx]; i++, sfb++) {
 8006d66:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8006d68:	3301      	adds	r3, #1
 8006d6a:	657b      	str	r3, [r7, #84]	; 0x54
 8006d6c:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8006d6e:	3301      	adds	r3, #1
 8006d70:	653b      	str	r3, [r7, #80]	; 0x50
 8006d72:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8006d74:	009b      	lsls	r3, r3, #2
 8006d76:	f107 0258 	add.w	r2, r7, #88	; 0x58
 8006d7a:	4413      	add	r3, r2
 8006d7c:	f853 2c44 	ldr.w	r2, [r3, #-68]
 8006d80:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8006d82:	429a      	cmp	r2, r3
 8006d84:	dcad      	bgt.n	8006ce2 <UnpackSFMPEG2+0x342>
		for (    ; nrIdx <= 3; nrIdx++) {
 8006d86:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8006d88:	3301      	adds	r3, #1
 8006d8a:	647b      	str	r3, [r7, #68]	; 0x44
 8006d8c:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8006d8e:	2b03      	cmp	r3, #3
 8006d90:	dd98      	ble.n	8006cc4 <UnpackSFMPEG2+0x324>
			}
		}
		/* last sf band not transmitted */
		sfis->s[12][0] = sfis->s[12][1] = sfis->s[12][2] = 0;
 8006d92:	687b      	ldr	r3, [r7, #4]
 8006d94:	2200      	movs	r2, #0
 8006d96:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d
 8006d9a:	687b      	ldr	r3, [r7, #4]
 8006d9c:	f893 203d 	ldrb.w	r2, [r3, #61]	; 0x3d
 8006da0:	687b      	ldr	r3, [r7, #4]
 8006da2:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c
 8006da6:	687b      	ldr	r3, [r7, #4]
 8006da8:	f893 203c 	ldrb.w	r2, [r3, #60]	; 0x3c
 8006dac:	687b      	ldr	r3, [r7, #4]
 8006dae:	f883 203b 	strb.w	r2, [r3, #59]	; 0x3b
		}
		/* last sf band not transmitted */
		sfis->l[21] = sfis->l[22] = 0;

	}
}
 8006db2:	e042      	b.n	8006e3a <UnpackSFMPEG2+0x49a>
		sfb = 0;
 8006db4:	2300      	movs	r3, #0
 8006db6:	653b      	str	r3, [r7, #80]	; 0x50
		for (nrIdx = 0; nrIdx <= 3; nrIdx++) {
 8006db8:	2300      	movs	r3, #0
 8006dba:	647b      	str	r3, [r7, #68]	; 0x44
 8006dbc:	e033      	b.n	8006e26 <UnpackSFMPEG2+0x486>
			iipTest = (1 << slen[nrIdx]) - 1;
 8006dbe:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8006dc0:	009b      	lsls	r3, r3, #2
 8006dc2:	f107 0258 	add.w	r2, r7, #88	; 0x58
 8006dc6:	4413      	add	r3, r2
 8006dc8:	f853 3c34 	ldr.w	r3, [r3, #-52]
 8006dcc:	2201      	movs	r2, #1
 8006dce:	fa02 f303 	lsl.w	r3, r2, r3
 8006dd2:	3b01      	subs	r3, #1
 8006dd4:	637b      	str	r3, [r7, #52]	; 0x34
			for(i=0; i < nr[nrIdx]; i++, sfb++) {
 8006dd6:	2300      	movs	r3, #0
 8006dd8:	657b      	str	r3, [r7, #84]	; 0x54
 8006dda:	e017      	b.n	8006e0c <UnpackSFMPEG2+0x46c>
				sfis->l[sfb] = (char)GetBits(bsi, slen[nrIdx]);
 8006ddc:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8006dde:	009b      	lsls	r3, r3, #2
 8006de0:	f107 0258 	add.w	r2, r7, #88	; 0x58
 8006de4:	4413      	add	r3, r2
 8006de6:	f853 3c34 	ldr.w	r3, [r3, #-52]
 8006dea:	4619      	mov	r1, r3
 8006dec:	68f8      	ldr	r0, [r7, #12]
 8006dee:	f7f9 fdd6 	bl	800099e <xmp3fixpt_GetBits>
 8006df2:	4603      	mov	r3, r0
 8006df4:	b2d9      	uxtb	r1, r3
 8006df6:	687a      	ldr	r2, [r7, #4]
 8006df8:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8006dfa:	4413      	add	r3, r2
 8006dfc:	460a      	mov	r2, r1
 8006dfe:	701a      	strb	r2, [r3, #0]
			for(i=0; i < nr[nrIdx]; i++, sfb++) {
 8006e00:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8006e02:	3301      	adds	r3, #1
 8006e04:	657b      	str	r3, [r7, #84]	; 0x54
 8006e06:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8006e08:	3301      	adds	r3, #1
 8006e0a:	653b      	str	r3, [r7, #80]	; 0x50
 8006e0c:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8006e0e:	009b      	lsls	r3, r3, #2
 8006e10:	f107 0258 	add.w	r2, r7, #88	; 0x58
 8006e14:	4413      	add	r3, r2
 8006e16:	f853 2c44 	ldr.w	r2, [r3, #-68]
 8006e1a:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8006e1c:	429a      	cmp	r2, r3
 8006e1e:	dcdd      	bgt.n	8006ddc <UnpackSFMPEG2+0x43c>
		for (nrIdx = 0; nrIdx <= 3; nrIdx++) {
 8006e20:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8006e22:	3301      	adds	r3, #1
 8006e24:	647b      	str	r3, [r7, #68]	; 0x44
 8006e26:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8006e28:	2b03      	cmp	r3, #3
 8006e2a:	ddc8      	ble.n	8006dbe <UnpackSFMPEG2+0x41e>
		sfis->l[21] = sfis->l[22] = 0;
 8006e2c:	687b      	ldr	r3, [r7, #4]
 8006e2e:	2200      	movs	r2, #0
 8006e30:	759a      	strb	r2, [r3, #22]
 8006e32:	687b      	ldr	r3, [r7, #4]
 8006e34:	7d9a      	ldrb	r2, [r3, #22]
 8006e36:	687b      	ldr	r3, [r7, #4]
 8006e38:	755a      	strb	r2, [r3, #21]
}
 8006e3a:	bf00      	nop
 8006e3c:	3758      	adds	r7, #88	; 0x58
 8006e3e:	46bd      	mov	sp, r7
 8006e40:	bd80      	pop	{r7, pc}

08006e42 <xmp3fixpt_UnpackScaleFactors>:
 *              updated bitOffset
 *
 * Return:      length (in bytes) of scale factor data, -1 if null input pointers
 **************************************************************************************/
int UnpackScaleFactors(MP3DecInfo *mp3DecInfo, unsigned char *buf, int *bitOffset, int bitsAvail, int gr, int ch)
{
 8006e42:	b590      	push	{r4, r7, lr}
 8006e44:	b093      	sub	sp, #76	; 0x4c
 8006e46:	af04      	add	r7, sp, #16
 8006e48:	60f8      	str	r0, [r7, #12]
 8006e4a:	60b9      	str	r1, [r7, #8]
 8006e4c:	607a      	str	r2, [r7, #4]
 8006e4e:	603b      	str	r3, [r7, #0]
	FrameHeader *fh;
	SideInfo *si;
	ScaleFactorInfo *sfi;

	/* validate pointers */
	if (!mp3DecInfo || !mp3DecInfo->FrameHeaderPS || !mp3DecInfo->SideInfoPS || !mp3DecInfo->ScaleFactorInfoPS)
 8006e50:	68fb      	ldr	r3, [r7, #12]
 8006e52:	2b00      	cmp	r3, #0
 8006e54:	d00b      	beq.n	8006e6e <xmp3fixpt_UnpackScaleFactors+0x2c>
 8006e56:	68fb      	ldr	r3, [r7, #12]
 8006e58:	681b      	ldr	r3, [r3, #0]
 8006e5a:	2b00      	cmp	r3, #0
 8006e5c:	d007      	beq.n	8006e6e <xmp3fixpt_UnpackScaleFactors+0x2c>
 8006e5e:	68fb      	ldr	r3, [r7, #12]
 8006e60:	685b      	ldr	r3, [r3, #4]
 8006e62:	2b00      	cmp	r3, #0
 8006e64:	d003      	beq.n	8006e6e <xmp3fixpt_UnpackScaleFactors+0x2c>
 8006e66:	68fb      	ldr	r3, [r7, #12]
 8006e68:	689b      	ldr	r3, [r3, #8]
 8006e6a:	2b00      	cmp	r3, #0
 8006e6c:	d102      	bne.n	8006e74 <xmp3fixpt_UnpackScaleFactors+0x32>
		return -1;
 8006e6e:	f04f 33ff 	mov.w	r3, #4294967295
 8006e72:	e0bc      	b.n	8006fee <xmp3fixpt_UnpackScaleFactors+0x1ac>
	fh = ((FrameHeader *)(mp3DecInfo->FrameHeaderPS));
 8006e74:	68fb      	ldr	r3, [r7, #12]
 8006e76:	681b      	ldr	r3, [r3, #0]
 8006e78:	637b      	str	r3, [r7, #52]	; 0x34
	si = ((SideInfo *)(mp3DecInfo->SideInfoPS));
 8006e7a:	68fb      	ldr	r3, [r7, #12]
 8006e7c:	685b      	ldr	r3, [r3, #4]
 8006e7e:	633b      	str	r3, [r7, #48]	; 0x30
	sfi = ((ScaleFactorInfo *)(mp3DecInfo->ScaleFactorInfoPS));
 8006e80:	68fb      	ldr	r3, [r7, #12]
 8006e82:	689b      	ldr	r3, [r3, #8]
 8006e84:	62fb      	str	r3, [r7, #44]	; 0x2c

	/* init GetBits reader */
	startBuf = buf;
 8006e86:	68bb      	ldr	r3, [r7, #8]
 8006e88:	62bb      	str	r3, [r7, #40]	; 0x28
	bsi = &bitStreamInfo;
 8006e8a:	f107 0310 	add.w	r3, r7, #16
 8006e8e:	627b      	str	r3, [r7, #36]	; 0x24
	SetBitstreamPointer(bsi, (bitsAvail + *bitOffset + 7) / 8, buf);
 8006e90:	687b      	ldr	r3, [r7, #4]
 8006e92:	681a      	ldr	r2, [r3, #0]
 8006e94:	683b      	ldr	r3, [r7, #0]
 8006e96:	4413      	add	r3, r2
 8006e98:	3307      	adds	r3, #7
 8006e9a:	2b00      	cmp	r3, #0
 8006e9c:	da00      	bge.n	8006ea0 <xmp3fixpt_UnpackScaleFactors+0x5e>
 8006e9e:	3307      	adds	r3, #7
 8006ea0:	10db      	asrs	r3, r3, #3
 8006ea2:	68ba      	ldr	r2, [r7, #8]
 8006ea4:	4619      	mov	r1, r3
 8006ea6:	6a78      	ldr	r0, [r7, #36]	; 0x24
 8006ea8:	f7f9 fcf0 	bl	800088c <xmp3fixpt_SetBitstreamPointer>
	if (*bitOffset)
 8006eac:	687b      	ldr	r3, [r7, #4]
 8006eae:	681b      	ldr	r3, [r3, #0]
 8006eb0:	2b00      	cmp	r3, #0
 8006eb2:	d005      	beq.n	8006ec0 <xmp3fixpt_UnpackScaleFactors+0x7e>
		GetBits(bsi, *bitOffset);
 8006eb4:	687b      	ldr	r3, [r7, #4]
 8006eb6:	681b      	ldr	r3, [r3, #0]
 8006eb8:	4619      	mov	r1, r3
 8006eba:	6a78      	ldr	r0, [r7, #36]	; 0x24
 8006ebc:	f7f9 fd6f 	bl	800099e <xmp3fixpt_GetBits>

	if (fh->ver == MPEG1) 
 8006ec0:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8006ec2:	781b      	ldrb	r3, [r3, #0]
 8006ec4:	2b00      	cmp	r3, #0
 8006ec6:	d132      	bne.n	8006f2e <xmp3fixpt_UnpackScaleFactors+0xec>
		UnpackSFMPEG1(bsi, &si->sis[gr][ch], &sfi->sfis[gr][ch], si->scfsi[ch], gr, &sfi->sfis[0][ch]);
 8006ec8:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8006eca:	461a      	mov	r2, r3
 8006ecc:	00d2      	lsls	r2, r2, #3
 8006ece:	441a      	add	r2, r3
 8006ed0:	00d3      	lsls	r3, r2, #3
 8006ed2:	461a      	mov	r2, r3
 8006ed4:	6cb9      	ldr	r1, [r7, #72]	; 0x48
 8006ed6:	460b      	mov	r3, r1
 8006ed8:	00db      	lsls	r3, r3, #3
 8006eda:	440b      	add	r3, r1
 8006edc:	011b      	lsls	r3, r3, #4
 8006ede:	4413      	add	r3, r2
 8006ee0:	3328      	adds	r3, #40	; 0x28
 8006ee2:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 8006ee4:	18d0      	adds	r0, r2, r3
 8006ee6:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8006ee8:	461a      	mov	r2, r3
 8006eea:	0152      	lsls	r2, r2, #5
 8006eec:	1ad2      	subs	r2, r2, r3
 8006eee:	0053      	lsls	r3, r2, #1
 8006ef0:	461a      	mov	r2, r3
 8006ef2:	6cb9      	ldr	r1, [r7, #72]	; 0x48
 8006ef4:	460b      	mov	r3, r1
 8006ef6:	015b      	lsls	r3, r3, #5
 8006ef8:	1a5b      	subs	r3, r3, r1
 8006efa:	009b      	lsls	r3, r3, #2
 8006efc:	4413      	add	r3, r2
 8006efe:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8006f00:	18d1      	adds	r1, r2, r3
 8006f02:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8006f04:	011b      	lsls	r3, r3, #4
 8006f06:	3308      	adds	r3, #8
 8006f08:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 8006f0a:	18d4      	adds	r4, r2, r3
 8006f0c:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
 8006f0e:	4613      	mov	r3, r2
 8006f10:	015b      	lsls	r3, r3, #5
 8006f12:	1a9b      	subs	r3, r3, r2
 8006f14:	005b      	lsls	r3, r3, #1
 8006f16:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8006f18:	4413      	add	r3, r2
 8006f1a:	9301      	str	r3, [sp, #4]
 8006f1c:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8006f1e:	9300      	str	r3, [sp, #0]
 8006f20:	4623      	mov	r3, r4
 8006f22:	460a      	mov	r2, r1
 8006f24:	4601      	mov	r1, r0
 8006f26:	6a78      	ldr	r0, [r7, #36]	; 0x24
 8006f28:	f7ff fbb6 	bl	8006698 <UnpackSFMPEG1>
 8006f2c:	e02a      	b.n	8006f84 <xmp3fixpt_UnpackScaleFactors+0x142>
	else 
		UnpackSFMPEG2(bsi, &si->sis[gr][ch], &sfi->sfis[gr][ch], gr, ch, fh->modeExt, &sfi->sfjs);
 8006f2e:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8006f30:	461a      	mov	r2, r3
 8006f32:	00d2      	lsls	r2, r2, #3
 8006f34:	441a      	add	r2, r3
 8006f36:	00d3      	lsls	r3, r2, #3
 8006f38:	461a      	mov	r2, r3
 8006f3a:	6cb9      	ldr	r1, [r7, #72]	; 0x48
 8006f3c:	460b      	mov	r3, r1
 8006f3e:	00db      	lsls	r3, r3, #3
 8006f40:	440b      	add	r3, r1
 8006f42:	011b      	lsls	r3, r3, #4
 8006f44:	4413      	add	r3, r2
 8006f46:	3328      	adds	r3, #40	; 0x28
 8006f48:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 8006f4a:	18d0      	adds	r0, r2, r3
 8006f4c:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8006f4e:	461a      	mov	r2, r3
 8006f50:	0152      	lsls	r2, r2, #5
 8006f52:	1ad2      	subs	r2, r2, r3
 8006f54:	0053      	lsls	r3, r2, #1
 8006f56:	461a      	mov	r2, r3
 8006f58:	6cb9      	ldr	r1, [r7, #72]	; 0x48
 8006f5a:	460b      	mov	r3, r1
 8006f5c:	015b      	lsls	r3, r3, #5
 8006f5e:	1a5b      	subs	r3, r3, r1
 8006f60:	009b      	lsls	r3, r3, #2
 8006f62:	4413      	add	r3, r2
 8006f64:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8006f66:	18d1      	adds	r1, r2, r3
 8006f68:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8006f6a:	6a1b      	ldr	r3, [r3, #32]
 8006f6c:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8006f6e:	32f8      	adds	r2, #248	; 0xf8
 8006f70:	9202      	str	r2, [sp, #8]
 8006f72:	9301      	str	r3, [sp, #4]
 8006f74:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8006f76:	9300      	str	r3, [sp, #0]
 8006f78:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8006f7a:	460a      	mov	r2, r1
 8006f7c:	4601      	mov	r1, r0
 8006f7e:	6a78      	ldr	r0, [r7, #36]	; 0x24
 8006f80:	f7ff fd0e 	bl	80069a0 <UnpackSFMPEG2>

	mp3DecInfo->part23Length[gr][ch] = si->sis[gr][ch].part23Length;
 8006f84:	6b38      	ldr	r0, [r7, #48]	; 0x30
 8006f86:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8006f88:	6cb9      	ldr	r1, [r7, #72]	; 0x48
 8006f8a:	461a      	mov	r2, r3
 8006f8c:	00d2      	lsls	r2, r2, #3
 8006f8e:	441a      	add	r2, r3
 8006f90:	00d3      	lsls	r3, r2, #3
 8006f92:	461a      	mov	r2, r3
 8006f94:	460b      	mov	r3, r1
 8006f96:	00db      	lsls	r3, r3, #3
 8006f98:	440b      	add	r3, r1
 8006f9a:	011b      	lsls	r3, r3, #4
 8006f9c:	4413      	add	r3, r2
 8006f9e:	4403      	add	r3, r0
 8006fa0:	3328      	adds	r3, #40	; 0x28
 8006fa2:	6819      	ldr	r1, [r3, #0]
 8006fa4:	68fb      	ldr	r3, [r7, #12]
 8006fa6:	6cba      	ldr	r2, [r7, #72]	; 0x48
 8006fa8:	0050      	lsls	r0, r2, #1
 8006faa:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
 8006fac:	4402      	add	r2, r0
 8006fae:	f502 72fc 	add.w	r2, r2, #504	; 0x1f8
 8006fb2:	f843 1022 	str.w	r1, [r3, r2, lsl #2]

	bitsUsed = CalcBitsUsed(bsi, buf, *bitOffset);
 8006fb6:	687b      	ldr	r3, [r7, #4]
 8006fb8:	681b      	ldr	r3, [r3, #0]
 8006fba:	461a      	mov	r2, r3
 8006fbc:	68b9      	ldr	r1, [r7, #8]
 8006fbe:	6a78      	ldr	r0, [r7, #36]	; 0x24
 8006fc0:	f7f9 fd35 	bl	8000a2e <xmp3fixpt_CalcBitsUsed>
 8006fc4:	6238      	str	r0, [r7, #32]
	buf += (bitsUsed + *bitOffset) >> 3;
 8006fc6:	687b      	ldr	r3, [r7, #4]
 8006fc8:	681a      	ldr	r2, [r3, #0]
 8006fca:	6a3b      	ldr	r3, [r7, #32]
 8006fcc:	4413      	add	r3, r2
 8006fce:	10db      	asrs	r3, r3, #3
 8006fd0:	461a      	mov	r2, r3
 8006fd2:	68bb      	ldr	r3, [r7, #8]
 8006fd4:	4413      	add	r3, r2
 8006fd6:	60bb      	str	r3, [r7, #8]
	*bitOffset = (bitsUsed + *bitOffset) & 0x07;
 8006fd8:	687b      	ldr	r3, [r7, #4]
 8006fda:	681a      	ldr	r2, [r3, #0]
 8006fdc:	6a3b      	ldr	r3, [r7, #32]
 8006fde:	4413      	add	r3, r2
 8006fe0:	f003 0207 	and.w	r2, r3, #7
 8006fe4:	687b      	ldr	r3, [r7, #4]
 8006fe6:	601a      	str	r2, [r3, #0]

	return (buf - startBuf);
 8006fe8:	68ba      	ldr	r2, [r7, #8]
 8006fea:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8006fec:	1ad3      	subs	r3, r2, r3
}
 8006fee:	4618      	mov	r0, r3
 8006ff0:	373c      	adds	r7, #60	; 0x3c
 8006ff2:	46bd      	mov	sp, r7
 8006ff4:	bd90      	pop	{r4, r7, pc}
 8006ff6:	bf00      	nop

08006ff8 <MULSHIFT32>:
{
 8006ff8:	b480      	push	{r7}
 8006ffa:	b085      	sub	sp, #20
 8006ffc:	af00      	add	r7, sp, #0
 8006ffe:	6078      	str	r0, [r7, #4]
 8007000:	6039      	str	r1, [r7, #0]
	__asm__ volatile ("smull %0,%1,%2,%3" : "=&r" (zlow), "=r" (y) : "r" (x), "1" (y) : "cc");
 8007002:	6879      	ldr	r1, [r7, #4]
 8007004:	683b      	ldr	r3, [r7, #0]
 8007006:	fb81 2303 	smull	r2, r3, r1, r3
 800700a:	60fa      	str	r2, [r7, #12]
 800700c:	603b      	str	r3, [r7, #0]
	return y;
 800700e:	683b      	ldr	r3, [r7, #0]
}
 8007010:	4618      	mov	r0, r3
 8007012:	3714      	adds	r7, #20
 8007014:	46bd      	mov	sp, r7
 8007016:	f85d 7b04 	ldr.w	r7, [sp], #4
 800701a:	4770      	bx	lr

0800701c <FASTABS>:
{
 800701c:	b480      	push	{r7}
 800701e:	b085      	sub	sp, #20
 8007020:	af00      	add	r7, sp, #0
 8007022:	6078      	str	r0, [r7, #4]
	sign = x >> (sizeof(int) * 8 - 1);
 8007024:	687b      	ldr	r3, [r7, #4]
 8007026:	17db      	asrs	r3, r3, #31
 8007028:	60fb      	str	r3, [r7, #12]
	x ^= sign;
 800702a:	687a      	ldr	r2, [r7, #4]
 800702c:	68fb      	ldr	r3, [r7, #12]
 800702e:	4053      	eors	r3, r2
 8007030:	607b      	str	r3, [r7, #4]
	x -= sign;
 8007032:	687a      	ldr	r2, [r7, #4]
 8007034:	68fb      	ldr	r3, [r7, #12]
 8007036:	1ad3      	subs	r3, r2, r3
 8007038:	607b      	str	r3, [r7, #4]
	return x;
 800703a:	687b      	ldr	r3, [r7, #4]
}
 800703c:	4618      	mov	r0, r3
 800703e:	3714      	adds	r7, #20
 8007040:	46bd      	mov	sp, r7
 8007042:	f85d 7b04 	ldr.w	r7, [sp], #4
 8007046:	4770      	bx	lr

08007048 <xmp3fixpt_MidSideProc>:
 * Return:      none
 *
 * Notes:       assume at least 1 GB in input
 **************************************************************************************/
void MidSideProc(int x[MAX_NCHAN][MAX_NSAMP], int nSamps, int mOut[2])  
{
 8007048:	b580      	push	{r7, lr}
 800704a:	b08a      	sub	sp, #40	; 0x28
 800704c:	af00      	add	r7, sp, #0
 800704e:	60f8      	str	r0, [r7, #12]
 8007050:	60b9      	str	r1, [r7, #8]
 8007052:	607a      	str	r2, [r7, #4]
	int i, xr, xl, mOutL, mOutR;
	
	/* L = (M+S)/sqrt(2), R = (M-S)/sqrt(2) 
	 * NOTE: 1/sqrt(2) done in DequantChannel() - see comments there
	 */
	mOutL = mOutR = 0;
 8007054:	2300      	movs	r3, #0
 8007056:	61fb      	str	r3, [r7, #28]
 8007058:	69fb      	ldr	r3, [r7, #28]
 800705a:	623b      	str	r3, [r7, #32]
	for(i = 0; i < nSamps; i++) {
 800705c:	2300      	movs	r3, #0
 800705e:	627b      	str	r3, [r7, #36]	; 0x24
 8007060:	e036      	b.n	80070d0 <xmp3fixpt_MidSideProc+0x88>
		xl = x[0][i];
 8007062:	68fb      	ldr	r3, [r7, #12]
 8007064:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8007066:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 800706a:	61bb      	str	r3, [r7, #24]
		xr = x[1][i];
 800706c:	68fb      	ldr	r3, [r7, #12]
 800706e:	f503 6310 	add.w	r3, r3, #2304	; 0x900
 8007072:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8007074:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8007078:	617b      	str	r3, [r7, #20]
		x[0][i] = xl + xr;
 800707a:	69ba      	ldr	r2, [r7, #24]
 800707c:	697b      	ldr	r3, [r7, #20]
 800707e:	18d1      	adds	r1, r2, r3
 8007080:	68fb      	ldr	r3, [r7, #12]
 8007082:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8007084:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
		x[1][i] = xl - xr;
 8007088:	68fb      	ldr	r3, [r7, #12]
 800708a:	f503 6310 	add.w	r3, r3, #2304	; 0x900
 800708e:	69b9      	ldr	r1, [r7, #24]
 8007090:	697a      	ldr	r2, [r7, #20]
 8007092:	1a89      	subs	r1, r1, r2
 8007094:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8007096:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
		mOutL |= FASTABS(x[0][i]);
 800709a:	68fb      	ldr	r3, [r7, #12]
 800709c:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 800709e:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 80070a2:	4618      	mov	r0, r3
 80070a4:	f7ff ffba 	bl	800701c <FASTABS>
 80070a8:	4602      	mov	r2, r0
 80070aa:	6a3b      	ldr	r3, [r7, #32]
 80070ac:	4313      	orrs	r3, r2
 80070ae:	623b      	str	r3, [r7, #32]
		mOutR |= FASTABS(x[1][i]);
 80070b0:	68fb      	ldr	r3, [r7, #12]
 80070b2:	f503 6310 	add.w	r3, r3, #2304	; 0x900
 80070b6:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 80070b8:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 80070bc:	4618      	mov	r0, r3
 80070be:	f7ff ffad 	bl	800701c <FASTABS>
 80070c2:	4602      	mov	r2, r0
 80070c4:	69fb      	ldr	r3, [r7, #28]
 80070c6:	4313      	orrs	r3, r2
 80070c8:	61fb      	str	r3, [r7, #28]
	for(i = 0; i < nSamps; i++) {
 80070ca:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80070cc:	3301      	adds	r3, #1
 80070ce:	627b      	str	r3, [r7, #36]	; 0x24
 80070d0:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 80070d2:	68bb      	ldr	r3, [r7, #8]
 80070d4:	429a      	cmp	r2, r3
 80070d6:	dbc4      	blt.n	8007062 <xmp3fixpt_MidSideProc+0x1a>
	}
	mOut[0] |= mOutL;
 80070d8:	687b      	ldr	r3, [r7, #4]
 80070da:	681a      	ldr	r2, [r3, #0]
 80070dc:	6a3b      	ldr	r3, [r7, #32]
 80070de:	431a      	orrs	r2, r3
 80070e0:	687b      	ldr	r3, [r7, #4]
 80070e2:	601a      	str	r2, [r3, #0]
	mOut[1] |= mOutR;
 80070e4:	687b      	ldr	r3, [r7, #4]
 80070e6:	3304      	adds	r3, #4
 80070e8:	687a      	ldr	r2, [r7, #4]
 80070ea:	3204      	adds	r2, #4
 80070ec:	6811      	ldr	r1, [r2, #0]
 80070ee:	69fa      	ldr	r2, [r7, #28]
 80070f0:	430a      	orrs	r2, r1
 80070f2:	601a      	str	r2, [r3, #0]
}
 80070f4:	bf00      	nop
 80070f6:	3728      	adds	r7, #40	; 0x28
 80070f8:	46bd      	mov	sp, r7
 80070fa:	bd80      	pop	{r7, pc}

080070fc <xmp3fixpt_IntensityProcMPEG1>:
 * TODO:        combine MPEG1/2 into one function (maybe)
 *              make sure all the mixed-block and IIP logic is right
 **************************************************************************************/
void IntensityProcMPEG1(int x[MAX_NCHAN][MAX_NSAMP], int nSamps, FrameHeader *fh, ScaleFactorInfoSub *sfis, 
						CriticalBandInfo *cbi, int midSideFlag, int mixFlag, int mOut[2])
{
 80070fc:	b580      	push	{r7, lr}
 80070fe:	b09c      	sub	sp, #112	; 0x70
 8007100:	af00      	add	r7, sp, #0
 8007102:	60f8      	str	r0, [r7, #12]
 8007104:	60b9      	str	r1, [r7, #8]
 8007106:	607a      	str	r2, [r7, #4]
 8007108:	603b      	str	r3, [r7, #0]
	int i=0, j=0, n=0, cb=0, w=0;
 800710a:	2300      	movs	r3, #0
 800710c:	66fb      	str	r3, [r7, #108]	; 0x6c
 800710e:	2300      	movs	r3, #0
 8007110:	66bb      	str	r3, [r7, #104]	; 0x68
 8007112:	2300      	movs	r3, #0
 8007114:	63bb      	str	r3, [r7, #56]	; 0x38
 8007116:	2300      	movs	r3, #0
 8007118:	667b      	str	r3, [r7, #100]	; 0x64
 800711a:	2300      	movs	r3, #0
 800711c:	663b      	str	r3, [r7, #96]	; 0x60
	int sampsLeft, isf, mOutL, mOutR, xl, xr;
	int fl, fr, fls[3], frs[3];
	int cbStartL=0, cbStartS=0, cbEndL=0, cbEndS=0;
 800711e:	2300      	movs	r3, #0
 8007120:	64bb      	str	r3, [r7, #72]	; 0x48
 8007122:	2300      	movs	r3, #0
 8007124:	647b      	str	r3, [r7, #68]	; 0x44
 8007126:	2300      	movs	r3, #0
 8007128:	643b      	str	r3, [r7, #64]	; 0x40
 800712a:	2300      	movs	r3, #0
 800712c:	63fb      	str	r3, [r7, #60]	; 0x3c
	 *  short block section (i.e. on or after sample 36 = sfBand->l[8] = 3*sfBand->s[3]
	 * is this a safe assumption?
	 * TODO - intensity + mixed not quite right (diff = 11 on he_mode)
	 *  figure out correct implementation (spec ambiguous about when to do short block reorder)
	 */
	if (cbi[1].cbType == 0) {
 800712e:	6fbb      	ldr	r3, [r7, #120]	; 0x78
 8007130:	3318      	adds	r3, #24
 8007132:	681b      	ldr	r3, [r3, #0]
 8007134:	2b00      	cmp	r3, #0
 8007136:	d113      	bne.n	8007160 <xmp3fixpt_IntensityProcMPEG1+0x64>
		/* long block */
		cbStartL = cbi[1].cbEndL + 1;
 8007138:	6fbb      	ldr	r3, [r7, #120]	; 0x78
 800713a:	3318      	adds	r3, #24
 800713c:	695b      	ldr	r3, [r3, #20]
 800713e:	3301      	adds	r3, #1
 8007140:	64bb      	str	r3, [r7, #72]	; 0x48
		cbEndL =   cbi[0].cbEndL + 1;
 8007142:	6fbb      	ldr	r3, [r7, #120]	; 0x78
 8007144:	695b      	ldr	r3, [r3, #20]
 8007146:	3301      	adds	r3, #1
 8007148:	643b      	str	r3, [r7, #64]	; 0x40
		cbStartS = cbEndS = 0;
 800714a:	2300      	movs	r3, #0
 800714c:	63fb      	str	r3, [r7, #60]	; 0x3c
 800714e:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8007150:	647b      	str	r3, [r7, #68]	; 0x44
		i = fh->sfBand->l[cbStartL];
 8007152:	687b      	ldr	r3, [r7, #4]
 8007154:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8007156:	6cba      	ldr	r2, [r7, #72]	; 0x48
 8007158:	f933 3012 	ldrsh.w	r3, [r3, r2, lsl #1]
 800715c:	66fb      	str	r3, [r7, #108]	; 0x6c
 800715e:	e023      	b.n	80071a8 <xmp3fixpt_IntensityProcMPEG1+0xac>
	} else if (cbi[1].cbType == 1 || cbi[1].cbType == 2) {
 8007160:	6fbb      	ldr	r3, [r7, #120]	; 0x78
 8007162:	3318      	adds	r3, #24
 8007164:	681b      	ldr	r3, [r3, #0]
 8007166:	2b01      	cmp	r3, #1
 8007168:	d004      	beq.n	8007174 <xmp3fixpt_IntensityProcMPEG1+0x78>
 800716a:	6fbb      	ldr	r3, [r7, #120]	; 0x78
 800716c:	3318      	adds	r3, #24
 800716e:	681b      	ldr	r3, [r3, #0]
 8007170:	2b02      	cmp	r3, #2
 8007172:	d119      	bne.n	80071a8 <xmp3fixpt_IntensityProcMPEG1+0xac>
		/* short or mixed block */
		cbStartS = cbi[1].cbEndSMax + 1;
 8007174:	6fbb      	ldr	r3, [r7, #120]	; 0x78
 8007176:	3318      	adds	r3, #24
 8007178:	691b      	ldr	r3, [r3, #16]
 800717a:	3301      	adds	r3, #1
 800717c:	647b      	str	r3, [r7, #68]	; 0x44
		cbEndS =   cbi[0].cbEndSMax + 1;
 800717e:	6fbb      	ldr	r3, [r7, #120]	; 0x78
 8007180:	691b      	ldr	r3, [r3, #16]
 8007182:	3301      	adds	r3, #1
 8007184:	63fb      	str	r3, [r7, #60]	; 0x3c
		cbStartL = cbEndL = 0;
 8007186:	2300      	movs	r3, #0
 8007188:	643b      	str	r3, [r7, #64]	; 0x40
 800718a:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800718c:	64bb      	str	r3, [r7, #72]	; 0x48
		i = 3 * fh->sfBand->s[cbStartS];
 800718e:	687b      	ldr	r3, [r7, #4]
 8007190:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8007192:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8007194:	3314      	adds	r3, #20
 8007196:	005b      	lsls	r3, r3, #1
 8007198:	4413      	add	r3, r2
 800719a:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
 800719e:	461a      	mov	r2, r3
 80071a0:	4613      	mov	r3, r2
 80071a2:	005b      	lsls	r3, r3, #1
 80071a4:	4413      	add	r3, r2
 80071a6:	66fb      	str	r3, [r7, #108]	; 0x6c
	}

	sampsLeft = nSamps - i;		/* process to length of left */
 80071a8:	68ba      	ldr	r2, [r7, #8]
 80071aa:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 80071ac:	1ad3      	subs	r3, r2, r3
 80071ae:	65fb      	str	r3, [r7, #92]	; 0x5c
	isfTab = (int *)ISFMpeg1[midSideFlag];
 80071b0:	6ffa      	ldr	r2, [r7, #124]	; 0x7c
 80071b2:	4613      	mov	r3, r2
 80071b4:	00db      	lsls	r3, r3, #3
 80071b6:	1a9b      	subs	r3, r3, r2
 80071b8:	009b      	lsls	r3, r3, #2
 80071ba:	4a77      	ldr	r2, [pc, #476]	; (8007398 <xmp3fixpt_IntensityProcMPEG1+0x29c>)
 80071bc:	4413      	add	r3, r2
 80071be:	637b      	str	r3, [r7, #52]	; 0x34
	mOutL = mOutR = 0;
 80071c0:	2300      	movs	r3, #0
 80071c2:	657b      	str	r3, [r7, #84]	; 0x54
 80071c4:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 80071c6:	65bb      	str	r3, [r7, #88]	; 0x58

	/* long blocks */
	for (cb = cbStartL; cb < cbEndL && sampsLeft > 0; cb++) {
 80071c8:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 80071ca:	667b      	str	r3, [r7, #100]	; 0x64
 80071cc:	e077      	b.n	80072be <xmp3fixpt_IntensityProcMPEG1+0x1c2>
		isf = sfis->l[cb];
 80071ce:	683a      	ldr	r2, [r7, #0]
 80071d0:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 80071d2:	4413      	add	r3, r2
 80071d4:	781b      	ldrb	r3, [r3, #0]
 80071d6:	633b      	str	r3, [r7, #48]	; 0x30
		if (isf == 7) {
 80071d8:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80071da:	2b07      	cmp	r3, #7
 80071dc:	d10b      	bne.n	80071f6 <xmp3fixpt_IntensityProcMPEG1+0xfa>
			fl = ISFIIP[midSideFlag][0];
 80071de:	4a6f      	ldr	r2, [pc, #444]	; (800739c <xmp3fixpt_IntensityProcMPEG1+0x2a0>)
 80071e0:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
 80071e2:	f852 3033 	ldr.w	r3, [r2, r3, lsl #3]
 80071e6:	653b      	str	r3, [r7, #80]	; 0x50
			fr = ISFIIP[midSideFlag][1];
 80071e8:	4a6c      	ldr	r2, [pc, #432]	; (800739c <xmp3fixpt_IntensityProcMPEG1+0x2a0>)
 80071ea:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
 80071ec:	00db      	lsls	r3, r3, #3
 80071ee:	4413      	add	r3, r2
 80071f0:	685b      	ldr	r3, [r3, #4]
 80071f2:	64fb      	str	r3, [r7, #76]	; 0x4c
 80071f4:	e00f      	b.n	8007216 <xmp3fixpt_IntensityProcMPEG1+0x11a>
		} else {
			fl = isfTab[isf];	
 80071f6:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80071f8:	009b      	lsls	r3, r3, #2
 80071fa:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 80071fc:	4413      	add	r3, r2
 80071fe:	681b      	ldr	r3, [r3, #0]
 8007200:	653b      	str	r3, [r7, #80]	; 0x50
			fr = isfTab[6] - isfTab[isf];
 8007202:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8007204:	3318      	adds	r3, #24
 8007206:	681a      	ldr	r2, [r3, #0]
 8007208:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800720a:	009b      	lsls	r3, r3, #2
 800720c:	6b79      	ldr	r1, [r7, #52]	; 0x34
 800720e:	440b      	add	r3, r1
 8007210:	681b      	ldr	r3, [r3, #0]
 8007212:	1ad3      	subs	r3, r2, r3
 8007214:	64fb      	str	r3, [r7, #76]	; 0x4c
		}

		n = fh->sfBand->l[cb + 1] - fh->sfBand->l[cb];
 8007216:	687b      	ldr	r3, [r7, #4]
 8007218:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 800721a:	6e7a      	ldr	r2, [r7, #100]	; 0x64
 800721c:	3201      	adds	r2, #1
 800721e:	f933 3012 	ldrsh.w	r3, [r3, r2, lsl #1]
 8007222:	4619      	mov	r1, r3
 8007224:	687b      	ldr	r3, [r7, #4]
 8007226:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8007228:	6e7a      	ldr	r2, [r7, #100]	; 0x64
 800722a:	f933 3012 	ldrsh.w	r3, [r3, r2, lsl #1]
 800722e:	1acb      	subs	r3, r1, r3
 8007230:	63bb      	str	r3, [r7, #56]	; 0x38
		for (j = 0; j < n && sampsLeft > 0; j++, i++) {
 8007232:	2300      	movs	r3, #0
 8007234:	66bb      	str	r3, [r7, #104]	; 0x68
 8007236:	e038      	b.n	80072aa <xmp3fixpt_IntensityProcMPEG1+0x1ae>
			xr = MULSHIFT32(fr, x[0][i]) << 2;	x[1][i] = xr; mOutR |= FASTABS(xr);
 8007238:	68fb      	ldr	r3, [r7, #12]
 800723a:	6efa      	ldr	r2, [r7, #108]	; 0x6c
 800723c:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8007240:	4619      	mov	r1, r3
 8007242:	6cf8      	ldr	r0, [r7, #76]	; 0x4c
 8007244:	f7ff fed8 	bl	8006ff8 <MULSHIFT32>
 8007248:	4603      	mov	r3, r0
 800724a:	009b      	lsls	r3, r3, #2
 800724c:	62fb      	str	r3, [r7, #44]	; 0x2c
 800724e:	68fb      	ldr	r3, [r7, #12]
 8007250:	f503 6310 	add.w	r3, r3, #2304	; 0x900
 8007254:	6efa      	ldr	r2, [r7, #108]	; 0x6c
 8007256:	6af9      	ldr	r1, [r7, #44]	; 0x2c
 8007258:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
 800725c:	6af8      	ldr	r0, [r7, #44]	; 0x2c
 800725e:	f7ff fedd 	bl	800701c <FASTABS>
 8007262:	4602      	mov	r2, r0
 8007264:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8007266:	4313      	orrs	r3, r2
 8007268:	657b      	str	r3, [r7, #84]	; 0x54
			xl = MULSHIFT32(fl, x[0][i]) << 2;	x[0][i] = xl; mOutL |= FASTABS(xl);
 800726a:	68fb      	ldr	r3, [r7, #12]
 800726c:	6efa      	ldr	r2, [r7, #108]	; 0x6c
 800726e:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8007272:	4619      	mov	r1, r3
 8007274:	6d38      	ldr	r0, [r7, #80]	; 0x50
 8007276:	f7ff febf 	bl	8006ff8 <MULSHIFT32>
 800727a:	4603      	mov	r3, r0
 800727c:	009b      	lsls	r3, r3, #2
 800727e:	62bb      	str	r3, [r7, #40]	; 0x28
 8007280:	68fb      	ldr	r3, [r7, #12]
 8007282:	6efa      	ldr	r2, [r7, #108]	; 0x6c
 8007284:	6ab9      	ldr	r1, [r7, #40]	; 0x28
 8007286:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
 800728a:	6ab8      	ldr	r0, [r7, #40]	; 0x28
 800728c:	f7ff fec6 	bl	800701c <FASTABS>
 8007290:	4602      	mov	r2, r0
 8007292:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8007294:	4313      	orrs	r3, r2
 8007296:	65bb      	str	r3, [r7, #88]	; 0x58
			sampsLeft--;
 8007298:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 800729a:	3b01      	subs	r3, #1
 800729c:	65fb      	str	r3, [r7, #92]	; 0x5c
		for (j = 0; j < n && sampsLeft > 0; j++, i++) {
 800729e:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 80072a0:	3301      	adds	r3, #1
 80072a2:	66bb      	str	r3, [r7, #104]	; 0x68
 80072a4:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 80072a6:	3301      	adds	r3, #1
 80072a8:	66fb      	str	r3, [r7, #108]	; 0x6c
 80072aa:	6eba      	ldr	r2, [r7, #104]	; 0x68
 80072ac:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 80072ae:	429a      	cmp	r2, r3
 80072b0:	da02      	bge.n	80072b8 <xmp3fixpt_IntensityProcMPEG1+0x1bc>
 80072b2:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 80072b4:	2b00      	cmp	r3, #0
 80072b6:	dcbf      	bgt.n	8007238 <xmp3fixpt_IntensityProcMPEG1+0x13c>
	for (cb = cbStartL; cb < cbEndL && sampsLeft > 0; cb++) {
 80072b8:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 80072ba:	3301      	adds	r3, #1
 80072bc:	667b      	str	r3, [r7, #100]	; 0x64
 80072be:	6e7a      	ldr	r2, [r7, #100]	; 0x64
 80072c0:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 80072c2:	429a      	cmp	r2, r3
 80072c4:	da02      	bge.n	80072cc <xmp3fixpt_IntensityProcMPEG1+0x1d0>
 80072c6:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 80072c8:	2b00      	cmp	r3, #0
 80072ca:	dc80      	bgt.n	80071ce <xmp3fixpt_IntensityProcMPEG1+0xd2>
		}
	}

	/* short blocks */
	for (cb = cbStartS; cb < cbEndS && sampsLeft >= 3; cb++) {
 80072cc:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 80072ce:	667b      	str	r3, [r7, #100]	; 0x64
 80072d0:	e112      	b.n	80074f8 <xmp3fixpt_IntensityProcMPEG1+0x3fc>
		for (w = 0; w < 3; w++) {
 80072d2:	2300      	movs	r3, #0
 80072d4:	663b      	str	r3, [r7, #96]	; 0x60
 80072d6:	e044      	b.n	8007362 <xmp3fixpt_IntensityProcMPEG1+0x266>
			isf = sfis->s[cb][w];
 80072d8:	6839      	ldr	r1, [r7, #0]
 80072da:	6e7a      	ldr	r2, [r7, #100]	; 0x64
 80072dc:	4613      	mov	r3, r2
 80072de:	005b      	lsls	r3, r3, #1
 80072e0:	4413      	add	r3, r2
 80072e2:	18ca      	adds	r2, r1, r3
 80072e4:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 80072e6:	4413      	add	r3, r2
 80072e8:	3317      	adds	r3, #23
 80072ea:	781b      	ldrb	r3, [r3, #0]
 80072ec:	633b      	str	r3, [r7, #48]	; 0x30
			if (isf == 7) {
 80072ee:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80072f0:	2b07      	cmp	r3, #7
 80072f2:	d117      	bne.n	8007324 <xmp3fixpt_IntensityProcMPEG1+0x228>
				fls[w] = ISFIIP[midSideFlag][0];
 80072f4:	4a29      	ldr	r2, [pc, #164]	; (800739c <xmp3fixpt_IntensityProcMPEG1+0x2a0>)
 80072f6:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
 80072f8:	f852 2033 	ldr.w	r2, [r2, r3, lsl #3]
 80072fc:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 80072fe:	009b      	lsls	r3, r3, #2
 8007300:	f107 0170 	add.w	r1, r7, #112	; 0x70
 8007304:	440b      	add	r3, r1
 8007306:	f843 2c54 	str.w	r2, [r3, #-84]
				frs[w] = ISFIIP[midSideFlag][1];
 800730a:	4a24      	ldr	r2, [pc, #144]	; (800739c <xmp3fixpt_IntensityProcMPEG1+0x2a0>)
 800730c:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
 800730e:	00db      	lsls	r3, r3, #3
 8007310:	4413      	add	r3, r2
 8007312:	685a      	ldr	r2, [r3, #4]
 8007314:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 8007316:	009b      	lsls	r3, r3, #2
 8007318:	f107 0170 	add.w	r1, r7, #112	; 0x70
 800731c:	440b      	add	r3, r1
 800731e:	f843 2c60 	str.w	r2, [r3, #-96]
 8007322:	e01b      	b.n	800735c <xmp3fixpt_IntensityProcMPEG1+0x260>
			} else {
				fls[w] = isfTab[isf];
 8007324:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8007326:	009b      	lsls	r3, r3, #2
 8007328:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 800732a:	4413      	add	r3, r2
 800732c:	681a      	ldr	r2, [r3, #0]
 800732e:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 8007330:	009b      	lsls	r3, r3, #2
 8007332:	f107 0170 	add.w	r1, r7, #112	; 0x70
 8007336:	440b      	add	r3, r1
 8007338:	f843 2c54 	str.w	r2, [r3, #-84]
				frs[w] = isfTab[6] - isfTab[isf];
 800733c:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800733e:	3318      	adds	r3, #24
 8007340:	681a      	ldr	r2, [r3, #0]
 8007342:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8007344:	009b      	lsls	r3, r3, #2
 8007346:	6b79      	ldr	r1, [r7, #52]	; 0x34
 8007348:	440b      	add	r3, r1
 800734a:	681b      	ldr	r3, [r3, #0]
 800734c:	1ad2      	subs	r2, r2, r3
 800734e:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 8007350:	009b      	lsls	r3, r3, #2
 8007352:	f107 0170 	add.w	r1, r7, #112	; 0x70
 8007356:	440b      	add	r3, r1
 8007358:	f843 2c60 	str.w	r2, [r3, #-96]
		for (w = 0; w < 3; w++) {
 800735c:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 800735e:	3301      	adds	r3, #1
 8007360:	663b      	str	r3, [r7, #96]	; 0x60
 8007362:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 8007364:	2b02      	cmp	r3, #2
 8007366:	ddb7      	ble.n	80072d8 <xmp3fixpt_IntensityProcMPEG1+0x1dc>
			}
		}

		n = fh->sfBand->s[cb + 1] - fh->sfBand->s[cb];
 8007368:	687b      	ldr	r3, [r7, #4]
 800736a:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 800736c:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 800736e:	3301      	adds	r3, #1
 8007370:	3314      	adds	r3, #20
 8007372:	005b      	lsls	r3, r3, #1
 8007374:	4413      	add	r3, r2
 8007376:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
 800737a:	4619      	mov	r1, r3
 800737c:	687b      	ldr	r3, [r7, #4]
 800737e:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8007380:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8007382:	3314      	adds	r3, #20
 8007384:	005b      	lsls	r3, r3, #1
 8007386:	4413      	add	r3, r2
 8007388:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
 800738c:	1acb      	subs	r3, r1, r3
 800738e:	63bb      	str	r3, [r7, #56]	; 0x38
		for (j = 0; j < n && sampsLeft >= 3; j++, i+=3) {
 8007390:	2300      	movs	r3, #0
 8007392:	66bb      	str	r3, [r7, #104]	; 0x68
 8007394:	e0a5      	b.n	80074e2 <xmp3fixpt_IntensityProcMPEG1+0x3e6>
 8007396:	bf00      	nop
 8007398:	0801a49c 	.word	0x0801a49c
 800739c:	0801a5d4 	.word	0x0801a5d4
			xr = MULSHIFT32(frs[0], x[0][i+0]) << 2;	x[1][i+0] = xr;	mOutR |= FASTABS(xr);
 80073a0:	6938      	ldr	r0, [r7, #16]
 80073a2:	68fb      	ldr	r3, [r7, #12]
 80073a4:	6efa      	ldr	r2, [r7, #108]	; 0x6c
 80073a6:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 80073aa:	4619      	mov	r1, r3
 80073ac:	f7ff fe24 	bl	8006ff8 <MULSHIFT32>
 80073b0:	4603      	mov	r3, r0
 80073b2:	009b      	lsls	r3, r3, #2
 80073b4:	62fb      	str	r3, [r7, #44]	; 0x2c
 80073b6:	68fb      	ldr	r3, [r7, #12]
 80073b8:	f503 6310 	add.w	r3, r3, #2304	; 0x900
 80073bc:	6efa      	ldr	r2, [r7, #108]	; 0x6c
 80073be:	6af9      	ldr	r1, [r7, #44]	; 0x2c
 80073c0:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
 80073c4:	6af8      	ldr	r0, [r7, #44]	; 0x2c
 80073c6:	f7ff fe29 	bl	800701c <FASTABS>
 80073ca:	4602      	mov	r2, r0
 80073cc:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 80073ce:	4313      	orrs	r3, r2
 80073d0:	657b      	str	r3, [r7, #84]	; 0x54
			xl = MULSHIFT32(fls[0], x[0][i+0]) << 2;	x[0][i+0] = xl;	mOutL |= FASTABS(xl);
 80073d2:	69f8      	ldr	r0, [r7, #28]
 80073d4:	68fb      	ldr	r3, [r7, #12]
 80073d6:	6efa      	ldr	r2, [r7, #108]	; 0x6c
 80073d8:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 80073dc:	4619      	mov	r1, r3
 80073de:	f7ff fe0b 	bl	8006ff8 <MULSHIFT32>
 80073e2:	4603      	mov	r3, r0
 80073e4:	009b      	lsls	r3, r3, #2
 80073e6:	62bb      	str	r3, [r7, #40]	; 0x28
 80073e8:	68fb      	ldr	r3, [r7, #12]
 80073ea:	6efa      	ldr	r2, [r7, #108]	; 0x6c
 80073ec:	6ab9      	ldr	r1, [r7, #40]	; 0x28
 80073ee:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
 80073f2:	6ab8      	ldr	r0, [r7, #40]	; 0x28
 80073f4:	f7ff fe12 	bl	800701c <FASTABS>
 80073f8:	4602      	mov	r2, r0
 80073fa:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 80073fc:	4313      	orrs	r3, r2
 80073fe:	65bb      	str	r3, [r7, #88]	; 0x58
			xr = MULSHIFT32(frs[1], x[0][i+1]) << 2;	x[1][i+1] = xr;	mOutR |= FASTABS(xr);
 8007400:	6978      	ldr	r0, [r7, #20]
 8007402:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 8007404:	1c5a      	adds	r2, r3, #1
 8007406:	68fb      	ldr	r3, [r7, #12]
 8007408:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 800740c:	4619      	mov	r1, r3
 800740e:	f7ff fdf3 	bl	8006ff8 <MULSHIFT32>
 8007412:	4603      	mov	r3, r0
 8007414:	009b      	lsls	r3, r3, #2
 8007416:	62fb      	str	r3, [r7, #44]	; 0x2c
 8007418:	68fb      	ldr	r3, [r7, #12]
 800741a:	f503 6310 	add.w	r3, r3, #2304	; 0x900
 800741e:	6efa      	ldr	r2, [r7, #108]	; 0x6c
 8007420:	3201      	adds	r2, #1
 8007422:	6af9      	ldr	r1, [r7, #44]	; 0x2c
 8007424:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
 8007428:	6af8      	ldr	r0, [r7, #44]	; 0x2c
 800742a:	f7ff fdf7 	bl	800701c <FASTABS>
 800742e:	4602      	mov	r2, r0
 8007430:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8007432:	4313      	orrs	r3, r2
 8007434:	657b      	str	r3, [r7, #84]	; 0x54
			xl = MULSHIFT32(fls[1], x[0][i+1]) << 2;	x[0][i+1] = xl;	mOutL |= FASTABS(xl);
 8007436:	6a38      	ldr	r0, [r7, #32]
 8007438:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 800743a:	1c5a      	adds	r2, r3, #1
 800743c:	68fb      	ldr	r3, [r7, #12]
 800743e:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8007442:	4619      	mov	r1, r3
 8007444:	f7ff fdd8 	bl	8006ff8 <MULSHIFT32>
 8007448:	4603      	mov	r3, r0
 800744a:	009b      	lsls	r3, r3, #2
 800744c:	62bb      	str	r3, [r7, #40]	; 0x28
 800744e:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 8007450:	1c5a      	adds	r2, r3, #1
 8007452:	68fb      	ldr	r3, [r7, #12]
 8007454:	6ab9      	ldr	r1, [r7, #40]	; 0x28
 8007456:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
 800745a:	6ab8      	ldr	r0, [r7, #40]	; 0x28
 800745c:	f7ff fdde 	bl	800701c <FASTABS>
 8007460:	4602      	mov	r2, r0
 8007462:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8007464:	4313      	orrs	r3, r2
 8007466:	65bb      	str	r3, [r7, #88]	; 0x58
			xr = MULSHIFT32(frs[2], x[0][i+2]) << 2;	x[1][i+2] = xr;	mOutR |= FASTABS(xr);
 8007468:	69b8      	ldr	r0, [r7, #24]
 800746a:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 800746c:	1c9a      	adds	r2, r3, #2
 800746e:	68fb      	ldr	r3, [r7, #12]
 8007470:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8007474:	4619      	mov	r1, r3
 8007476:	f7ff fdbf 	bl	8006ff8 <MULSHIFT32>
 800747a:	4603      	mov	r3, r0
 800747c:	009b      	lsls	r3, r3, #2
 800747e:	62fb      	str	r3, [r7, #44]	; 0x2c
 8007480:	68fb      	ldr	r3, [r7, #12]
 8007482:	f503 6310 	add.w	r3, r3, #2304	; 0x900
 8007486:	6efa      	ldr	r2, [r7, #108]	; 0x6c
 8007488:	3202      	adds	r2, #2
 800748a:	6af9      	ldr	r1, [r7, #44]	; 0x2c
 800748c:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
 8007490:	6af8      	ldr	r0, [r7, #44]	; 0x2c
 8007492:	f7ff fdc3 	bl	800701c <FASTABS>
 8007496:	4602      	mov	r2, r0
 8007498:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 800749a:	4313      	orrs	r3, r2
 800749c:	657b      	str	r3, [r7, #84]	; 0x54
			xl = MULSHIFT32(fls[2], x[0][i+2]) << 2;	x[0][i+2] = xl;	mOutL |= FASTABS(xl);
 800749e:	6a78      	ldr	r0, [r7, #36]	; 0x24
 80074a0:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 80074a2:	1c9a      	adds	r2, r3, #2
 80074a4:	68fb      	ldr	r3, [r7, #12]
 80074a6:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 80074aa:	4619      	mov	r1, r3
 80074ac:	f7ff fda4 	bl	8006ff8 <MULSHIFT32>
 80074b0:	4603      	mov	r3, r0
 80074b2:	009b      	lsls	r3, r3, #2
 80074b4:	62bb      	str	r3, [r7, #40]	; 0x28
 80074b6:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 80074b8:	1c9a      	adds	r2, r3, #2
 80074ba:	68fb      	ldr	r3, [r7, #12]
 80074bc:	6ab9      	ldr	r1, [r7, #40]	; 0x28
 80074be:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
 80074c2:	6ab8      	ldr	r0, [r7, #40]	; 0x28
 80074c4:	f7ff fdaa 	bl	800701c <FASTABS>
 80074c8:	4602      	mov	r2, r0
 80074ca:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 80074cc:	4313      	orrs	r3, r2
 80074ce:	65bb      	str	r3, [r7, #88]	; 0x58
			sampsLeft -= 3;
 80074d0:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 80074d2:	3b03      	subs	r3, #3
 80074d4:	65fb      	str	r3, [r7, #92]	; 0x5c
		for (j = 0; j < n && sampsLeft >= 3; j++, i+=3) {
 80074d6:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 80074d8:	3301      	adds	r3, #1
 80074da:	66bb      	str	r3, [r7, #104]	; 0x68
 80074dc:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 80074de:	3303      	adds	r3, #3
 80074e0:	66fb      	str	r3, [r7, #108]	; 0x6c
 80074e2:	6eba      	ldr	r2, [r7, #104]	; 0x68
 80074e4:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 80074e6:	429a      	cmp	r2, r3
 80074e8:	da03      	bge.n	80074f2 <xmp3fixpt_IntensityProcMPEG1+0x3f6>
 80074ea:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 80074ec:	2b02      	cmp	r3, #2
 80074ee:	f73f af57 	bgt.w	80073a0 <xmp3fixpt_IntensityProcMPEG1+0x2a4>
	for (cb = cbStartS; cb < cbEndS && sampsLeft >= 3; cb++) {
 80074f2:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 80074f4:	3301      	adds	r3, #1
 80074f6:	667b      	str	r3, [r7, #100]	; 0x64
 80074f8:	6e7a      	ldr	r2, [r7, #100]	; 0x64
 80074fa:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 80074fc:	429a      	cmp	r2, r3
 80074fe:	da03      	bge.n	8007508 <xmp3fixpt_IntensityProcMPEG1+0x40c>
 8007500:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 8007502:	2b02      	cmp	r3, #2
 8007504:	f73f aee5 	bgt.w	80072d2 <xmp3fixpt_IntensityProcMPEG1+0x1d6>
		}
	}
	mOut[0] = mOutL;
 8007508:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
 800750c:	6dba      	ldr	r2, [r7, #88]	; 0x58
 800750e:	601a      	str	r2, [r3, #0]
	mOut[1] = mOutR;
 8007510:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
 8007514:	3304      	adds	r3, #4
 8007516:	6d7a      	ldr	r2, [r7, #84]	; 0x54
 8007518:	601a      	str	r2, [r3, #0]
	
	return;
 800751a:	bf00      	nop
}
 800751c:	3770      	adds	r7, #112	; 0x70
 800751e:	46bd      	mov	sp, r7
 8007520:	bd80      	pop	{r7, pc}

08007522 <xmp3fixpt_IntensityProcMPEG2>:
 *              make sure all the mixed-block and IIP logic is right
 *                probably redo IIP logic to be simpler
 **************************************************************************************/
void IntensityProcMPEG2(int x[MAX_NCHAN][MAX_NSAMP], int nSamps, FrameHeader *fh, ScaleFactorInfoSub *sfis, 
						CriticalBandInfo *cbi, ScaleFactorJS *sfjs, int midSideFlag, int mixFlag, int mOut[2])
{
 8007522:	b580      	push	{r7, lr}
 8007524:	b0b2      	sub	sp, #200	; 0xc8
 8007526:	af00      	add	r7, sp, #0
 8007528:	60f8      	str	r0, [r7, #12]
 800752a:	60b9      	str	r1, [r7, #8]
 800752c:	607a      	str	r2, [r7, #4]
 800752e:	603b      	str	r3, [r7, #0]
	int sampsLeft;
	int isf, sfIdx, tmp, il[23];
	int *isfTab;
	int cbStartL, cbStartS, cbEndL, cbEndS;
	
	isfTab = (int *)ISFMpeg2[sfjs->intensityScale][midSideFlag];
 8007530:	f8d7 30d4 	ldr.w	r3, [r7, #212]	; 0xd4
 8007534:	681b      	ldr	r3, [r3, #0]
 8007536:	005a      	lsls	r2, r3, #1
 8007538:	f8d7 30d8 	ldr.w	r3, [r7, #216]	; 0xd8
 800753c:	4413      	add	r3, r2
 800753e:	019b      	lsls	r3, r3, #6
 8007540:	4acd      	ldr	r2, [pc, #820]	; (8007878 <xmp3fixpt_IntensityProcMPEG2+0x356>)
 8007542:	4413      	add	r3, r2
 8007544:	f8c7 3098 	str.w	r3, [r7, #152]	; 0x98
	mOutL = mOutR = 0;
 8007548:	2300      	movs	r3, #0
 800754a:	f8c7 30a0 	str.w	r3, [r7, #160]	; 0xa0
 800754e:	f8d7 30a0 	ldr.w	r3, [r7, #160]	; 0xa0
 8007552:	f8c7 30a4 	str.w	r3, [r7, #164]	; 0xa4

	/* fill buffer with illegal intensity positions (depending on slen) */
	for (k = r = 0; r < 4; r++) {
 8007556:	2300      	movs	r3, #0
 8007558:	f8c7 30b8 	str.w	r3, [r7, #184]	; 0xb8
 800755c:	f8d7 30b8 	ldr.w	r3, [r7, #184]	; 0xb8
 8007560:	f8c7 30bc 	str.w	r3, [r7, #188]	; 0xbc
 8007564:	e035      	b.n	80075d2 <xmp3fixpt_IntensityProcMPEG2+0xb0>
		tmp = (1 << sfjs->slen[r]) - 1;
 8007566:	f8d7 20d4 	ldr.w	r2, [r7, #212]	; 0xd4
 800756a:	f8d7 30b8 	ldr.w	r3, [r7, #184]	; 0xb8
 800756e:	009b      	lsls	r3, r3, #2
 8007570:	4413      	add	r3, r2
 8007572:	685b      	ldr	r3, [r3, #4]
 8007574:	2201      	movs	r2, #1
 8007576:	fa02 f303 	lsl.w	r3, r2, r3
 800757a:	3b01      	subs	r3, #1
 800757c:	f8c7 3094 	str.w	r3, [r7, #148]	; 0x94
		for (j = 0; j < sfjs->nr[r]; j++, k++) 
 8007580:	2300      	movs	r3, #0
 8007582:	f8c7 30c0 	str.w	r3, [r7, #192]	; 0xc0
 8007586:	e013      	b.n	80075b0 <xmp3fixpt_IntensityProcMPEG2+0x8e>
			il[k] = tmp;
 8007588:	f8d7 30bc 	ldr.w	r3, [r7, #188]	; 0xbc
 800758c:	009b      	lsls	r3, r3, #2
 800758e:	f107 02c8 	add.w	r2, r7, #200	; 0xc8
 8007592:	4413      	add	r3, r2
 8007594:	f8d7 2094 	ldr.w	r2, [r7, #148]	; 0x94
 8007598:	f843 2cb4 	str.w	r2, [r3, #-180]
		for (j = 0; j < sfjs->nr[r]; j++, k++) 
 800759c:	f8d7 30c0 	ldr.w	r3, [r7, #192]	; 0xc0
 80075a0:	3301      	adds	r3, #1
 80075a2:	f8c7 30c0 	str.w	r3, [r7, #192]	; 0xc0
 80075a6:	f8d7 30bc 	ldr.w	r3, [r7, #188]	; 0xbc
 80075aa:	3301      	adds	r3, #1
 80075ac:	f8c7 30bc 	str.w	r3, [r7, #188]	; 0xbc
 80075b0:	f8d7 20d4 	ldr.w	r2, [r7, #212]	; 0xd4
 80075b4:	f8d7 30b8 	ldr.w	r3, [r7, #184]	; 0xb8
 80075b8:	3304      	adds	r3, #4
 80075ba:	009b      	lsls	r3, r3, #2
 80075bc:	4413      	add	r3, r2
 80075be:	685a      	ldr	r2, [r3, #4]
 80075c0:	f8d7 30c0 	ldr.w	r3, [r7, #192]	; 0xc0
 80075c4:	429a      	cmp	r2, r3
 80075c6:	dcdf      	bgt.n	8007588 <xmp3fixpt_IntensityProcMPEG2+0x66>
	for (k = r = 0; r < 4; r++) {
 80075c8:	f8d7 30b8 	ldr.w	r3, [r7, #184]	; 0xb8
 80075cc:	3301      	adds	r3, #1
 80075ce:	f8c7 30b8 	str.w	r3, [r7, #184]	; 0xb8
 80075d2:	f8d7 30b8 	ldr.w	r3, [r7, #184]	; 0xb8
 80075d6:	2b03      	cmp	r3, #3
 80075d8:	ddc5      	ble.n	8007566 <xmp3fixpt_IntensityProcMPEG2+0x44>
	}

	if (cbi[1].cbType == 0) {
 80075da:	f8d7 30d0 	ldr.w	r3, [r7, #208]	; 0xd0
 80075de:	3318      	adds	r3, #24
 80075e0:	681b      	ldr	r3, [r3, #0]
 80075e2:	2b00      	cmp	r3, #0
 80075e4:	f040 80ef 	bne.w	80077c6 <xmp3fixpt_IntensityProcMPEG2+0x2a4>
		/* long blocks */
		il[21] = il[22] = 1;
 80075e8:	2301      	movs	r3, #1
 80075ea:	66fb      	str	r3, [r7, #108]	; 0x6c
 80075ec:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 80075ee:	66bb      	str	r3, [r7, #104]	; 0x68
		cbStartL = cbi[1].cbEndL + 1;	/* start at end of right */
 80075f0:	f8d7 30d0 	ldr.w	r3, [r7, #208]	; 0xd0
 80075f4:	3318      	adds	r3, #24
 80075f6:	695b      	ldr	r3, [r3, #20]
 80075f8:	3301      	adds	r3, #1
 80075fa:	f8c7 3090 	str.w	r3, [r7, #144]	; 0x90
		cbEndL =   cbi[0].cbEndL + 1;	/* process to end of left */
 80075fe:	f8d7 30d0 	ldr.w	r3, [r7, #208]	; 0xd0
 8007602:	695b      	ldr	r3, [r3, #20]
 8007604:	3301      	adds	r3, #1
 8007606:	f8c7 308c 	str.w	r3, [r7, #140]	; 0x8c
		i = fh->sfBand->l[cbStartL];
 800760a:	687b      	ldr	r3, [r7, #4]
 800760c:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 800760e:	f8d7 2090 	ldr.w	r2, [r7, #144]	; 0x90
 8007612:	f933 3012 	ldrsh.w	r3, [r3, r2, lsl #1]
 8007616:	f8c7 30c4 	str.w	r3, [r7, #196]	; 0xc4
		sampsLeft = nSamps - i;
 800761a:	68ba      	ldr	r2, [r7, #8]
 800761c:	f8d7 30c4 	ldr.w	r3, [r7, #196]	; 0xc4
 8007620:	1ad3      	subs	r3, r2, r3
 8007622:	f8c7 309c 	str.w	r3, [r7, #156]	; 0x9c

		for(cb = cbStartL; cb < cbEndL; cb++) {
 8007626:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
 800762a:	f8c7 30b4 	str.w	r3, [r7, #180]	; 0xb4
 800762e:	e0c2      	b.n	80077b6 <xmp3fixpt_IntensityProcMPEG2+0x294>
			sfIdx = sfis->l[cb];
 8007630:	683a      	ldr	r2, [r7, #0]
 8007632:	f8d7 30b4 	ldr.w	r3, [r7, #180]	; 0xb4
 8007636:	4413      	add	r3, r2
 8007638:	781b      	ldrb	r3, [r3, #0]
 800763a:	f8c7 3088 	str.w	r3, [r7, #136]	; 0x88
			if (sfIdx == il[cb]) {
 800763e:	f8d7 30b4 	ldr.w	r3, [r7, #180]	; 0xb4
 8007642:	009b      	lsls	r3, r3, #2
 8007644:	f107 02c8 	add.w	r2, r7, #200	; 0xc8
 8007648:	4413      	add	r3, r2
 800764a:	f853 2cb4 	ldr.w	r2, [r3, #-180]
 800764e:	f8d7 3088 	ldr.w	r3, [r7, #136]	; 0x88
 8007652:	429a      	cmp	r2, r3
 8007654:	d10f      	bne.n	8007676 <xmp3fixpt_IntensityProcMPEG2+0x154>
				fl = ISFIIP[midSideFlag][0];
 8007656:	4a89      	ldr	r2, [pc, #548]	; (800787c <xmp3fixpt_IntensityProcMPEG2+0x35a>)
 8007658:	f8d7 30d8 	ldr.w	r3, [r7, #216]	; 0xd8
 800765c:	f852 3033 	ldr.w	r3, [r2, r3, lsl #3]
 8007660:	f8c7 30ac 	str.w	r3, [r7, #172]	; 0xac
				fr = ISFIIP[midSideFlag][1];
 8007664:	4a85      	ldr	r2, [pc, #532]	; (800787c <xmp3fixpt_IntensityProcMPEG2+0x35a>)
 8007666:	f8d7 30d8 	ldr.w	r3, [r7, #216]	; 0xd8
 800766a:	00db      	lsls	r3, r3, #3
 800766c:	4413      	add	r3, r2
 800766e:	685b      	ldr	r3, [r3, #4]
 8007670:	f8c7 30a8 	str.w	r3, [r7, #168]	; 0xa8
 8007674:	e02a      	b.n	80076cc <xmp3fixpt_IntensityProcMPEG2+0x1aa>
			} else {
				isf = (sfis->l[cb] + 1) >> 1;
 8007676:	683a      	ldr	r2, [r7, #0]
 8007678:	f8d7 30b4 	ldr.w	r3, [r7, #180]	; 0xb4
 800767c:	4413      	add	r3, r2
 800767e:	781b      	ldrb	r3, [r3, #0]
 8007680:	3301      	adds	r3, #1
 8007682:	105b      	asrs	r3, r3, #1
 8007684:	f8c7 3084 	str.w	r3, [r7, #132]	; 0x84
				fl = isfTab[(sfIdx & 0x01 ? isf : 0)];
 8007688:	f8d7 3088 	ldr.w	r3, [r7, #136]	; 0x88
 800768c:	f003 0301 	and.w	r3, r3, #1
 8007690:	2b00      	cmp	r3, #0
 8007692:	d003      	beq.n	800769c <xmp3fixpt_IntensityProcMPEG2+0x17a>
 8007694:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
 8007698:	009b      	lsls	r3, r3, #2
 800769a:	e000      	b.n	800769e <xmp3fixpt_IntensityProcMPEG2+0x17c>
 800769c:	2300      	movs	r3, #0
 800769e:	f8d7 2098 	ldr.w	r2, [r7, #152]	; 0x98
 80076a2:	4413      	add	r3, r2
 80076a4:	681b      	ldr	r3, [r3, #0]
 80076a6:	f8c7 30ac 	str.w	r3, [r7, #172]	; 0xac
				fr = isfTab[(sfIdx & 0x01 ? 0 : isf)];
 80076aa:	f8d7 3088 	ldr.w	r3, [r7, #136]	; 0x88
 80076ae:	f003 0301 	and.w	r3, r3, #1
 80076b2:	2b00      	cmp	r3, #0
 80076b4:	d103      	bne.n	80076be <xmp3fixpt_IntensityProcMPEG2+0x19c>
 80076b6:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
 80076ba:	009b      	lsls	r3, r3, #2
 80076bc:	e000      	b.n	80076c0 <xmp3fixpt_IntensityProcMPEG2+0x19e>
 80076be:	2300      	movs	r3, #0
 80076c0:	f8d7 2098 	ldr.w	r2, [r7, #152]	; 0x98
 80076c4:	4413      	add	r3, r2
 80076c6:	681b      	ldr	r3, [r3, #0]
 80076c8:	f8c7 30a8 	str.w	r3, [r7, #168]	; 0xa8
			}
			n = MIN(fh->sfBand->l[cb + 1] - fh->sfBand->l[cb], sampsLeft);
 80076cc:	687b      	ldr	r3, [r7, #4]
 80076ce:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 80076d0:	f8d7 20b4 	ldr.w	r2, [r7, #180]	; 0xb4
 80076d4:	3201      	adds	r2, #1
 80076d6:	f933 3012 	ldrsh.w	r3, [r3, r2, lsl #1]
 80076da:	4619      	mov	r1, r3
 80076dc:	687b      	ldr	r3, [r7, #4]
 80076de:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 80076e0:	f8d7 20b4 	ldr.w	r2, [r7, #180]	; 0xb4
 80076e4:	f933 3012 	ldrsh.w	r3, [r3, r2, lsl #1]
 80076e8:	1aca      	subs	r2, r1, r3
 80076ea:	f8d7 309c 	ldr.w	r3, [r7, #156]	; 0x9c
 80076ee:	4293      	cmp	r3, r2
 80076f0:	bfa8      	it	ge
 80076f2:	4613      	movge	r3, r2
 80076f4:	f8c7 3080 	str.w	r3, [r7, #128]	; 0x80

			for(j = 0; j < n; j++, i++) {
 80076f8:	2300      	movs	r3, #0
 80076fa:	f8c7 30c0 	str.w	r3, [r7, #192]	; 0xc0
 80076fe:	e043      	b.n	8007788 <xmp3fixpt_IntensityProcMPEG2+0x266>
				xr = MULSHIFT32(fr, x[0][i]) << 2;	x[1][i] = xr;	mOutR |= FASTABS(xr);
 8007700:	68fb      	ldr	r3, [r7, #12]
 8007702:	f8d7 20c4 	ldr.w	r2, [r7, #196]	; 0xc4
 8007706:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 800770a:	4619      	mov	r1, r3
 800770c:	f8d7 00a8 	ldr.w	r0, [r7, #168]	; 0xa8
 8007710:	f7ff fc72 	bl	8006ff8 <MULSHIFT32>
 8007714:	4603      	mov	r3, r0
 8007716:	009b      	lsls	r3, r3, #2
 8007718:	67fb      	str	r3, [r7, #124]	; 0x7c
 800771a:	68fb      	ldr	r3, [r7, #12]
 800771c:	f503 6310 	add.w	r3, r3, #2304	; 0x900
 8007720:	f8d7 20c4 	ldr.w	r2, [r7, #196]	; 0xc4
 8007724:	6ff9      	ldr	r1, [r7, #124]	; 0x7c
 8007726:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
 800772a:	6ff8      	ldr	r0, [r7, #124]	; 0x7c
 800772c:	f7ff fc76 	bl	800701c <FASTABS>
 8007730:	4602      	mov	r2, r0
 8007732:	f8d7 30a0 	ldr.w	r3, [r7, #160]	; 0xa0
 8007736:	4313      	orrs	r3, r2
 8007738:	f8c7 30a0 	str.w	r3, [r7, #160]	; 0xa0
				xl = MULSHIFT32(fl, x[0][i]) << 2;	x[0][i] = xl;	mOutL |= FASTABS(xl);
 800773c:	68fb      	ldr	r3, [r7, #12]
 800773e:	f8d7 20c4 	ldr.w	r2, [r7, #196]	; 0xc4
 8007742:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8007746:	4619      	mov	r1, r3
 8007748:	f8d7 00ac 	ldr.w	r0, [r7, #172]	; 0xac
 800774c:	f7ff fc54 	bl	8006ff8 <MULSHIFT32>
 8007750:	4603      	mov	r3, r0
 8007752:	009b      	lsls	r3, r3, #2
 8007754:	67bb      	str	r3, [r7, #120]	; 0x78
 8007756:	68fb      	ldr	r3, [r7, #12]
 8007758:	f8d7 20c4 	ldr.w	r2, [r7, #196]	; 0xc4
 800775c:	6fb9      	ldr	r1, [r7, #120]	; 0x78
 800775e:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
 8007762:	6fb8      	ldr	r0, [r7, #120]	; 0x78
 8007764:	f7ff fc5a 	bl	800701c <FASTABS>
 8007768:	4602      	mov	r2, r0
 800776a:	f8d7 30a4 	ldr.w	r3, [r7, #164]	; 0xa4
 800776e:	4313      	orrs	r3, r2
 8007770:	f8c7 30a4 	str.w	r3, [r7, #164]	; 0xa4
			for(j = 0; j < n; j++, i++) {
 8007774:	f8d7 30c0 	ldr.w	r3, [r7, #192]	; 0xc0
 8007778:	3301      	adds	r3, #1
 800777a:	f8c7 30c0 	str.w	r3, [r7, #192]	; 0xc0
 800777e:	f8d7 30c4 	ldr.w	r3, [r7, #196]	; 0xc4
 8007782:	3301      	adds	r3, #1
 8007784:	f8c7 30c4 	str.w	r3, [r7, #196]	; 0xc4
 8007788:	f8d7 20c0 	ldr.w	r2, [r7, #192]	; 0xc0
 800778c:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
 8007790:	429a      	cmp	r2, r3
 8007792:	dbb5      	blt.n	8007700 <xmp3fixpt_IntensityProcMPEG2+0x1de>
			}

			/* early exit once we've used all the non-zero samples */
			sampsLeft -= n;
 8007794:	f8d7 209c 	ldr.w	r2, [r7, #156]	; 0x9c
 8007798:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
 800779c:	1ad3      	subs	r3, r2, r3
 800779e:	f8c7 309c 	str.w	r3, [r7, #156]	; 0x9c
			if (sampsLeft == 0)		
 80077a2:	f8d7 309c 	ldr.w	r3, [r7, #156]	; 0x9c
 80077a6:	2b00      	cmp	r3, #0
 80077a8:	f000 8117 	beq.w	80079da <xmp3fixpt_IntensityProcMPEG2+0x4b8>
		for(cb = cbStartL; cb < cbEndL; cb++) {
 80077ac:	f8d7 30b4 	ldr.w	r3, [r7, #180]	; 0xb4
 80077b0:	3301      	adds	r3, #1
 80077b2:	f8c7 30b4 	str.w	r3, [r7, #180]	; 0xb4
 80077b6:	f8d7 20b4 	ldr.w	r2, [r7, #180]	; 0xb4
 80077ba:	f8d7 308c 	ldr.w	r3, [r7, #140]	; 0x8c
 80077be:	429a      	cmp	r2, r3
 80077c0:	f6ff af36 	blt.w	8007630 <xmp3fixpt_IntensityProcMPEG2+0x10e>
 80077c4:	e10a      	b.n	80079dc <xmp3fixpt_IntensityProcMPEG2+0x4ba>
				break;
		}
	} else {
		/* short or mixed blocks */
		il[12] = 1;
 80077c6:	2301      	movs	r3, #1
 80077c8:	647b      	str	r3, [r7, #68]	; 0x44

		for(w = 0; w < 3; w++) {
 80077ca:	2300      	movs	r3, #0
 80077cc:	f8c7 30b0 	str.w	r3, [r7, #176]	; 0xb0
 80077d0:	e0fd      	b.n	80079ce <xmp3fixpt_IntensityProcMPEG2+0x4ac>
			cbStartS = cbi[1].cbEndS[w] + 1;		/* start at end of right */
 80077d2:	f8d7 30d0 	ldr.w	r3, [r7, #208]	; 0xd0
 80077d6:	f103 0218 	add.w	r2, r3, #24
 80077da:	f8d7 30b0 	ldr.w	r3, [r7, #176]	; 0xb0
 80077de:	009b      	lsls	r3, r3, #2
 80077e0:	4413      	add	r3, r2
 80077e2:	685b      	ldr	r3, [r3, #4]
 80077e4:	3301      	adds	r3, #1
 80077e6:	677b      	str	r3, [r7, #116]	; 0x74
			cbEndS =   cbi[0].cbEndS[w] + 1;		/* process to end of left */
 80077e8:	f8d7 20d0 	ldr.w	r2, [r7, #208]	; 0xd0
 80077ec:	f8d7 30b0 	ldr.w	r3, [r7, #176]	; 0xb0
 80077f0:	009b      	lsls	r3, r3, #2
 80077f2:	4413      	add	r3, r2
 80077f4:	685b      	ldr	r3, [r3, #4]
 80077f6:	3301      	adds	r3, #1
 80077f8:	673b      	str	r3, [r7, #112]	; 0x70
			i = 3 * fh->sfBand->s[cbStartS] + w;
 80077fa:	687b      	ldr	r3, [r7, #4]
 80077fc:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 80077fe:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 8007800:	3314      	adds	r3, #20
 8007802:	005b      	lsls	r3, r3, #1
 8007804:	4413      	add	r3, r2
 8007806:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
 800780a:	461a      	mov	r2, r3
 800780c:	4613      	mov	r3, r2
 800780e:	005b      	lsls	r3, r3, #1
 8007810:	441a      	add	r2, r3
 8007812:	f8d7 30b0 	ldr.w	r3, [r7, #176]	; 0xb0
 8007816:	4413      	add	r3, r2
 8007818:	f8c7 30c4 	str.w	r3, [r7, #196]	; 0xc4

			/* skip through sample array by 3, so early-exit logic would be more tricky */
			for(cb = cbStartS; cb < cbEndS; cb++) {
 800781c:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 800781e:	f8c7 30b4 	str.w	r3, [r7, #180]	; 0xb4
 8007822:	e0c9      	b.n	80079b8 <xmp3fixpt_IntensityProcMPEG2+0x496>
				sfIdx = sfis->s[cb][w];
 8007824:	6839      	ldr	r1, [r7, #0]
 8007826:	f8d7 20b4 	ldr.w	r2, [r7, #180]	; 0xb4
 800782a:	4613      	mov	r3, r2
 800782c:	005b      	lsls	r3, r3, #1
 800782e:	4413      	add	r3, r2
 8007830:	18ca      	adds	r2, r1, r3
 8007832:	f8d7 30b0 	ldr.w	r3, [r7, #176]	; 0xb0
 8007836:	4413      	add	r3, r2
 8007838:	3317      	adds	r3, #23
 800783a:	781b      	ldrb	r3, [r3, #0]
 800783c:	f8c7 3088 	str.w	r3, [r7, #136]	; 0x88
				if (sfIdx == il[cb]) {
 8007840:	f8d7 30b4 	ldr.w	r3, [r7, #180]	; 0xb4
 8007844:	009b      	lsls	r3, r3, #2
 8007846:	f107 02c8 	add.w	r2, r7, #200	; 0xc8
 800784a:	4413      	add	r3, r2
 800784c:	f853 2cb4 	ldr.w	r2, [r3, #-180]
 8007850:	f8d7 3088 	ldr.w	r3, [r7, #136]	; 0x88
 8007854:	429a      	cmp	r2, r3
 8007856:	d113      	bne.n	8007880 <xmp3fixpt_IntensityProcMPEG2+0x35e>
					fl = ISFIIP[midSideFlag][0];
 8007858:	4a08      	ldr	r2, [pc, #32]	; (800787c <xmp3fixpt_IntensityProcMPEG2+0x35a>)
 800785a:	f8d7 30d8 	ldr.w	r3, [r7, #216]	; 0xd8
 800785e:	f852 3033 	ldr.w	r3, [r2, r3, lsl #3]
 8007862:	f8c7 30ac 	str.w	r3, [r7, #172]	; 0xac
					fr = ISFIIP[midSideFlag][1];
 8007866:	4a05      	ldr	r2, [pc, #20]	; (800787c <xmp3fixpt_IntensityProcMPEG2+0x35a>)
 8007868:	f8d7 30d8 	ldr.w	r3, [r7, #216]	; 0xd8
 800786c:	00db      	lsls	r3, r3, #3
 800786e:	4413      	add	r3, r2
 8007870:	685b      	ldr	r3, [r3, #4]
 8007872:	f8c7 30a8 	str.w	r3, [r7, #168]	; 0xa8
 8007876:	e035      	b.n	80078e4 <xmp3fixpt_IntensityProcMPEG2+0x3c2>
 8007878:	0801a4d4 	.word	0x0801a4d4
 800787c:	0801a5d4 	.word	0x0801a5d4
				} else {
					isf = (sfis->s[cb][w] + 1) >> 1;
 8007880:	6839      	ldr	r1, [r7, #0]
 8007882:	f8d7 20b4 	ldr.w	r2, [r7, #180]	; 0xb4
 8007886:	4613      	mov	r3, r2
 8007888:	005b      	lsls	r3, r3, #1
 800788a:	4413      	add	r3, r2
 800788c:	18ca      	adds	r2, r1, r3
 800788e:	f8d7 30b0 	ldr.w	r3, [r7, #176]	; 0xb0
 8007892:	4413      	add	r3, r2
 8007894:	3317      	adds	r3, #23
 8007896:	781b      	ldrb	r3, [r3, #0]
 8007898:	3301      	adds	r3, #1
 800789a:	105b      	asrs	r3, r3, #1
 800789c:	f8c7 3084 	str.w	r3, [r7, #132]	; 0x84
					fl = isfTab[(sfIdx & 0x01 ? isf : 0)];
 80078a0:	f8d7 3088 	ldr.w	r3, [r7, #136]	; 0x88
 80078a4:	f003 0301 	and.w	r3, r3, #1
 80078a8:	2b00      	cmp	r3, #0
 80078aa:	d003      	beq.n	80078b4 <xmp3fixpt_IntensityProcMPEG2+0x392>
 80078ac:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
 80078b0:	009b      	lsls	r3, r3, #2
 80078b2:	e000      	b.n	80078b6 <xmp3fixpt_IntensityProcMPEG2+0x394>
 80078b4:	2300      	movs	r3, #0
 80078b6:	f8d7 2098 	ldr.w	r2, [r7, #152]	; 0x98
 80078ba:	4413      	add	r3, r2
 80078bc:	681b      	ldr	r3, [r3, #0]
 80078be:	f8c7 30ac 	str.w	r3, [r7, #172]	; 0xac
					fr = isfTab[(sfIdx & 0x01 ? 0 : isf)];
 80078c2:	f8d7 3088 	ldr.w	r3, [r7, #136]	; 0x88
 80078c6:	f003 0301 	and.w	r3, r3, #1
 80078ca:	2b00      	cmp	r3, #0
 80078cc:	d103      	bne.n	80078d6 <xmp3fixpt_IntensityProcMPEG2+0x3b4>
 80078ce:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
 80078d2:	009b      	lsls	r3, r3, #2
 80078d4:	e000      	b.n	80078d8 <xmp3fixpt_IntensityProcMPEG2+0x3b6>
 80078d6:	2300      	movs	r3, #0
 80078d8:	f8d7 2098 	ldr.w	r2, [r7, #152]	; 0x98
 80078dc:	4413      	add	r3, r2
 80078de:	681b      	ldr	r3, [r3, #0]
 80078e0:	f8c7 30a8 	str.w	r3, [r7, #168]	; 0xa8
				}
				n = fh->sfBand->s[cb + 1] - fh->sfBand->s[cb];
 80078e4:	687b      	ldr	r3, [r7, #4]
 80078e6:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 80078e8:	f8d7 30b4 	ldr.w	r3, [r7, #180]	; 0xb4
 80078ec:	3301      	adds	r3, #1
 80078ee:	3314      	adds	r3, #20
 80078f0:	005b      	lsls	r3, r3, #1
 80078f2:	4413      	add	r3, r2
 80078f4:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
 80078f8:	4619      	mov	r1, r3
 80078fa:	687b      	ldr	r3, [r7, #4]
 80078fc:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 80078fe:	f8d7 30b4 	ldr.w	r3, [r7, #180]	; 0xb4
 8007902:	3314      	adds	r3, #20
 8007904:	005b      	lsls	r3, r3, #1
 8007906:	4413      	add	r3, r2
 8007908:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
 800790c:	1acb      	subs	r3, r1, r3
 800790e:	f8c7 3080 	str.w	r3, [r7, #128]	; 0x80

				for(j = 0; j < n; j++, i+=3) {
 8007912:	2300      	movs	r3, #0
 8007914:	f8c7 30c0 	str.w	r3, [r7, #192]	; 0xc0
 8007918:	e043      	b.n	80079a2 <xmp3fixpt_IntensityProcMPEG2+0x480>
					xr = MULSHIFT32(fr, x[0][i]) << 2;	x[1][i] = xr;	mOutR |= FASTABS(xr);
 800791a:	68fb      	ldr	r3, [r7, #12]
 800791c:	f8d7 20c4 	ldr.w	r2, [r7, #196]	; 0xc4
 8007920:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8007924:	4619      	mov	r1, r3
 8007926:	f8d7 00a8 	ldr.w	r0, [r7, #168]	; 0xa8
 800792a:	f7ff fb65 	bl	8006ff8 <MULSHIFT32>
 800792e:	4603      	mov	r3, r0
 8007930:	009b      	lsls	r3, r3, #2
 8007932:	67fb      	str	r3, [r7, #124]	; 0x7c
 8007934:	68fb      	ldr	r3, [r7, #12]
 8007936:	f503 6310 	add.w	r3, r3, #2304	; 0x900
 800793a:	f8d7 20c4 	ldr.w	r2, [r7, #196]	; 0xc4
 800793e:	6ff9      	ldr	r1, [r7, #124]	; 0x7c
 8007940:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
 8007944:	6ff8      	ldr	r0, [r7, #124]	; 0x7c
 8007946:	f7ff fb69 	bl	800701c <FASTABS>
 800794a:	4602      	mov	r2, r0
 800794c:	f8d7 30a0 	ldr.w	r3, [r7, #160]	; 0xa0
 8007950:	4313      	orrs	r3, r2
 8007952:	f8c7 30a0 	str.w	r3, [r7, #160]	; 0xa0
					xl = MULSHIFT32(fl, x[0][i]) << 2;	x[0][i] = xl;	mOutL |= FASTABS(xl);
 8007956:	68fb      	ldr	r3, [r7, #12]
 8007958:	f8d7 20c4 	ldr.w	r2, [r7, #196]	; 0xc4
 800795c:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8007960:	4619      	mov	r1, r3
 8007962:	f8d7 00ac 	ldr.w	r0, [r7, #172]	; 0xac
 8007966:	f7ff fb47 	bl	8006ff8 <MULSHIFT32>
 800796a:	4603      	mov	r3, r0
 800796c:	009b      	lsls	r3, r3, #2
 800796e:	67bb      	str	r3, [r7, #120]	; 0x78
 8007970:	68fb      	ldr	r3, [r7, #12]
 8007972:	f8d7 20c4 	ldr.w	r2, [r7, #196]	; 0xc4
 8007976:	6fb9      	ldr	r1, [r7, #120]	; 0x78
 8007978:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
 800797c:	6fb8      	ldr	r0, [r7, #120]	; 0x78
 800797e:	f7ff fb4d 	bl	800701c <FASTABS>
 8007982:	4602      	mov	r2, r0
 8007984:	f8d7 30a4 	ldr.w	r3, [r7, #164]	; 0xa4
 8007988:	4313      	orrs	r3, r2
 800798a:	f8c7 30a4 	str.w	r3, [r7, #164]	; 0xa4
				for(j = 0; j < n; j++, i+=3) {
 800798e:	f8d7 30c0 	ldr.w	r3, [r7, #192]	; 0xc0
 8007992:	3301      	adds	r3, #1
 8007994:	f8c7 30c0 	str.w	r3, [r7, #192]	; 0xc0
 8007998:	f8d7 30c4 	ldr.w	r3, [r7, #196]	; 0xc4
 800799c:	3303      	adds	r3, #3
 800799e:	f8c7 30c4 	str.w	r3, [r7, #196]	; 0xc4
 80079a2:	f8d7 20c0 	ldr.w	r2, [r7, #192]	; 0xc0
 80079a6:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
 80079aa:	429a      	cmp	r2, r3
 80079ac:	dbb5      	blt.n	800791a <xmp3fixpt_IntensityProcMPEG2+0x3f8>
			for(cb = cbStartS; cb < cbEndS; cb++) {
 80079ae:	f8d7 30b4 	ldr.w	r3, [r7, #180]	; 0xb4
 80079b2:	3301      	adds	r3, #1
 80079b4:	f8c7 30b4 	str.w	r3, [r7, #180]	; 0xb4
 80079b8:	f8d7 20b4 	ldr.w	r2, [r7, #180]	; 0xb4
 80079bc:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 80079be:	429a      	cmp	r2, r3
 80079c0:	f6ff af30 	blt.w	8007824 <xmp3fixpt_IntensityProcMPEG2+0x302>
		for(w = 0; w < 3; w++) {
 80079c4:	f8d7 30b0 	ldr.w	r3, [r7, #176]	; 0xb0
 80079c8:	3301      	adds	r3, #1
 80079ca:	f8c7 30b0 	str.w	r3, [r7, #176]	; 0xb0
 80079ce:	f8d7 30b0 	ldr.w	r3, [r7, #176]	; 0xb0
 80079d2:	2b02      	cmp	r3, #2
 80079d4:	f77f aefd 	ble.w	80077d2 <xmp3fixpt_IntensityProcMPEG2+0x2b0>
 80079d8:	e000      	b.n	80079dc <xmp3fixpt_IntensityProcMPEG2+0x4ba>
				break;
 80079da:	bf00      	nop
				}
			}
		}
	}
	mOut[0] = mOutL;
 80079dc:	f8d7 30e0 	ldr.w	r3, [r7, #224]	; 0xe0
 80079e0:	f8d7 20a4 	ldr.w	r2, [r7, #164]	; 0xa4
 80079e4:	601a      	str	r2, [r3, #0]
	mOut[1] = mOutR;
 80079e6:	f8d7 30e0 	ldr.w	r3, [r7, #224]	; 0xe0
 80079ea:	3304      	adds	r3, #4
 80079ec:	f8d7 20a0 	ldr.w	r2, [r7, #160]	; 0xa0
 80079f0:	601a      	str	r2, [r3, #0]

	return;
 80079f2:	bf00      	nop
}
 80079f4:	37c8      	adds	r7, #200	; 0xc8
 80079f6:	46bd      	mov	sp, r7
 80079f8:	bd80      	pop	{r7, pc}
 80079fa:	bf00      	nop

080079fc <xmp3fixpt_Subband>:
 * Outputs:     decoded PCM data, interleaved LRLRLR... if stereo
 *
 * Return:      0 on success,  -1 if null input pointers
 **************************************************************************************/
int Subband(MP3DecInfo *mp3DecInfo, short *pcmBuf)
{
 80079fc:	b590      	push	{r4, r7, lr}
 80079fe:	b089      	sub	sp, #36	; 0x24
 8007a00:	af02      	add	r7, sp, #8
 8007a02:	6078      	str	r0, [r7, #4]
 8007a04:	6039      	str	r1, [r7, #0]
	HuffmanInfo *hi;
	IMDCTInfo *mi;
	SubbandInfo *sbi;

	/* validate pointers */
	if (!mp3DecInfo || !mp3DecInfo->HuffmanInfoPS || !mp3DecInfo->IMDCTInfoPS || !mp3DecInfo->SubbandInfoPS)
 8007a06:	687b      	ldr	r3, [r7, #4]
 8007a08:	2b00      	cmp	r3, #0
 8007a0a:	d00b      	beq.n	8007a24 <xmp3fixpt_Subband+0x28>
 8007a0c:	687b      	ldr	r3, [r7, #4]
 8007a0e:	68db      	ldr	r3, [r3, #12]
 8007a10:	2b00      	cmp	r3, #0
 8007a12:	d007      	beq.n	8007a24 <xmp3fixpt_Subband+0x28>
 8007a14:	687b      	ldr	r3, [r7, #4]
 8007a16:	695b      	ldr	r3, [r3, #20]
 8007a18:	2b00      	cmp	r3, #0
 8007a1a:	d003      	beq.n	8007a24 <xmp3fixpt_Subband+0x28>
 8007a1c:	687b      	ldr	r3, [r7, #4]
 8007a1e:	699b      	ldr	r3, [r3, #24]
 8007a20:	2b00      	cmp	r3, #0
 8007a22:	d102      	bne.n	8007a2a <xmp3fixpt_Subband+0x2e>
		return -1;
 8007a24:	f04f 33ff 	mov.w	r3, #4294967295
 8007a28:	e0ad      	b.n	8007b86 <xmp3fixpt_Subband+0x18a>

	hi = (HuffmanInfo *)mp3DecInfo->HuffmanInfoPS;
 8007a2a:	687b      	ldr	r3, [r7, #4]
 8007a2c:	68db      	ldr	r3, [r3, #12]
 8007a2e:	613b      	str	r3, [r7, #16]
	mi = (IMDCTInfo *)(mp3DecInfo->IMDCTInfoPS);
 8007a30:	687b      	ldr	r3, [r7, #4]
 8007a32:	695b      	ldr	r3, [r3, #20]
 8007a34:	60fb      	str	r3, [r7, #12]
	sbi = (SubbandInfo*)(mp3DecInfo->SubbandInfoPS);
 8007a36:	687b      	ldr	r3, [r7, #4]
 8007a38:	699b      	ldr	r3, [r3, #24]
 8007a3a:	60bb      	str	r3, [r7, #8]

	if (mp3DecInfo->nChans == 2) {
 8007a3c:	687b      	ldr	r3, [r7, #4]
 8007a3e:	f8d3 37bc 	ldr.w	r3, [r3, #1980]	; 0x7bc
 8007a42:	2b02      	cmp	r3, #2
 8007a44:	d15b      	bne.n	8007afe <xmp3fixpt_Subband+0x102>
		/* stereo */
		for (b = 0; b < BLOCK_SIZE; b++) {
 8007a46:	2300      	movs	r3, #0
 8007a48:	617b      	str	r3, [r7, #20]
 8007a4a:	e054      	b.n	8007af6 <xmp3fixpt_Subband+0xfa>
			FDCT32(mi->outBuf[0][b], sbi->vbuf + 0*32, sbi->vindex, (b & 0x01), mi->gb[0]);
 8007a4c:	697b      	ldr	r3, [r7, #20]
 8007a4e:	01db      	lsls	r3, r3, #7
 8007a50:	68fa      	ldr	r2, [r7, #12]
 8007a52:	18d0      	adds	r0, r2, r3
 8007a54:	68b9      	ldr	r1, [r7, #8]
 8007a56:	68bb      	ldr	r3, [r7, #8]
 8007a58:	f503 5308 	add.w	r3, r3, #8704	; 0x2200
 8007a5c:	681a      	ldr	r2, [r3, #0]
 8007a5e:	697b      	ldr	r3, [r7, #20]
 8007a60:	f003 0401 	and.w	r4, r3, #1
 8007a64:	68fb      	ldr	r3, [r7, #12]
 8007a66:	f503 53d8 	add.w	r3, r3, #6912	; 0x1b00
 8007a6a:	3318      	adds	r3, #24
 8007a6c:	681b      	ldr	r3, [r3, #0]
 8007a6e:	9300      	str	r3, [sp, #0]
 8007a70:	4623      	mov	r3, r4
 8007a72:	f7f9 fbeb 	bl	800124c <xmp3fixpt_FDCT32>
			FDCT32(mi->outBuf[1][b], sbi->vbuf + 1*32, sbi->vindex, (b & 0x01), mi->gb[1]);
 8007a76:	697b      	ldr	r3, [r7, #20]
 8007a78:	3312      	adds	r3, #18
 8007a7a:	01db      	lsls	r3, r3, #7
 8007a7c:	68fa      	ldr	r2, [r7, #12]
 8007a7e:	18d0      	adds	r0, r2, r3
 8007a80:	68bb      	ldr	r3, [r7, #8]
 8007a82:	f103 0180 	add.w	r1, r3, #128	; 0x80
 8007a86:	68bb      	ldr	r3, [r7, #8]
 8007a88:	f503 5308 	add.w	r3, r3, #8704	; 0x2200
 8007a8c:	681a      	ldr	r2, [r3, #0]
 8007a8e:	697b      	ldr	r3, [r7, #20]
 8007a90:	f003 0401 	and.w	r4, r3, #1
 8007a94:	68fb      	ldr	r3, [r7, #12]
 8007a96:	f503 53d8 	add.w	r3, r3, #6912	; 0x1b00
 8007a9a:	331c      	adds	r3, #28
 8007a9c:	681b      	ldr	r3, [r3, #0]
 8007a9e:	9300      	str	r3, [sp, #0]
 8007aa0:	4623      	mov	r3, r4
 8007aa2:	f7f9 fbd3 	bl	800124c <xmp3fixpt_FDCT32>
			PolyphaseStereo(pcmBuf, sbi->vbuf + sbi->vindex + VBUF_LENGTH * (b & 0x01), polyCoef);
 8007aa6:	68b9      	ldr	r1, [r7, #8]
 8007aa8:	68bb      	ldr	r3, [r7, #8]
 8007aaa:	f503 5308 	add.w	r3, r3, #8704	; 0x2200
 8007aae:	681b      	ldr	r3, [r3, #0]
 8007ab0:	0098      	lsls	r0, r3, #2
 8007ab2:	697b      	ldr	r3, [r7, #20]
 8007ab4:	f003 0201 	and.w	r2, r3, #1
 8007ab8:	4613      	mov	r3, r2
 8007aba:	011b      	lsls	r3, r3, #4
 8007abc:	4413      	add	r3, r2
 8007abe:	021b      	lsls	r3, r3, #8
 8007ac0:	4403      	add	r3, r0
 8007ac2:	440b      	add	r3, r1
 8007ac4:	4a32      	ldr	r2, [pc, #200]	; (8007b90 <xmp3fixpt_Subband+0x194>)
 8007ac6:	4619      	mov	r1, r3
 8007ac8:	6838      	ldr	r0, [r7, #0]
 8007aca:	f7fd ff60 	bl	800598e <xmp3fixpt_PolyphaseStereo>
			sbi->vindex = (sbi->vindex - (b & 0x01)) & 7;
 8007ace:	68bb      	ldr	r3, [r7, #8]
 8007ad0:	f503 5308 	add.w	r3, r3, #8704	; 0x2200
 8007ad4:	681a      	ldr	r2, [r3, #0]
 8007ad6:	697b      	ldr	r3, [r7, #20]
 8007ad8:	f003 0301 	and.w	r3, r3, #1
 8007adc:	1ad3      	subs	r3, r2, r3
 8007ade:	f003 0207 	and.w	r2, r3, #7
 8007ae2:	68bb      	ldr	r3, [r7, #8]
 8007ae4:	f503 5308 	add.w	r3, r3, #8704	; 0x2200
 8007ae8:	601a      	str	r2, [r3, #0]
			pcmBuf += (2 * NBANDS);
 8007aea:	683b      	ldr	r3, [r7, #0]
 8007aec:	3380      	adds	r3, #128	; 0x80
 8007aee:	603b      	str	r3, [r7, #0]
		for (b = 0; b < BLOCK_SIZE; b++) {
 8007af0:	697b      	ldr	r3, [r7, #20]
 8007af2:	3301      	adds	r3, #1
 8007af4:	617b      	str	r3, [r7, #20]
 8007af6:	697b      	ldr	r3, [r7, #20]
 8007af8:	2b11      	cmp	r3, #17
 8007afa:	dda7      	ble.n	8007a4c <xmp3fixpt_Subband+0x50>
 8007afc:	e042      	b.n	8007b84 <xmp3fixpt_Subband+0x188>
		}
	} else {
		/* mono */
		for (b = 0; b < BLOCK_SIZE; b++) {
 8007afe:	2300      	movs	r3, #0
 8007b00:	617b      	str	r3, [r7, #20]
 8007b02:	e03c      	b.n	8007b7e <xmp3fixpt_Subband+0x182>
			FDCT32(mi->outBuf[0][b], sbi->vbuf + 0*32, sbi->vindex, (b & 0x01), mi->gb[0]);
 8007b04:	697b      	ldr	r3, [r7, #20]
 8007b06:	01db      	lsls	r3, r3, #7
 8007b08:	68fa      	ldr	r2, [r7, #12]
 8007b0a:	18d0      	adds	r0, r2, r3
 8007b0c:	68b9      	ldr	r1, [r7, #8]
 8007b0e:	68bb      	ldr	r3, [r7, #8]
 8007b10:	f503 5308 	add.w	r3, r3, #8704	; 0x2200
 8007b14:	681a      	ldr	r2, [r3, #0]
 8007b16:	697b      	ldr	r3, [r7, #20]
 8007b18:	f003 0401 	and.w	r4, r3, #1
 8007b1c:	68fb      	ldr	r3, [r7, #12]
 8007b1e:	f503 53d8 	add.w	r3, r3, #6912	; 0x1b00
 8007b22:	3318      	adds	r3, #24
 8007b24:	681b      	ldr	r3, [r3, #0]
 8007b26:	9300      	str	r3, [sp, #0]
 8007b28:	4623      	mov	r3, r4
 8007b2a:	f7f9 fb8f 	bl	800124c <xmp3fixpt_FDCT32>
			PolyphaseMono(pcmBuf, sbi->vbuf + sbi->vindex + VBUF_LENGTH * (b & 0x01), polyCoef);
 8007b2e:	68b9      	ldr	r1, [r7, #8]
 8007b30:	68bb      	ldr	r3, [r7, #8]
 8007b32:	f503 5308 	add.w	r3, r3, #8704	; 0x2200
 8007b36:	681b      	ldr	r3, [r3, #0]
 8007b38:	0098      	lsls	r0, r3, #2
 8007b3a:	697b      	ldr	r3, [r7, #20]
 8007b3c:	f003 0201 	and.w	r2, r3, #1
 8007b40:	4613      	mov	r3, r2
 8007b42:	011b      	lsls	r3, r3, #4
 8007b44:	4413      	add	r3, r2
 8007b46:	021b      	lsls	r3, r3, #8
 8007b48:	4403      	add	r3, r0
 8007b4a:	440b      	add	r3, r1
 8007b4c:	4a10      	ldr	r2, [pc, #64]	; (8007b90 <xmp3fixpt_Subband+0x194>)
 8007b4e:	4619      	mov	r1, r3
 8007b50:	6838      	ldr	r0, [r7, #0]
 8007b52:	f7fd fb5b 	bl	800520c <xmp3fixpt_PolyphaseMono>
			sbi->vindex = (sbi->vindex - (b & 0x01)) & 7;
 8007b56:	68bb      	ldr	r3, [r7, #8]
 8007b58:	f503 5308 	add.w	r3, r3, #8704	; 0x2200
 8007b5c:	681a      	ldr	r2, [r3, #0]
 8007b5e:	697b      	ldr	r3, [r7, #20]
 8007b60:	f003 0301 	and.w	r3, r3, #1
 8007b64:	1ad3      	subs	r3, r2, r3
 8007b66:	f003 0207 	and.w	r2, r3, #7
 8007b6a:	68bb      	ldr	r3, [r7, #8]
 8007b6c:	f503 5308 	add.w	r3, r3, #8704	; 0x2200
 8007b70:	601a      	str	r2, [r3, #0]
			pcmBuf += NBANDS;
 8007b72:	683b      	ldr	r3, [r7, #0]
 8007b74:	3340      	adds	r3, #64	; 0x40
 8007b76:	603b      	str	r3, [r7, #0]
		for (b = 0; b < BLOCK_SIZE; b++) {
 8007b78:	697b      	ldr	r3, [r7, #20]
 8007b7a:	3301      	adds	r3, #1
 8007b7c:	617b      	str	r3, [r7, #20]
 8007b7e:	697b      	ldr	r3, [r7, #20]
 8007b80:	2b11      	cmp	r3, #17
 8007b82:	ddbf      	ble.n	8007b04 <xmp3fixpt_Subband+0x108>
		}
	}

	return 0;
 8007b84:	2300      	movs	r3, #0
}
 8007b86:	4618      	mov	r0, r3
 8007b88:	371c      	adds	r7, #28
 8007b8a:	46bd      	mov	sp, r7
 8007b8c:	bd90      	pop	{r4, r7, pc}
 8007b8e:	bf00      	nop
 8007b90:	0801a6a8 	.word	0x0801a6a8

08007b94 <NVIC_PriorityGroupConfig>:
  * @note   When the NVIC_PriorityGroup_0 is selected, IRQ pre-emption is no more possible. 
  *         The pending IRQ priority will be managed only by the subpriority. 
  * @retval None
  */
void NVIC_PriorityGroupConfig(uint32_t NVIC_PriorityGroup)
{
 8007b94:	b480      	push	{r7}
 8007b96:	b083      	sub	sp, #12
 8007b98:	af00      	add	r7, sp, #0
 8007b9a:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_NVIC_PRIORITY_GROUP(NVIC_PriorityGroup));
  
  /* Set the PRIGROUP[10:8] bits according to NVIC_PriorityGroup value */
  SCB->AIRCR = AIRCR_VECTKEY_MASK | NVIC_PriorityGroup;
 8007b9c:	4a06      	ldr	r2, [pc, #24]	; (8007bb8 <NVIC_PriorityGroupConfig+0x24>)
 8007b9e:	687b      	ldr	r3, [r7, #4]
 8007ba0:	f043 63bf 	orr.w	r3, r3, #100139008	; 0x5f80000
 8007ba4:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
 8007ba8:	60d3      	str	r3, [r2, #12]
}
 8007baa:	bf00      	nop
 8007bac:	370c      	adds	r7, #12
 8007bae:	46bd      	mov	sp, r7
 8007bb0:	f85d 7b04 	ldr.w	r7, [sp], #4
 8007bb4:	4770      	bx	lr
 8007bb6:	bf00      	nop
 8007bb8:	e000ed00 	.word	0xe000ed00

08007bbc <NVIC_Init>:
  * @param  NVIC_InitStruct: pointer to a NVIC_InitTypeDef structure that contains
  *         the configuration information for the specified NVIC peripheral.
  * @retval None
  */
void NVIC_Init(NVIC_InitTypeDef* NVIC_InitStruct)
{
 8007bbc:	b480      	push	{r7}
 8007bbe:	b085      	sub	sp, #20
 8007bc0:	af00      	add	r7, sp, #0
 8007bc2:	6078      	str	r0, [r7, #4]
  uint8_t tmppriority = 0x00, tmppre = 0x00, tmpsub = 0x0F;
 8007bc4:	2300      	movs	r3, #0
 8007bc6:	73fb      	strb	r3, [r7, #15]
 8007bc8:	2300      	movs	r3, #0
 8007bca:	73bb      	strb	r3, [r7, #14]
 8007bcc:	230f      	movs	r3, #15
 8007bce:	737b      	strb	r3, [r7, #13]
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NVIC_InitStruct->NVIC_IRQChannelCmd));
  assert_param(IS_NVIC_PREEMPTION_PRIORITY(NVIC_InitStruct->NVIC_IRQChannelPreemptionPriority));  
  assert_param(IS_NVIC_SUB_PRIORITY(NVIC_InitStruct->NVIC_IRQChannelSubPriority));
    
  if (NVIC_InitStruct->NVIC_IRQChannelCmd != DISABLE)
 8007bd0:	687b      	ldr	r3, [r7, #4]
 8007bd2:	78db      	ldrb	r3, [r3, #3]
 8007bd4:	2b00      	cmp	r3, #0
 8007bd6:	d039      	beq.n	8007c4c <NVIC_Init+0x90>
  {
    /* Compute the Corresponding IRQ Priority --------------------------------*/    
    tmppriority = (0x700 - ((SCB->AIRCR) & (uint32_t)0x700))>> 0x08;
 8007bd8:	4b27      	ldr	r3, [pc, #156]	; (8007c78 <NVIC_Init+0xbc>)
 8007bda:	68db      	ldr	r3, [r3, #12]
 8007bdc:	43db      	mvns	r3, r3
 8007bde:	0a1b      	lsrs	r3, r3, #8
 8007be0:	b2db      	uxtb	r3, r3
 8007be2:	f003 0307 	and.w	r3, r3, #7
 8007be6:	73fb      	strb	r3, [r7, #15]
    tmppre = (0x4 - tmppriority);
 8007be8:	7bfb      	ldrb	r3, [r7, #15]
 8007bea:	f1c3 0304 	rsb	r3, r3, #4
 8007bee:	73bb      	strb	r3, [r7, #14]
    tmpsub = tmpsub >> tmppriority;
 8007bf0:	7b7a      	ldrb	r2, [r7, #13]
 8007bf2:	7bfb      	ldrb	r3, [r7, #15]
 8007bf4:	fa42 f303 	asr.w	r3, r2, r3
 8007bf8:	737b      	strb	r3, [r7, #13]

    tmppriority = NVIC_InitStruct->NVIC_IRQChannelPreemptionPriority << tmppre;
 8007bfa:	687b      	ldr	r3, [r7, #4]
 8007bfc:	785b      	ldrb	r3, [r3, #1]
 8007bfe:	461a      	mov	r2, r3
 8007c00:	7bbb      	ldrb	r3, [r7, #14]
 8007c02:	fa02 f303 	lsl.w	r3, r2, r3
 8007c06:	73fb      	strb	r3, [r7, #15]
    tmppriority |=  (uint8_t)(NVIC_InitStruct->NVIC_IRQChannelSubPriority & tmpsub);
 8007c08:	687b      	ldr	r3, [r7, #4]
 8007c0a:	789a      	ldrb	r2, [r3, #2]
 8007c0c:	7b7b      	ldrb	r3, [r7, #13]
 8007c0e:	4013      	ands	r3, r2
 8007c10:	b2da      	uxtb	r2, r3
 8007c12:	7bfb      	ldrb	r3, [r7, #15]
 8007c14:	4313      	orrs	r3, r2
 8007c16:	73fb      	strb	r3, [r7, #15]
        
    tmppriority = tmppriority << 0x04;
 8007c18:	7bfb      	ldrb	r3, [r7, #15]
 8007c1a:	011b      	lsls	r3, r3, #4
 8007c1c:	73fb      	strb	r3, [r7, #15]
        
    NVIC->IP[NVIC_InitStruct->NVIC_IRQChannel] = tmppriority;
 8007c1e:	4a17      	ldr	r2, [pc, #92]	; (8007c7c <NVIC_Init+0xc0>)
 8007c20:	687b      	ldr	r3, [r7, #4]
 8007c22:	781b      	ldrb	r3, [r3, #0]
 8007c24:	4413      	add	r3, r2
 8007c26:	7bfa      	ldrb	r2, [r7, #15]
 8007c28:	f883 2300 	strb.w	r2, [r3, #768]	; 0x300
    
    /* Enable the Selected IRQ Channels --------------------------------------*/
    NVIC->ISER[NVIC_InitStruct->NVIC_IRQChannel >> 0x05] =
 8007c2c:	4a13      	ldr	r2, [pc, #76]	; (8007c7c <NVIC_Init+0xc0>)
 8007c2e:	687b      	ldr	r3, [r7, #4]
 8007c30:	781b      	ldrb	r3, [r3, #0]
 8007c32:	095b      	lsrs	r3, r3, #5
 8007c34:	b2db      	uxtb	r3, r3
 8007c36:	4618      	mov	r0, r3
      (uint32_t)0x01 << (NVIC_InitStruct->NVIC_IRQChannel & (uint8_t)0x1F);
 8007c38:	687b      	ldr	r3, [r7, #4]
 8007c3a:	781b      	ldrb	r3, [r3, #0]
 8007c3c:	f003 031f 	and.w	r3, r3, #31
 8007c40:	2101      	movs	r1, #1
 8007c42:	fa01 f303 	lsl.w	r3, r1, r3
    NVIC->ISER[NVIC_InitStruct->NVIC_IRQChannel >> 0x05] =
 8007c46:	f842 3020 	str.w	r3, [r2, r0, lsl #2]
  {
    /* Disable the Selected IRQ Channels -------------------------------------*/
    NVIC->ICER[NVIC_InitStruct->NVIC_IRQChannel >> 0x05] =
      (uint32_t)0x01 << (NVIC_InitStruct->NVIC_IRQChannel & (uint8_t)0x1F);
  }
}
 8007c4a:	e00f      	b.n	8007c6c <NVIC_Init+0xb0>
    NVIC->ICER[NVIC_InitStruct->NVIC_IRQChannel >> 0x05] =
 8007c4c:	490b      	ldr	r1, [pc, #44]	; (8007c7c <NVIC_Init+0xc0>)
 8007c4e:	687b      	ldr	r3, [r7, #4]
 8007c50:	781b      	ldrb	r3, [r3, #0]
 8007c52:	095b      	lsrs	r3, r3, #5
 8007c54:	b2db      	uxtb	r3, r3
 8007c56:	4618      	mov	r0, r3
      (uint32_t)0x01 << (NVIC_InitStruct->NVIC_IRQChannel & (uint8_t)0x1F);
 8007c58:	687b      	ldr	r3, [r7, #4]
 8007c5a:	781b      	ldrb	r3, [r3, #0]
 8007c5c:	f003 031f 	and.w	r3, r3, #31
 8007c60:	2201      	movs	r2, #1
 8007c62:	409a      	lsls	r2, r3
    NVIC->ICER[NVIC_InitStruct->NVIC_IRQChannel >> 0x05] =
 8007c64:	f100 0320 	add.w	r3, r0, #32
 8007c68:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
 8007c6c:	bf00      	nop
 8007c6e:	3714      	adds	r7, #20
 8007c70:	46bd      	mov	sp, r7
 8007c72:	f85d 7b04 	ldr.w	r7, [sp], #4
 8007c76:	4770      	bx	lr
 8007c78:	e000ed00 	.word	0xe000ed00
 8007c7c:	e000e100 	.word	0xe000e100

08007c80 <NVIC_SetVectorTable>:
  *     @arg NVIC_VectTab_FLASH: Vector Table in internal FLASH.
  * @param  Offset: Vector Table base offset field. This value must be a multiple of 0x200.
  * @retval None
  */
void NVIC_SetVectorTable(uint32_t NVIC_VectTab, uint32_t Offset)
{ 
 8007c80:	b480      	push	{r7}
 8007c82:	b083      	sub	sp, #12
 8007c84:	af00      	add	r7, sp, #0
 8007c86:	6078      	str	r0, [r7, #4]
 8007c88:	6039      	str	r1, [r7, #0]
  /* Check the parameters */
  assert_param(IS_NVIC_VECTTAB(NVIC_VectTab));
  assert_param(IS_NVIC_OFFSET(Offset));  
   
  SCB->VTOR = NVIC_VectTab | (Offset & (uint32_t)0x1FFFFF80);
 8007c8a:	4907      	ldr	r1, [pc, #28]	; (8007ca8 <NVIC_SetVectorTable+0x28>)
 8007c8c:	683b      	ldr	r3, [r7, #0]
 8007c8e:	f023 4360 	bic.w	r3, r3, #3758096384	; 0xe0000000
 8007c92:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
 8007c96:	687a      	ldr	r2, [r7, #4]
 8007c98:	4313      	orrs	r3, r2
 8007c9a:	608b      	str	r3, [r1, #8]
}
 8007c9c:	bf00      	nop
 8007c9e:	370c      	adds	r7, #12
 8007ca0:	46bd      	mov	sp, r7
 8007ca2:	f85d 7b04 	ldr.w	r7, [sp], #4
 8007ca6:	4770      	bx	lr
 8007ca8:	e000ed00 	.word	0xe000ed00

08007cac <NVIC_SystemLPConfig>:
  *     @arg NVIC_LP_SLEEPONEXIT: Low Power Sleep on Exit.
  * @param  NewState: new state of LP condition. This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void NVIC_SystemLPConfig(uint8_t LowPowerMode, FunctionalState NewState)
{
 8007cac:	b480      	push	{r7}
 8007cae:	b083      	sub	sp, #12
 8007cb0:	af00      	add	r7, sp, #0
 8007cb2:	4603      	mov	r3, r0
 8007cb4:	460a      	mov	r2, r1
 8007cb6:	71fb      	strb	r3, [r7, #7]
 8007cb8:	4613      	mov	r3, r2
 8007cba:	71bb      	strb	r3, [r7, #6]
  /* Check the parameters */
  assert_param(IS_NVIC_LP(LowPowerMode));
  assert_param(IS_FUNCTIONAL_STATE(NewState));  
  
  if (NewState != DISABLE)
 8007cbc:	79bb      	ldrb	r3, [r7, #6]
 8007cbe:	2b00      	cmp	r3, #0
 8007cc0:	d006      	beq.n	8007cd0 <NVIC_SystemLPConfig+0x24>
  {
    SCB->SCR |= LowPowerMode;
 8007cc2:	490a      	ldr	r1, [pc, #40]	; (8007cec <NVIC_SystemLPConfig+0x40>)
 8007cc4:	4b09      	ldr	r3, [pc, #36]	; (8007cec <NVIC_SystemLPConfig+0x40>)
 8007cc6:	691a      	ldr	r2, [r3, #16]
 8007cc8:	79fb      	ldrb	r3, [r7, #7]
 8007cca:	4313      	orrs	r3, r2
 8007ccc:	610b      	str	r3, [r1, #16]
  }
  else
  {
    SCB->SCR &= (uint32_t)(~(uint32_t)LowPowerMode);
  }
}
 8007cce:	e006      	b.n	8007cde <NVIC_SystemLPConfig+0x32>
    SCB->SCR &= (uint32_t)(~(uint32_t)LowPowerMode);
 8007cd0:	4906      	ldr	r1, [pc, #24]	; (8007cec <NVIC_SystemLPConfig+0x40>)
 8007cd2:	4b06      	ldr	r3, [pc, #24]	; (8007cec <NVIC_SystemLPConfig+0x40>)
 8007cd4:	691a      	ldr	r2, [r3, #16]
 8007cd6:	79fb      	ldrb	r3, [r7, #7]
 8007cd8:	43db      	mvns	r3, r3
 8007cda:	4013      	ands	r3, r2
 8007cdc:	610b      	str	r3, [r1, #16]
}
 8007cde:	bf00      	nop
 8007ce0:	370c      	adds	r7, #12
 8007ce2:	46bd      	mov	sp, r7
 8007ce4:	f85d 7b04 	ldr.w	r7, [sp], #4
 8007ce8:	4770      	bx	lr
 8007cea:	bf00      	nop
 8007cec:	e000ed00 	.word	0xe000ed00

08007cf0 <SysTick_CLKSourceConfig>:
  *     @arg SysTick_CLKSource_HCLK_Div8: AHB clock divided by 8 selected as SysTick clock source.
  *     @arg SysTick_CLKSource_HCLK: AHB clock selected as SysTick clock source.
  * @retval None
  */
void SysTick_CLKSourceConfig(uint32_t SysTick_CLKSource)
{
 8007cf0:	b480      	push	{r7}
 8007cf2:	b083      	sub	sp, #12
 8007cf4:	af00      	add	r7, sp, #0
 8007cf6:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_SYSTICK_CLK_SOURCE(SysTick_CLKSource));
  if (SysTick_CLKSource == SysTick_CLKSource_HCLK)
 8007cf8:	687b      	ldr	r3, [r7, #4]
 8007cfa:	2b04      	cmp	r3, #4
 8007cfc:	d106      	bne.n	8007d0c <SysTick_CLKSourceConfig+0x1c>
  {
    SysTick->CTRL |= SysTick_CLKSource_HCLK;
 8007cfe:	4a09      	ldr	r2, [pc, #36]	; (8007d24 <SysTick_CLKSourceConfig+0x34>)
 8007d00:	4b08      	ldr	r3, [pc, #32]	; (8007d24 <SysTick_CLKSourceConfig+0x34>)
 8007d02:	681b      	ldr	r3, [r3, #0]
 8007d04:	f043 0304 	orr.w	r3, r3, #4
 8007d08:	6013      	str	r3, [r2, #0]
  }
  else
  {
    SysTick->CTRL &= SysTick_CLKSource_HCLK_Div8;
  }
}
 8007d0a:	e005      	b.n	8007d18 <SysTick_CLKSourceConfig+0x28>
    SysTick->CTRL &= SysTick_CLKSource_HCLK_Div8;
 8007d0c:	4a05      	ldr	r2, [pc, #20]	; (8007d24 <SysTick_CLKSourceConfig+0x34>)
 8007d0e:	4b05      	ldr	r3, [pc, #20]	; (8007d24 <SysTick_CLKSourceConfig+0x34>)
 8007d10:	681b      	ldr	r3, [r3, #0]
 8007d12:	f023 0304 	bic.w	r3, r3, #4
 8007d16:	6013      	str	r3, [r2, #0]
}
 8007d18:	bf00      	nop
 8007d1a:	370c      	adds	r7, #12
 8007d1c:	46bd      	mov	sp, r7
 8007d1e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8007d22:	4770      	bx	lr
 8007d24:	e000e010 	.word	0xe000e010

08007d28 <ADC_DeInit>:
  *         values.
  * @param  None
  * @retval None
  */
void ADC_DeInit(void)
{
 8007d28:	b580      	push	{r7, lr}
 8007d2a:	af00      	add	r7, sp, #0
  /* Enable all ADCs reset state */
  RCC_APB2PeriphResetCmd(RCC_APB2Periph_ADC, ENABLE);
 8007d2c:	2101      	movs	r1, #1
 8007d2e:	f44f 7080 	mov.w	r0, #256	; 0x100
 8007d32:	f007 fe0f 	bl	800f954 <RCC_APB2PeriphResetCmd>
  
  /* Release all ADCs from reset state */
  RCC_APB2PeriphResetCmd(RCC_APB2Periph_ADC, DISABLE);
 8007d36:	2100      	movs	r1, #0
 8007d38:	f44f 7080 	mov.w	r0, #256	; 0x100
 8007d3c:	f007 fe0a 	bl	800f954 <RCC_APB2PeriphResetCmd>
}
 8007d40:	bf00      	nop
 8007d42:	bd80      	pop	{r7, pc}

08007d44 <ADC_Init>:
  * @param  ADC_InitStruct: pointer to an ADC_InitTypeDef structure that contains
  *         the configuration information for the specified ADC peripheral.
  * @retval None
  */
void ADC_Init(ADC_TypeDef* ADCx, ADC_InitTypeDef* ADC_InitStruct)
{
 8007d44:	b480      	push	{r7}
 8007d46:	b085      	sub	sp, #20
 8007d48:	af00      	add	r7, sp, #0
 8007d4a:	6078      	str	r0, [r7, #4]
 8007d4c:	6039      	str	r1, [r7, #0]
  uint32_t tmpreg1 = 0;
 8007d4e:	2300      	movs	r3, #0
 8007d50:	60fb      	str	r3, [r7, #12]
  uint8_t tmpreg2 = 0;
 8007d52:	2300      	movs	r3, #0
 8007d54:	72fb      	strb	r3, [r7, #11]
  assert_param(IS_ADC_DATA_ALIGN(ADC_InitStruct->ADC_DataAlign)); 
  assert_param(IS_ADC_REGULAR_LENGTH(ADC_InitStruct->ADC_NbrOfConversion));
  
  /*---------------------------- ADCx CR1 Configuration -----------------*/
  /* Get the ADCx CR1 value */
  tmpreg1 = ADCx->CR1;
 8007d56:	687b      	ldr	r3, [r7, #4]
 8007d58:	685b      	ldr	r3, [r3, #4]
 8007d5a:	60fb      	str	r3, [r7, #12]
  
  /* Clear RES and SCAN bits */
  tmpreg1 &= CR1_CLEAR_MASK;
 8007d5c:	68fb      	ldr	r3, [r7, #12]
 8007d5e:	f023 7340 	bic.w	r3, r3, #50331648	; 0x3000000
 8007d62:	f423 7380 	bic.w	r3, r3, #256	; 0x100
 8007d66:	60fb      	str	r3, [r7, #12]
  
  /* Configure ADCx: scan conversion mode and resolution */
  /* Set SCAN bit according to ADC_ScanConvMode value */
  /* Set RES bit according to ADC_Resolution value */ 
  tmpreg1 |= (uint32_t)(((uint32_t)ADC_InitStruct->ADC_ScanConvMode << 8) | \
 8007d68:	683b      	ldr	r3, [r7, #0]
 8007d6a:	791b      	ldrb	r3, [r3, #4]
 8007d6c:	021a      	lsls	r2, r3, #8
                                   ADC_InitStruct->ADC_Resolution);
 8007d6e:	683b      	ldr	r3, [r7, #0]
 8007d70:	681b      	ldr	r3, [r3, #0]
  tmpreg1 |= (uint32_t)(((uint32_t)ADC_InitStruct->ADC_ScanConvMode << 8) | \
 8007d72:	4313      	orrs	r3, r2
 8007d74:	68fa      	ldr	r2, [r7, #12]
 8007d76:	4313      	orrs	r3, r2
 8007d78:	60fb      	str	r3, [r7, #12]
  /* Write to ADCx CR1 */
  ADCx->CR1 = tmpreg1;
 8007d7a:	687b      	ldr	r3, [r7, #4]
 8007d7c:	68fa      	ldr	r2, [r7, #12]
 8007d7e:	605a      	str	r2, [r3, #4]
  /*---------------------------- ADCx CR2 Configuration -----------------*/
  /* Get the ADCx CR2 value */
  tmpreg1 = ADCx->CR2;
 8007d80:	687b      	ldr	r3, [r7, #4]
 8007d82:	689b      	ldr	r3, [r3, #8]
 8007d84:	60fb      	str	r3, [r7, #12]
  
  /* Clear CONT, ALIGN, EXTEN and EXTSEL bits */
  tmpreg1 &= CR2_CLEAR_MASK;
 8007d86:	68fa      	ldr	r2, [r7, #12]
 8007d88:	4b18      	ldr	r3, [pc, #96]	; (8007dec <ADC_Init+0xa8>)
 8007d8a:	4013      	ands	r3, r2
 8007d8c:	60fb      	str	r3, [r7, #12]
     continuous conversion mode */
  /* Set ALIGN bit according to ADC_DataAlign value */
  /* Set EXTEN bits according to ADC_ExternalTrigConvEdge value */ 
  /* Set EXTSEL bits according to ADC_ExternalTrigConv value */
  /* Set CONT bit according to ADC_ContinuousConvMode value */
  tmpreg1 |= (uint32_t)(ADC_InitStruct->ADC_DataAlign | \
 8007d8e:	683b      	ldr	r3, [r7, #0]
 8007d90:	691a      	ldr	r2, [r3, #16]
                        ADC_InitStruct->ADC_ExternalTrigConv | 
 8007d92:	683b      	ldr	r3, [r7, #0]
 8007d94:	68db      	ldr	r3, [r3, #12]
  tmpreg1 |= (uint32_t)(ADC_InitStruct->ADC_DataAlign | \
 8007d96:	431a      	orrs	r2, r3
                        ADC_InitStruct->ADC_ExternalTrigConvEdge | \
 8007d98:	683b      	ldr	r3, [r7, #0]
 8007d9a:	689b      	ldr	r3, [r3, #8]
                        ADC_InitStruct->ADC_ExternalTrigConv | 
 8007d9c:	431a      	orrs	r2, r3
                        ((uint32_t)ADC_InitStruct->ADC_ContinuousConvMode << 1));
 8007d9e:	683b      	ldr	r3, [r7, #0]
 8007da0:	795b      	ldrb	r3, [r3, #5]
 8007da2:	005b      	lsls	r3, r3, #1
  tmpreg1 |= (uint32_t)(ADC_InitStruct->ADC_DataAlign | \
 8007da4:	4313      	orrs	r3, r2
 8007da6:	68fa      	ldr	r2, [r7, #12]
 8007da8:	4313      	orrs	r3, r2
 8007daa:	60fb      	str	r3, [r7, #12]
                        
  /* Write to ADCx CR2 */
  ADCx->CR2 = tmpreg1;
 8007dac:	687b      	ldr	r3, [r7, #4]
 8007dae:	68fa      	ldr	r2, [r7, #12]
 8007db0:	609a      	str	r2, [r3, #8]
  /*---------------------------- ADCx SQR1 Configuration -----------------*/
  /* Get the ADCx SQR1 value */
  tmpreg1 = ADCx->SQR1;
 8007db2:	687b      	ldr	r3, [r7, #4]
 8007db4:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8007db6:	60fb      	str	r3, [r7, #12]
  
  /* Clear L bits */
  tmpreg1 &= SQR1_L_RESET;
 8007db8:	68fb      	ldr	r3, [r7, #12]
 8007dba:	f423 0370 	bic.w	r3, r3, #15728640	; 0xf00000
 8007dbe:	60fb      	str	r3, [r7, #12]
  
  /* Configure ADCx: regular channel sequence length */
  /* Set L bits according to ADC_NbrOfConversion value */
  tmpreg2 |= (uint8_t)(ADC_InitStruct->ADC_NbrOfConversion - (uint8_t)1);
 8007dc0:	683b      	ldr	r3, [r7, #0]
 8007dc2:	7d1b      	ldrb	r3, [r3, #20]
 8007dc4:	3b01      	subs	r3, #1
 8007dc6:	b2da      	uxtb	r2, r3
 8007dc8:	7afb      	ldrb	r3, [r7, #11]
 8007dca:	4313      	orrs	r3, r2
 8007dcc:	72fb      	strb	r3, [r7, #11]
  tmpreg1 |= ((uint32_t)tmpreg2 << 20);
 8007dce:	7afb      	ldrb	r3, [r7, #11]
 8007dd0:	051b      	lsls	r3, r3, #20
 8007dd2:	68fa      	ldr	r2, [r7, #12]
 8007dd4:	4313      	orrs	r3, r2
 8007dd6:	60fb      	str	r3, [r7, #12]
  
  /* Write to ADCx SQR1 */
  ADCx->SQR1 = tmpreg1;
 8007dd8:	687b      	ldr	r3, [r7, #4]
 8007dda:	68fa      	ldr	r2, [r7, #12]
 8007ddc:	62da      	str	r2, [r3, #44]	; 0x2c
}
 8007dde:	bf00      	nop
 8007de0:	3714      	adds	r7, #20
 8007de2:	46bd      	mov	sp, r7
 8007de4:	f85d 7b04 	ldr.w	r7, [sp], #4
 8007de8:	4770      	bx	lr
 8007dea:	bf00      	nop
 8007dec:	c0fff7fd 	.word	0xc0fff7fd

08007df0 <ADC_StructInit>:
  * @param  ADC_InitStruct: pointer to an ADC_InitTypeDef structure which will 
  *         be initialized.
  * @retval None
  */
void ADC_StructInit(ADC_InitTypeDef* ADC_InitStruct)
{
 8007df0:	b480      	push	{r7}
 8007df2:	b083      	sub	sp, #12
 8007df4:	af00      	add	r7, sp, #0
 8007df6:	6078      	str	r0, [r7, #4]
  /* Initialize the ADC_Mode member */
  ADC_InitStruct->ADC_Resolution = ADC_Resolution_12b;
 8007df8:	687b      	ldr	r3, [r7, #4]
 8007dfa:	2200      	movs	r2, #0
 8007dfc:	601a      	str	r2, [r3, #0]

  /* initialize the ADC_ScanConvMode member */
  ADC_InitStruct->ADC_ScanConvMode = DISABLE;
 8007dfe:	687b      	ldr	r3, [r7, #4]
 8007e00:	2200      	movs	r2, #0
 8007e02:	711a      	strb	r2, [r3, #4]

  /* Initialize the ADC_ContinuousConvMode member */
  ADC_InitStruct->ADC_ContinuousConvMode = DISABLE;
 8007e04:	687b      	ldr	r3, [r7, #4]
 8007e06:	2200      	movs	r2, #0
 8007e08:	715a      	strb	r2, [r3, #5]

  /* Initialize the ADC_ExternalTrigConvEdge member */
  ADC_InitStruct->ADC_ExternalTrigConvEdge = ADC_ExternalTrigConvEdge_None;
 8007e0a:	687b      	ldr	r3, [r7, #4]
 8007e0c:	2200      	movs	r2, #0
 8007e0e:	609a      	str	r2, [r3, #8]

  /* Initialize the ADC_ExternalTrigConv member */
  ADC_InitStruct->ADC_ExternalTrigConv = ADC_ExternalTrigConv_T1_CC1;
 8007e10:	687b      	ldr	r3, [r7, #4]
 8007e12:	2200      	movs	r2, #0
 8007e14:	60da      	str	r2, [r3, #12]

  /* Initialize the ADC_DataAlign member */
  ADC_InitStruct->ADC_DataAlign = ADC_DataAlign_Right;
 8007e16:	687b      	ldr	r3, [r7, #4]
 8007e18:	2200      	movs	r2, #0
 8007e1a:	611a      	str	r2, [r3, #16]

  /* Initialize the ADC_NbrOfConversion member */
  ADC_InitStruct->ADC_NbrOfConversion = 1;
 8007e1c:	687b      	ldr	r3, [r7, #4]
 8007e1e:	2201      	movs	r2, #1
 8007e20:	751a      	strb	r2, [r3, #20]
}
 8007e22:	bf00      	nop
 8007e24:	370c      	adds	r7, #12
 8007e26:	46bd      	mov	sp, r7
 8007e28:	f85d 7b04 	ldr.w	r7, [sp], #4
 8007e2c:	4770      	bx	lr

08007e2e <ADC_CommonInit>:
  * @param  ADC_CommonInitStruct: pointer to an ADC_CommonInitTypeDef structure 
  *         that contains the configuration information for  All ADCs peripherals.
  * @retval None
  */
void ADC_CommonInit(ADC_CommonInitTypeDef* ADC_CommonInitStruct)
{
 8007e2e:	b480      	push	{r7}
 8007e30:	b085      	sub	sp, #20
 8007e32:	af00      	add	r7, sp, #0
 8007e34:	6078      	str	r0, [r7, #4]
  uint32_t tmpreg1 = 0;
 8007e36:	2300      	movs	r3, #0
 8007e38:	60fb      	str	r3, [r7, #12]
  assert_param(IS_ADC_PRESCALER(ADC_CommonInitStruct->ADC_Prescaler));
  assert_param(IS_ADC_DMA_ACCESS_MODE(ADC_CommonInitStruct->ADC_DMAAccessMode));
  assert_param(IS_ADC_SAMPLING_DELAY(ADC_CommonInitStruct->ADC_TwoSamplingDelay));
  /*---------------------------- ADC CCR Configuration -----------------*/
  /* Get the ADC CCR value */
  tmpreg1 = ADC->CCR;
 8007e3a:	4b0f      	ldr	r3, [pc, #60]	; (8007e78 <ADC_CommonInit+0x4a>)
 8007e3c:	685b      	ldr	r3, [r3, #4]
 8007e3e:	60fb      	str	r3, [r7, #12]
  
  /* Clear MULTI, DELAY, DMA and ADCPRE bits */
  tmpreg1 &= CR_CLEAR_MASK;
 8007e40:	68fa      	ldr	r2, [r7, #12]
 8007e42:	4b0e      	ldr	r3, [pc, #56]	; (8007e7c <ADC_CommonInit+0x4e>)
 8007e44:	4013      	ands	r3, r2
 8007e46:	60fb      	str	r3, [r7, #12]
     and DMA access mode for multimode */
  /* Set MULTI bits according to ADC_Mode value */
  /* Set ADCPRE bits according to ADC_Prescaler value */
  /* Set DMA bits according to ADC_DMAAccessMode value */
  /* Set DELAY bits according to ADC_TwoSamplingDelay value */    
  tmpreg1 |= (uint32_t)(ADC_CommonInitStruct->ADC_Mode | 
 8007e48:	687b      	ldr	r3, [r7, #4]
 8007e4a:	681a      	ldr	r2, [r3, #0]
                        ADC_CommonInitStruct->ADC_Prescaler | 
 8007e4c:	687b      	ldr	r3, [r7, #4]
 8007e4e:	685b      	ldr	r3, [r3, #4]
  tmpreg1 |= (uint32_t)(ADC_CommonInitStruct->ADC_Mode | 
 8007e50:	431a      	orrs	r2, r3
                        ADC_CommonInitStruct->ADC_DMAAccessMode | 
 8007e52:	687b      	ldr	r3, [r7, #4]
 8007e54:	689b      	ldr	r3, [r3, #8]
                        ADC_CommonInitStruct->ADC_Prescaler | 
 8007e56:	431a      	orrs	r2, r3
                        ADC_CommonInitStruct->ADC_TwoSamplingDelay);
 8007e58:	687b      	ldr	r3, [r7, #4]
 8007e5a:	68db      	ldr	r3, [r3, #12]
                        ADC_CommonInitStruct->ADC_DMAAccessMode | 
 8007e5c:	4313      	orrs	r3, r2
  tmpreg1 |= (uint32_t)(ADC_CommonInitStruct->ADC_Mode | 
 8007e5e:	68fa      	ldr	r2, [r7, #12]
 8007e60:	4313      	orrs	r3, r2
 8007e62:	60fb      	str	r3, [r7, #12]
                        
  /* Write to ADC CCR */
  ADC->CCR = tmpreg1;
 8007e64:	4a04      	ldr	r2, [pc, #16]	; (8007e78 <ADC_CommonInit+0x4a>)
 8007e66:	68fb      	ldr	r3, [r7, #12]
 8007e68:	6053      	str	r3, [r2, #4]
}
 8007e6a:	bf00      	nop
 8007e6c:	3714      	adds	r7, #20
 8007e6e:	46bd      	mov	sp, r7
 8007e70:	f85d 7b04 	ldr.w	r7, [sp], #4
 8007e74:	4770      	bx	lr
 8007e76:	bf00      	nop
 8007e78:	40012300 	.word	0x40012300
 8007e7c:	fffc30e0 	.word	0xfffc30e0

08007e80 <ADC_CommonStructInit>:
  * @param  ADC_CommonInitStruct: pointer to an ADC_CommonInitTypeDef structure
  *         which will be initialized.
  * @retval None
  */
void ADC_CommonStructInit(ADC_CommonInitTypeDef* ADC_CommonInitStruct)
{
 8007e80:	b480      	push	{r7}
 8007e82:	b083      	sub	sp, #12
 8007e84:	af00      	add	r7, sp, #0
 8007e86:	6078      	str	r0, [r7, #4]
  /* Initialize the ADC_Mode member */
  ADC_CommonInitStruct->ADC_Mode = ADC_Mode_Independent;
 8007e88:	687b      	ldr	r3, [r7, #4]
 8007e8a:	2200      	movs	r2, #0
 8007e8c:	601a      	str	r2, [r3, #0]

  /* initialize the ADC_Prescaler member */
  ADC_CommonInitStruct->ADC_Prescaler = ADC_Prescaler_Div2;
 8007e8e:	687b      	ldr	r3, [r7, #4]
 8007e90:	2200      	movs	r2, #0
 8007e92:	605a      	str	r2, [r3, #4]

  /* Initialize the ADC_DMAAccessMode member */
  ADC_CommonInitStruct->ADC_DMAAccessMode = ADC_DMAAccessMode_Disabled;
 8007e94:	687b      	ldr	r3, [r7, #4]
 8007e96:	2200      	movs	r2, #0
 8007e98:	609a      	str	r2, [r3, #8]

  /* Initialize the ADC_TwoSamplingDelay member */
  ADC_CommonInitStruct->ADC_TwoSamplingDelay = ADC_TwoSamplingDelay_5Cycles;
 8007e9a:	687b      	ldr	r3, [r7, #4]
 8007e9c:	2200      	movs	r2, #0
 8007e9e:	60da      	str	r2, [r3, #12]
}
 8007ea0:	bf00      	nop
 8007ea2:	370c      	adds	r7, #12
 8007ea4:	46bd      	mov	sp, r7
 8007ea6:	f85d 7b04 	ldr.w	r7, [sp], #4
 8007eaa:	4770      	bx	lr

08007eac <ADC_Cmd>:
  * @param  NewState: new state of the ADCx peripheral. 
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void ADC_Cmd(ADC_TypeDef* ADCx, FunctionalState NewState)
{
 8007eac:	b480      	push	{r7}
 8007eae:	b083      	sub	sp, #12
 8007eb0:	af00      	add	r7, sp, #0
 8007eb2:	6078      	str	r0, [r7, #4]
 8007eb4:	460b      	mov	r3, r1
 8007eb6:	70fb      	strb	r3, [r7, #3]
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 8007eb8:	78fb      	ldrb	r3, [r7, #3]
 8007eba:	2b00      	cmp	r3, #0
 8007ebc:	d006      	beq.n	8007ecc <ADC_Cmd+0x20>
  {
    /* Set the ADON bit to wake up the ADC from power down mode */
    ADCx->CR2 |= (uint32_t)ADC_CR2_ADON;
 8007ebe:	687b      	ldr	r3, [r7, #4]
 8007ec0:	689b      	ldr	r3, [r3, #8]
 8007ec2:	f043 0201 	orr.w	r2, r3, #1
 8007ec6:	687b      	ldr	r3, [r7, #4]
 8007ec8:	609a      	str	r2, [r3, #8]
  else
  {
    /* Disable the selected ADC peripheral */
    ADCx->CR2 &= (uint32_t)(~ADC_CR2_ADON);
  }
}
 8007eca:	e005      	b.n	8007ed8 <ADC_Cmd+0x2c>
    ADCx->CR2 &= (uint32_t)(~ADC_CR2_ADON);
 8007ecc:	687b      	ldr	r3, [r7, #4]
 8007ece:	689b      	ldr	r3, [r3, #8]
 8007ed0:	f023 0201 	bic.w	r2, r3, #1
 8007ed4:	687b      	ldr	r3, [r7, #4]
 8007ed6:	609a      	str	r2, [r3, #8]
}
 8007ed8:	bf00      	nop
 8007eda:	370c      	adds	r7, #12
 8007edc:	46bd      	mov	sp, r7
 8007ede:	f85d 7b04 	ldr.w	r7, [sp], #4
 8007ee2:	4770      	bx	lr

08007ee4 <ADC_AnalogWatchdogCmd>:
  *            @arg ADC_AnalogWatchdog_AllRegAllInjecEnable: Analog watchdog on all regular and injected channels
  *            @arg ADC_AnalogWatchdog_None: No channel guarded by the analog watchdog
  * @retval None	  
  */
void ADC_AnalogWatchdogCmd(ADC_TypeDef* ADCx, uint32_t ADC_AnalogWatchdog)
{
 8007ee4:	b480      	push	{r7}
 8007ee6:	b085      	sub	sp, #20
 8007ee8:	af00      	add	r7, sp, #0
 8007eea:	6078      	str	r0, [r7, #4]
 8007eec:	6039      	str	r1, [r7, #0]
  uint32_t tmpreg = 0;
 8007eee:	2300      	movs	r3, #0
 8007ef0:	60fb      	str	r3, [r7, #12]
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_ADC_ANALOG_WATCHDOG(ADC_AnalogWatchdog));
  
  /* Get the old register value */
  tmpreg = ADCx->CR1;
 8007ef2:	687b      	ldr	r3, [r7, #4]
 8007ef4:	685b      	ldr	r3, [r3, #4]
 8007ef6:	60fb      	str	r3, [r7, #12]
  
  /* Clear AWDEN, JAWDEN and AWDSGL bits */
  tmpreg &= CR1_AWDMode_RESET;
 8007ef8:	68fb      	ldr	r3, [r7, #12]
 8007efa:	f423 0340 	bic.w	r3, r3, #12582912	; 0xc00000
 8007efe:	f423 7300 	bic.w	r3, r3, #512	; 0x200
 8007f02:	60fb      	str	r3, [r7, #12]
  
  /* Set the analog watchdog enable mode */
  tmpreg |= ADC_AnalogWatchdog;
 8007f04:	68fa      	ldr	r2, [r7, #12]
 8007f06:	683b      	ldr	r3, [r7, #0]
 8007f08:	4313      	orrs	r3, r2
 8007f0a:	60fb      	str	r3, [r7, #12]
  
  /* Store the new register value */
  ADCx->CR1 = tmpreg;
 8007f0c:	687b      	ldr	r3, [r7, #4]
 8007f0e:	68fa      	ldr	r2, [r7, #12]
 8007f10:	605a      	str	r2, [r3, #4]
}
 8007f12:	bf00      	nop
 8007f14:	3714      	adds	r7, #20
 8007f16:	46bd      	mov	sp, r7
 8007f18:	f85d 7b04 	ldr.w	r7, [sp], #4
 8007f1c:	4770      	bx	lr

08007f1e <ADC_AnalogWatchdogThresholdsConfig>:
  *          This parameter must be a 12-bit value.
  * @retval None
  */
void ADC_AnalogWatchdogThresholdsConfig(ADC_TypeDef* ADCx, uint16_t HighThreshold,
                                        uint16_t LowThreshold)
{
 8007f1e:	b480      	push	{r7}
 8007f20:	b083      	sub	sp, #12
 8007f22:	af00      	add	r7, sp, #0
 8007f24:	6078      	str	r0, [r7, #4]
 8007f26:	460b      	mov	r3, r1
 8007f28:	807b      	strh	r3, [r7, #2]
 8007f2a:	4613      	mov	r3, r2
 8007f2c:	803b      	strh	r3, [r7, #0]
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_ADC_THRESHOLD(HighThreshold));
  assert_param(IS_ADC_THRESHOLD(LowThreshold));
  
  /* Set the ADCx high threshold */
  ADCx->HTR = HighThreshold;
 8007f2e:	887a      	ldrh	r2, [r7, #2]
 8007f30:	687b      	ldr	r3, [r7, #4]
 8007f32:	625a      	str	r2, [r3, #36]	; 0x24
  
  /* Set the ADCx low threshold */
  ADCx->LTR = LowThreshold;
 8007f34:	883a      	ldrh	r2, [r7, #0]
 8007f36:	687b      	ldr	r3, [r7, #4]
 8007f38:	629a      	str	r2, [r3, #40]	; 0x28
}
 8007f3a:	bf00      	nop
 8007f3c:	370c      	adds	r7, #12
 8007f3e:	46bd      	mov	sp, r7
 8007f40:	f85d 7b04 	ldr.w	r7, [sp], #4
 8007f44:	4770      	bx	lr

08007f46 <ADC_AnalogWatchdogSingleChannelConfig>:
  *            @arg ADC_Channel_17: ADC Channel17 selected
  *            @arg ADC_Channel_18: ADC Channel18 selected
  * @retval None
  */
void ADC_AnalogWatchdogSingleChannelConfig(ADC_TypeDef* ADCx, uint8_t ADC_Channel)
{
 8007f46:	b480      	push	{r7}
 8007f48:	b085      	sub	sp, #20
 8007f4a:	af00      	add	r7, sp, #0
 8007f4c:	6078      	str	r0, [r7, #4]
 8007f4e:	460b      	mov	r3, r1
 8007f50:	70fb      	strb	r3, [r7, #3]
  uint32_t tmpreg = 0;
 8007f52:	2300      	movs	r3, #0
 8007f54:	60fb      	str	r3, [r7, #12]
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_ADC_CHANNEL(ADC_Channel));
  
  /* Get the old register value */
  tmpreg = ADCx->CR1;
 8007f56:	687b      	ldr	r3, [r7, #4]
 8007f58:	685b      	ldr	r3, [r3, #4]
 8007f5a:	60fb      	str	r3, [r7, #12]
  
  /* Clear the Analog watchdog channel select bits */
  tmpreg &= CR1_AWDCH_RESET;
 8007f5c:	68fb      	ldr	r3, [r7, #12]
 8007f5e:	f023 031f 	bic.w	r3, r3, #31
 8007f62:	60fb      	str	r3, [r7, #12]
  
  /* Set the Analog watchdog channel */
  tmpreg |= ADC_Channel;
 8007f64:	78fb      	ldrb	r3, [r7, #3]
 8007f66:	68fa      	ldr	r2, [r7, #12]
 8007f68:	4313      	orrs	r3, r2
 8007f6a:	60fb      	str	r3, [r7, #12]
  
  /* Store the new register value */
  ADCx->CR1 = tmpreg;
 8007f6c:	687b      	ldr	r3, [r7, #4]
 8007f6e:	68fa      	ldr	r2, [r7, #12]
 8007f70:	605a      	str	r2, [r3, #4]
}
 8007f72:	bf00      	nop
 8007f74:	3714      	adds	r7, #20
 8007f76:	46bd      	mov	sp, r7
 8007f78:	f85d 7b04 	ldr.w	r7, [sp], #4
 8007f7c:	4770      	bx	lr

08007f7e <ADC_TempSensorVrefintCmd>:
  * @param  NewState: new state of the temperature sensor and Vrefint channels.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void ADC_TempSensorVrefintCmd(FunctionalState NewState)                
{
 8007f7e:	b480      	push	{r7}
 8007f80:	b083      	sub	sp, #12
 8007f82:	af00      	add	r7, sp, #0
 8007f84:	4603      	mov	r3, r0
 8007f86:	71fb      	strb	r3, [r7, #7]
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 8007f88:	79fb      	ldrb	r3, [r7, #7]
 8007f8a:	2b00      	cmp	r3, #0
 8007f8c:	d006      	beq.n	8007f9c <ADC_TempSensorVrefintCmd+0x1e>
  {
    /* Enable the temperature sensor and Vrefint channel*/
    ADC->CCR |= (uint32_t)ADC_CCR_TSVREFE;
 8007f8e:	4a09      	ldr	r2, [pc, #36]	; (8007fb4 <ADC_TempSensorVrefintCmd+0x36>)
 8007f90:	4b08      	ldr	r3, [pc, #32]	; (8007fb4 <ADC_TempSensorVrefintCmd+0x36>)
 8007f92:	685b      	ldr	r3, [r3, #4]
 8007f94:	f443 0300 	orr.w	r3, r3, #8388608	; 0x800000
 8007f98:	6053      	str	r3, [r2, #4]
  else
  {
    /* Disable the temperature sensor and Vrefint channel*/
    ADC->CCR &= (uint32_t)(~ADC_CCR_TSVREFE);
  }
}
 8007f9a:	e005      	b.n	8007fa8 <ADC_TempSensorVrefintCmd+0x2a>
    ADC->CCR &= (uint32_t)(~ADC_CCR_TSVREFE);
 8007f9c:	4a05      	ldr	r2, [pc, #20]	; (8007fb4 <ADC_TempSensorVrefintCmd+0x36>)
 8007f9e:	4b05      	ldr	r3, [pc, #20]	; (8007fb4 <ADC_TempSensorVrefintCmd+0x36>)
 8007fa0:	685b      	ldr	r3, [r3, #4]
 8007fa2:	f423 0300 	bic.w	r3, r3, #8388608	; 0x800000
 8007fa6:	6053      	str	r3, [r2, #4]
}
 8007fa8:	bf00      	nop
 8007faa:	370c      	adds	r7, #12
 8007fac:	46bd      	mov	sp, r7
 8007fae:	f85d 7b04 	ldr.w	r7, [sp], #4
 8007fb2:	4770      	bx	lr
 8007fb4:	40012300 	.word	0x40012300

08007fb8 <ADC_VBATCmd>:
  * @param  NewState: new state of the VBAT channel.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void ADC_VBATCmd(FunctionalState NewState)                             
{
 8007fb8:	b480      	push	{r7}
 8007fba:	b083      	sub	sp, #12
 8007fbc:	af00      	add	r7, sp, #0
 8007fbe:	4603      	mov	r3, r0
 8007fc0:	71fb      	strb	r3, [r7, #7]
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 8007fc2:	79fb      	ldrb	r3, [r7, #7]
 8007fc4:	2b00      	cmp	r3, #0
 8007fc6:	d006      	beq.n	8007fd6 <ADC_VBATCmd+0x1e>
  {
    /* Enable the VBAT channel*/
    ADC->CCR |= (uint32_t)ADC_CCR_VBATE;
 8007fc8:	4a09      	ldr	r2, [pc, #36]	; (8007ff0 <ADC_VBATCmd+0x38>)
 8007fca:	4b09      	ldr	r3, [pc, #36]	; (8007ff0 <ADC_VBATCmd+0x38>)
 8007fcc:	685b      	ldr	r3, [r3, #4]
 8007fce:	f443 0380 	orr.w	r3, r3, #4194304	; 0x400000
 8007fd2:	6053      	str	r3, [r2, #4]
  else
  {
    /* Disable the VBAT channel*/
    ADC->CCR &= (uint32_t)(~ADC_CCR_VBATE);
  }
}
 8007fd4:	e005      	b.n	8007fe2 <ADC_VBATCmd+0x2a>
    ADC->CCR &= (uint32_t)(~ADC_CCR_VBATE);
 8007fd6:	4a06      	ldr	r2, [pc, #24]	; (8007ff0 <ADC_VBATCmd+0x38>)
 8007fd8:	4b05      	ldr	r3, [pc, #20]	; (8007ff0 <ADC_VBATCmd+0x38>)
 8007fda:	685b      	ldr	r3, [r3, #4]
 8007fdc:	f423 0380 	bic.w	r3, r3, #4194304	; 0x400000
 8007fe0:	6053      	str	r3, [r2, #4]
}
 8007fe2:	bf00      	nop
 8007fe4:	370c      	adds	r7, #12
 8007fe6:	46bd      	mov	sp, r7
 8007fe8:	f85d 7b04 	ldr.w	r7, [sp], #4
 8007fec:	4770      	bx	lr
 8007fee:	bf00      	nop
 8007ff0:	40012300 	.word	0x40012300

08007ff4 <ADC_RegularChannelConfig>:
  *            @arg ADC_SampleTime_144Cycles: Sample time equal to 144 cycles	
  *            @arg ADC_SampleTime_480Cycles: Sample time equal to 480 cycles	
  * @retval None
  */
void ADC_RegularChannelConfig(ADC_TypeDef* ADCx, uint8_t ADC_Channel, uint8_t Rank, uint8_t ADC_SampleTime)
{
 8007ff4:	b480      	push	{r7}
 8007ff6:	b085      	sub	sp, #20
 8007ff8:	af00      	add	r7, sp, #0
 8007ffa:	6078      	str	r0, [r7, #4]
 8007ffc:	4608      	mov	r0, r1
 8007ffe:	4611      	mov	r1, r2
 8008000:	461a      	mov	r2, r3
 8008002:	4603      	mov	r3, r0
 8008004:	70fb      	strb	r3, [r7, #3]
 8008006:	460b      	mov	r3, r1
 8008008:	70bb      	strb	r3, [r7, #2]
 800800a:	4613      	mov	r3, r2
 800800c:	707b      	strb	r3, [r7, #1]
  uint32_t tmpreg1 = 0, tmpreg2 = 0;
 800800e:	2300      	movs	r3, #0
 8008010:	60fb      	str	r3, [r7, #12]
 8008012:	2300      	movs	r3, #0
 8008014:	60bb      	str	r3, [r7, #8]
  assert_param(IS_ADC_CHANNEL(ADC_Channel));
  assert_param(IS_ADC_REGULAR_RANK(Rank));
  assert_param(IS_ADC_SAMPLE_TIME(ADC_SampleTime));
  
  /* if ADC_Channel_10 ... ADC_Channel_18 is selected */
  if (ADC_Channel > ADC_Channel_9)
 8008016:	78fb      	ldrb	r3, [r7, #3]
 8008018:	2b09      	cmp	r3, #9
 800801a:	d923      	bls.n	8008064 <ADC_RegularChannelConfig+0x70>
  {
    /* Get the old register value */
    tmpreg1 = ADCx->SMPR1;
 800801c:	687b      	ldr	r3, [r7, #4]
 800801e:	68db      	ldr	r3, [r3, #12]
 8008020:	60fb      	str	r3, [r7, #12]
    
    /* Calculate the mask to clear */
    tmpreg2 = SMPR1_SMP_SET << (3 * (ADC_Channel - 10));
 8008022:	78fb      	ldrb	r3, [r7, #3]
 8008024:	f1a3 020a 	sub.w	r2, r3, #10
 8008028:	4613      	mov	r3, r2
 800802a:	005b      	lsls	r3, r3, #1
 800802c:	4413      	add	r3, r2
 800802e:	2207      	movs	r2, #7
 8008030:	fa02 f303 	lsl.w	r3, r2, r3
 8008034:	60bb      	str	r3, [r7, #8]
    
    /* Clear the old sample time */
    tmpreg1 &= ~tmpreg2;
 8008036:	68bb      	ldr	r3, [r7, #8]
 8008038:	43db      	mvns	r3, r3
 800803a:	68fa      	ldr	r2, [r7, #12]
 800803c:	4013      	ands	r3, r2
 800803e:	60fb      	str	r3, [r7, #12]
    
    /* Calculate the mask to set */
    tmpreg2 = (uint32_t)ADC_SampleTime << (3 * (ADC_Channel - 10));
 8008040:	7879      	ldrb	r1, [r7, #1]
 8008042:	78fb      	ldrb	r3, [r7, #3]
 8008044:	f1a3 020a 	sub.w	r2, r3, #10
 8008048:	4613      	mov	r3, r2
 800804a:	005b      	lsls	r3, r3, #1
 800804c:	4413      	add	r3, r2
 800804e:	fa01 f303 	lsl.w	r3, r1, r3
 8008052:	60bb      	str	r3, [r7, #8]
    
    /* Set the new sample time */
    tmpreg1 |= tmpreg2;
 8008054:	68fa      	ldr	r2, [r7, #12]
 8008056:	68bb      	ldr	r3, [r7, #8]
 8008058:	4313      	orrs	r3, r2
 800805a:	60fb      	str	r3, [r7, #12]
    
    /* Store the new register value */
    ADCx->SMPR1 = tmpreg1;
 800805c:	687b      	ldr	r3, [r7, #4]
 800805e:	68fa      	ldr	r2, [r7, #12]
 8008060:	60da      	str	r2, [r3, #12]
 8008062:	e01e      	b.n	80080a2 <ADC_RegularChannelConfig+0xae>
  }
  else /* ADC_Channel include in ADC_Channel_[0..9] */
  {
    /* Get the old register value */
    tmpreg1 = ADCx->SMPR2;
 8008064:	687b      	ldr	r3, [r7, #4]
 8008066:	691b      	ldr	r3, [r3, #16]
 8008068:	60fb      	str	r3, [r7, #12]
    
    /* Calculate the mask to clear */
    tmpreg2 = SMPR2_SMP_SET << (3 * ADC_Channel);
 800806a:	78fa      	ldrb	r2, [r7, #3]
 800806c:	4613      	mov	r3, r2
 800806e:	005b      	lsls	r3, r3, #1
 8008070:	4413      	add	r3, r2
 8008072:	2207      	movs	r2, #7
 8008074:	fa02 f303 	lsl.w	r3, r2, r3
 8008078:	60bb      	str	r3, [r7, #8]
    
    /* Clear the old sample time */
    tmpreg1 &= ~tmpreg2;
 800807a:	68bb      	ldr	r3, [r7, #8]
 800807c:	43db      	mvns	r3, r3
 800807e:	68fa      	ldr	r2, [r7, #12]
 8008080:	4013      	ands	r3, r2
 8008082:	60fb      	str	r3, [r7, #12]
    
    /* Calculate the mask to set */
    tmpreg2 = (uint32_t)ADC_SampleTime << (3 * ADC_Channel);
 8008084:	7879      	ldrb	r1, [r7, #1]
 8008086:	78fa      	ldrb	r2, [r7, #3]
 8008088:	4613      	mov	r3, r2
 800808a:	005b      	lsls	r3, r3, #1
 800808c:	4413      	add	r3, r2
 800808e:	fa01 f303 	lsl.w	r3, r1, r3
 8008092:	60bb      	str	r3, [r7, #8]
    
    /* Set the new sample time */
    tmpreg1 |= tmpreg2;
 8008094:	68fa      	ldr	r2, [r7, #12]
 8008096:	68bb      	ldr	r3, [r7, #8]
 8008098:	4313      	orrs	r3, r2
 800809a:	60fb      	str	r3, [r7, #12]
    
    /* Store the new register value */
    ADCx->SMPR2 = tmpreg1;
 800809c:	687b      	ldr	r3, [r7, #4]
 800809e:	68fa      	ldr	r2, [r7, #12]
 80080a0:	611a      	str	r2, [r3, #16]
  }
  /* For Rank 1 to 6 */
  if (Rank < 7)
 80080a2:	78bb      	ldrb	r3, [r7, #2]
 80080a4:	2b06      	cmp	r3, #6
 80080a6:	d821      	bhi.n	80080ec <ADC_RegularChannelConfig+0xf8>
  {
    /* Get the old register value */
    tmpreg1 = ADCx->SQR3;
 80080a8:	687b      	ldr	r3, [r7, #4]
 80080aa:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 80080ac:	60fb      	str	r3, [r7, #12]
    
    /* Calculate the mask to clear */
    tmpreg2 = SQR3_SQ_SET << (5 * (Rank - 1));
 80080ae:	78bb      	ldrb	r3, [r7, #2]
 80080b0:	1e5a      	subs	r2, r3, #1
 80080b2:	4613      	mov	r3, r2
 80080b4:	009b      	lsls	r3, r3, #2
 80080b6:	4413      	add	r3, r2
 80080b8:	221f      	movs	r2, #31
 80080ba:	fa02 f303 	lsl.w	r3, r2, r3
 80080be:	60bb      	str	r3, [r7, #8]
    
    /* Clear the old SQx bits for the selected rank */
    tmpreg1 &= ~tmpreg2;
 80080c0:	68bb      	ldr	r3, [r7, #8]
 80080c2:	43db      	mvns	r3, r3
 80080c4:	68fa      	ldr	r2, [r7, #12]
 80080c6:	4013      	ands	r3, r2
 80080c8:	60fb      	str	r3, [r7, #12]
    
    /* Calculate the mask to set */
    tmpreg2 = (uint32_t)ADC_Channel << (5 * (Rank - 1));
 80080ca:	78f9      	ldrb	r1, [r7, #3]
 80080cc:	78bb      	ldrb	r3, [r7, #2]
 80080ce:	1e5a      	subs	r2, r3, #1
 80080d0:	4613      	mov	r3, r2
 80080d2:	009b      	lsls	r3, r3, #2
 80080d4:	4413      	add	r3, r2
 80080d6:	fa01 f303 	lsl.w	r3, r1, r3
 80080da:	60bb      	str	r3, [r7, #8]
    
    /* Set the SQx bits for the selected rank */
    tmpreg1 |= tmpreg2;
 80080dc:	68fa      	ldr	r2, [r7, #12]
 80080de:	68bb      	ldr	r3, [r7, #8]
 80080e0:	4313      	orrs	r3, r2
 80080e2:	60fb      	str	r3, [r7, #12]
    
    /* Store the new register value */
    ADCx->SQR3 = tmpreg1;
 80080e4:	687b      	ldr	r3, [r7, #4]
 80080e6:	68fa      	ldr	r2, [r7, #12]
 80080e8:	635a      	str	r2, [r3, #52]	; 0x34
    tmpreg1 |= tmpreg2;
    
    /* Store the new register value */
    ADCx->SQR1 = tmpreg1;
  }
}
 80080ea:	e047      	b.n	800817c <ADC_RegularChannelConfig+0x188>
  else if (Rank < 13)
 80080ec:	78bb      	ldrb	r3, [r7, #2]
 80080ee:	2b0c      	cmp	r3, #12
 80080f0:	d821      	bhi.n	8008136 <ADC_RegularChannelConfig+0x142>
    tmpreg1 = ADCx->SQR2;
 80080f2:	687b      	ldr	r3, [r7, #4]
 80080f4:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80080f6:	60fb      	str	r3, [r7, #12]
    tmpreg2 = SQR2_SQ_SET << (5 * (Rank - 7));
 80080f8:	78bb      	ldrb	r3, [r7, #2]
 80080fa:	1fda      	subs	r2, r3, #7
 80080fc:	4613      	mov	r3, r2
 80080fe:	009b      	lsls	r3, r3, #2
 8008100:	4413      	add	r3, r2
 8008102:	221f      	movs	r2, #31
 8008104:	fa02 f303 	lsl.w	r3, r2, r3
 8008108:	60bb      	str	r3, [r7, #8]
    tmpreg1 &= ~tmpreg2;
 800810a:	68bb      	ldr	r3, [r7, #8]
 800810c:	43db      	mvns	r3, r3
 800810e:	68fa      	ldr	r2, [r7, #12]
 8008110:	4013      	ands	r3, r2
 8008112:	60fb      	str	r3, [r7, #12]
    tmpreg2 = (uint32_t)ADC_Channel << (5 * (Rank - 7));
 8008114:	78f9      	ldrb	r1, [r7, #3]
 8008116:	78bb      	ldrb	r3, [r7, #2]
 8008118:	1fda      	subs	r2, r3, #7
 800811a:	4613      	mov	r3, r2
 800811c:	009b      	lsls	r3, r3, #2
 800811e:	4413      	add	r3, r2
 8008120:	fa01 f303 	lsl.w	r3, r1, r3
 8008124:	60bb      	str	r3, [r7, #8]
    tmpreg1 |= tmpreg2;
 8008126:	68fa      	ldr	r2, [r7, #12]
 8008128:	68bb      	ldr	r3, [r7, #8]
 800812a:	4313      	orrs	r3, r2
 800812c:	60fb      	str	r3, [r7, #12]
    ADCx->SQR2 = tmpreg1;
 800812e:	687b      	ldr	r3, [r7, #4]
 8008130:	68fa      	ldr	r2, [r7, #12]
 8008132:	631a      	str	r2, [r3, #48]	; 0x30
}
 8008134:	e022      	b.n	800817c <ADC_RegularChannelConfig+0x188>
    tmpreg1 = ADCx->SQR1;
 8008136:	687b      	ldr	r3, [r7, #4]
 8008138:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800813a:	60fb      	str	r3, [r7, #12]
    tmpreg2 = SQR1_SQ_SET << (5 * (Rank - 13));
 800813c:	78bb      	ldrb	r3, [r7, #2]
 800813e:	f1a3 020d 	sub.w	r2, r3, #13
 8008142:	4613      	mov	r3, r2
 8008144:	009b      	lsls	r3, r3, #2
 8008146:	4413      	add	r3, r2
 8008148:	221f      	movs	r2, #31
 800814a:	fa02 f303 	lsl.w	r3, r2, r3
 800814e:	60bb      	str	r3, [r7, #8]
    tmpreg1 &= ~tmpreg2;
 8008150:	68bb      	ldr	r3, [r7, #8]
 8008152:	43db      	mvns	r3, r3
 8008154:	68fa      	ldr	r2, [r7, #12]
 8008156:	4013      	ands	r3, r2
 8008158:	60fb      	str	r3, [r7, #12]
    tmpreg2 = (uint32_t)ADC_Channel << (5 * (Rank - 13));
 800815a:	78f9      	ldrb	r1, [r7, #3]
 800815c:	78bb      	ldrb	r3, [r7, #2]
 800815e:	f1a3 020d 	sub.w	r2, r3, #13
 8008162:	4613      	mov	r3, r2
 8008164:	009b      	lsls	r3, r3, #2
 8008166:	4413      	add	r3, r2
 8008168:	fa01 f303 	lsl.w	r3, r1, r3
 800816c:	60bb      	str	r3, [r7, #8]
    tmpreg1 |= tmpreg2;
 800816e:	68fa      	ldr	r2, [r7, #12]
 8008170:	68bb      	ldr	r3, [r7, #8]
 8008172:	4313      	orrs	r3, r2
 8008174:	60fb      	str	r3, [r7, #12]
    ADCx->SQR1 = tmpreg1;
 8008176:	687b      	ldr	r3, [r7, #4]
 8008178:	68fa      	ldr	r2, [r7, #12]
 800817a:	62da      	str	r2, [r3, #44]	; 0x2c
}
 800817c:	bf00      	nop
 800817e:	3714      	adds	r7, #20
 8008180:	46bd      	mov	sp, r7
 8008182:	f85d 7b04 	ldr.w	r7, [sp], #4
 8008186:	4770      	bx	lr

08008188 <ADC_SoftwareStartConv>:
  * @brief  Enables the selected ADC software start conversion of the regular channels.
  * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
  * @retval None
  */
void ADC_SoftwareStartConv(ADC_TypeDef* ADCx)
{
 8008188:	b480      	push	{r7}
 800818a:	b083      	sub	sp, #12
 800818c:	af00      	add	r7, sp, #0
 800818e:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  
  /* Enable the selected ADC conversion for regular group */
  ADCx->CR2 |= (uint32_t)ADC_CR2_SWSTART;
 8008190:	687b      	ldr	r3, [r7, #4]
 8008192:	689b      	ldr	r3, [r3, #8]
 8008194:	f043 4280 	orr.w	r2, r3, #1073741824	; 0x40000000
 8008198:	687b      	ldr	r3, [r7, #4]
 800819a:	609a      	str	r2, [r3, #8]
}
 800819c:	bf00      	nop
 800819e:	370c      	adds	r7, #12
 80081a0:	46bd      	mov	sp, r7
 80081a2:	f85d 7b04 	ldr.w	r7, [sp], #4
 80081a6:	4770      	bx	lr

080081a8 <ADC_GetSoftwareStartConvStatus>:
  * @brief  Gets the selected ADC Software start regular conversion Status.
  * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
  * @retval The new state of ADC software start conversion (SET or RESET).
  */
FlagStatus ADC_GetSoftwareStartConvStatus(ADC_TypeDef* ADCx)
{
 80081a8:	b480      	push	{r7}
 80081aa:	b085      	sub	sp, #20
 80081ac:	af00      	add	r7, sp, #0
 80081ae:	6078      	str	r0, [r7, #4]
  FlagStatus bitstatus = RESET;
 80081b0:	2300      	movs	r3, #0
 80081b2:	73fb      	strb	r3, [r7, #15]
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  
  /* Check the status of SWSTART bit */
  if ((ADCx->CR2 & ADC_CR2_JSWSTART) != (uint32_t)RESET)
 80081b4:	687b      	ldr	r3, [r7, #4]
 80081b6:	689b      	ldr	r3, [r3, #8]
 80081b8:	f403 0380 	and.w	r3, r3, #4194304	; 0x400000
 80081bc:	2b00      	cmp	r3, #0
 80081be:	d002      	beq.n	80081c6 <ADC_GetSoftwareStartConvStatus+0x1e>
  {
    /* SWSTART bit is set */
    bitstatus = SET;
 80081c0:	2301      	movs	r3, #1
 80081c2:	73fb      	strb	r3, [r7, #15]
 80081c4:	e001      	b.n	80081ca <ADC_GetSoftwareStartConvStatus+0x22>
  }
  else
  {
    /* SWSTART bit is reset */
    bitstatus = RESET;
 80081c6:	2300      	movs	r3, #0
 80081c8:	73fb      	strb	r3, [r7, #15]
  }
  
  /* Return the SWSTART bit status */
  return  bitstatus;
 80081ca:	7bfb      	ldrb	r3, [r7, #15]
}
 80081cc:	4618      	mov	r0, r3
 80081ce:	3714      	adds	r7, #20
 80081d0:	46bd      	mov	sp, r7
 80081d2:	f85d 7b04 	ldr.w	r7, [sp], #4
 80081d6:	4770      	bx	lr

080081d8 <ADC_EOCOnEachRegularChannelCmd>:
  * @param  NewState: new state of the selected ADC EOC flag rising
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void ADC_EOCOnEachRegularChannelCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
{
 80081d8:	b480      	push	{r7}
 80081da:	b083      	sub	sp, #12
 80081dc:	af00      	add	r7, sp, #0
 80081de:	6078      	str	r0, [r7, #4]
 80081e0:	460b      	mov	r3, r1
 80081e2:	70fb      	strb	r3, [r7, #3]
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
 80081e4:	78fb      	ldrb	r3, [r7, #3]
 80081e6:	2b00      	cmp	r3, #0
 80081e8:	d006      	beq.n	80081f8 <ADC_EOCOnEachRegularChannelCmd+0x20>
  {
    /* Enable the selected ADC EOC rising on each regular channel conversion */
    ADCx->CR2 |= (uint32_t)ADC_CR2_EOCS;
 80081ea:	687b      	ldr	r3, [r7, #4]
 80081ec:	689b      	ldr	r3, [r3, #8]
 80081ee:	f443 6280 	orr.w	r2, r3, #1024	; 0x400
 80081f2:	687b      	ldr	r3, [r7, #4]
 80081f4:	609a      	str	r2, [r3, #8]
  else
  {
    /* Disable the selected ADC EOC rising on each regular channel conversion */
    ADCx->CR2 &= (uint32_t)(~ADC_CR2_EOCS);
  }
}
 80081f6:	e005      	b.n	8008204 <ADC_EOCOnEachRegularChannelCmd+0x2c>
    ADCx->CR2 &= (uint32_t)(~ADC_CR2_EOCS);
 80081f8:	687b      	ldr	r3, [r7, #4]
 80081fa:	689b      	ldr	r3, [r3, #8]
 80081fc:	f423 6280 	bic.w	r2, r3, #1024	; 0x400
 8008200:	687b      	ldr	r3, [r7, #4]
 8008202:	609a      	str	r2, [r3, #8]
}
 8008204:	bf00      	nop
 8008206:	370c      	adds	r7, #12
 8008208:	46bd      	mov	sp, r7
 800820a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800820e:	4770      	bx	lr

08008210 <ADC_ContinuousModeCmd>:
  * @param  NewState: new state of the selected ADC continuous conversion mode
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void ADC_ContinuousModeCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
{
 8008210:	b480      	push	{r7}
 8008212:	b083      	sub	sp, #12
 8008214:	af00      	add	r7, sp, #0
 8008216:	6078      	str	r0, [r7, #4]
 8008218:	460b      	mov	r3, r1
 800821a:	70fb      	strb	r3, [r7, #3]
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
 800821c:	78fb      	ldrb	r3, [r7, #3]
 800821e:	2b00      	cmp	r3, #0
 8008220:	d006      	beq.n	8008230 <ADC_ContinuousModeCmd+0x20>
  {
    /* Enable the selected ADC continuous conversion mode */
    ADCx->CR2 |= (uint32_t)ADC_CR2_CONT;
 8008222:	687b      	ldr	r3, [r7, #4]
 8008224:	689b      	ldr	r3, [r3, #8]
 8008226:	f043 0202 	orr.w	r2, r3, #2
 800822a:	687b      	ldr	r3, [r7, #4]
 800822c:	609a      	str	r2, [r3, #8]
  else
  {
    /* Disable the selected ADC continuous conversion mode */
    ADCx->CR2 &= (uint32_t)(~ADC_CR2_CONT);
  }
}
 800822e:	e005      	b.n	800823c <ADC_ContinuousModeCmd+0x2c>
    ADCx->CR2 &= (uint32_t)(~ADC_CR2_CONT);
 8008230:	687b      	ldr	r3, [r7, #4]
 8008232:	689b      	ldr	r3, [r3, #8]
 8008234:	f023 0202 	bic.w	r2, r3, #2
 8008238:	687b      	ldr	r3, [r7, #4]
 800823a:	609a      	str	r2, [r3, #8]
}
 800823c:	bf00      	nop
 800823e:	370c      	adds	r7, #12
 8008240:	46bd      	mov	sp, r7
 8008242:	f85d 7b04 	ldr.w	r7, [sp], #4
 8008246:	4770      	bx	lr

08008248 <ADC_DiscModeChannelCountConfig>:
  * @param  Number: specifies the discontinuous mode regular channel count value.
  *          This number must be between 1 and 8.
  * @retval None
  */
void ADC_DiscModeChannelCountConfig(ADC_TypeDef* ADCx, uint8_t Number)
{
 8008248:	b480      	push	{r7}
 800824a:	b085      	sub	sp, #20
 800824c:	af00      	add	r7, sp, #0
 800824e:	6078      	str	r0, [r7, #4]
 8008250:	460b      	mov	r3, r1
 8008252:	70fb      	strb	r3, [r7, #3]
  uint32_t tmpreg1 = 0;
 8008254:	2300      	movs	r3, #0
 8008256:	60fb      	str	r3, [r7, #12]
  uint32_t tmpreg2 = 0;
 8008258:	2300      	movs	r3, #0
 800825a:	60bb      	str	r3, [r7, #8]
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_ADC_REGULAR_DISC_NUMBER(Number));
  
  /* Get the old register value */
  tmpreg1 = ADCx->CR1;
 800825c:	687b      	ldr	r3, [r7, #4]
 800825e:	685b      	ldr	r3, [r3, #4]
 8008260:	60fb      	str	r3, [r7, #12]
  
  /* Clear the old discontinuous mode channel count */
  tmpreg1 &= CR1_DISCNUM_RESET;
 8008262:	68fb      	ldr	r3, [r7, #12]
 8008264:	f423 4360 	bic.w	r3, r3, #57344	; 0xe000
 8008268:	60fb      	str	r3, [r7, #12]
  
  /* Set the discontinuous mode channel count */
  tmpreg2 = Number - 1;
 800826a:	78fb      	ldrb	r3, [r7, #3]
 800826c:	3b01      	subs	r3, #1
 800826e:	60bb      	str	r3, [r7, #8]
  tmpreg1 |= tmpreg2 << 13;
 8008270:	68bb      	ldr	r3, [r7, #8]
 8008272:	035b      	lsls	r3, r3, #13
 8008274:	68fa      	ldr	r2, [r7, #12]
 8008276:	4313      	orrs	r3, r2
 8008278:	60fb      	str	r3, [r7, #12]
  
  /* Store the new register value */
  ADCx->CR1 = tmpreg1;
 800827a:	687b      	ldr	r3, [r7, #4]
 800827c:	68fa      	ldr	r2, [r7, #12]
 800827e:	605a      	str	r2, [r3, #4]
}
 8008280:	bf00      	nop
 8008282:	3714      	adds	r7, #20
 8008284:	46bd      	mov	sp, r7
 8008286:	f85d 7b04 	ldr.w	r7, [sp], #4
 800828a:	4770      	bx	lr

0800828c <ADC_DiscModeCmd>:
  *         regular group channel.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void ADC_DiscModeCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
{
 800828c:	b480      	push	{r7}
 800828e:	b083      	sub	sp, #12
 8008290:	af00      	add	r7, sp, #0
 8008292:	6078      	str	r0, [r7, #4]
 8008294:	460b      	mov	r3, r1
 8008296:	70fb      	strb	r3, [r7, #3]
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
 8008298:	78fb      	ldrb	r3, [r7, #3]
 800829a:	2b00      	cmp	r3, #0
 800829c:	d006      	beq.n	80082ac <ADC_DiscModeCmd+0x20>
  {
    /* Enable the selected ADC regular discontinuous mode */
    ADCx->CR1 |= (uint32_t)ADC_CR1_DISCEN;
 800829e:	687b      	ldr	r3, [r7, #4]
 80082a0:	685b      	ldr	r3, [r3, #4]
 80082a2:	f443 6200 	orr.w	r2, r3, #2048	; 0x800
 80082a6:	687b      	ldr	r3, [r7, #4]
 80082a8:	605a      	str	r2, [r3, #4]
  else
  {
    /* Disable the selected ADC regular discontinuous mode */
    ADCx->CR1 &= (uint32_t)(~ADC_CR1_DISCEN);
  }
}
 80082aa:	e005      	b.n	80082b8 <ADC_DiscModeCmd+0x2c>
    ADCx->CR1 &= (uint32_t)(~ADC_CR1_DISCEN);
 80082ac:	687b      	ldr	r3, [r7, #4]
 80082ae:	685b      	ldr	r3, [r3, #4]
 80082b0:	f423 6200 	bic.w	r2, r3, #2048	; 0x800
 80082b4:	687b      	ldr	r3, [r7, #4]
 80082b6:	605a      	str	r2, [r3, #4]
}
 80082b8:	bf00      	nop
 80082ba:	370c      	adds	r7, #12
 80082bc:	46bd      	mov	sp, r7
 80082be:	f85d 7b04 	ldr.w	r7, [sp], #4
 80082c2:	4770      	bx	lr

080082c4 <ADC_GetConversionValue>:
  * @brief  Returns the last ADCx conversion result data for regular channel.
  * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
  * @retval The Data conversion value.
  */
uint16_t ADC_GetConversionValue(ADC_TypeDef* ADCx)
{
 80082c4:	b480      	push	{r7}
 80082c6:	b083      	sub	sp, #12
 80082c8:	af00      	add	r7, sp, #0
 80082ca:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  
  /* Return the selected ADC conversion value */
  return (uint16_t) ADCx->DR;
 80082cc:	687b      	ldr	r3, [r7, #4]
 80082ce:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 80082d0:	b29b      	uxth	r3, r3
}
 80082d2:	4618      	mov	r0, r3
 80082d4:	370c      	adds	r7, #12
 80082d6:	46bd      	mov	sp, r7
 80082d8:	f85d 7b04 	ldr.w	r7, [sp], #4
 80082dc:	4770      	bx	lr

080082de <ADC_GetMultiModeConversionValue>:
  * @note   In triple mode, the value returned by this function is as following
  *           Data[15:0] : these bits contain alternatively the regular data of ADC1, ADC3 and ADC2.
  *           Data[31:16]: these bits contain alternatively the regular data of ADC2, ADC1 and ADC3.           
  */
uint32_t ADC_GetMultiModeConversionValue(void)
{
 80082de:	b480      	push	{r7}
 80082e0:	af00      	add	r7, sp, #0
  /* Return the multi mode conversion value */
  return (*(__IO uint32_t *) CDR_ADDRESS);
 80082e2:	4b03      	ldr	r3, [pc, #12]	; (80082f0 <ADC_GetMultiModeConversionValue+0x12>)
 80082e4:	681b      	ldr	r3, [r3, #0]
}
 80082e6:	4618      	mov	r0, r3
 80082e8:	46bd      	mov	sp, r7
 80082ea:	f85d 7b04 	ldr.w	r7, [sp], #4
 80082ee:	4770      	bx	lr
 80082f0:	40012308 	.word	0x40012308

080082f4 <ADC_DMACmd>:
  * @param  NewState: new state of the selected ADC DMA transfer.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void ADC_DMACmd(ADC_TypeDef* ADCx, FunctionalState NewState)
{
 80082f4:	b480      	push	{r7}
 80082f6:	b083      	sub	sp, #12
 80082f8:	af00      	add	r7, sp, #0
 80082fa:	6078      	str	r0, [r7, #4]
 80082fc:	460b      	mov	r3, r1
 80082fe:	70fb      	strb	r3, [r7, #3]
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 8008300:	78fb      	ldrb	r3, [r7, #3]
 8008302:	2b00      	cmp	r3, #0
 8008304:	d006      	beq.n	8008314 <ADC_DMACmd+0x20>
  {
    /* Enable the selected ADC DMA request */
    ADCx->CR2 |= (uint32_t)ADC_CR2_DMA;
 8008306:	687b      	ldr	r3, [r7, #4]
 8008308:	689b      	ldr	r3, [r3, #8]
 800830a:	f443 7280 	orr.w	r2, r3, #256	; 0x100
 800830e:	687b      	ldr	r3, [r7, #4]
 8008310:	609a      	str	r2, [r3, #8]
  else
  {
    /* Disable the selected ADC DMA request */
    ADCx->CR2 &= (uint32_t)(~ADC_CR2_DMA);
  }
}
 8008312:	e005      	b.n	8008320 <ADC_DMACmd+0x2c>
    ADCx->CR2 &= (uint32_t)(~ADC_CR2_DMA);
 8008314:	687b      	ldr	r3, [r7, #4]
 8008316:	689b      	ldr	r3, [r3, #8]
 8008318:	f423 7280 	bic.w	r2, r3, #256	; 0x100
 800831c:	687b      	ldr	r3, [r7, #4]
 800831e:	609a      	str	r2, [r3, #8]
}
 8008320:	bf00      	nop
 8008322:	370c      	adds	r7, #12
 8008324:	46bd      	mov	sp, r7
 8008326:	f85d 7b04 	ldr.w	r7, [sp], #4
 800832a:	4770      	bx	lr

0800832c <ADC_DMARequestAfterLastTransferCmd>:
  * @param  NewState: new state of the selected ADC DMA request after last transfer.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void ADC_DMARequestAfterLastTransferCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
{
 800832c:	b480      	push	{r7}
 800832e:	b083      	sub	sp, #12
 8008330:	af00      	add	r7, sp, #0
 8008332:	6078      	str	r0, [r7, #4]
 8008334:	460b      	mov	r3, r1
 8008336:	70fb      	strb	r3, [r7, #3]
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 8008338:	78fb      	ldrb	r3, [r7, #3]
 800833a:	2b00      	cmp	r3, #0
 800833c:	d006      	beq.n	800834c <ADC_DMARequestAfterLastTransferCmd+0x20>
  {
    /* Enable the selected ADC DMA request after last transfer */
    ADCx->CR2 |= (uint32_t)ADC_CR2_DDS;
 800833e:	687b      	ldr	r3, [r7, #4]
 8008340:	689b      	ldr	r3, [r3, #8]
 8008342:	f443 7200 	orr.w	r2, r3, #512	; 0x200
 8008346:	687b      	ldr	r3, [r7, #4]
 8008348:	609a      	str	r2, [r3, #8]
  else
  {
    /* Disable the selected ADC DMA request after last transfer */
    ADCx->CR2 &= (uint32_t)(~ADC_CR2_DDS);
  }
}
 800834a:	e005      	b.n	8008358 <ADC_DMARequestAfterLastTransferCmd+0x2c>
    ADCx->CR2 &= (uint32_t)(~ADC_CR2_DDS);
 800834c:	687b      	ldr	r3, [r7, #4]
 800834e:	689b      	ldr	r3, [r3, #8]
 8008350:	f423 7200 	bic.w	r2, r3, #512	; 0x200
 8008354:	687b      	ldr	r3, [r7, #4]
 8008356:	609a      	str	r2, [r3, #8]
}
 8008358:	bf00      	nop
 800835a:	370c      	adds	r7, #12
 800835c:	46bd      	mov	sp, r7
 800835e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8008362:	4770      	bx	lr

08008364 <ADC_MultiModeDMARequestAfterLastTransferCmd>:
  *         by ADC_CommonInitStruct.ADC_DMAAccessMode structure member) is 
  *          ADC_DMAAccessMode_1, ADC_DMAAccessMode_2 or ADC_DMAAccessMode_3.     
  * @retval None
  */
void ADC_MultiModeDMARequestAfterLastTransferCmd(FunctionalState NewState)
{
 8008364:	b480      	push	{r7}
 8008366:	b083      	sub	sp, #12
 8008368:	af00      	add	r7, sp, #0
 800836a:	4603      	mov	r3, r0
 800836c:	71fb      	strb	r3, [r7, #7]
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 800836e:	79fb      	ldrb	r3, [r7, #7]
 8008370:	2b00      	cmp	r3, #0
 8008372:	d006      	beq.n	8008382 <ADC_MultiModeDMARequestAfterLastTransferCmd+0x1e>
  {
    /* Enable the selected ADC DMA request after last transfer */
    ADC->CCR |= (uint32_t)ADC_CCR_DDS;
 8008374:	4a09      	ldr	r2, [pc, #36]	; (800839c <ADC_MultiModeDMARequestAfterLastTransferCmd+0x38>)
 8008376:	4b09      	ldr	r3, [pc, #36]	; (800839c <ADC_MultiModeDMARequestAfterLastTransferCmd+0x38>)
 8008378:	685b      	ldr	r3, [r3, #4]
 800837a:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
 800837e:	6053      	str	r3, [r2, #4]
  else
  {
    /* Disable the selected ADC DMA request after last transfer */
    ADC->CCR &= (uint32_t)(~ADC_CCR_DDS);
  }
}
 8008380:	e005      	b.n	800838e <ADC_MultiModeDMARequestAfterLastTransferCmd+0x2a>
    ADC->CCR &= (uint32_t)(~ADC_CCR_DDS);
 8008382:	4a06      	ldr	r2, [pc, #24]	; (800839c <ADC_MultiModeDMARequestAfterLastTransferCmd+0x38>)
 8008384:	4b05      	ldr	r3, [pc, #20]	; (800839c <ADC_MultiModeDMARequestAfterLastTransferCmd+0x38>)
 8008386:	685b      	ldr	r3, [r3, #4]
 8008388:	f423 5300 	bic.w	r3, r3, #8192	; 0x2000
 800838c:	6053      	str	r3, [r2, #4]
}
 800838e:	bf00      	nop
 8008390:	370c      	adds	r7, #12
 8008392:	46bd      	mov	sp, r7
 8008394:	f85d 7b04 	ldr.w	r7, [sp], #4
 8008398:	4770      	bx	lr
 800839a:	bf00      	nop
 800839c:	40012300 	.word	0x40012300

080083a0 <ADC_InjectedChannelConfig>:
  *            @arg ADC_SampleTime_144Cycles: Sample time equal to 144 cycles	
  *            @arg ADC_SampleTime_480Cycles: Sample time equal to 480 cycles	
  * @retval None
  */
void ADC_InjectedChannelConfig(ADC_TypeDef* ADCx, uint8_t ADC_Channel, uint8_t Rank, uint8_t ADC_SampleTime)
{
 80083a0:	b480      	push	{r7}
 80083a2:	b087      	sub	sp, #28
 80083a4:	af00      	add	r7, sp, #0
 80083a6:	6078      	str	r0, [r7, #4]
 80083a8:	4608      	mov	r0, r1
 80083aa:	4611      	mov	r1, r2
 80083ac:	461a      	mov	r2, r3
 80083ae:	4603      	mov	r3, r0
 80083b0:	70fb      	strb	r3, [r7, #3]
 80083b2:	460b      	mov	r3, r1
 80083b4:	70bb      	strb	r3, [r7, #2]
 80083b6:	4613      	mov	r3, r2
 80083b8:	707b      	strb	r3, [r7, #1]
  uint32_t tmpreg1 = 0, tmpreg2 = 0, tmpreg3 = 0;
 80083ba:	2300      	movs	r3, #0
 80083bc:	617b      	str	r3, [r7, #20]
 80083be:	2300      	movs	r3, #0
 80083c0:	613b      	str	r3, [r7, #16]
 80083c2:	2300      	movs	r3, #0
 80083c4:	60fb      	str	r3, [r7, #12]
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_ADC_CHANNEL(ADC_Channel));
  assert_param(IS_ADC_INJECTED_RANK(Rank));
  assert_param(IS_ADC_SAMPLE_TIME(ADC_SampleTime));
  /* if ADC_Channel_10 ... ADC_Channel_18 is selected */
  if (ADC_Channel > ADC_Channel_9)
 80083c6:	78fb      	ldrb	r3, [r7, #3]
 80083c8:	2b09      	cmp	r3, #9
 80083ca:	d923      	bls.n	8008414 <ADC_InjectedChannelConfig+0x74>
  {
    /* Get the old register value */
    tmpreg1 = ADCx->SMPR1;
 80083cc:	687b      	ldr	r3, [r7, #4]
 80083ce:	68db      	ldr	r3, [r3, #12]
 80083d0:	617b      	str	r3, [r7, #20]
    /* Calculate the mask to clear */
    tmpreg2 = SMPR1_SMP_SET << (3*(ADC_Channel - 10));
 80083d2:	78fb      	ldrb	r3, [r7, #3]
 80083d4:	f1a3 020a 	sub.w	r2, r3, #10
 80083d8:	4613      	mov	r3, r2
 80083da:	005b      	lsls	r3, r3, #1
 80083dc:	4413      	add	r3, r2
 80083de:	2207      	movs	r2, #7
 80083e0:	fa02 f303 	lsl.w	r3, r2, r3
 80083e4:	613b      	str	r3, [r7, #16]
    /* Clear the old sample time */
    tmpreg1 &= ~tmpreg2;
 80083e6:	693b      	ldr	r3, [r7, #16]
 80083e8:	43db      	mvns	r3, r3
 80083ea:	697a      	ldr	r2, [r7, #20]
 80083ec:	4013      	ands	r3, r2
 80083ee:	617b      	str	r3, [r7, #20]
    /* Calculate the mask to set */
    tmpreg2 = (uint32_t)ADC_SampleTime << (3*(ADC_Channel - 10));
 80083f0:	7879      	ldrb	r1, [r7, #1]
 80083f2:	78fb      	ldrb	r3, [r7, #3]
 80083f4:	f1a3 020a 	sub.w	r2, r3, #10
 80083f8:	4613      	mov	r3, r2
 80083fa:	005b      	lsls	r3, r3, #1
 80083fc:	4413      	add	r3, r2
 80083fe:	fa01 f303 	lsl.w	r3, r1, r3
 8008402:	613b      	str	r3, [r7, #16]
    /* Set the new sample time */
    tmpreg1 |= tmpreg2;
 8008404:	697a      	ldr	r2, [r7, #20]
 8008406:	693b      	ldr	r3, [r7, #16]
 8008408:	4313      	orrs	r3, r2
 800840a:	617b      	str	r3, [r7, #20]
    /* Store the new register value */
    ADCx->SMPR1 = tmpreg1;
 800840c:	687b      	ldr	r3, [r7, #4]
 800840e:	697a      	ldr	r2, [r7, #20]
 8008410:	60da      	str	r2, [r3, #12]
 8008412:	e01e      	b.n	8008452 <ADC_InjectedChannelConfig+0xb2>
  }
  else /* ADC_Channel include in ADC_Channel_[0..9] */
  {
    /* Get the old register value */
    tmpreg1 = ADCx->SMPR2;
 8008414:	687b      	ldr	r3, [r7, #4]
 8008416:	691b      	ldr	r3, [r3, #16]
 8008418:	617b      	str	r3, [r7, #20]
    /* Calculate the mask to clear */
    tmpreg2 = SMPR2_SMP_SET << (3 * ADC_Channel);
 800841a:	78fa      	ldrb	r2, [r7, #3]
 800841c:	4613      	mov	r3, r2
 800841e:	005b      	lsls	r3, r3, #1
 8008420:	4413      	add	r3, r2
 8008422:	2207      	movs	r2, #7
 8008424:	fa02 f303 	lsl.w	r3, r2, r3
 8008428:	613b      	str	r3, [r7, #16]
    /* Clear the old sample time */
    tmpreg1 &= ~tmpreg2;
 800842a:	693b      	ldr	r3, [r7, #16]
 800842c:	43db      	mvns	r3, r3
 800842e:	697a      	ldr	r2, [r7, #20]
 8008430:	4013      	ands	r3, r2
 8008432:	617b      	str	r3, [r7, #20]
    /* Calculate the mask to set */
    tmpreg2 = (uint32_t)ADC_SampleTime << (3 * ADC_Channel);
 8008434:	7879      	ldrb	r1, [r7, #1]
 8008436:	78fa      	ldrb	r2, [r7, #3]
 8008438:	4613      	mov	r3, r2
 800843a:	005b      	lsls	r3, r3, #1
 800843c:	4413      	add	r3, r2
 800843e:	fa01 f303 	lsl.w	r3, r1, r3
 8008442:	613b      	str	r3, [r7, #16]
    /* Set the new sample time */
    tmpreg1 |= tmpreg2;
 8008444:	697a      	ldr	r2, [r7, #20]
 8008446:	693b      	ldr	r3, [r7, #16]
 8008448:	4313      	orrs	r3, r2
 800844a:	617b      	str	r3, [r7, #20]
    /* Store the new register value */
    ADCx->SMPR2 = tmpreg1;
 800844c:	687b      	ldr	r3, [r7, #4]
 800844e:	697a      	ldr	r2, [r7, #20]
 8008450:	611a      	str	r2, [r3, #16]
  }
  /* Rank configuration */
  /* Get the old register value */
  tmpreg1 = ADCx->JSQR;
 8008452:	687b      	ldr	r3, [r7, #4]
 8008454:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8008456:	617b      	str	r3, [r7, #20]
  /* Get JL value: Number = JL+1 */
  tmpreg3 =  (tmpreg1 & JSQR_JL_SET)>> 20;
 8008458:	697b      	ldr	r3, [r7, #20]
 800845a:	0d1b      	lsrs	r3, r3, #20
 800845c:	f003 0303 	and.w	r3, r3, #3
 8008460:	60fb      	str	r3, [r7, #12]
  /* Calculate the mask to clear: ((Rank-1)+(4-JL-1)) */
  tmpreg2 = JSQR_JSQ_SET << (5 * (uint8_t)((Rank + 3) - (tmpreg3 + 1)));
 8008462:	68fb      	ldr	r3, [r7, #12]
 8008464:	b2db      	uxtb	r3, r3
 8008466:	78ba      	ldrb	r2, [r7, #2]
 8008468:	1ad3      	subs	r3, r2, r3
 800846a:	b2db      	uxtb	r3, r3
 800846c:	3302      	adds	r3, #2
 800846e:	b2db      	uxtb	r3, r3
 8008470:	461a      	mov	r2, r3
 8008472:	4613      	mov	r3, r2
 8008474:	009b      	lsls	r3, r3, #2
 8008476:	4413      	add	r3, r2
 8008478:	221f      	movs	r2, #31
 800847a:	fa02 f303 	lsl.w	r3, r2, r3
 800847e:	613b      	str	r3, [r7, #16]
  /* Clear the old JSQx bits for the selected rank */
  tmpreg1 &= ~tmpreg2;
 8008480:	693b      	ldr	r3, [r7, #16]
 8008482:	43db      	mvns	r3, r3
 8008484:	697a      	ldr	r2, [r7, #20]
 8008486:	4013      	ands	r3, r2
 8008488:	617b      	str	r3, [r7, #20]
  /* Calculate the mask to set: ((Rank-1)+(4-JL-1)) */
  tmpreg2 = (uint32_t)ADC_Channel << (5 * (uint8_t)((Rank + 3) - (tmpreg3 + 1)));
 800848a:	78fa      	ldrb	r2, [r7, #3]
 800848c:	68fb      	ldr	r3, [r7, #12]
 800848e:	b2db      	uxtb	r3, r3
 8008490:	78b9      	ldrb	r1, [r7, #2]
 8008492:	1acb      	subs	r3, r1, r3
 8008494:	b2db      	uxtb	r3, r3
 8008496:	3302      	adds	r3, #2
 8008498:	b2db      	uxtb	r3, r3
 800849a:	4619      	mov	r1, r3
 800849c:	460b      	mov	r3, r1
 800849e:	009b      	lsls	r3, r3, #2
 80084a0:	440b      	add	r3, r1
 80084a2:	fa02 f303 	lsl.w	r3, r2, r3
 80084a6:	613b      	str	r3, [r7, #16]
  /* Set the JSQx bits for the selected rank */
  tmpreg1 |= tmpreg2;
 80084a8:	697a      	ldr	r2, [r7, #20]
 80084aa:	693b      	ldr	r3, [r7, #16]
 80084ac:	4313      	orrs	r3, r2
 80084ae:	617b      	str	r3, [r7, #20]
  /* Store the new register value */
  ADCx->JSQR = tmpreg1;
 80084b0:	687b      	ldr	r3, [r7, #4]
 80084b2:	697a      	ldr	r2, [r7, #20]
 80084b4:	639a      	str	r2, [r3, #56]	; 0x38
}
 80084b6:	bf00      	nop
 80084b8:	371c      	adds	r7, #28
 80084ba:	46bd      	mov	sp, r7
 80084bc:	f85d 7b04 	ldr.w	r7, [sp], #4
 80084c0:	4770      	bx	lr

080084c2 <ADC_InjectedSequencerLengthConfig>:
  * @param  Length: The sequencer length. 
  *          This parameter must be a number between 1 to 4.
  * @retval None
  */
void ADC_InjectedSequencerLengthConfig(ADC_TypeDef* ADCx, uint8_t Length)
{
 80084c2:	b480      	push	{r7}
 80084c4:	b085      	sub	sp, #20
 80084c6:	af00      	add	r7, sp, #0
 80084c8:	6078      	str	r0, [r7, #4]
 80084ca:	460b      	mov	r3, r1
 80084cc:	70fb      	strb	r3, [r7, #3]
  uint32_t tmpreg1 = 0;
 80084ce:	2300      	movs	r3, #0
 80084d0:	60fb      	str	r3, [r7, #12]
  uint32_t tmpreg2 = 0;
 80084d2:	2300      	movs	r3, #0
 80084d4:	60bb      	str	r3, [r7, #8]
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_ADC_INJECTED_LENGTH(Length));
  
  /* Get the old register value */
  tmpreg1 = ADCx->JSQR;
 80084d6:	687b      	ldr	r3, [r7, #4]
 80084d8:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 80084da:	60fb      	str	r3, [r7, #12]
  
  /* Clear the old injected sequence length JL bits */
  tmpreg1 &= JSQR_JL_RESET;
 80084dc:	68fb      	ldr	r3, [r7, #12]
 80084de:	f423 1340 	bic.w	r3, r3, #3145728	; 0x300000
 80084e2:	60fb      	str	r3, [r7, #12]
  
  /* Set the injected sequence length JL bits */
  tmpreg2 = Length - 1; 
 80084e4:	78fb      	ldrb	r3, [r7, #3]
 80084e6:	3b01      	subs	r3, #1
 80084e8:	60bb      	str	r3, [r7, #8]
  tmpreg1 |= tmpreg2 << 20;
 80084ea:	68bb      	ldr	r3, [r7, #8]
 80084ec:	051b      	lsls	r3, r3, #20
 80084ee:	68fa      	ldr	r2, [r7, #12]
 80084f0:	4313      	orrs	r3, r2
 80084f2:	60fb      	str	r3, [r7, #12]
  
  /* Store the new register value */
  ADCx->JSQR = tmpreg1;
 80084f4:	687b      	ldr	r3, [r7, #4]
 80084f6:	68fa      	ldr	r2, [r7, #12]
 80084f8:	639a      	str	r2, [r3, #56]	; 0x38
}
 80084fa:	bf00      	nop
 80084fc:	3714      	adds	r7, #20
 80084fe:	46bd      	mov	sp, r7
 8008500:	f85d 7b04 	ldr.w	r7, [sp], #4
 8008504:	4770      	bx	lr

08008506 <ADC_SetInjectedOffset>:
  * @param  Offset: the offset value for the selected ADC injected channel
  *          This parameter must be a 12bit value.
  * @retval None
  */
void ADC_SetInjectedOffset(ADC_TypeDef* ADCx, uint8_t ADC_InjectedChannel, uint16_t Offset)
{
 8008506:	b480      	push	{r7}
 8008508:	b085      	sub	sp, #20
 800850a:	af00      	add	r7, sp, #0
 800850c:	6078      	str	r0, [r7, #4]
 800850e:	460b      	mov	r3, r1
 8008510:	70fb      	strb	r3, [r7, #3]
 8008512:	4613      	mov	r3, r2
 8008514:	803b      	strh	r3, [r7, #0]
    __IO uint32_t tmp = 0;
 8008516:	2300      	movs	r3, #0
 8008518:	60fb      	str	r3, [r7, #12]
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_ADC_INJECTED_CHANNEL(ADC_InjectedChannel));
  assert_param(IS_ADC_OFFSET(Offset));
  
  tmp = (uint32_t)ADCx;
 800851a:	687b      	ldr	r3, [r7, #4]
 800851c:	60fb      	str	r3, [r7, #12]
  tmp += ADC_InjectedChannel;
 800851e:	78fa      	ldrb	r2, [r7, #3]
 8008520:	68fb      	ldr	r3, [r7, #12]
 8008522:	4413      	add	r3, r2
 8008524:	60fb      	str	r3, [r7, #12]
  
  /* Set the selected injected channel data offset */
 *(__IO uint32_t *) tmp = (uint32_t)Offset;
 8008526:	68fb      	ldr	r3, [r7, #12]
 8008528:	461a      	mov	r2, r3
 800852a:	883b      	ldrh	r3, [r7, #0]
 800852c:	6013      	str	r3, [r2, #0]
}
 800852e:	bf00      	nop
 8008530:	3714      	adds	r7, #20
 8008532:	46bd      	mov	sp, r7
 8008534:	f85d 7b04 	ldr.w	r7, [sp], #4
 8008538:	4770      	bx	lr

0800853a <ADC_ExternalTrigInjectedConvConfig>:
  *            @arg ADC_ExternalTrigInjecConv_T8_CC4: Timer8 capture compare4 selected 
  *            @arg ADC_ExternalTrigInjecConv_Ext_IT15: External interrupt line 15 event selected                          
  * @retval None
  */
void ADC_ExternalTrigInjectedConvConfig(ADC_TypeDef* ADCx, uint32_t ADC_ExternalTrigInjecConv)
{
 800853a:	b480      	push	{r7}
 800853c:	b085      	sub	sp, #20
 800853e:	af00      	add	r7, sp, #0
 8008540:	6078      	str	r0, [r7, #4]
 8008542:	6039      	str	r1, [r7, #0]
  uint32_t tmpreg = 0;
 8008544:	2300      	movs	r3, #0
 8008546:	60fb      	str	r3, [r7, #12]
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_ADC_EXT_INJEC_TRIG(ADC_ExternalTrigInjecConv));
  
  /* Get the old register value */
  tmpreg = ADCx->CR2;
 8008548:	687b      	ldr	r3, [r7, #4]
 800854a:	689b      	ldr	r3, [r3, #8]
 800854c:	60fb      	str	r3, [r7, #12]
  
  /* Clear the old external event selection for injected group */
  tmpreg &= CR2_JEXTSEL_RESET;
 800854e:	68fb      	ldr	r3, [r7, #12]
 8008550:	f423 2370 	bic.w	r3, r3, #983040	; 0xf0000
 8008554:	60fb      	str	r3, [r7, #12]
  
  /* Set the external event selection for injected group */
  tmpreg |= ADC_ExternalTrigInjecConv;
 8008556:	68fa      	ldr	r2, [r7, #12]
 8008558:	683b      	ldr	r3, [r7, #0]
 800855a:	4313      	orrs	r3, r2
 800855c:	60fb      	str	r3, [r7, #12]
  
  /* Store the new register value */
  ADCx->CR2 = tmpreg;
 800855e:	687b      	ldr	r3, [r7, #4]
 8008560:	68fa      	ldr	r2, [r7, #12]
 8008562:	609a      	str	r2, [r3, #8]
}
 8008564:	bf00      	nop
 8008566:	3714      	adds	r7, #20
 8008568:	46bd      	mov	sp, r7
 800856a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800856e:	4770      	bx	lr

08008570 <ADC_ExternalTrigInjectedConvEdgeConfig>:
  *            @arg ADC_ExternalTrigInjecConvEdge_RisingFalling: detection on both rising 
  *                                                               and falling edge
  * @retval None
  */
void ADC_ExternalTrigInjectedConvEdgeConfig(ADC_TypeDef* ADCx, uint32_t ADC_ExternalTrigInjecConvEdge)
{
 8008570:	b480      	push	{r7}
 8008572:	b085      	sub	sp, #20
 8008574:	af00      	add	r7, sp, #0
 8008576:	6078      	str	r0, [r7, #4]
 8008578:	6039      	str	r1, [r7, #0]
  uint32_t tmpreg = 0;
 800857a:	2300      	movs	r3, #0
 800857c:	60fb      	str	r3, [r7, #12]
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_ADC_EXT_INJEC_TRIG_EDGE(ADC_ExternalTrigInjecConvEdge));
  /* Get the old register value */
  tmpreg = ADCx->CR2;
 800857e:	687b      	ldr	r3, [r7, #4]
 8008580:	689b      	ldr	r3, [r3, #8]
 8008582:	60fb      	str	r3, [r7, #12]
  /* Clear the old external trigger edge for injected group */
  tmpreg &= CR2_JEXTEN_RESET;
 8008584:	68fb      	ldr	r3, [r7, #12]
 8008586:	f423 1340 	bic.w	r3, r3, #3145728	; 0x300000
 800858a:	60fb      	str	r3, [r7, #12]
  /* Set the new external trigger edge for injected group */
  tmpreg |= ADC_ExternalTrigInjecConvEdge;
 800858c:	68fa      	ldr	r2, [r7, #12]
 800858e:	683b      	ldr	r3, [r7, #0]
 8008590:	4313      	orrs	r3, r2
 8008592:	60fb      	str	r3, [r7, #12]
  /* Store the new register value */
  ADCx->CR2 = tmpreg;
 8008594:	687b      	ldr	r3, [r7, #4]
 8008596:	68fa      	ldr	r2, [r7, #12]
 8008598:	609a      	str	r2, [r3, #8]
}
 800859a:	bf00      	nop
 800859c:	3714      	adds	r7, #20
 800859e:	46bd      	mov	sp, r7
 80085a0:	f85d 7b04 	ldr.w	r7, [sp], #4
 80085a4:	4770      	bx	lr

080085a6 <ADC_SoftwareStartInjectedConv>:
  * @brief  Enables the selected ADC software start conversion of the injected channels.
  * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
  * @retval None
  */
void ADC_SoftwareStartInjectedConv(ADC_TypeDef* ADCx)
{
 80085a6:	b480      	push	{r7}
 80085a8:	b083      	sub	sp, #12
 80085aa:	af00      	add	r7, sp, #0
 80085ac:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  /* Enable the selected ADC conversion for injected group */
  ADCx->CR2 |= (uint32_t)ADC_CR2_JSWSTART;
 80085ae:	687b      	ldr	r3, [r7, #4]
 80085b0:	689b      	ldr	r3, [r3, #8]
 80085b2:	f443 0280 	orr.w	r2, r3, #4194304	; 0x400000
 80085b6:	687b      	ldr	r3, [r7, #4]
 80085b8:	609a      	str	r2, [r3, #8]
}
 80085ba:	bf00      	nop
 80085bc:	370c      	adds	r7, #12
 80085be:	46bd      	mov	sp, r7
 80085c0:	f85d 7b04 	ldr.w	r7, [sp], #4
 80085c4:	4770      	bx	lr

080085c6 <ADC_GetSoftwareStartInjectedConvCmdStatus>:
  * @brief  Gets the selected ADC Software start injected conversion Status.
  * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
  * @retval The new state of ADC software start injected conversion (SET or RESET).
  */
FlagStatus ADC_GetSoftwareStartInjectedConvCmdStatus(ADC_TypeDef* ADCx)
{
 80085c6:	b480      	push	{r7}
 80085c8:	b085      	sub	sp, #20
 80085ca:	af00      	add	r7, sp, #0
 80085cc:	6078      	str	r0, [r7, #4]
  FlagStatus bitstatus = RESET;
 80085ce:	2300      	movs	r3, #0
 80085d0:	73fb      	strb	r3, [r7, #15]
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  
  /* Check the status of JSWSTART bit */
  if ((ADCx->CR2 & ADC_CR2_JSWSTART) != (uint32_t)RESET)
 80085d2:	687b      	ldr	r3, [r7, #4]
 80085d4:	689b      	ldr	r3, [r3, #8]
 80085d6:	f403 0380 	and.w	r3, r3, #4194304	; 0x400000
 80085da:	2b00      	cmp	r3, #0
 80085dc:	d002      	beq.n	80085e4 <ADC_GetSoftwareStartInjectedConvCmdStatus+0x1e>
  {
    /* JSWSTART bit is set */
    bitstatus = SET;
 80085de:	2301      	movs	r3, #1
 80085e0:	73fb      	strb	r3, [r7, #15]
 80085e2:	e001      	b.n	80085e8 <ADC_GetSoftwareStartInjectedConvCmdStatus+0x22>
  }
  else
  {
    /* JSWSTART bit is reset */
    bitstatus = RESET;
 80085e4:	2300      	movs	r3, #0
 80085e6:	73fb      	strb	r3, [r7, #15]
  }
  /* Return the JSWSTART bit status */
  return  bitstatus;
 80085e8:	7bfb      	ldrb	r3, [r7, #15]
}
 80085ea:	4618      	mov	r0, r3
 80085ec:	3714      	adds	r7, #20
 80085ee:	46bd      	mov	sp, r7
 80085f0:	f85d 7b04 	ldr.w	r7, [sp], #4
 80085f4:	4770      	bx	lr

080085f6 <ADC_AutoInjectedConvCmd>:
  * @param  NewState: new state of the selected ADC auto injected conversion
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void ADC_AutoInjectedConvCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
{
 80085f6:	b480      	push	{r7}
 80085f8:	b083      	sub	sp, #12
 80085fa:	af00      	add	r7, sp, #0
 80085fc:	6078      	str	r0, [r7, #4]
 80085fe:	460b      	mov	r3, r1
 8008600:	70fb      	strb	r3, [r7, #3]
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 8008602:	78fb      	ldrb	r3, [r7, #3]
 8008604:	2b00      	cmp	r3, #0
 8008606:	d006      	beq.n	8008616 <ADC_AutoInjectedConvCmd+0x20>
  {
    /* Enable the selected ADC automatic injected group conversion */
    ADCx->CR1 |= (uint32_t)ADC_CR1_JAUTO;
 8008608:	687b      	ldr	r3, [r7, #4]
 800860a:	685b      	ldr	r3, [r3, #4]
 800860c:	f443 6280 	orr.w	r2, r3, #1024	; 0x400
 8008610:	687b      	ldr	r3, [r7, #4]
 8008612:	605a      	str	r2, [r3, #4]
  else
  {
    /* Disable the selected ADC automatic injected group conversion */
    ADCx->CR1 &= (uint32_t)(~ADC_CR1_JAUTO);
  }
}
 8008614:	e005      	b.n	8008622 <ADC_AutoInjectedConvCmd+0x2c>
    ADCx->CR1 &= (uint32_t)(~ADC_CR1_JAUTO);
 8008616:	687b      	ldr	r3, [r7, #4]
 8008618:	685b      	ldr	r3, [r3, #4]
 800861a:	f423 6280 	bic.w	r2, r3, #1024	; 0x400
 800861e:	687b      	ldr	r3, [r7, #4]
 8008620:	605a      	str	r2, [r3, #4]
}
 8008622:	bf00      	nop
 8008624:	370c      	adds	r7, #12
 8008626:	46bd      	mov	sp, r7
 8008628:	f85d 7b04 	ldr.w	r7, [sp], #4
 800862c:	4770      	bx	lr

0800862e <ADC_InjectedDiscModeCmd>:
  *         group channel.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void ADC_InjectedDiscModeCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
{
 800862e:	b480      	push	{r7}
 8008630:	b083      	sub	sp, #12
 8008632:	af00      	add	r7, sp, #0
 8008634:	6078      	str	r0, [r7, #4]
 8008636:	460b      	mov	r3, r1
 8008638:	70fb      	strb	r3, [r7, #3]
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 800863a:	78fb      	ldrb	r3, [r7, #3]
 800863c:	2b00      	cmp	r3, #0
 800863e:	d006      	beq.n	800864e <ADC_InjectedDiscModeCmd+0x20>
  {
    /* Enable the selected ADC injected discontinuous mode */
    ADCx->CR1 |= (uint32_t)ADC_CR1_JDISCEN;
 8008640:	687b      	ldr	r3, [r7, #4]
 8008642:	685b      	ldr	r3, [r3, #4]
 8008644:	f443 5280 	orr.w	r2, r3, #4096	; 0x1000
 8008648:	687b      	ldr	r3, [r7, #4]
 800864a:	605a      	str	r2, [r3, #4]
  else
  {
    /* Disable the selected ADC injected discontinuous mode */
    ADCx->CR1 &= (uint32_t)(~ADC_CR1_JDISCEN);
  }
}
 800864c:	e005      	b.n	800865a <ADC_InjectedDiscModeCmd+0x2c>
    ADCx->CR1 &= (uint32_t)(~ADC_CR1_JDISCEN);
 800864e:	687b      	ldr	r3, [r7, #4]
 8008650:	685b      	ldr	r3, [r3, #4]
 8008652:	f423 5280 	bic.w	r2, r3, #4096	; 0x1000
 8008656:	687b      	ldr	r3, [r7, #4]
 8008658:	605a      	str	r2, [r3, #4]
}
 800865a:	bf00      	nop
 800865c:	370c      	adds	r7, #12
 800865e:	46bd      	mov	sp, r7
 8008660:	f85d 7b04 	ldr.w	r7, [sp], #4
 8008664:	4770      	bx	lr

08008666 <ADC_GetInjectedConversionValue>:
  *            @arg ADC_InjectedChannel_3: Injected Channel3 selected
  *            @arg ADC_InjectedChannel_4: Injected Channel4 selected
  * @retval The Data conversion value.
  */
uint16_t ADC_GetInjectedConversionValue(ADC_TypeDef* ADCx, uint8_t ADC_InjectedChannel)
{
 8008666:	b480      	push	{r7}
 8008668:	b085      	sub	sp, #20
 800866a:	af00      	add	r7, sp, #0
 800866c:	6078      	str	r0, [r7, #4]
 800866e:	460b      	mov	r3, r1
 8008670:	70fb      	strb	r3, [r7, #3]
  __IO uint32_t tmp = 0;
 8008672:	2300      	movs	r3, #0
 8008674:	60fb      	str	r3, [r7, #12]
  
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_ADC_INJECTED_CHANNEL(ADC_InjectedChannel));

  tmp = (uint32_t)ADCx;
 8008676:	687b      	ldr	r3, [r7, #4]
 8008678:	60fb      	str	r3, [r7, #12]
  tmp += ADC_InjectedChannel + JDR_OFFSET;
 800867a:	78fa      	ldrb	r2, [r7, #3]
 800867c:	68fb      	ldr	r3, [r7, #12]
 800867e:	4413      	add	r3, r2
 8008680:	3328      	adds	r3, #40	; 0x28
 8008682:	60fb      	str	r3, [r7, #12]
  
  /* Returns the selected injected channel conversion data value */
  return (uint16_t) (*(__IO uint32_t*)  tmp); 
 8008684:	68fb      	ldr	r3, [r7, #12]
 8008686:	681b      	ldr	r3, [r3, #0]
 8008688:	b29b      	uxth	r3, r3
}
 800868a:	4618      	mov	r0, r3
 800868c:	3714      	adds	r7, #20
 800868e:	46bd      	mov	sp, r7
 8008690:	f85d 7b04 	ldr.w	r7, [sp], #4
 8008694:	4770      	bx	lr

08008696 <ADC_ITConfig>:
  * @param  NewState: new state of the specified ADC interrupts.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void ADC_ITConfig(ADC_TypeDef* ADCx, uint16_t ADC_IT, FunctionalState NewState)  
{
 8008696:	b480      	push	{r7}
 8008698:	b085      	sub	sp, #20
 800869a:	af00      	add	r7, sp, #0
 800869c:	6078      	str	r0, [r7, #4]
 800869e:	460b      	mov	r3, r1
 80086a0:	807b      	strh	r3, [r7, #2]
 80086a2:	4613      	mov	r3, r2
 80086a4:	707b      	strb	r3, [r7, #1]
  uint32_t itmask = 0;
 80086a6:	2300      	movs	r3, #0
 80086a8:	60fb      	str	r3, [r7, #12]
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  assert_param(IS_ADC_IT(ADC_IT)); 

  /* Get the ADC IT index */
  itmask = (uint8_t)ADC_IT;
 80086aa:	887b      	ldrh	r3, [r7, #2]
 80086ac:	b2db      	uxtb	r3, r3
 80086ae:	60fb      	str	r3, [r7, #12]
  itmask = (uint32_t)0x01 << itmask;    
 80086b0:	2201      	movs	r2, #1
 80086b2:	68fb      	ldr	r3, [r7, #12]
 80086b4:	fa02 f303 	lsl.w	r3, r2, r3
 80086b8:	60fb      	str	r3, [r7, #12]

  if (NewState != DISABLE)
 80086ba:	787b      	ldrb	r3, [r7, #1]
 80086bc:	2b00      	cmp	r3, #0
 80086be:	d006      	beq.n	80086ce <ADC_ITConfig+0x38>
  {
    /* Enable the selected ADC interrupts */
    ADCx->CR1 |= itmask;
 80086c0:	687b      	ldr	r3, [r7, #4]
 80086c2:	685a      	ldr	r2, [r3, #4]
 80086c4:	68fb      	ldr	r3, [r7, #12]
 80086c6:	431a      	orrs	r2, r3
 80086c8:	687b      	ldr	r3, [r7, #4]
 80086ca:	605a      	str	r2, [r3, #4]
  else
  {
    /* Disable the selected ADC interrupts */
    ADCx->CR1 &= (~(uint32_t)itmask);
  }
}
 80086cc:	e006      	b.n	80086dc <ADC_ITConfig+0x46>
    ADCx->CR1 &= (~(uint32_t)itmask);
 80086ce:	687b      	ldr	r3, [r7, #4]
 80086d0:	685a      	ldr	r2, [r3, #4]
 80086d2:	68fb      	ldr	r3, [r7, #12]
 80086d4:	43db      	mvns	r3, r3
 80086d6:	401a      	ands	r2, r3
 80086d8:	687b      	ldr	r3, [r7, #4]
 80086da:	605a      	str	r2, [r3, #4]
}
 80086dc:	bf00      	nop
 80086de:	3714      	adds	r7, #20
 80086e0:	46bd      	mov	sp, r7
 80086e2:	f85d 7b04 	ldr.w	r7, [sp], #4
 80086e6:	4770      	bx	lr

080086e8 <ADC_GetFlagStatus>:
  *            @arg ADC_FLAG_STRT: Start of regular group conversion flag
  *            @arg ADC_FLAG_OVR: Overrun flag                                                 
  * @retval The new state of ADC_FLAG (SET or RESET).
  */
FlagStatus ADC_GetFlagStatus(ADC_TypeDef* ADCx, uint8_t ADC_FLAG)
{
 80086e8:	b480      	push	{r7}
 80086ea:	b085      	sub	sp, #20
 80086ec:	af00      	add	r7, sp, #0
 80086ee:	6078      	str	r0, [r7, #4]
 80086f0:	460b      	mov	r3, r1
 80086f2:	70fb      	strb	r3, [r7, #3]
  FlagStatus bitstatus = RESET;
 80086f4:	2300      	movs	r3, #0
 80086f6:	73fb      	strb	r3, [r7, #15]
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_ADC_GET_FLAG(ADC_FLAG));

  /* Check the status of the specified ADC flag */
  if ((ADCx->SR & ADC_FLAG) != (uint8_t)RESET)
 80086f8:	687b      	ldr	r3, [r7, #4]
 80086fa:	681a      	ldr	r2, [r3, #0]
 80086fc:	78fb      	ldrb	r3, [r7, #3]
 80086fe:	4013      	ands	r3, r2
 8008700:	2b00      	cmp	r3, #0
 8008702:	d002      	beq.n	800870a <ADC_GetFlagStatus+0x22>
  {
    /* ADC_FLAG is set */
    bitstatus = SET;
 8008704:	2301      	movs	r3, #1
 8008706:	73fb      	strb	r3, [r7, #15]
 8008708:	e001      	b.n	800870e <ADC_GetFlagStatus+0x26>
  }
  else
  {
    /* ADC_FLAG is reset */
    bitstatus = RESET;
 800870a:	2300      	movs	r3, #0
 800870c:	73fb      	strb	r3, [r7, #15]
  }
  /* Return the ADC_FLAG status */
  return  bitstatus;
 800870e:	7bfb      	ldrb	r3, [r7, #15]
}
 8008710:	4618      	mov	r0, r3
 8008712:	3714      	adds	r7, #20
 8008714:	46bd      	mov	sp, r7
 8008716:	f85d 7b04 	ldr.w	r7, [sp], #4
 800871a:	4770      	bx	lr

0800871c <ADC_ClearFlag>:
  *            @arg ADC_FLAG_STRT: Start of regular group conversion flag
  *            @arg ADC_FLAG_OVR: Overrun flag                          
  * @retval None
  */
void ADC_ClearFlag(ADC_TypeDef* ADCx, uint8_t ADC_FLAG)
{
 800871c:	b480      	push	{r7}
 800871e:	b083      	sub	sp, #12
 8008720:	af00      	add	r7, sp, #0
 8008722:	6078      	str	r0, [r7, #4]
 8008724:	460b      	mov	r3, r1
 8008726:	70fb      	strb	r3, [r7, #3]
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_ADC_CLEAR_FLAG(ADC_FLAG));

  /* Clear the selected ADC flags */
  ADCx->SR = ~(uint32_t)ADC_FLAG;
 8008728:	78fb      	ldrb	r3, [r7, #3]
 800872a:	43da      	mvns	r2, r3
 800872c:	687b      	ldr	r3, [r7, #4]
 800872e:	601a      	str	r2, [r3, #0]
}
 8008730:	bf00      	nop
 8008732:	370c      	adds	r7, #12
 8008734:	46bd      	mov	sp, r7
 8008736:	f85d 7b04 	ldr.w	r7, [sp], #4
 800873a:	4770      	bx	lr

0800873c <ADC_GetITStatus>:
  *            @arg ADC_IT_JEOC: End of injected conversion interrupt mask
  *            @arg ADC_IT_OVR: Overrun interrupt mask                        
  * @retval The new state of ADC_IT (SET or RESET).
  */
ITStatus ADC_GetITStatus(ADC_TypeDef* ADCx, uint16_t ADC_IT)
{
 800873c:	b480      	push	{r7}
 800873e:	b087      	sub	sp, #28
 8008740:	af00      	add	r7, sp, #0
 8008742:	6078      	str	r0, [r7, #4]
 8008744:	460b      	mov	r3, r1
 8008746:	807b      	strh	r3, [r7, #2]
  ITStatus bitstatus = RESET;
 8008748:	2300      	movs	r3, #0
 800874a:	75fb      	strb	r3, [r7, #23]
  uint32_t itmask = 0, enablestatus = 0;
 800874c:	2300      	movs	r3, #0
 800874e:	613b      	str	r3, [r7, #16]
 8008750:	2300      	movs	r3, #0
 8008752:	60fb      	str	r3, [r7, #12]
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_ADC_IT(ADC_IT));

  /* Get the ADC IT index */
  itmask = ADC_IT >> 8;
 8008754:	887b      	ldrh	r3, [r7, #2]
 8008756:	0a1b      	lsrs	r3, r3, #8
 8008758:	b29b      	uxth	r3, r3
 800875a:	613b      	str	r3, [r7, #16]

  /* Get the ADC_IT enable bit status */
  enablestatus = (ADCx->CR1 & ((uint32_t)0x01 << (uint8_t)ADC_IT)) ;
 800875c:	687b      	ldr	r3, [r7, #4]
 800875e:	685a      	ldr	r2, [r3, #4]
 8008760:	887b      	ldrh	r3, [r7, #2]
 8008762:	b2db      	uxtb	r3, r3
 8008764:	4619      	mov	r1, r3
 8008766:	2301      	movs	r3, #1
 8008768:	408b      	lsls	r3, r1
 800876a:	4013      	ands	r3, r2
 800876c:	60fb      	str	r3, [r7, #12]

  /* Check the status of the specified ADC interrupt */
  if (((ADCx->SR & itmask) != (uint32_t)RESET) && enablestatus)
 800876e:	687b      	ldr	r3, [r7, #4]
 8008770:	681a      	ldr	r2, [r3, #0]
 8008772:	693b      	ldr	r3, [r7, #16]
 8008774:	4013      	ands	r3, r2
 8008776:	2b00      	cmp	r3, #0
 8008778:	d005      	beq.n	8008786 <ADC_GetITStatus+0x4a>
 800877a:	68fb      	ldr	r3, [r7, #12]
 800877c:	2b00      	cmp	r3, #0
 800877e:	d002      	beq.n	8008786 <ADC_GetITStatus+0x4a>
  {
    /* ADC_IT is set */
    bitstatus = SET;
 8008780:	2301      	movs	r3, #1
 8008782:	75fb      	strb	r3, [r7, #23]
 8008784:	e001      	b.n	800878a <ADC_GetITStatus+0x4e>
  }
  else
  {
    /* ADC_IT is reset */
    bitstatus = RESET;
 8008786:	2300      	movs	r3, #0
 8008788:	75fb      	strb	r3, [r7, #23]
  }
  /* Return the ADC_IT status */
  return  bitstatus;
 800878a:	7dfb      	ldrb	r3, [r7, #23]
}
 800878c:	4618      	mov	r0, r3
 800878e:	371c      	adds	r7, #28
 8008790:	46bd      	mov	sp, r7
 8008792:	f85d 7b04 	ldr.w	r7, [sp], #4
 8008796:	4770      	bx	lr

08008798 <ADC_ClearITPendingBit>:
  *            @arg ADC_IT_JEOC: End of injected conversion interrupt mask
  *            @arg ADC_IT_OVR: Overrun interrupt mask                         
  * @retval None
  */
void ADC_ClearITPendingBit(ADC_TypeDef* ADCx, uint16_t ADC_IT)
{
 8008798:	b480      	push	{r7}
 800879a:	b085      	sub	sp, #20
 800879c:	af00      	add	r7, sp, #0
 800879e:	6078      	str	r0, [r7, #4]
 80087a0:	460b      	mov	r3, r1
 80087a2:	807b      	strh	r3, [r7, #2]
  uint8_t itmask = 0;
 80087a4:	2300      	movs	r3, #0
 80087a6:	73fb      	strb	r3, [r7, #15]
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_ADC_IT(ADC_IT)); 
  /* Get the ADC IT index */
  itmask = (uint8_t)(ADC_IT >> 8);
 80087a8:	887b      	ldrh	r3, [r7, #2]
 80087aa:	0a1b      	lsrs	r3, r3, #8
 80087ac:	b29b      	uxth	r3, r3
 80087ae:	73fb      	strb	r3, [r7, #15]
  /* Clear the selected ADC interrupt pending bits */
  ADCx->SR = ~(uint32_t)itmask;
 80087b0:	7bfb      	ldrb	r3, [r7, #15]
 80087b2:	43da      	mvns	r2, r3
 80087b4:	687b      	ldr	r3, [r7, #4]
 80087b6:	601a      	str	r2, [r3, #0]
}                    
 80087b8:	bf00      	nop
 80087ba:	3714      	adds	r7, #20
 80087bc:	46bd      	mov	sp, r7
 80087be:	f85d 7b04 	ldr.w	r7, [sp], #4
 80087c2:	4770      	bx	lr

080087c4 <CAN_DeInit>:
  * @brief  Deinitializes the CAN peripheral registers to their default reset values.
  * @param  CANx: where x can be 1 or 2 to select the CAN peripheral.
  * @retval None.
  */
void CAN_DeInit(CAN_TypeDef* CANx)
{
 80087c4:	b580      	push	{r7, lr}
 80087c6:	b082      	sub	sp, #8
 80087c8:	af00      	add	r7, sp, #0
 80087ca:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_CAN_ALL_PERIPH(CANx));
 
  if (CANx == CAN1)
 80087cc:	687b      	ldr	r3, [r7, #4]
 80087ce:	4a0e      	ldr	r2, [pc, #56]	; (8008808 <CAN_DeInit+0x44>)
 80087d0:	4293      	cmp	r3, r2
 80087d2:	d10a      	bne.n	80087ea <CAN_DeInit+0x26>
  {
    /* Enable CAN1 reset state */
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_CAN1, ENABLE);
 80087d4:	2101      	movs	r1, #1
 80087d6:	f04f 7000 	mov.w	r0, #33554432	; 0x2000000
 80087da:	f007 f89b 	bl	800f914 <RCC_APB1PeriphResetCmd>
    /* Release CAN1 from reset state */
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_CAN1, DISABLE);
 80087de:	2100      	movs	r1, #0
 80087e0:	f04f 7000 	mov.w	r0, #33554432	; 0x2000000
 80087e4:	f007 f896 	bl	800f914 <RCC_APB1PeriphResetCmd>
    /* Enable CAN2 reset state */
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_CAN2, ENABLE);
    /* Release CAN2 from reset state */
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_CAN2, DISABLE);
  }
}
 80087e8:	e009      	b.n	80087fe <CAN_DeInit+0x3a>
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_CAN2, ENABLE);
 80087ea:	2101      	movs	r1, #1
 80087ec:	f04f 6080 	mov.w	r0, #67108864	; 0x4000000
 80087f0:	f007 f890 	bl	800f914 <RCC_APB1PeriphResetCmd>
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_CAN2, DISABLE);
 80087f4:	2100      	movs	r1, #0
 80087f6:	f04f 6080 	mov.w	r0, #67108864	; 0x4000000
 80087fa:	f007 f88b 	bl	800f914 <RCC_APB1PeriphResetCmd>
}
 80087fe:	bf00      	nop
 8008800:	3708      	adds	r7, #8
 8008802:	46bd      	mov	sp, r7
 8008804:	bd80      	pop	{r7, pc}
 8008806:	bf00      	nop
 8008808:	40006400 	.word	0x40006400

0800880c <CAN_Init>:
  *         the configuration information for the CAN peripheral.
  * @retval Constant indicates initialization succeed which will be 
  *         CAN_InitStatus_Failed or CAN_InitStatus_Success.
  */
uint8_t CAN_Init(CAN_TypeDef* CANx, CAN_InitTypeDef* CAN_InitStruct)
{
 800880c:	b480      	push	{r7}
 800880e:	b085      	sub	sp, #20
 8008810:	af00      	add	r7, sp, #0
 8008812:	6078      	str	r0, [r7, #4]
 8008814:	6039      	str	r1, [r7, #0]
  uint8_t InitStatus = CAN_InitStatus_Failed;
 8008816:	2300      	movs	r3, #0
 8008818:	73fb      	strb	r3, [r7, #15]
  uint32_t wait_ack = 0x00000000;
 800881a:	2300      	movs	r3, #0
 800881c:	60bb      	str	r3, [r7, #8]
  assert_param(IS_CAN_BS1(CAN_InitStruct->CAN_BS1));
  assert_param(IS_CAN_BS2(CAN_InitStruct->CAN_BS2));
  assert_param(IS_CAN_PRESCALER(CAN_InitStruct->CAN_Prescaler));

  /* Exit from sleep mode */
  CANx->MCR &= (~(uint32_t)CAN_MCR_SLEEP);
 800881e:	687b      	ldr	r3, [r7, #4]
 8008820:	681b      	ldr	r3, [r3, #0]
 8008822:	f023 0202 	bic.w	r2, r3, #2
 8008826:	687b      	ldr	r3, [r7, #4]
 8008828:	601a      	str	r2, [r3, #0]

  /* Request initialisation */
  CANx->MCR |= CAN_MCR_INRQ ;
 800882a:	687b      	ldr	r3, [r7, #4]
 800882c:	681b      	ldr	r3, [r3, #0]
 800882e:	f043 0201 	orr.w	r2, r3, #1
 8008832:	687b      	ldr	r3, [r7, #4]
 8008834:	601a      	str	r2, [r3, #0]

  /* Wait the acknowledge */
  while (((CANx->MSR & CAN_MSR_INAK) != CAN_MSR_INAK) && (wait_ack != INAK_TIMEOUT))
 8008836:	e002      	b.n	800883e <CAN_Init+0x32>
  {
    wait_ack++;
 8008838:	68bb      	ldr	r3, [r7, #8]
 800883a:	3301      	adds	r3, #1
 800883c:	60bb      	str	r3, [r7, #8]
  while (((CANx->MSR & CAN_MSR_INAK) != CAN_MSR_INAK) && (wait_ack != INAK_TIMEOUT))
 800883e:	687b      	ldr	r3, [r7, #4]
 8008840:	685b      	ldr	r3, [r3, #4]
 8008842:	f003 0301 	and.w	r3, r3, #1
 8008846:	2b01      	cmp	r3, #1
 8008848:	d004      	beq.n	8008854 <CAN_Init+0x48>
 800884a:	68bb      	ldr	r3, [r7, #8]
 800884c:	f64f 72ff 	movw	r2, #65535	; 0xffff
 8008850:	4293      	cmp	r3, r2
 8008852:	d1f1      	bne.n	8008838 <CAN_Init+0x2c>
  }

  /* Check acknowledge */
  if ((CANx->MSR & CAN_MSR_INAK) != CAN_MSR_INAK)
 8008854:	687b      	ldr	r3, [r7, #4]
 8008856:	685b      	ldr	r3, [r3, #4]
 8008858:	f003 0301 	and.w	r3, r3, #1
 800885c:	2b01      	cmp	r3, #1
 800885e:	d002      	beq.n	8008866 <CAN_Init+0x5a>
  {
    InitStatus = CAN_InitStatus_Failed;
 8008860:	2300      	movs	r3, #0
 8008862:	73fb      	strb	r3, [r7, #15]
 8008864:	e09c      	b.n	80089a0 <CAN_Init+0x194>
  }
  else 
  {
    /* Set the time triggered communication mode */
    if (CAN_InitStruct->CAN_TTCM == ENABLE)
 8008866:	683b      	ldr	r3, [r7, #0]
 8008868:	799b      	ldrb	r3, [r3, #6]
 800886a:	2b01      	cmp	r3, #1
 800886c:	d106      	bne.n	800887c <CAN_Init+0x70>
    {
      CANx->MCR |= CAN_MCR_TTCM;
 800886e:	687b      	ldr	r3, [r7, #4]
 8008870:	681b      	ldr	r3, [r3, #0]
 8008872:	f043 0280 	orr.w	r2, r3, #128	; 0x80
 8008876:	687b      	ldr	r3, [r7, #4]
 8008878:	601a      	str	r2, [r3, #0]
 800887a:	e005      	b.n	8008888 <CAN_Init+0x7c>
    }
    else
    {
      CANx->MCR &= ~(uint32_t)CAN_MCR_TTCM;
 800887c:	687b      	ldr	r3, [r7, #4]
 800887e:	681b      	ldr	r3, [r3, #0]
 8008880:	f023 0280 	bic.w	r2, r3, #128	; 0x80
 8008884:	687b      	ldr	r3, [r7, #4]
 8008886:	601a      	str	r2, [r3, #0]
    }

    /* Set the automatic bus-off management */
    if (CAN_InitStruct->CAN_ABOM == ENABLE)
 8008888:	683b      	ldr	r3, [r7, #0]
 800888a:	79db      	ldrb	r3, [r3, #7]
 800888c:	2b01      	cmp	r3, #1
 800888e:	d106      	bne.n	800889e <CAN_Init+0x92>
    {
      CANx->MCR |= CAN_MCR_ABOM;
 8008890:	687b      	ldr	r3, [r7, #4]
 8008892:	681b      	ldr	r3, [r3, #0]
 8008894:	f043 0240 	orr.w	r2, r3, #64	; 0x40
 8008898:	687b      	ldr	r3, [r7, #4]
 800889a:	601a      	str	r2, [r3, #0]
 800889c:	e005      	b.n	80088aa <CAN_Init+0x9e>
    }
    else
    {
      CANx->MCR &= ~(uint32_t)CAN_MCR_ABOM;
 800889e:	687b      	ldr	r3, [r7, #4]
 80088a0:	681b      	ldr	r3, [r3, #0]
 80088a2:	f023 0240 	bic.w	r2, r3, #64	; 0x40
 80088a6:	687b      	ldr	r3, [r7, #4]
 80088a8:	601a      	str	r2, [r3, #0]
    }

    /* Set the automatic wake-up mode */
    if (CAN_InitStruct->CAN_AWUM == ENABLE)
 80088aa:	683b      	ldr	r3, [r7, #0]
 80088ac:	7a1b      	ldrb	r3, [r3, #8]
 80088ae:	2b01      	cmp	r3, #1
 80088b0:	d106      	bne.n	80088c0 <CAN_Init+0xb4>
    {
      CANx->MCR |= CAN_MCR_AWUM;
 80088b2:	687b      	ldr	r3, [r7, #4]
 80088b4:	681b      	ldr	r3, [r3, #0]
 80088b6:	f043 0220 	orr.w	r2, r3, #32
 80088ba:	687b      	ldr	r3, [r7, #4]
 80088bc:	601a      	str	r2, [r3, #0]
 80088be:	e005      	b.n	80088cc <CAN_Init+0xc0>
    }
    else
    {
      CANx->MCR &= ~(uint32_t)CAN_MCR_AWUM;
 80088c0:	687b      	ldr	r3, [r7, #4]
 80088c2:	681b      	ldr	r3, [r3, #0]
 80088c4:	f023 0220 	bic.w	r2, r3, #32
 80088c8:	687b      	ldr	r3, [r7, #4]
 80088ca:	601a      	str	r2, [r3, #0]
    }

    /* Set the no automatic retransmission */
    if (CAN_InitStruct->CAN_NART == ENABLE)
 80088cc:	683b      	ldr	r3, [r7, #0]
 80088ce:	7a5b      	ldrb	r3, [r3, #9]
 80088d0:	2b01      	cmp	r3, #1
 80088d2:	d106      	bne.n	80088e2 <CAN_Init+0xd6>
    {
      CANx->MCR |= CAN_MCR_NART;
 80088d4:	687b      	ldr	r3, [r7, #4]
 80088d6:	681b      	ldr	r3, [r3, #0]
 80088d8:	f043 0210 	orr.w	r2, r3, #16
 80088dc:	687b      	ldr	r3, [r7, #4]
 80088de:	601a      	str	r2, [r3, #0]
 80088e0:	e005      	b.n	80088ee <CAN_Init+0xe2>
    }
    else
    {
      CANx->MCR &= ~(uint32_t)CAN_MCR_NART;
 80088e2:	687b      	ldr	r3, [r7, #4]
 80088e4:	681b      	ldr	r3, [r3, #0]
 80088e6:	f023 0210 	bic.w	r2, r3, #16
 80088ea:	687b      	ldr	r3, [r7, #4]
 80088ec:	601a      	str	r2, [r3, #0]
    }

    /* Set the receive FIFO locked mode */
    if (CAN_InitStruct->CAN_RFLM == ENABLE)
 80088ee:	683b      	ldr	r3, [r7, #0]
 80088f0:	7a9b      	ldrb	r3, [r3, #10]
 80088f2:	2b01      	cmp	r3, #1
 80088f4:	d106      	bne.n	8008904 <CAN_Init+0xf8>
    {
      CANx->MCR |= CAN_MCR_RFLM;
 80088f6:	687b      	ldr	r3, [r7, #4]
 80088f8:	681b      	ldr	r3, [r3, #0]
 80088fa:	f043 0208 	orr.w	r2, r3, #8
 80088fe:	687b      	ldr	r3, [r7, #4]
 8008900:	601a      	str	r2, [r3, #0]
 8008902:	e005      	b.n	8008910 <CAN_Init+0x104>
    }
    else
    {
      CANx->MCR &= ~(uint32_t)CAN_MCR_RFLM;
 8008904:	687b      	ldr	r3, [r7, #4]
 8008906:	681b      	ldr	r3, [r3, #0]
 8008908:	f023 0208 	bic.w	r2, r3, #8
 800890c:	687b      	ldr	r3, [r7, #4]
 800890e:	601a      	str	r2, [r3, #0]
    }

    /* Set the transmit FIFO priority */
    if (CAN_InitStruct->CAN_TXFP == ENABLE)
 8008910:	683b      	ldr	r3, [r7, #0]
 8008912:	7adb      	ldrb	r3, [r3, #11]
 8008914:	2b01      	cmp	r3, #1
 8008916:	d106      	bne.n	8008926 <CAN_Init+0x11a>
    {
      CANx->MCR |= CAN_MCR_TXFP;
 8008918:	687b      	ldr	r3, [r7, #4]
 800891a:	681b      	ldr	r3, [r3, #0]
 800891c:	f043 0204 	orr.w	r2, r3, #4
 8008920:	687b      	ldr	r3, [r7, #4]
 8008922:	601a      	str	r2, [r3, #0]
 8008924:	e005      	b.n	8008932 <CAN_Init+0x126>
    }
    else
    {
      CANx->MCR &= ~(uint32_t)CAN_MCR_TXFP;
 8008926:	687b      	ldr	r3, [r7, #4]
 8008928:	681b      	ldr	r3, [r3, #0]
 800892a:	f023 0204 	bic.w	r2, r3, #4
 800892e:	687b      	ldr	r3, [r7, #4]
 8008930:	601a      	str	r2, [r3, #0]
    }

    /* Set the bit timing register */
    CANx->BTR = (uint32_t)((uint32_t)CAN_InitStruct->CAN_Mode << 30) | \
 8008932:	683b      	ldr	r3, [r7, #0]
 8008934:	789b      	ldrb	r3, [r3, #2]
 8008936:	079a      	lsls	r2, r3, #30
                ((uint32_t)CAN_InitStruct->CAN_SJW << 24) | \
 8008938:	683b      	ldr	r3, [r7, #0]
 800893a:	78db      	ldrb	r3, [r3, #3]
 800893c:	061b      	lsls	r3, r3, #24
    CANx->BTR = (uint32_t)((uint32_t)CAN_InitStruct->CAN_Mode << 30) | \
 800893e:	431a      	orrs	r2, r3
                ((uint32_t)CAN_InitStruct->CAN_BS1 << 16) | \
 8008940:	683b      	ldr	r3, [r7, #0]
 8008942:	791b      	ldrb	r3, [r3, #4]
 8008944:	041b      	lsls	r3, r3, #16
                ((uint32_t)CAN_InitStruct->CAN_SJW << 24) | \
 8008946:	431a      	orrs	r2, r3
                ((uint32_t)CAN_InitStruct->CAN_BS2 << 20) | \
 8008948:	683b      	ldr	r3, [r7, #0]
 800894a:	795b      	ldrb	r3, [r3, #5]
 800894c:	051b      	lsls	r3, r3, #20
                ((uint32_t)CAN_InitStruct->CAN_BS1 << 16) | \
 800894e:	431a      	orrs	r2, r3
               ((uint32_t)CAN_InitStruct->CAN_Prescaler - 1);
 8008950:	683b      	ldr	r3, [r7, #0]
 8008952:	881b      	ldrh	r3, [r3, #0]
 8008954:	3b01      	subs	r3, #1
                ((uint32_t)CAN_InitStruct->CAN_BS2 << 20) | \
 8008956:	431a      	orrs	r2, r3
    CANx->BTR = (uint32_t)((uint32_t)CAN_InitStruct->CAN_Mode << 30) | \
 8008958:	687b      	ldr	r3, [r7, #4]
 800895a:	61da      	str	r2, [r3, #28]

    /* Request leave initialisation */
    CANx->MCR &= ~(uint32_t)CAN_MCR_INRQ;
 800895c:	687b      	ldr	r3, [r7, #4]
 800895e:	681b      	ldr	r3, [r3, #0]
 8008960:	f023 0201 	bic.w	r2, r3, #1
 8008964:	687b      	ldr	r3, [r7, #4]
 8008966:	601a      	str	r2, [r3, #0]

   /* Wait the acknowledge */
   wait_ack = 0;
 8008968:	2300      	movs	r3, #0
 800896a:	60bb      	str	r3, [r7, #8]

   while (((CANx->MSR & CAN_MSR_INAK) == CAN_MSR_INAK) && (wait_ack != INAK_TIMEOUT))
 800896c:	e002      	b.n	8008974 <CAN_Init+0x168>
   {
     wait_ack++;
 800896e:	68bb      	ldr	r3, [r7, #8]
 8008970:	3301      	adds	r3, #1
 8008972:	60bb      	str	r3, [r7, #8]
   while (((CANx->MSR & CAN_MSR_INAK) == CAN_MSR_INAK) && (wait_ack != INAK_TIMEOUT))
 8008974:	687b      	ldr	r3, [r7, #4]
 8008976:	685b      	ldr	r3, [r3, #4]
 8008978:	f003 0301 	and.w	r3, r3, #1
 800897c:	2b01      	cmp	r3, #1
 800897e:	d104      	bne.n	800898a <CAN_Init+0x17e>
 8008980:	68bb      	ldr	r3, [r7, #8]
 8008982:	f64f 72ff 	movw	r2, #65535	; 0xffff
 8008986:	4293      	cmp	r3, r2
 8008988:	d1f1      	bne.n	800896e <CAN_Init+0x162>
   }

    /* ...and check acknowledged */
    if ((CANx->MSR & CAN_MSR_INAK) == CAN_MSR_INAK)
 800898a:	687b      	ldr	r3, [r7, #4]
 800898c:	685b      	ldr	r3, [r3, #4]
 800898e:	f003 0301 	and.w	r3, r3, #1
 8008992:	2b01      	cmp	r3, #1
 8008994:	d102      	bne.n	800899c <CAN_Init+0x190>
    {
      InitStatus = CAN_InitStatus_Failed;
 8008996:	2300      	movs	r3, #0
 8008998:	73fb      	strb	r3, [r7, #15]
 800899a:	e001      	b.n	80089a0 <CAN_Init+0x194>
    }
    else
    {
      InitStatus = CAN_InitStatus_Success ;
 800899c:	2301      	movs	r3, #1
 800899e:	73fb      	strb	r3, [r7, #15]
    }
  }

  /* At this step, return the status of initialization */
  return InitStatus;
 80089a0:	7bfb      	ldrb	r3, [r7, #15]
}
 80089a2:	4618      	mov	r0, r3
 80089a4:	3714      	adds	r7, #20
 80089a6:	46bd      	mov	sp, r7
 80089a8:	f85d 7b04 	ldr.w	r7, [sp], #4
 80089ac:	4770      	bx	lr

080089ae <CAN_FilterInit>:
  * @param  CAN_FilterInitStruct: pointer to a CAN_FilterInitTypeDef structure that
  *         contains the configuration information.
  * @retval None
  */
void CAN_FilterInit(CAN_FilterInitTypeDef* CAN_FilterInitStruct)
{
 80089ae:	b480      	push	{r7}
 80089b0:	b085      	sub	sp, #20
 80089b2:	af00      	add	r7, sp, #0
 80089b4:	6078      	str	r0, [r7, #4]
  uint32_t filter_number_bit_pos = 0;
 80089b6:	2300      	movs	r3, #0
 80089b8:	60fb      	str	r3, [r7, #12]
  assert_param(IS_CAN_FILTER_MODE(CAN_FilterInitStruct->CAN_FilterMode));
  assert_param(IS_CAN_FILTER_SCALE(CAN_FilterInitStruct->CAN_FilterScale));
  assert_param(IS_CAN_FILTER_FIFO(CAN_FilterInitStruct->CAN_FilterFIFOAssignment));
  assert_param(IS_FUNCTIONAL_STATE(CAN_FilterInitStruct->CAN_FilterActivation));

  filter_number_bit_pos = ((uint32_t)1) << CAN_FilterInitStruct->CAN_FilterNumber;
 80089ba:	687b      	ldr	r3, [r7, #4]
 80089bc:	7a9b      	ldrb	r3, [r3, #10]
 80089be:	461a      	mov	r2, r3
 80089c0:	2301      	movs	r3, #1
 80089c2:	4093      	lsls	r3, r2
 80089c4:	60fb      	str	r3, [r7, #12]

  /* Initialisation mode for the filter */
  CAN1->FMR |= FMR_FINIT;
 80089c6:	4a56      	ldr	r2, [pc, #344]	; (8008b20 <CAN_FilterInit+0x172>)
 80089c8:	4b55      	ldr	r3, [pc, #340]	; (8008b20 <CAN_FilterInit+0x172>)
 80089ca:	f8d3 3200 	ldr.w	r3, [r3, #512]	; 0x200
 80089ce:	f043 0301 	orr.w	r3, r3, #1
 80089d2:	f8c2 3200 	str.w	r3, [r2, #512]	; 0x200

  /* Filter Deactivation */
  CAN1->FA1R &= ~(uint32_t)filter_number_bit_pos;
 80089d6:	4952      	ldr	r1, [pc, #328]	; (8008b20 <CAN_FilterInit+0x172>)
 80089d8:	4b51      	ldr	r3, [pc, #324]	; (8008b20 <CAN_FilterInit+0x172>)
 80089da:	f8d3 221c 	ldr.w	r2, [r3, #540]	; 0x21c
 80089de:	68fb      	ldr	r3, [r7, #12]
 80089e0:	43db      	mvns	r3, r3
 80089e2:	4013      	ands	r3, r2
 80089e4:	f8c1 321c 	str.w	r3, [r1, #540]	; 0x21c

  /* Filter Scale */
  if (CAN_FilterInitStruct->CAN_FilterScale == CAN_FilterScale_16bit)
 80089e8:	687b      	ldr	r3, [r7, #4]
 80089ea:	7b1b      	ldrb	r3, [r3, #12]
 80089ec:	2b00      	cmp	r3, #0
 80089ee:	d125      	bne.n	8008a3c <CAN_FilterInit+0x8e>
  {
    /* 16-bit scale for the filter */
    CAN1->FS1R &= ~(uint32_t)filter_number_bit_pos;
 80089f0:	494b      	ldr	r1, [pc, #300]	; (8008b20 <CAN_FilterInit+0x172>)
 80089f2:	4b4b      	ldr	r3, [pc, #300]	; (8008b20 <CAN_FilterInit+0x172>)
 80089f4:	f8d3 220c 	ldr.w	r2, [r3, #524]	; 0x20c
 80089f8:	68fb      	ldr	r3, [r7, #12]
 80089fa:	43db      	mvns	r3, r3
 80089fc:	4013      	ands	r3, r2
 80089fe:	f8c1 320c 	str.w	r3, [r1, #524]	; 0x20c

    /* First 16-bit identifier and First 16-bit mask */
    /* Or First 16-bit identifier and Second 16-bit identifier */
    CAN1->sFilterRegister[CAN_FilterInitStruct->CAN_FilterNumber].FR1 = 
 8008a02:	4947      	ldr	r1, [pc, #284]	; (8008b20 <CAN_FilterInit+0x172>)
 8008a04:	687b      	ldr	r3, [r7, #4]
 8008a06:	7a9b      	ldrb	r3, [r3, #10]
 8008a08:	4618      	mov	r0, r3
       ((0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterMaskIdLow) << 16) |
 8008a0a:	687b      	ldr	r3, [r7, #4]
 8008a0c:	88db      	ldrh	r3, [r3, #6]
 8008a0e:	041b      	lsls	r3, r3, #16
        (0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterIdLow);
 8008a10:	687a      	ldr	r2, [r7, #4]
 8008a12:	8852      	ldrh	r2, [r2, #2]
       ((0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterMaskIdLow) << 16) |
 8008a14:	431a      	orrs	r2, r3
    CAN1->sFilterRegister[CAN_FilterInitStruct->CAN_FilterNumber].FR1 = 
 8008a16:	f100 0348 	add.w	r3, r0, #72	; 0x48
 8008a1a:	f841 2033 	str.w	r2, [r1, r3, lsl #3]

    /* Second 16-bit identifier and Second 16-bit mask */
    /* Or Third 16-bit identifier and Fourth 16-bit identifier */
    CAN1->sFilterRegister[CAN_FilterInitStruct->CAN_FilterNumber].FR2 = 
 8008a1e:	4940      	ldr	r1, [pc, #256]	; (8008b20 <CAN_FilterInit+0x172>)
 8008a20:	687b      	ldr	r3, [r7, #4]
 8008a22:	7a9b      	ldrb	r3, [r3, #10]
 8008a24:	4618      	mov	r0, r3
       ((0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterMaskIdHigh) << 16) |
 8008a26:	687b      	ldr	r3, [r7, #4]
 8008a28:	889b      	ldrh	r3, [r3, #4]
 8008a2a:	041b      	lsls	r3, r3, #16
        (0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterIdHigh);
 8008a2c:	687a      	ldr	r2, [r7, #4]
 8008a2e:	8812      	ldrh	r2, [r2, #0]
       ((0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterMaskIdHigh) << 16) |
 8008a30:	431a      	orrs	r2, r3
    CAN1->sFilterRegister[CAN_FilterInitStruct->CAN_FilterNumber].FR2 = 
 8008a32:	f100 0348 	add.w	r3, r0, #72	; 0x48
 8008a36:	00db      	lsls	r3, r3, #3
 8008a38:	440b      	add	r3, r1
 8008a3a:	605a      	str	r2, [r3, #4]
  }

  if (CAN_FilterInitStruct->CAN_FilterScale == CAN_FilterScale_32bit)
 8008a3c:	687b      	ldr	r3, [r7, #4]
 8008a3e:	7b1b      	ldrb	r3, [r3, #12]
 8008a40:	2b01      	cmp	r3, #1
 8008a42:	d124      	bne.n	8008a8e <CAN_FilterInit+0xe0>
  {
    /* 32-bit scale for the filter */
    CAN1->FS1R |= filter_number_bit_pos;
 8008a44:	4936      	ldr	r1, [pc, #216]	; (8008b20 <CAN_FilterInit+0x172>)
 8008a46:	4b36      	ldr	r3, [pc, #216]	; (8008b20 <CAN_FilterInit+0x172>)
 8008a48:	f8d3 220c 	ldr.w	r2, [r3, #524]	; 0x20c
 8008a4c:	68fb      	ldr	r3, [r7, #12]
 8008a4e:	4313      	orrs	r3, r2
 8008a50:	f8c1 320c 	str.w	r3, [r1, #524]	; 0x20c
    /* 32-bit identifier or First 32-bit identifier */
    CAN1->sFilterRegister[CAN_FilterInitStruct->CAN_FilterNumber].FR1 = 
 8008a54:	4932      	ldr	r1, [pc, #200]	; (8008b20 <CAN_FilterInit+0x172>)
 8008a56:	687b      	ldr	r3, [r7, #4]
 8008a58:	7a9b      	ldrb	r3, [r3, #10]
 8008a5a:	4618      	mov	r0, r3
       ((0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterIdHigh) << 16) |
 8008a5c:	687b      	ldr	r3, [r7, #4]
 8008a5e:	881b      	ldrh	r3, [r3, #0]
 8008a60:	041b      	lsls	r3, r3, #16
        (0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterIdLow);
 8008a62:	687a      	ldr	r2, [r7, #4]
 8008a64:	8852      	ldrh	r2, [r2, #2]
       ((0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterIdHigh) << 16) |
 8008a66:	431a      	orrs	r2, r3
    CAN1->sFilterRegister[CAN_FilterInitStruct->CAN_FilterNumber].FR1 = 
 8008a68:	f100 0348 	add.w	r3, r0, #72	; 0x48
 8008a6c:	f841 2033 	str.w	r2, [r1, r3, lsl #3]
    /* 32-bit mask or Second 32-bit identifier */
    CAN1->sFilterRegister[CAN_FilterInitStruct->CAN_FilterNumber].FR2 = 
 8008a70:	492b      	ldr	r1, [pc, #172]	; (8008b20 <CAN_FilterInit+0x172>)
 8008a72:	687b      	ldr	r3, [r7, #4]
 8008a74:	7a9b      	ldrb	r3, [r3, #10]
 8008a76:	4618      	mov	r0, r3
       ((0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterMaskIdHigh) << 16) |
 8008a78:	687b      	ldr	r3, [r7, #4]
 8008a7a:	889b      	ldrh	r3, [r3, #4]
 8008a7c:	041b      	lsls	r3, r3, #16
        (0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterMaskIdLow);
 8008a7e:	687a      	ldr	r2, [r7, #4]
 8008a80:	88d2      	ldrh	r2, [r2, #6]
       ((0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterMaskIdHigh) << 16) |
 8008a82:	431a      	orrs	r2, r3
    CAN1->sFilterRegister[CAN_FilterInitStruct->CAN_FilterNumber].FR2 = 
 8008a84:	f100 0348 	add.w	r3, r0, #72	; 0x48
 8008a88:	00db      	lsls	r3, r3, #3
 8008a8a:	440b      	add	r3, r1
 8008a8c:	605a      	str	r2, [r3, #4]
  }

  /* Filter Mode */
  if (CAN_FilterInitStruct->CAN_FilterMode == CAN_FilterMode_IdMask)
 8008a8e:	687b      	ldr	r3, [r7, #4]
 8008a90:	7adb      	ldrb	r3, [r3, #11]
 8008a92:	2b00      	cmp	r3, #0
 8008a94:	d109      	bne.n	8008aaa <CAN_FilterInit+0xfc>
  {
    /*Id/Mask mode for the filter*/
    CAN1->FM1R &= ~(uint32_t)filter_number_bit_pos;
 8008a96:	4922      	ldr	r1, [pc, #136]	; (8008b20 <CAN_FilterInit+0x172>)
 8008a98:	4b21      	ldr	r3, [pc, #132]	; (8008b20 <CAN_FilterInit+0x172>)
 8008a9a:	f8d3 2204 	ldr.w	r2, [r3, #516]	; 0x204
 8008a9e:	68fb      	ldr	r3, [r7, #12]
 8008aa0:	43db      	mvns	r3, r3
 8008aa2:	4013      	ands	r3, r2
 8008aa4:	f8c1 3204 	str.w	r3, [r1, #516]	; 0x204
 8008aa8:	e007      	b.n	8008aba <CAN_FilterInit+0x10c>
  }
  else /* CAN_FilterInitStruct->CAN_FilterMode == CAN_FilterMode_IdList */
  {
    /*Identifier list mode for the filter*/
    CAN1->FM1R |= (uint32_t)filter_number_bit_pos;
 8008aaa:	491d      	ldr	r1, [pc, #116]	; (8008b20 <CAN_FilterInit+0x172>)
 8008aac:	4b1c      	ldr	r3, [pc, #112]	; (8008b20 <CAN_FilterInit+0x172>)
 8008aae:	f8d3 2204 	ldr.w	r2, [r3, #516]	; 0x204
 8008ab2:	68fb      	ldr	r3, [r7, #12]
 8008ab4:	4313      	orrs	r3, r2
 8008ab6:	f8c1 3204 	str.w	r3, [r1, #516]	; 0x204
  }

  /* Filter FIFO assignment */
  if (CAN_FilterInitStruct->CAN_FilterFIFOAssignment == CAN_Filter_FIFO0)
 8008aba:	687b      	ldr	r3, [r7, #4]
 8008abc:	891b      	ldrh	r3, [r3, #8]
 8008abe:	2b00      	cmp	r3, #0
 8008ac0:	d108      	bne.n	8008ad4 <CAN_FilterInit+0x126>
  {
    /* FIFO 0 assignation for the filter */
    CAN1->FFA1R &= ~(uint32_t)filter_number_bit_pos;
 8008ac2:	4917      	ldr	r1, [pc, #92]	; (8008b20 <CAN_FilterInit+0x172>)
 8008ac4:	4b16      	ldr	r3, [pc, #88]	; (8008b20 <CAN_FilterInit+0x172>)
 8008ac6:	f8d3 2214 	ldr.w	r2, [r3, #532]	; 0x214
 8008aca:	68fb      	ldr	r3, [r7, #12]
 8008acc:	43db      	mvns	r3, r3
 8008ace:	4013      	ands	r3, r2
 8008ad0:	f8c1 3214 	str.w	r3, [r1, #532]	; 0x214
  }

  if (CAN_FilterInitStruct->CAN_FilterFIFOAssignment == CAN_Filter_FIFO1)
 8008ad4:	687b      	ldr	r3, [r7, #4]
 8008ad6:	891b      	ldrh	r3, [r3, #8]
 8008ad8:	2b01      	cmp	r3, #1
 8008ada:	d107      	bne.n	8008aec <CAN_FilterInit+0x13e>
  {
    /* FIFO 1 assignation for the filter */
    CAN1->FFA1R |= (uint32_t)filter_number_bit_pos;
 8008adc:	4910      	ldr	r1, [pc, #64]	; (8008b20 <CAN_FilterInit+0x172>)
 8008ade:	4b10      	ldr	r3, [pc, #64]	; (8008b20 <CAN_FilterInit+0x172>)
 8008ae0:	f8d3 2214 	ldr.w	r2, [r3, #532]	; 0x214
 8008ae4:	68fb      	ldr	r3, [r7, #12]
 8008ae6:	4313      	orrs	r3, r2
 8008ae8:	f8c1 3214 	str.w	r3, [r1, #532]	; 0x214
  }
  
  /* Filter activation */
  if (CAN_FilterInitStruct->CAN_FilterActivation == ENABLE)
 8008aec:	687b      	ldr	r3, [r7, #4]
 8008aee:	7b5b      	ldrb	r3, [r3, #13]
 8008af0:	2b01      	cmp	r3, #1
 8008af2:	d107      	bne.n	8008b04 <CAN_FilterInit+0x156>
  {
    CAN1->FA1R |= filter_number_bit_pos;
 8008af4:	490a      	ldr	r1, [pc, #40]	; (8008b20 <CAN_FilterInit+0x172>)
 8008af6:	4b0a      	ldr	r3, [pc, #40]	; (8008b20 <CAN_FilterInit+0x172>)
 8008af8:	f8d3 221c 	ldr.w	r2, [r3, #540]	; 0x21c
 8008afc:	68fb      	ldr	r3, [r7, #12]
 8008afe:	4313      	orrs	r3, r2
 8008b00:	f8c1 321c 	str.w	r3, [r1, #540]	; 0x21c
  }

  /* Leave the initialisation mode for the filter */
  CAN1->FMR &= ~FMR_FINIT;
 8008b04:	4a06      	ldr	r2, [pc, #24]	; (8008b20 <CAN_FilterInit+0x172>)
 8008b06:	4b06      	ldr	r3, [pc, #24]	; (8008b20 <CAN_FilterInit+0x172>)
 8008b08:	f8d3 3200 	ldr.w	r3, [r3, #512]	; 0x200
 8008b0c:	f023 0301 	bic.w	r3, r3, #1
 8008b10:	f8c2 3200 	str.w	r3, [r2, #512]	; 0x200
}
 8008b14:	bf00      	nop
 8008b16:	3714      	adds	r7, #20
 8008b18:	46bd      	mov	sp, r7
 8008b1a:	f85d 7b04 	ldr.w	r7, [sp], #4
 8008b1e:	4770      	bx	lr
 8008b20:	40006400 	.word	0x40006400

08008b24 <CAN_StructInit>:
  * @brief  Fills each CAN_InitStruct member with its default value.
  * @param  CAN_InitStruct: pointer to a CAN_InitTypeDef structure which ill be initialized.
  * @retval None
  */
void CAN_StructInit(CAN_InitTypeDef* CAN_InitStruct)
{
 8008b24:	b480      	push	{r7}
 8008b26:	b083      	sub	sp, #12
 8008b28:	af00      	add	r7, sp, #0
 8008b2a:	6078      	str	r0, [r7, #4]
  /* Reset CAN init structure parameters values */
  
  /* Initialize the time triggered communication mode */
  CAN_InitStruct->CAN_TTCM = DISABLE;
 8008b2c:	687b      	ldr	r3, [r7, #4]
 8008b2e:	2200      	movs	r2, #0
 8008b30:	719a      	strb	r2, [r3, #6]
  
  /* Initialize the automatic bus-off management */
  CAN_InitStruct->CAN_ABOM = DISABLE;
 8008b32:	687b      	ldr	r3, [r7, #4]
 8008b34:	2200      	movs	r2, #0
 8008b36:	71da      	strb	r2, [r3, #7]
  
  /* Initialize the automatic wake-up mode */
  CAN_InitStruct->CAN_AWUM = DISABLE;
 8008b38:	687b      	ldr	r3, [r7, #4]
 8008b3a:	2200      	movs	r2, #0
 8008b3c:	721a      	strb	r2, [r3, #8]
  
  /* Initialize the no automatic retransmission */
  CAN_InitStruct->CAN_NART = DISABLE;
 8008b3e:	687b      	ldr	r3, [r7, #4]
 8008b40:	2200      	movs	r2, #0
 8008b42:	725a      	strb	r2, [r3, #9]
  
  /* Initialize the receive FIFO locked mode */
  CAN_InitStruct->CAN_RFLM = DISABLE;
 8008b44:	687b      	ldr	r3, [r7, #4]
 8008b46:	2200      	movs	r2, #0
 8008b48:	729a      	strb	r2, [r3, #10]
  
  /* Initialize the transmit FIFO priority */
  CAN_InitStruct->CAN_TXFP = DISABLE;
 8008b4a:	687b      	ldr	r3, [r7, #4]
 8008b4c:	2200      	movs	r2, #0
 8008b4e:	72da      	strb	r2, [r3, #11]
  
  /* Initialize the CAN_Mode member */
  CAN_InitStruct->CAN_Mode = CAN_Mode_Normal;
 8008b50:	687b      	ldr	r3, [r7, #4]
 8008b52:	2200      	movs	r2, #0
 8008b54:	709a      	strb	r2, [r3, #2]
  
  /* Initialize the CAN_SJW member */
  CAN_InitStruct->CAN_SJW = CAN_SJW_1tq;
 8008b56:	687b      	ldr	r3, [r7, #4]
 8008b58:	2200      	movs	r2, #0
 8008b5a:	70da      	strb	r2, [r3, #3]
  
  /* Initialize the CAN_BS1 member */
  CAN_InitStruct->CAN_BS1 = CAN_BS1_4tq;
 8008b5c:	687b      	ldr	r3, [r7, #4]
 8008b5e:	2203      	movs	r2, #3
 8008b60:	711a      	strb	r2, [r3, #4]
  
  /* Initialize the CAN_BS2 member */
  CAN_InitStruct->CAN_BS2 = CAN_BS2_3tq;
 8008b62:	687b      	ldr	r3, [r7, #4]
 8008b64:	2202      	movs	r2, #2
 8008b66:	715a      	strb	r2, [r3, #5]
  
  /* Initialize the CAN_Prescaler member */
  CAN_InitStruct->CAN_Prescaler = 1;
 8008b68:	687b      	ldr	r3, [r7, #4]
 8008b6a:	2201      	movs	r2, #1
 8008b6c:	801a      	strh	r2, [r3, #0]
}
 8008b6e:	bf00      	nop
 8008b70:	370c      	adds	r7, #12
 8008b72:	46bd      	mov	sp, r7
 8008b74:	f85d 7b04 	ldr.w	r7, [sp], #4
 8008b78:	4770      	bx	lr

08008b7a <CAN_SlaveStartBank>:
  * @brief  Select the start bank filter for slave CAN.
  * @param  CAN_BankNumber: Select the start slave bank filter from 1..27.
  * @retval None
  */
void CAN_SlaveStartBank(uint8_t CAN_BankNumber) 
{
 8008b7a:	b480      	push	{r7}
 8008b7c:	b083      	sub	sp, #12
 8008b7e:	af00      	add	r7, sp, #0
 8008b80:	4603      	mov	r3, r0
 8008b82:	71fb      	strb	r3, [r7, #7]
  /* Check the parameters */
  assert_param(IS_CAN_BANKNUMBER(CAN_BankNumber));
  
  /* Enter Initialisation mode for the filter */
  CAN1->FMR |= FMR_FINIT;
 8008b84:	4a14      	ldr	r2, [pc, #80]	; (8008bd8 <CAN_SlaveStartBank+0x5e>)
 8008b86:	4b14      	ldr	r3, [pc, #80]	; (8008bd8 <CAN_SlaveStartBank+0x5e>)
 8008b88:	f8d3 3200 	ldr.w	r3, [r3, #512]	; 0x200
 8008b8c:	f043 0301 	orr.w	r3, r3, #1
 8008b90:	f8c2 3200 	str.w	r3, [r2, #512]	; 0x200
  
  /* Select the start slave bank */
  CAN1->FMR &= (uint32_t)0xFFFFC0F1 ;
 8008b94:	4a10      	ldr	r2, [pc, #64]	; (8008bd8 <CAN_SlaveStartBank+0x5e>)
 8008b96:	4b10      	ldr	r3, [pc, #64]	; (8008bd8 <CAN_SlaveStartBank+0x5e>)
 8008b98:	f8d3 3200 	ldr.w	r3, [r3, #512]	; 0x200
 8008b9c:	f423 537c 	bic.w	r3, r3, #16128	; 0x3f00
 8008ba0:	f023 030e 	bic.w	r3, r3, #14
 8008ba4:	f8c2 3200 	str.w	r3, [r2, #512]	; 0x200
  CAN1->FMR |= (uint32_t)(CAN_BankNumber)<<8;
 8008ba8:	490b      	ldr	r1, [pc, #44]	; (8008bd8 <CAN_SlaveStartBank+0x5e>)
 8008baa:	4b0b      	ldr	r3, [pc, #44]	; (8008bd8 <CAN_SlaveStartBank+0x5e>)
 8008bac:	f8d3 2200 	ldr.w	r2, [r3, #512]	; 0x200
 8008bb0:	79fb      	ldrb	r3, [r7, #7]
 8008bb2:	021b      	lsls	r3, r3, #8
 8008bb4:	4313      	orrs	r3, r2
 8008bb6:	f8c1 3200 	str.w	r3, [r1, #512]	; 0x200
  
  /* Leave Initialisation mode for the filter */
  CAN1->FMR &= ~FMR_FINIT;
 8008bba:	4a07      	ldr	r2, [pc, #28]	; (8008bd8 <CAN_SlaveStartBank+0x5e>)
 8008bbc:	4b06      	ldr	r3, [pc, #24]	; (8008bd8 <CAN_SlaveStartBank+0x5e>)
 8008bbe:	f8d3 3200 	ldr.w	r3, [r3, #512]	; 0x200
 8008bc2:	f023 0301 	bic.w	r3, r3, #1
 8008bc6:	f8c2 3200 	str.w	r3, [r2, #512]	; 0x200
}
 8008bca:	bf00      	nop
 8008bcc:	370c      	adds	r7, #12
 8008bce:	46bd      	mov	sp, r7
 8008bd0:	f85d 7b04 	ldr.w	r7, [sp], #4
 8008bd4:	4770      	bx	lr
 8008bd6:	bf00      	nop
 8008bd8:	40006400 	.word	0x40006400

08008bdc <CAN_DBGFreeze>:
  *          during debug. Reception FIFOs can still be accessed/controlled normally) 
  *          or DISABLE (CAN is working during debug).
  * @retval None
  */
void CAN_DBGFreeze(CAN_TypeDef* CANx, FunctionalState NewState)
{
 8008bdc:	b480      	push	{r7}
 8008bde:	b083      	sub	sp, #12
 8008be0:	af00      	add	r7, sp, #0
 8008be2:	6078      	str	r0, [r7, #4]
 8008be4:	460b      	mov	r3, r1
 8008be6:	70fb      	strb	r3, [r7, #3]
  /* Check the parameters */
  assert_param(IS_CAN_ALL_PERIPH(CANx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
 8008be8:	78fb      	ldrb	r3, [r7, #3]
 8008bea:	2b00      	cmp	r3, #0
 8008bec:	d006      	beq.n	8008bfc <CAN_DBGFreeze+0x20>
  {
    /* Enable Debug Freeze  */
    CANx->MCR |= MCR_DBF;
 8008bee:	687b      	ldr	r3, [r7, #4]
 8008bf0:	681b      	ldr	r3, [r3, #0]
 8008bf2:	f443 3280 	orr.w	r2, r3, #65536	; 0x10000
 8008bf6:	687b      	ldr	r3, [r7, #4]
 8008bf8:	601a      	str	r2, [r3, #0]
  else
  {
    /* Disable Debug Freeze */
    CANx->MCR &= ~MCR_DBF;
  }
}
 8008bfa:	e005      	b.n	8008c08 <CAN_DBGFreeze+0x2c>
    CANx->MCR &= ~MCR_DBF;
 8008bfc:	687b      	ldr	r3, [r7, #4]
 8008bfe:	681b      	ldr	r3, [r3, #0]
 8008c00:	f423 3280 	bic.w	r2, r3, #65536	; 0x10000
 8008c04:	687b      	ldr	r3, [r7, #4]
 8008c06:	601a      	str	r2, [r3, #0]
}
 8008c08:	bf00      	nop
 8008c0a:	370c      	adds	r7, #12
 8008c0c:	46bd      	mov	sp, r7
 8008c0e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8008c12:	4770      	bx	lr

08008c14 <CAN_TTComModeCmd>:
  *         data bytes of the 8-byte message: TIME[7:0] in data byte 6 and TIME[15:8] 
  *         in data byte 7. 
  * @retval None
  */
void CAN_TTComModeCmd(CAN_TypeDef* CANx, FunctionalState NewState)
{
 8008c14:	b480      	push	{r7}
 8008c16:	b083      	sub	sp, #12
 8008c18:	af00      	add	r7, sp, #0
 8008c1a:	6078      	str	r0, [r7, #4]
 8008c1c:	460b      	mov	r3, r1
 8008c1e:	70fb      	strb	r3, [r7, #3]
  /* Check the parameters */
  assert_param(IS_CAN_ALL_PERIPH(CANx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 8008c20:	78fb      	ldrb	r3, [r7, #3]
 8008c22:	2b00      	cmp	r3, #0
 8008c24:	d01e      	beq.n	8008c64 <CAN_TTComModeCmd+0x50>
  {
    /* Enable the TTCM mode */
    CANx->MCR |= CAN_MCR_TTCM;
 8008c26:	687b      	ldr	r3, [r7, #4]
 8008c28:	681b      	ldr	r3, [r3, #0]
 8008c2a:	f043 0280 	orr.w	r2, r3, #128	; 0x80
 8008c2e:	687b      	ldr	r3, [r7, #4]
 8008c30:	601a      	str	r2, [r3, #0]

    /* Set TGT bits */
    CANx->sTxMailBox[0].TDTR |= ((uint32_t)CAN_TDT0R_TGT);
 8008c32:	687b      	ldr	r3, [r7, #4]
 8008c34:	f8d3 3184 	ldr.w	r3, [r3, #388]	; 0x184
 8008c38:	f443 7280 	orr.w	r2, r3, #256	; 0x100
 8008c3c:	687b      	ldr	r3, [r7, #4]
 8008c3e:	f8c3 2184 	str.w	r2, [r3, #388]	; 0x184
    CANx->sTxMailBox[1].TDTR |= ((uint32_t)CAN_TDT1R_TGT);
 8008c42:	687b      	ldr	r3, [r7, #4]
 8008c44:	f8d3 3194 	ldr.w	r3, [r3, #404]	; 0x194
 8008c48:	f443 7280 	orr.w	r2, r3, #256	; 0x100
 8008c4c:	687b      	ldr	r3, [r7, #4]
 8008c4e:	f8c3 2194 	str.w	r2, [r3, #404]	; 0x194
    CANx->sTxMailBox[2].TDTR |= ((uint32_t)CAN_TDT2R_TGT);
 8008c52:	687b      	ldr	r3, [r7, #4]
 8008c54:	f8d3 31a4 	ldr.w	r3, [r3, #420]	; 0x1a4
 8008c58:	f443 7280 	orr.w	r2, r3, #256	; 0x100
 8008c5c:	687b      	ldr	r3, [r7, #4]
 8008c5e:	f8c3 21a4 	str.w	r2, [r3, #420]	; 0x1a4
    /* Reset TGT bits */
    CANx->sTxMailBox[0].TDTR &= ((uint32_t)~CAN_TDT0R_TGT);
    CANx->sTxMailBox[1].TDTR &= ((uint32_t)~CAN_TDT1R_TGT);
    CANx->sTxMailBox[2].TDTR &= ((uint32_t)~CAN_TDT2R_TGT);
  }
}
 8008c62:	e01d      	b.n	8008ca0 <CAN_TTComModeCmd+0x8c>
    CANx->MCR &= (uint32_t)(~(uint32_t)CAN_MCR_TTCM);
 8008c64:	687b      	ldr	r3, [r7, #4]
 8008c66:	681b      	ldr	r3, [r3, #0]
 8008c68:	f023 0280 	bic.w	r2, r3, #128	; 0x80
 8008c6c:	687b      	ldr	r3, [r7, #4]
 8008c6e:	601a      	str	r2, [r3, #0]
    CANx->sTxMailBox[0].TDTR &= ((uint32_t)~CAN_TDT0R_TGT);
 8008c70:	687b      	ldr	r3, [r7, #4]
 8008c72:	f8d3 3184 	ldr.w	r3, [r3, #388]	; 0x184
 8008c76:	f423 7280 	bic.w	r2, r3, #256	; 0x100
 8008c7a:	687b      	ldr	r3, [r7, #4]
 8008c7c:	f8c3 2184 	str.w	r2, [r3, #388]	; 0x184
    CANx->sTxMailBox[1].TDTR &= ((uint32_t)~CAN_TDT1R_TGT);
 8008c80:	687b      	ldr	r3, [r7, #4]
 8008c82:	f8d3 3194 	ldr.w	r3, [r3, #404]	; 0x194
 8008c86:	f423 7280 	bic.w	r2, r3, #256	; 0x100
 8008c8a:	687b      	ldr	r3, [r7, #4]
 8008c8c:	f8c3 2194 	str.w	r2, [r3, #404]	; 0x194
    CANx->sTxMailBox[2].TDTR &= ((uint32_t)~CAN_TDT2R_TGT);
 8008c90:	687b      	ldr	r3, [r7, #4]
 8008c92:	f8d3 31a4 	ldr.w	r3, [r3, #420]	; 0x1a4
 8008c96:	f423 7280 	bic.w	r2, r3, #256	; 0x100
 8008c9a:	687b      	ldr	r3, [r7, #4]
 8008c9c:	f8c3 21a4 	str.w	r2, [r3, #420]	; 0x1a4
}
 8008ca0:	bf00      	nop
 8008ca2:	370c      	adds	r7, #12
 8008ca4:	46bd      	mov	sp, r7
 8008ca6:	f85d 7b04 	ldr.w	r7, [sp], #4
 8008caa:	4770      	bx	lr

08008cac <CAN_Transmit>:
  * @param  TxMessage: pointer to a structure which contains CAN Id, CAN DLC and CAN data.
  * @retval The number of the mailbox that is used for transmission or
  *         CAN_TxStatus_NoMailBox if there is no empty mailbox.
  */
uint8_t CAN_Transmit(CAN_TypeDef* CANx, CanTxMsg* TxMessage)
{
 8008cac:	b480      	push	{r7}
 8008cae:	b085      	sub	sp, #20
 8008cb0:	af00      	add	r7, sp, #0
 8008cb2:	6078      	str	r0, [r7, #4]
 8008cb4:	6039      	str	r1, [r7, #0]
  uint8_t transmit_mailbox = 0;
 8008cb6:	2300      	movs	r3, #0
 8008cb8:	73fb      	strb	r3, [r7, #15]
  assert_param(IS_CAN_IDTYPE(TxMessage->IDE));
  assert_param(IS_CAN_RTR(TxMessage->RTR));
  assert_param(IS_CAN_DLC(TxMessage->DLC));

  /* Select one empty transmit mailbox */
  if ((CANx->TSR&CAN_TSR_TME0) == CAN_TSR_TME0)
 8008cba:	687b      	ldr	r3, [r7, #4]
 8008cbc:	689b      	ldr	r3, [r3, #8]
 8008cbe:	f003 6380 	and.w	r3, r3, #67108864	; 0x4000000
 8008cc2:	f1b3 6f80 	cmp.w	r3, #67108864	; 0x4000000
 8008cc6:	d102      	bne.n	8008cce <CAN_Transmit+0x22>
  {
    transmit_mailbox = 0;
 8008cc8:	2300      	movs	r3, #0
 8008cca:	73fb      	strb	r3, [r7, #15]
 8008ccc:	e015      	b.n	8008cfa <CAN_Transmit+0x4e>
  }
  else if ((CANx->TSR&CAN_TSR_TME1) == CAN_TSR_TME1)
 8008cce:	687b      	ldr	r3, [r7, #4]
 8008cd0:	689b      	ldr	r3, [r3, #8]
 8008cd2:	f003 6300 	and.w	r3, r3, #134217728	; 0x8000000
 8008cd6:	f1b3 6f00 	cmp.w	r3, #134217728	; 0x8000000
 8008cda:	d102      	bne.n	8008ce2 <CAN_Transmit+0x36>
  {
    transmit_mailbox = 1;
 8008cdc:	2301      	movs	r3, #1
 8008cde:	73fb      	strb	r3, [r7, #15]
 8008ce0:	e00b      	b.n	8008cfa <CAN_Transmit+0x4e>
  }
  else if ((CANx->TSR&CAN_TSR_TME2) == CAN_TSR_TME2)
 8008ce2:	687b      	ldr	r3, [r7, #4]
 8008ce4:	689b      	ldr	r3, [r3, #8]
 8008ce6:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 8008cea:	f1b3 5f80 	cmp.w	r3, #268435456	; 0x10000000
 8008cee:	d102      	bne.n	8008cf6 <CAN_Transmit+0x4a>
  {
    transmit_mailbox = 2;
 8008cf0:	2302      	movs	r3, #2
 8008cf2:	73fb      	strb	r3, [r7, #15]
 8008cf4:	e001      	b.n	8008cfa <CAN_Transmit+0x4e>
  }
  else
  {
    transmit_mailbox = CAN_TxStatus_NoMailBox;
 8008cf6:	2304      	movs	r3, #4
 8008cf8:	73fb      	strb	r3, [r7, #15]
  }

  if (transmit_mailbox != CAN_TxStatus_NoMailBox)
 8008cfa:	7bfb      	ldrb	r3, [r7, #15]
 8008cfc:	2b04      	cmp	r3, #4
 8008cfe:	f000 809c 	beq.w	8008e3a <CAN_Transmit+0x18e>
  {
    /* Set up the Id */
    CANx->sTxMailBox[transmit_mailbox].TIR &= TMIDxR_TXRQ;
 8008d02:	7bfb      	ldrb	r3, [r7, #15]
 8008d04:	7bfa      	ldrb	r2, [r7, #15]
 8008d06:	6879      	ldr	r1, [r7, #4]
 8008d08:	3218      	adds	r2, #24
 8008d0a:	0112      	lsls	r2, r2, #4
 8008d0c:	440a      	add	r2, r1
 8008d0e:	6812      	ldr	r2, [r2, #0]
 8008d10:	f002 0201 	and.w	r2, r2, #1
 8008d14:	6879      	ldr	r1, [r7, #4]
 8008d16:	3318      	adds	r3, #24
 8008d18:	011b      	lsls	r3, r3, #4
 8008d1a:	440b      	add	r3, r1
 8008d1c:	601a      	str	r2, [r3, #0]
    if (TxMessage->IDE == CAN_Id_Standard)
 8008d1e:	683b      	ldr	r3, [r7, #0]
 8008d20:	7a1b      	ldrb	r3, [r3, #8]
 8008d22:	2b00      	cmp	r3, #0
 8008d24:	d113      	bne.n	8008d4e <CAN_Transmit+0xa2>
    {
      assert_param(IS_CAN_STDID(TxMessage->StdId));  
      CANx->sTxMailBox[transmit_mailbox].TIR |= ((TxMessage->StdId << 21) | \
 8008d26:	7bfb      	ldrb	r3, [r7, #15]
 8008d28:	7bfa      	ldrb	r2, [r7, #15]
 8008d2a:	6879      	ldr	r1, [r7, #4]
 8008d2c:	3218      	adds	r2, #24
 8008d2e:	0112      	lsls	r2, r2, #4
 8008d30:	440a      	add	r2, r1
 8008d32:	6811      	ldr	r1, [r2, #0]
 8008d34:	683a      	ldr	r2, [r7, #0]
 8008d36:	6812      	ldr	r2, [r2, #0]
 8008d38:	0552      	lsls	r2, r2, #21
                                                  TxMessage->RTR);
 8008d3a:	6838      	ldr	r0, [r7, #0]
 8008d3c:	7a40      	ldrb	r0, [r0, #9]
      CANx->sTxMailBox[transmit_mailbox].TIR |= ((TxMessage->StdId << 21) | \
 8008d3e:	4302      	orrs	r2, r0
 8008d40:	430a      	orrs	r2, r1
 8008d42:	6879      	ldr	r1, [r7, #4]
 8008d44:	3318      	adds	r3, #24
 8008d46:	011b      	lsls	r3, r3, #4
 8008d48:	440b      	add	r3, r1
 8008d4a:	601a      	str	r2, [r3, #0]
 8008d4c:	e015      	b.n	8008d7a <CAN_Transmit+0xce>
    }
    else
    {
      assert_param(IS_CAN_EXTID(TxMessage->ExtId));
      CANx->sTxMailBox[transmit_mailbox].TIR |= ((TxMessage->ExtId << 3) | \
 8008d4e:	7bfb      	ldrb	r3, [r7, #15]
 8008d50:	7bfa      	ldrb	r2, [r7, #15]
 8008d52:	6879      	ldr	r1, [r7, #4]
 8008d54:	3218      	adds	r2, #24
 8008d56:	0112      	lsls	r2, r2, #4
 8008d58:	440a      	add	r2, r1
 8008d5a:	6811      	ldr	r1, [r2, #0]
 8008d5c:	683a      	ldr	r2, [r7, #0]
 8008d5e:	6852      	ldr	r2, [r2, #4]
 8008d60:	00d2      	lsls	r2, r2, #3
                                                  TxMessage->IDE | \
 8008d62:	6838      	ldr	r0, [r7, #0]
 8008d64:	7a00      	ldrb	r0, [r0, #8]
      CANx->sTxMailBox[transmit_mailbox].TIR |= ((TxMessage->ExtId << 3) | \
 8008d66:	4302      	orrs	r2, r0
                                                  TxMessage->RTR);
 8008d68:	6838      	ldr	r0, [r7, #0]
 8008d6a:	7a40      	ldrb	r0, [r0, #9]
                                                  TxMessage->IDE | \
 8008d6c:	4302      	orrs	r2, r0
      CANx->sTxMailBox[transmit_mailbox].TIR |= ((TxMessage->ExtId << 3) | \
 8008d6e:	430a      	orrs	r2, r1
 8008d70:	6879      	ldr	r1, [r7, #4]
 8008d72:	3318      	adds	r3, #24
 8008d74:	011b      	lsls	r3, r3, #4
 8008d76:	440b      	add	r3, r1
 8008d78:	601a      	str	r2, [r3, #0]
    }
    
    /* Set up the DLC */
    TxMessage->DLC &= (uint8_t)0x0000000F;
 8008d7a:	683b      	ldr	r3, [r7, #0]
 8008d7c:	7a9b      	ldrb	r3, [r3, #10]
 8008d7e:	f003 030f 	and.w	r3, r3, #15
 8008d82:	b2da      	uxtb	r2, r3
 8008d84:	683b      	ldr	r3, [r7, #0]
 8008d86:	729a      	strb	r2, [r3, #10]
    CANx->sTxMailBox[transmit_mailbox].TDTR &= (uint32_t)0xFFFFFFF0;
 8008d88:	7bfb      	ldrb	r3, [r7, #15]
 8008d8a:	7bfa      	ldrb	r2, [r7, #15]
 8008d8c:	6879      	ldr	r1, [r7, #4]
 8008d8e:	3218      	adds	r2, #24
 8008d90:	0112      	lsls	r2, r2, #4
 8008d92:	440a      	add	r2, r1
 8008d94:	3204      	adds	r2, #4
 8008d96:	6812      	ldr	r2, [r2, #0]
 8008d98:	f022 020f 	bic.w	r2, r2, #15
 8008d9c:	6879      	ldr	r1, [r7, #4]
 8008d9e:	3318      	adds	r3, #24
 8008da0:	011b      	lsls	r3, r3, #4
 8008da2:	440b      	add	r3, r1
 8008da4:	3304      	adds	r3, #4
 8008da6:	601a      	str	r2, [r3, #0]
    CANx->sTxMailBox[transmit_mailbox].TDTR |= TxMessage->DLC;
 8008da8:	7bfb      	ldrb	r3, [r7, #15]
 8008daa:	7bfa      	ldrb	r2, [r7, #15]
 8008dac:	6879      	ldr	r1, [r7, #4]
 8008dae:	3218      	adds	r2, #24
 8008db0:	0112      	lsls	r2, r2, #4
 8008db2:	440a      	add	r2, r1
 8008db4:	3204      	adds	r2, #4
 8008db6:	6812      	ldr	r2, [r2, #0]
 8008db8:	6839      	ldr	r1, [r7, #0]
 8008dba:	7a89      	ldrb	r1, [r1, #10]
 8008dbc:	430a      	orrs	r2, r1
 8008dbe:	6879      	ldr	r1, [r7, #4]
 8008dc0:	3318      	adds	r3, #24
 8008dc2:	011b      	lsls	r3, r3, #4
 8008dc4:	440b      	add	r3, r1
 8008dc6:	3304      	adds	r3, #4
 8008dc8:	601a      	str	r2, [r3, #0]

    /* Set up the data field */
    CANx->sTxMailBox[transmit_mailbox].TDLR = (((uint32_t)TxMessage->Data[3] << 24) | 
 8008dca:	7bfb      	ldrb	r3, [r7, #15]
 8008dcc:	683a      	ldr	r2, [r7, #0]
 8008dce:	7b92      	ldrb	r2, [r2, #14]
 8008dd0:	0611      	lsls	r1, r2, #24
                                             ((uint32_t)TxMessage->Data[2] << 16) |
 8008dd2:	683a      	ldr	r2, [r7, #0]
 8008dd4:	7b52      	ldrb	r2, [r2, #13]
 8008dd6:	0412      	lsls	r2, r2, #16
    CANx->sTxMailBox[transmit_mailbox].TDLR = (((uint32_t)TxMessage->Data[3] << 24) | 
 8008dd8:	4311      	orrs	r1, r2
                                             ((uint32_t)TxMessage->Data[1] << 8) | 
 8008dda:	683a      	ldr	r2, [r7, #0]
 8008ddc:	7b12      	ldrb	r2, [r2, #12]
 8008dde:	0212      	lsls	r2, r2, #8
                                             ((uint32_t)TxMessage->Data[2] << 16) |
 8008de0:	430a      	orrs	r2, r1
                                             ((uint32_t)TxMessage->Data[0]));
 8008de2:	6839      	ldr	r1, [r7, #0]
 8008de4:	7ac9      	ldrb	r1, [r1, #11]
                                             ((uint32_t)TxMessage->Data[1] << 8) | 
 8008de6:	430a      	orrs	r2, r1
    CANx->sTxMailBox[transmit_mailbox].TDLR = (((uint32_t)TxMessage->Data[3] << 24) | 
 8008de8:	6879      	ldr	r1, [r7, #4]
 8008dea:	011b      	lsls	r3, r3, #4
 8008dec:	440b      	add	r3, r1
 8008dee:	f503 73c4 	add.w	r3, r3, #392	; 0x188
 8008df2:	601a      	str	r2, [r3, #0]
    CANx->sTxMailBox[transmit_mailbox].TDHR = (((uint32_t)TxMessage->Data[7] << 24) | 
 8008df4:	7bfb      	ldrb	r3, [r7, #15]
 8008df6:	683a      	ldr	r2, [r7, #0]
 8008df8:	7c92      	ldrb	r2, [r2, #18]
 8008dfa:	0611      	lsls	r1, r2, #24
                                             ((uint32_t)TxMessage->Data[6] << 16) |
 8008dfc:	683a      	ldr	r2, [r7, #0]
 8008dfe:	7c52      	ldrb	r2, [r2, #17]
 8008e00:	0412      	lsls	r2, r2, #16
    CANx->sTxMailBox[transmit_mailbox].TDHR = (((uint32_t)TxMessage->Data[7] << 24) | 
 8008e02:	4311      	orrs	r1, r2
                                             ((uint32_t)TxMessage->Data[5] << 8) |
 8008e04:	683a      	ldr	r2, [r7, #0]
 8008e06:	7c12      	ldrb	r2, [r2, #16]
 8008e08:	0212      	lsls	r2, r2, #8
                                             ((uint32_t)TxMessage->Data[6] << 16) |
 8008e0a:	430a      	orrs	r2, r1
                                             ((uint32_t)TxMessage->Data[4]));
 8008e0c:	6839      	ldr	r1, [r7, #0]
 8008e0e:	7bc9      	ldrb	r1, [r1, #15]
                                             ((uint32_t)TxMessage->Data[5] << 8) |
 8008e10:	430a      	orrs	r2, r1
    CANx->sTxMailBox[transmit_mailbox].TDHR = (((uint32_t)TxMessage->Data[7] << 24) | 
 8008e12:	6879      	ldr	r1, [r7, #4]
 8008e14:	011b      	lsls	r3, r3, #4
 8008e16:	440b      	add	r3, r1
 8008e18:	f503 73c6 	add.w	r3, r3, #396	; 0x18c
 8008e1c:	601a      	str	r2, [r3, #0]
    /* Request transmission */
    CANx->sTxMailBox[transmit_mailbox].TIR |= TMIDxR_TXRQ;
 8008e1e:	7bfb      	ldrb	r3, [r7, #15]
 8008e20:	7bfa      	ldrb	r2, [r7, #15]
 8008e22:	6879      	ldr	r1, [r7, #4]
 8008e24:	3218      	adds	r2, #24
 8008e26:	0112      	lsls	r2, r2, #4
 8008e28:	440a      	add	r2, r1
 8008e2a:	6812      	ldr	r2, [r2, #0]
 8008e2c:	f042 0201 	orr.w	r2, r2, #1
 8008e30:	6879      	ldr	r1, [r7, #4]
 8008e32:	3318      	adds	r3, #24
 8008e34:	011b      	lsls	r3, r3, #4
 8008e36:	440b      	add	r3, r1
 8008e38:	601a      	str	r2, [r3, #0]
  }
  return transmit_mailbox;
 8008e3a:	7bfb      	ldrb	r3, [r7, #15]
}
 8008e3c:	4618      	mov	r0, r3
 8008e3e:	3714      	adds	r7, #20
 8008e40:	46bd      	mov	sp, r7
 8008e42:	f85d 7b04 	ldr.w	r7, [sp], #4
 8008e46:	4770      	bx	lr

08008e48 <CAN_TransmitStatus>:
  * @param  TransmitMailbox: the number of the mailbox that is used for transmission.
  * @retval CAN_TxStatus_Ok if the CAN driver transmits the message, 
  *         CAN_TxStatus_Failed in an other case.
  */
uint8_t CAN_TransmitStatus(CAN_TypeDef* CANx, uint8_t TransmitMailbox)
{
 8008e48:	b480      	push	{r7}
 8008e4a:	b085      	sub	sp, #20
 8008e4c:	af00      	add	r7, sp, #0
 8008e4e:	6078      	str	r0, [r7, #4]
 8008e50:	460b      	mov	r3, r1
 8008e52:	70fb      	strb	r3, [r7, #3]
  uint32_t state = 0;
 8008e54:	2300      	movs	r3, #0
 8008e56:	60fb      	str	r3, [r7, #12]

  /* Check the parameters */
  assert_param(IS_CAN_ALL_PERIPH(CANx));
  assert_param(IS_CAN_TRANSMITMAILBOX(TransmitMailbox));
 
  switch (TransmitMailbox)
 8008e58:	78fb      	ldrb	r3, [r7, #3]
 8008e5a:	2b01      	cmp	r3, #1
 8008e5c:	d009      	beq.n	8008e72 <CAN_TransmitStatus+0x2a>
 8008e5e:	2b02      	cmp	r3, #2
 8008e60:	d00d      	beq.n	8008e7e <CAN_TransmitStatus+0x36>
 8008e62:	2b00      	cmp	r3, #0
 8008e64:	d111      	bne.n	8008e8a <CAN_TransmitStatus+0x42>
  {
    case (CAN_TXMAILBOX_0): 
      state =   CANx->TSR &  (CAN_TSR_RQCP0 | CAN_TSR_TXOK0 | CAN_TSR_TME0);
 8008e66:	687b      	ldr	r3, [r7, #4]
 8008e68:	689a      	ldr	r2, [r3, #8]
 8008e6a:	4b26      	ldr	r3, [pc, #152]	; (8008f04 <CAN_TransmitStatus+0xbc>)
 8008e6c:	4013      	ands	r3, r2
 8008e6e:	60fb      	str	r3, [r7, #12]
      break;
 8008e70:	e00e      	b.n	8008e90 <CAN_TransmitStatus+0x48>
    case (CAN_TXMAILBOX_1): 
      state =   CANx->TSR &  (CAN_TSR_RQCP1 | CAN_TSR_TXOK1 | CAN_TSR_TME1);
 8008e72:	687b      	ldr	r3, [r7, #4]
 8008e74:	689a      	ldr	r2, [r3, #8]
 8008e76:	4b24      	ldr	r3, [pc, #144]	; (8008f08 <CAN_TransmitStatus+0xc0>)
 8008e78:	4013      	ands	r3, r2
 8008e7a:	60fb      	str	r3, [r7, #12]
      break;
 8008e7c:	e008      	b.n	8008e90 <CAN_TransmitStatus+0x48>
    case (CAN_TXMAILBOX_2): 
      state =   CANx->TSR &  (CAN_TSR_RQCP2 | CAN_TSR_TXOK2 | CAN_TSR_TME2);
 8008e7e:	687b      	ldr	r3, [r7, #4]
 8008e80:	689a      	ldr	r2, [r3, #8]
 8008e82:	4b22      	ldr	r3, [pc, #136]	; (8008f0c <CAN_TransmitStatus+0xc4>)
 8008e84:	4013      	ands	r3, r2
 8008e86:	60fb      	str	r3, [r7, #12]
      break;
 8008e88:	e002      	b.n	8008e90 <CAN_TransmitStatus+0x48>
    default:
      state = CAN_TxStatus_Failed;
 8008e8a:	2300      	movs	r3, #0
 8008e8c:	60fb      	str	r3, [r7, #12]
      break;
 8008e8e:	bf00      	nop
  }
  switch (state)
 8008e90:	68fb      	ldr	r3, [r7, #12]
 8008e92:	4a1f      	ldr	r2, [pc, #124]	; (8008f10 <CAN_TransmitStatus+0xc8>)
 8008e94:	4293      	cmp	r3, r2
 8008e96:	d01b      	beq.n	8008ed0 <CAN_TransmitStatus+0x88>
 8008e98:	4a1d      	ldr	r2, [pc, #116]	; (8008f10 <CAN_TransmitStatus+0xc8>)
 8008e9a:	4293      	cmp	r3, r2
 8008e9c:	d808      	bhi.n	8008eb0 <CAN_TransmitStatus+0x68>
 8008e9e:	4a1d      	ldr	r2, [pc, #116]	; (8008f14 <CAN_TransmitStatus+0xcc>)
 8008ea0:	4293      	cmp	r3, r2
 8008ea2:	d012      	beq.n	8008eca <CAN_TransmitStatus+0x82>
 8008ea4:	4a17      	ldr	r2, [pc, #92]	; (8008f04 <CAN_TransmitStatus+0xbc>)
 8008ea6:	4293      	cmp	r3, r2
 8008ea8:	d018      	beq.n	8008edc <CAN_TransmitStatus+0x94>
 8008eaa:	2b00      	cmp	r3, #0
 8008eac:	d00a      	beq.n	8008ec4 <CAN_TransmitStatus+0x7c>
 8008eae:	e01e      	b.n	8008eee <CAN_TransmitStatus+0xa6>
 8008eb0:	4a19      	ldr	r2, [pc, #100]	; (8008f18 <CAN_TransmitStatus+0xd0>)
 8008eb2:	4293      	cmp	r3, r2
 8008eb4:	d00f      	beq.n	8008ed6 <CAN_TransmitStatus+0x8e>
 8008eb6:	4a15      	ldr	r2, [pc, #84]	; (8008f0c <CAN_TransmitStatus+0xc4>)
 8008eb8:	4293      	cmp	r3, r2
 8008eba:	d015      	beq.n	8008ee8 <CAN_TransmitStatus+0xa0>
 8008ebc:	4a12      	ldr	r2, [pc, #72]	; (8008f08 <CAN_TransmitStatus+0xc0>)
 8008ebe:	4293      	cmp	r3, r2
 8008ec0:	d00f      	beq.n	8008ee2 <CAN_TransmitStatus+0x9a>
 8008ec2:	e014      	b.n	8008eee <CAN_TransmitStatus+0xa6>
  {
      /* transmit pending  */
    case (0x0): state = CAN_TxStatus_Pending;
 8008ec4:	2302      	movs	r3, #2
 8008ec6:	60fb      	str	r3, [r7, #12]
      break;
 8008ec8:	e014      	b.n	8008ef4 <CAN_TransmitStatus+0xac>
      /* transmit failed  */
     case (CAN_TSR_RQCP0 | CAN_TSR_TME0): state = CAN_TxStatus_Failed;
 8008eca:	2300      	movs	r3, #0
 8008ecc:	60fb      	str	r3, [r7, #12]
      break;
 8008ece:	e011      	b.n	8008ef4 <CAN_TransmitStatus+0xac>
     case (CAN_TSR_RQCP1 | CAN_TSR_TME1): state = CAN_TxStatus_Failed;
 8008ed0:	2300      	movs	r3, #0
 8008ed2:	60fb      	str	r3, [r7, #12]
      break;
 8008ed4:	e00e      	b.n	8008ef4 <CAN_TransmitStatus+0xac>
     case (CAN_TSR_RQCP2 | CAN_TSR_TME2): state = CAN_TxStatus_Failed;
 8008ed6:	2300      	movs	r3, #0
 8008ed8:	60fb      	str	r3, [r7, #12]
      break;
 8008eda:	e00b      	b.n	8008ef4 <CAN_TransmitStatus+0xac>
      /* transmit succeeded  */
    case (CAN_TSR_RQCP0 | CAN_TSR_TXOK0 | CAN_TSR_TME0):state = CAN_TxStatus_Ok;
 8008edc:	2301      	movs	r3, #1
 8008ede:	60fb      	str	r3, [r7, #12]
      break;
 8008ee0:	e008      	b.n	8008ef4 <CAN_TransmitStatus+0xac>
    case (CAN_TSR_RQCP1 | CAN_TSR_TXOK1 | CAN_TSR_TME1):state = CAN_TxStatus_Ok;
 8008ee2:	2301      	movs	r3, #1
 8008ee4:	60fb      	str	r3, [r7, #12]
      break;
 8008ee6:	e005      	b.n	8008ef4 <CAN_TransmitStatus+0xac>
    case (CAN_TSR_RQCP2 | CAN_TSR_TXOK2 | CAN_TSR_TME2):state = CAN_TxStatus_Ok;
 8008ee8:	2301      	movs	r3, #1
 8008eea:	60fb      	str	r3, [r7, #12]
      break;
 8008eec:	e002      	b.n	8008ef4 <CAN_TransmitStatus+0xac>
    default: state = CAN_TxStatus_Failed;
 8008eee:	2300      	movs	r3, #0
 8008ef0:	60fb      	str	r3, [r7, #12]
      break;
 8008ef2:	bf00      	nop
  }
  return (uint8_t) state;
 8008ef4:	68fb      	ldr	r3, [r7, #12]
 8008ef6:	b2db      	uxtb	r3, r3
}
 8008ef8:	4618      	mov	r0, r3
 8008efa:	3714      	adds	r7, #20
 8008efc:	46bd      	mov	sp, r7
 8008efe:	f85d 7b04 	ldr.w	r7, [sp], #4
 8008f02:	4770      	bx	lr
 8008f04:	04000003 	.word	0x04000003
 8008f08:	08000300 	.word	0x08000300
 8008f0c:	10030000 	.word	0x10030000
 8008f10:	08000100 	.word	0x08000100
 8008f14:	04000001 	.word	0x04000001
 8008f18:	10010000 	.word	0x10010000

08008f1c <CAN_CancelTransmit>:
  * @param  CANx: where x can be 1 or 2 to select the CAN peripheral.
  * @param  Mailbox: Mailbox number.
  * @retval None
  */
void CAN_CancelTransmit(CAN_TypeDef* CANx, uint8_t Mailbox)
{
 8008f1c:	b480      	push	{r7}
 8008f1e:	b083      	sub	sp, #12
 8008f20:	af00      	add	r7, sp, #0
 8008f22:	6078      	str	r0, [r7, #4]
 8008f24:	460b      	mov	r3, r1
 8008f26:	70fb      	strb	r3, [r7, #3]
  /* Check the parameters */
  assert_param(IS_CAN_ALL_PERIPH(CANx));
  assert_param(IS_CAN_TRANSMITMAILBOX(Mailbox));
  /* abort transmission */
  switch (Mailbox)
 8008f28:	78fb      	ldrb	r3, [r7, #3]
 8008f2a:	2b01      	cmp	r3, #1
 8008f2c:	d00b      	beq.n	8008f46 <CAN_CancelTransmit+0x2a>
 8008f2e:	2b02      	cmp	r3, #2
 8008f30:	d010      	beq.n	8008f54 <CAN_CancelTransmit+0x38>
 8008f32:	2b00      	cmp	r3, #0
 8008f34:	d000      	beq.n	8008f38 <CAN_CancelTransmit+0x1c>
    case (CAN_TXMAILBOX_1): CANx->TSR |= CAN_TSR_ABRQ1;
      break;
    case (CAN_TXMAILBOX_2): CANx->TSR |= CAN_TSR_ABRQ2;
      break;
    default:
      break;
 8008f36:	e014      	b.n	8008f62 <CAN_CancelTransmit+0x46>
    case (CAN_TXMAILBOX_0): CANx->TSR |= CAN_TSR_ABRQ0;
 8008f38:	687b      	ldr	r3, [r7, #4]
 8008f3a:	689b      	ldr	r3, [r3, #8]
 8008f3c:	f043 0280 	orr.w	r2, r3, #128	; 0x80
 8008f40:	687b      	ldr	r3, [r7, #4]
 8008f42:	609a      	str	r2, [r3, #8]
      break;
 8008f44:	e00d      	b.n	8008f62 <CAN_CancelTransmit+0x46>
    case (CAN_TXMAILBOX_1): CANx->TSR |= CAN_TSR_ABRQ1;
 8008f46:	687b      	ldr	r3, [r7, #4]
 8008f48:	689b      	ldr	r3, [r3, #8]
 8008f4a:	f443 4200 	orr.w	r2, r3, #32768	; 0x8000
 8008f4e:	687b      	ldr	r3, [r7, #4]
 8008f50:	609a      	str	r2, [r3, #8]
      break;
 8008f52:	e006      	b.n	8008f62 <CAN_CancelTransmit+0x46>
    case (CAN_TXMAILBOX_2): CANx->TSR |= CAN_TSR_ABRQ2;
 8008f54:	687b      	ldr	r3, [r7, #4]
 8008f56:	689b      	ldr	r3, [r3, #8]
 8008f58:	f443 0200 	orr.w	r2, r3, #8388608	; 0x800000
 8008f5c:	687b      	ldr	r3, [r7, #4]
 8008f5e:	609a      	str	r2, [r3, #8]
      break;
 8008f60:	bf00      	nop
  }
}
 8008f62:	bf00      	nop
 8008f64:	370c      	adds	r7, #12
 8008f66:	46bd      	mov	sp, r7
 8008f68:	f85d 7b04 	ldr.w	r7, [sp], #4
 8008f6c:	4770      	bx	lr

08008f6e <CAN_Receive>:
  * @param  RxMessage: pointer to a structure receive frame which contains CAN Id,
  *         CAN DLC, CAN data and FMI number.
  * @retval None
  */
void CAN_Receive(CAN_TypeDef* CANx, uint8_t FIFONumber, CanRxMsg* RxMessage)
{
 8008f6e:	b480      	push	{r7}
 8008f70:	b085      	sub	sp, #20
 8008f72:	af00      	add	r7, sp, #0
 8008f74:	60f8      	str	r0, [r7, #12]
 8008f76:	460b      	mov	r3, r1
 8008f78:	607a      	str	r2, [r7, #4]
 8008f7a:	72fb      	strb	r3, [r7, #11]
  /* Check the parameters */
  assert_param(IS_CAN_ALL_PERIPH(CANx));
  assert_param(IS_CAN_FIFO(FIFONumber));
  /* Get the Id */
  RxMessage->IDE = (uint8_t)0x04 & CANx->sFIFOMailBox[FIFONumber].RIR;
 8008f7c:	7afb      	ldrb	r3, [r7, #11]
 8008f7e:	68fa      	ldr	r2, [r7, #12]
 8008f80:	331b      	adds	r3, #27
 8008f82:	011b      	lsls	r3, r3, #4
 8008f84:	4413      	add	r3, r2
 8008f86:	681b      	ldr	r3, [r3, #0]
 8008f88:	b2db      	uxtb	r3, r3
 8008f8a:	f003 0304 	and.w	r3, r3, #4
 8008f8e:	b2da      	uxtb	r2, r3
 8008f90:	687b      	ldr	r3, [r7, #4]
 8008f92:	721a      	strb	r2, [r3, #8]
  if (RxMessage->IDE == CAN_Id_Standard)
 8008f94:	687b      	ldr	r3, [r7, #4]
 8008f96:	7a1b      	ldrb	r3, [r3, #8]
 8008f98:	2b00      	cmp	r3, #0
 8008f9a:	d10b      	bne.n	8008fb4 <CAN_Receive+0x46>
  {
    RxMessage->StdId = (uint32_t)0x000007FF & (CANx->sFIFOMailBox[FIFONumber].RIR >> 21);
 8008f9c:	7afb      	ldrb	r3, [r7, #11]
 8008f9e:	68fa      	ldr	r2, [r7, #12]
 8008fa0:	331b      	adds	r3, #27
 8008fa2:	011b      	lsls	r3, r3, #4
 8008fa4:	4413      	add	r3, r2
 8008fa6:	681b      	ldr	r3, [r3, #0]
 8008fa8:	0d5b      	lsrs	r3, r3, #21
 8008faa:	f3c3 020a 	ubfx	r2, r3, #0, #11
 8008fae:	687b      	ldr	r3, [r7, #4]
 8008fb0:	601a      	str	r2, [r3, #0]
 8008fb2:	e00a      	b.n	8008fca <CAN_Receive+0x5c>
  }
  else
  {
    RxMessage->ExtId = (uint32_t)0x1FFFFFFF & (CANx->sFIFOMailBox[FIFONumber].RIR >> 3);
 8008fb4:	7afb      	ldrb	r3, [r7, #11]
 8008fb6:	68fa      	ldr	r2, [r7, #12]
 8008fb8:	331b      	adds	r3, #27
 8008fba:	011b      	lsls	r3, r3, #4
 8008fbc:	4413      	add	r3, r2
 8008fbe:	681b      	ldr	r3, [r3, #0]
 8008fc0:	08db      	lsrs	r3, r3, #3
 8008fc2:	f023 4260 	bic.w	r2, r3, #3758096384	; 0xe0000000
 8008fc6:	687b      	ldr	r3, [r7, #4]
 8008fc8:	605a      	str	r2, [r3, #4]
  }
  
  RxMessage->RTR = (uint8_t)0x02 & CANx->sFIFOMailBox[FIFONumber].RIR;
 8008fca:	7afb      	ldrb	r3, [r7, #11]
 8008fcc:	68fa      	ldr	r2, [r7, #12]
 8008fce:	331b      	adds	r3, #27
 8008fd0:	011b      	lsls	r3, r3, #4
 8008fd2:	4413      	add	r3, r2
 8008fd4:	681b      	ldr	r3, [r3, #0]
 8008fd6:	b2db      	uxtb	r3, r3
 8008fd8:	f003 0302 	and.w	r3, r3, #2
 8008fdc:	b2da      	uxtb	r2, r3
 8008fde:	687b      	ldr	r3, [r7, #4]
 8008fe0:	725a      	strb	r2, [r3, #9]
  /* Get the DLC */
  RxMessage->DLC = (uint8_t)0x0F & CANx->sFIFOMailBox[FIFONumber].RDTR;
 8008fe2:	7afb      	ldrb	r3, [r7, #11]
 8008fe4:	68fa      	ldr	r2, [r7, #12]
 8008fe6:	331b      	adds	r3, #27
 8008fe8:	011b      	lsls	r3, r3, #4
 8008fea:	4413      	add	r3, r2
 8008fec:	3304      	adds	r3, #4
 8008fee:	681b      	ldr	r3, [r3, #0]
 8008ff0:	b2db      	uxtb	r3, r3
 8008ff2:	f003 030f 	and.w	r3, r3, #15
 8008ff6:	b2da      	uxtb	r2, r3
 8008ff8:	687b      	ldr	r3, [r7, #4]
 8008ffa:	729a      	strb	r2, [r3, #10]
  /* Get the FMI */
  RxMessage->FMI = (uint8_t)0xFF & (CANx->sFIFOMailBox[FIFONumber].RDTR >> 8);
 8008ffc:	7afb      	ldrb	r3, [r7, #11]
 8008ffe:	68fa      	ldr	r2, [r7, #12]
 8009000:	331b      	adds	r3, #27
 8009002:	011b      	lsls	r3, r3, #4
 8009004:	4413      	add	r3, r2
 8009006:	3304      	adds	r3, #4
 8009008:	681b      	ldr	r3, [r3, #0]
 800900a:	0a1b      	lsrs	r3, r3, #8
 800900c:	b2da      	uxtb	r2, r3
 800900e:	687b      	ldr	r3, [r7, #4]
 8009010:	74da      	strb	r2, [r3, #19]
  /* Get the data field */
  RxMessage->Data[0] = (uint8_t)0xFF & CANx->sFIFOMailBox[FIFONumber].RDLR;
 8009012:	7afb      	ldrb	r3, [r7, #11]
 8009014:	68fa      	ldr	r2, [r7, #12]
 8009016:	011b      	lsls	r3, r3, #4
 8009018:	4413      	add	r3, r2
 800901a:	f503 73dc 	add.w	r3, r3, #440	; 0x1b8
 800901e:	681b      	ldr	r3, [r3, #0]
 8009020:	b2da      	uxtb	r2, r3
 8009022:	687b      	ldr	r3, [r7, #4]
 8009024:	72da      	strb	r2, [r3, #11]
  RxMessage->Data[1] = (uint8_t)0xFF & (CANx->sFIFOMailBox[FIFONumber].RDLR >> 8);
 8009026:	7afb      	ldrb	r3, [r7, #11]
 8009028:	68fa      	ldr	r2, [r7, #12]
 800902a:	011b      	lsls	r3, r3, #4
 800902c:	4413      	add	r3, r2
 800902e:	f503 73dc 	add.w	r3, r3, #440	; 0x1b8
 8009032:	681b      	ldr	r3, [r3, #0]
 8009034:	0a1b      	lsrs	r3, r3, #8
 8009036:	b2da      	uxtb	r2, r3
 8009038:	687b      	ldr	r3, [r7, #4]
 800903a:	731a      	strb	r2, [r3, #12]
  RxMessage->Data[2] = (uint8_t)0xFF & (CANx->sFIFOMailBox[FIFONumber].RDLR >> 16);
 800903c:	7afb      	ldrb	r3, [r7, #11]
 800903e:	68fa      	ldr	r2, [r7, #12]
 8009040:	011b      	lsls	r3, r3, #4
 8009042:	4413      	add	r3, r2
 8009044:	f503 73dc 	add.w	r3, r3, #440	; 0x1b8
 8009048:	681b      	ldr	r3, [r3, #0]
 800904a:	0c1b      	lsrs	r3, r3, #16
 800904c:	b2da      	uxtb	r2, r3
 800904e:	687b      	ldr	r3, [r7, #4]
 8009050:	735a      	strb	r2, [r3, #13]
  RxMessage->Data[3] = (uint8_t)0xFF & (CANx->sFIFOMailBox[FIFONumber].RDLR >> 24);
 8009052:	7afb      	ldrb	r3, [r7, #11]
 8009054:	68fa      	ldr	r2, [r7, #12]
 8009056:	011b      	lsls	r3, r3, #4
 8009058:	4413      	add	r3, r2
 800905a:	f503 73dc 	add.w	r3, r3, #440	; 0x1b8
 800905e:	681b      	ldr	r3, [r3, #0]
 8009060:	0e1b      	lsrs	r3, r3, #24
 8009062:	b2da      	uxtb	r2, r3
 8009064:	687b      	ldr	r3, [r7, #4]
 8009066:	739a      	strb	r2, [r3, #14]
  RxMessage->Data[4] = (uint8_t)0xFF & CANx->sFIFOMailBox[FIFONumber].RDHR;
 8009068:	7afb      	ldrb	r3, [r7, #11]
 800906a:	68fa      	ldr	r2, [r7, #12]
 800906c:	011b      	lsls	r3, r3, #4
 800906e:	4413      	add	r3, r2
 8009070:	f503 73de 	add.w	r3, r3, #444	; 0x1bc
 8009074:	681b      	ldr	r3, [r3, #0]
 8009076:	b2da      	uxtb	r2, r3
 8009078:	687b      	ldr	r3, [r7, #4]
 800907a:	73da      	strb	r2, [r3, #15]
  RxMessage->Data[5] = (uint8_t)0xFF & (CANx->sFIFOMailBox[FIFONumber].RDHR >> 8);
 800907c:	7afb      	ldrb	r3, [r7, #11]
 800907e:	68fa      	ldr	r2, [r7, #12]
 8009080:	011b      	lsls	r3, r3, #4
 8009082:	4413      	add	r3, r2
 8009084:	f503 73de 	add.w	r3, r3, #444	; 0x1bc
 8009088:	681b      	ldr	r3, [r3, #0]
 800908a:	0a1b      	lsrs	r3, r3, #8
 800908c:	b2da      	uxtb	r2, r3
 800908e:	687b      	ldr	r3, [r7, #4]
 8009090:	741a      	strb	r2, [r3, #16]
  RxMessage->Data[6] = (uint8_t)0xFF & (CANx->sFIFOMailBox[FIFONumber].RDHR >> 16);
 8009092:	7afb      	ldrb	r3, [r7, #11]
 8009094:	68fa      	ldr	r2, [r7, #12]
 8009096:	011b      	lsls	r3, r3, #4
 8009098:	4413      	add	r3, r2
 800909a:	f503 73de 	add.w	r3, r3, #444	; 0x1bc
 800909e:	681b      	ldr	r3, [r3, #0]
 80090a0:	0c1b      	lsrs	r3, r3, #16
 80090a2:	b2da      	uxtb	r2, r3
 80090a4:	687b      	ldr	r3, [r7, #4]
 80090a6:	745a      	strb	r2, [r3, #17]
  RxMessage->Data[7] = (uint8_t)0xFF & (CANx->sFIFOMailBox[FIFONumber].RDHR >> 24);
 80090a8:	7afb      	ldrb	r3, [r7, #11]
 80090aa:	68fa      	ldr	r2, [r7, #12]
 80090ac:	011b      	lsls	r3, r3, #4
 80090ae:	4413      	add	r3, r2
 80090b0:	f503 73de 	add.w	r3, r3, #444	; 0x1bc
 80090b4:	681b      	ldr	r3, [r3, #0]
 80090b6:	0e1b      	lsrs	r3, r3, #24
 80090b8:	b2da      	uxtb	r2, r3
 80090ba:	687b      	ldr	r3, [r7, #4]
 80090bc:	749a      	strb	r2, [r3, #18]
  /* Release the FIFO */
  /* Release FIFO0 */
  if (FIFONumber == CAN_FIFO0)
 80090be:	7afb      	ldrb	r3, [r7, #11]
 80090c0:	2b00      	cmp	r3, #0
 80090c2:	d106      	bne.n	80090d2 <CAN_Receive+0x164>
  {
    CANx->RF0R |= CAN_RF0R_RFOM0;
 80090c4:	68fb      	ldr	r3, [r7, #12]
 80090c6:	68db      	ldr	r3, [r3, #12]
 80090c8:	f043 0220 	orr.w	r2, r3, #32
 80090cc:	68fb      	ldr	r3, [r7, #12]
 80090ce:	60da      	str	r2, [r3, #12]
  /* Release FIFO1 */
  else /* FIFONumber == CAN_FIFO1 */
  {
    CANx->RF1R |= CAN_RF1R_RFOM1;
  }
}
 80090d0:	e005      	b.n	80090de <CAN_Receive+0x170>
    CANx->RF1R |= CAN_RF1R_RFOM1;
 80090d2:	68fb      	ldr	r3, [r7, #12]
 80090d4:	691b      	ldr	r3, [r3, #16]
 80090d6:	f043 0220 	orr.w	r2, r3, #32
 80090da:	68fb      	ldr	r3, [r7, #12]
 80090dc:	611a      	str	r2, [r3, #16]
}
 80090de:	bf00      	nop
 80090e0:	3714      	adds	r7, #20
 80090e2:	46bd      	mov	sp, r7
 80090e4:	f85d 7b04 	ldr.w	r7, [sp], #4
 80090e8:	4770      	bx	lr

080090ea <CAN_FIFORelease>:
  * @param  CANx: where x can be 1 or 2 to select the CAN peripheral.
  * @param  FIFONumber: FIFO to release, CAN_FIFO0 or CAN_FIFO1.
  * @retval None
  */
void CAN_FIFORelease(CAN_TypeDef* CANx, uint8_t FIFONumber)
{
 80090ea:	b480      	push	{r7}
 80090ec:	b083      	sub	sp, #12
 80090ee:	af00      	add	r7, sp, #0
 80090f0:	6078      	str	r0, [r7, #4]
 80090f2:	460b      	mov	r3, r1
 80090f4:	70fb      	strb	r3, [r7, #3]
  /* Check the parameters */
  assert_param(IS_CAN_ALL_PERIPH(CANx));
  assert_param(IS_CAN_FIFO(FIFONumber));
  /* Release FIFO0 */
  if (FIFONumber == CAN_FIFO0)
 80090f6:	78fb      	ldrb	r3, [r7, #3]
 80090f8:	2b00      	cmp	r3, #0
 80090fa:	d106      	bne.n	800910a <CAN_FIFORelease+0x20>
  {
    CANx->RF0R |= CAN_RF0R_RFOM0;
 80090fc:	687b      	ldr	r3, [r7, #4]
 80090fe:	68db      	ldr	r3, [r3, #12]
 8009100:	f043 0220 	orr.w	r2, r3, #32
 8009104:	687b      	ldr	r3, [r7, #4]
 8009106:	60da      	str	r2, [r3, #12]
  /* Release FIFO1 */
  else /* FIFONumber == CAN_FIFO1 */
  {
    CANx->RF1R |= CAN_RF1R_RFOM1;
  }
}
 8009108:	e005      	b.n	8009116 <CAN_FIFORelease+0x2c>
    CANx->RF1R |= CAN_RF1R_RFOM1;
 800910a:	687b      	ldr	r3, [r7, #4]
 800910c:	691b      	ldr	r3, [r3, #16]
 800910e:	f043 0220 	orr.w	r2, r3, #32
 8009112:	687b      	ldr	r3, [r7, #4]
 8009114:	611a      	str	r2, [r3, #16]
}
 8009116:	bf00      	nop
 8009118:	370c      	adds	r7, #12
 800911a:	46bd      	mov	sp, r7
 800911c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8009120:	4770      	bx	lr

08009122 <CAN_MessagePending>:
  * @param  CANx: where x can be 1 or 2 to select the CAN peripheral.
  * @param  FIFONumber: Receive FIFO number, CAN_FIFO0 or CAN_FIFO1.
  * @retval NbMessage : which is the number of pending message.
  */
uint8_t CAN_MessagePending(CAN_TypeDef* CANx, uint8_t FIFONumber)
{
 8009122:	b480      	push	{r7}
 8009124:	b085      	sub	sp, #20
 8009126:	af00      	add	r7, sp, #0
 8009128:	6078      	str	r0, [r7, #4]
 800912a:	460b      	mov	r3, r1
 800912c:	70fb      	strb	r3, [r7, #3]
  uint8_t message_pending=0;
 800912e:	2300      	movs	r3, #0
 8009130:	73fb      	strb	r3, [r7, #15]
  /* Check the parameters */
  assert_param(IS_CAN_ALL_PERIPH(CANx));
  assert_param(IS_CAN_FIFO(FIFONumber));
  if (FIFONumber == CAN_FIFO0)
 8009132:	78fb      	ldrb	r3, [r7, #3]
 8009134:	2b00      	cmp	r3, #0
 8009136:	d106      	bne.n	8009146 <CAN_MessagePending+0x24>
  {
    message_pending = (uint8_t)(CANx->RF0R&(uint32_t)0x03);
 8009138:	687b      	ldr	r3, [r7, #4]
 800913a:	68db      	ldr	r3, [r3, #12]
 800913c:	b2db      	uxtb	r3, r3
 800913e:	f003 0303 	and.w	r3, r3, #3
 8009142:	73fb      	strb	r3, [r7, #15]
 8009144:	e00b      	b.n	800915e <CAN_MessagePending+0x3c>
  }
  else if (FIFONumber == CAN_FIFO1)
 8009146:	78fb      	ldrb	r3, [r7, #3]
 8009148:	2b01      	cmp	r3, #1
 800914a:	d106      	bne.n	800915a <CAN_MessagePending+0x38>
  {
    message_pending = (uint8_t)(CANx->RF1R&(uint32_t)0x03);
 800914c:	687b      	ldr	r3, [r7, #4]
 800914e:	691b      	ldr	r3, [r3, #16]
 8009150:	b2db      	uxtb	r3, r3
 8009152:	f003 0303 	and.w	r3, r3, #3
 8009156:	73fb      	strb	r3, [r7, #15]
 8009158:	e001      	b.n	800915e <CAN_MessagePending+0x3c>
  }
  else
  {
    message_pending = 0;
 800915a:	2300      	movs	r3, #0
 800915c:	73fb      	strb	r3, [r7, #15]
  }
  return message_pending;
 800915e:	7bfb      	ldrb	r3, [r7, #15]
}
 8009160:	4618      	mov	r0, r3
 8009162:	3714      	adds	r7, #20
 8009164:	46bd      	mov	sp, r7
 8009166:	f85d 7b04 	ldr.w	r7, [sp], #4
 800916a:	4770      	bx	lr

0800916c <CAN_OperatingModeRequest>:
  * @retval status of the requested mode which can be 
  *         - CAN_ModeStatus_Failed:  CAN failed entering the specific mode 
  *         - CAN_ModeStatus_Success: CAN Succeed entering the specific mode 
  */
uint8_t CAN_OperatingModeRequest(CAN_TypeDef* CANx, uint8_t CAN_OperatingMode)
{
 800916c:	b480      	push	{r7}
 800916e:	b085      	sub	sp, #20
 8009170:	af00      	add	r7, sp, #0
 8009172:	6078      	str	r0, [r7, #4]
 8009174:	460b      	mov	r3, r1
 8009176:	70fb      	strb	r3, [r7, #3]
  uint8_t status = CAN_ModeStatus_Failed;
 8009178:	2300      	movs	r3, #0
 800917a:	73fb      	strb	r3, [r7, #15]
  
  /* Timeout for INAK or also for SLAK bits*/
  uint32_t timeout = INAK_TIMEOUT; 
 800917c:	f64f 73ff 	movw	r3, #65535	; 0xffff
 8009180:	60bb      	str	r3, [r7, #8]

  /* Check the parameters */
  assert_param(IS_CAN_ALL_PERIPH(CANx));
  assert_param(IS_CAN_OPERATING_MODE(CAN_OperatingMode));

  if (CAN_OperatingMode == CAN_OperatingMode_Initialization)
 8009182:	78fb      	ldrb	r3, [r7, #3]
 8009184:	2b00      	cmp	r3, #0
 8009186:	d120      	bne.n	80091ca <CAN_OperatingModeRequest+0x5e>
  {
    /* Request initialisation */
    CANx->MCR = (uint32_t)((CANx->MCR & (uint32_t)(~(uint32_t)CAN_MCR_SLEEP)) | CAN_MCR_INRQ);
 8009188:	687b      	ldr	r3, [r7, #4]
 800918a:	681b      	ldr	r3, [r3, #0]
 800918c:	f023 0303 	bic.w	r3, r3, #3
 8009190:	f043 0201 	orr.w	r2, r3, #1
 8009194:	687b      	ldr	r3, [r7, #4]
 8009196:	601a      	str	r2, [r3, #0]

    /* Wait the acknowledge */
    while (((CANx->MSR & CAN_MODE_MASK) != CAN_MSR_INAK) && (timeout != 0))
 8009198:	e002      	b.n	80091a0 <CAN_OperatingModeRequest+0x34>
    {
      timeout--;
 800919a:	68bb      	ldr	r3, [r7, #8]
 800919c:	3b01      	subs	r3, #1
 800919e:	60bb      	str	r3, [r7, #8]
    while (((CANx->MSR & CAN_MODE_MASK) != CAN_MSR_INAK) && (timeout != 0))
 80091a0:	687b      	ldr	r3, [r7, #4]
 80091a2:	685b      	ldr	r3, [r3, #4]
 80091a4:	f003 0303 	and.w	r3, r3, #3
 80091a8:	2b01      	cmp	r3, #1
 80091aa:	d002      	beq.n	80091b2 <CAN_OperatingModeRequest+0x46>
 80091ac:	68bb      	ldr	r3, [r7, #8]
 80091ae:	2b00      	cmp	r3, #0
 80091b0:	d1f3      	bne.n	800919a <CAN_OperatingModeRequest+0x2e>
    }
    if ((CANx->MSR & CAN_MODE_MASK) != CAN_MSR_INAK)
 80091b2:	687b      	ldr	r3, [r7, #4]
 80091b4:	685b      	ldr	r3, [r3, #4]
 80091b6:	f003 0303 	and.w	r3, r3, #3
 80091ba:	2b01      	cmp	r3, #1
 80091bc:	d002      	beq.n	80091c4 <CAN_OperatingModeRequest+0x58>
    {
      status = CAN_ModeStatus_Failed;
 80091be:	2300      	movs	r3, #0
 80091c0:	73fb      	strb	r3, [r7, #15]
 80091c2:	e04a      	b.n	800925a <CAN_OperatingModeRequest+0xee>
    }
    else
    {
      status = CAN_ModeStatus_Success;
 80091c4:	2301      	movs	r3, #1
 80091c6:	73fb      	strb	r3, [r7, #15]
 80091c8:	e047      	b.n	800925a <CAN_OperatingModeRequest+0xee>
    }
  }
  else  if (CAN_OperatingMode == CAN_OperatingMode_Normal)
 80091ca:	78fb      	ldrb	r3, [r7, #3]
 80091cc:	2b01      	cmp	r3, #1
 80091ce:	d11e      	bne.n	800920e <CAN_OperatingModeRequest+0xa2>
  {
    /* Request leave initialisation and sleep mode  and enter Normal mode */
    CANx->MCR &= (uint32_t)(~(CAN_MCR_SLEEP|CAN_MCR_INRQ));
 80091d0:	687b      	ldr	r3, [r7, #4]
 80091d2:	681b      	ldr	r3, [r3, #0]
 80091d4:	f023 0203 	bic.w	r2, r3, #3
 80091d8:	687b      	ldr	r3, [r7, #4]
 80091da:	601a      	str	r2, [r3, #0]

    /* Wait the acknowledge */
    while (((CANx->MSR & CAN_MODE_MASK) != 0) && (timeout!=0))
 80091dc:	e002      	b.n	80091e4 <CAN_OperatingModeRequest+0x78>
    {
      timeout--;
 80091de:	68bb      	ldr	r3, [r7, #8]
 80091e0:	3b01      	subs	r3, #1
 80091e2:	60bb      	str	r3, [r7, #8]
    while (((CANx->MSR & CAN_MODE_MASK) != 0) && (timeout!=0))
 80091e4:	687b      	ldr	r3, [r7, #4]
 80091e6:	685b      	ldr	r3, [r3, #4]
 80091e8:	f003 0303 	and.w	r3, r3, #3
 80091ec:	2b00      	cmp	r3, #0
 80091ee:	d002      	beq.n	80091f6 <CAN_OperatingModeRequest+0x8a>
 80091f0:	68bb      	ldr	r3, [r7, #8]
 80091f2:	2b00      	cmp	r3, #0
 80091f4:	d1f3      	bne.n	80091de <CAN_OperatingModeRequest+0x72>
    }
    if ((CANx->MSR & CAN_MODE_MASK) != 0)
 80091f6:	687b      	ldr	r3, [r7, #4]
 80091f8:	685b      	ldr	r3, [r3, #4]
 80091fa:	f003 0303 	and.w	r3, r3, #3
 80091fe:	2b00      	cmp	r3, #0
 8009200:	d002      	beq.n	8009208 <CAN_OperatingModeRequest+0x9c>
    {
      status = CAN_ModeStatus_Failed;
 8009202:	2300      	movs	r3, #0
 8009204:	73fb      	strb	r3, [r7, #15]
 8009206:	e028      	b.n	800925a <CAN_OperatingModeRequest+0xee>
    }
    else
    {
      status = CAN_ModeStatus_Success;
 8009208:	2301      	movs	r3, #1
 800920a:	73fb      	strb	r3, [r7, #15]
 800920c:	e025      	b.n	800925a <CAN_OperatingModeRequest+0xee>
    }
  }
  else  if (CAN_OperatingMode == CAN_OperatingMode_Sleep)
 800920e:	78fb      	ldrb	r3, [r7, #3]
 8009210:	2b02      	cmp	r3, #2
 8009212:	d120      	bne.n	8009256 <CAN_OperatingModeRequest+0xea>
  {
    /* Request Sleep mode */
    CANx->MCR = (uint32_t)((CANx->MCR & (uint32_t)(~(uint32_t)CAN_MCR_INRQ)) | CAN_MCR_SLEEP);
 8009214:	687b      	ldr	r3, [r7, #4]
 8009216:	681b      	ldr	r3, [r3, #0]
 8009218:	f023 0303 	bic.w	r3, r3, #3
 800921c:	f043 0202 	orr.w	r2, r3, #2
 8009220:	687b      	ldr	r3, [r7, #4]
 8009222:	601a      	str	r2, [r3, #0]

    /* Wait the acknowledge */
    while (((CANx->MSR & CAN_MODE_MASK) != CAN_MSR_SLAK) && (timeout!=0))
 8009224:	e002      	b.n	800922c <CAN_OperatingModeRequest+0xc0>
    {
      timeout--;
 8009226:	68bb      	ldr	r3, [r7, #8]
 8009228:	3b01      	subs	r3, #1
 800922a:	60bb      	str	r3, [r7, #8]
    while (((CANx->MSR & CAN_MODE_MASK) != CAN_MSR_SLAK) && (timeout!=0))
 800922c:	687b      	ldr	r3, [r7, #4]
 800922e:	685b      	ldr	r3, [r3, #4]
 8009230:	f003 0303 	and.w	r3, r3, #3
 8009234:	2b02      	cmp	r3, #2
 8009236:	d002      	beq.n	800923e <CAN_OperatingModeRequest+0xd2>
 8009238:	68bb      	ldr	r3, [r7, #8]
 800923a:	2b00      	cmp	r3, #0
 800923c:	d1f3      	bne.n	8009226 <CAN_OperatingModeRequest+0xba>
    }
    if ((CANx->MSR & CAN_MODE_MASK) != CAN_MSR_SLAK)
 800923e:	687b      	ldr	r3, [r7, #4]
 8009240:	685b      	ldr	r3, [r3, #4]
 8009242:	f003 0303 	and.w	r3, r3, #3
 8009246:	2b02      	cmp	r3, #2
 8009248:	d002      	beq.n	8009250 <CAN_OperatingModeRequest+0xe4>
    {
      status = CAN_ModeStatus_Failed;
 800924a:	2300      	movs	r3, #0
 800924c:	73fb      	strb	r3, [r7, #15]
 800924e:	e004      	b.n	800925a <CAN_OperatingModeRequest+0xee>
    }
    else
    {
      status = CAN_ModeStatus_Success;
 8009250:	2301      	movs	r3, #1
 8009252:	73fb      	strb	r3, [r7, #15]
 8009254:	e001      	b.n	800925a <CAN_OperatingModeRequest+0xee>
    }
  }
  else
  {
    status = CAN_ModeStatus_Failed;
 8009256:	2300      	movs	r3, #0
 8009258:	73fb      	strb	r3, [r7, #15]
  }

  return  (uint8_t) status;
 800925a:	7bfb      	ldrb	r3, [r7, #15]
}
 800925c:	4618      	mov	r0, r3
 800925e:	3714      	adds	r7, #20
 8009260:	46bd      	mov	sp, r7
 8009262:	f85d 7b04 	ldr.w	r7, [sp], #4
 8009266:	4770      	bx	lr

08009268 <CAN_Sleep>:
  * @brief  Enters the Sleep (low power) mode.
  * @param  CANx: where x can be 1 or 2 to select the CAN peripheral.
  * @retval CAN_Sleep_Ok if sleep entered, CAN_Sleep_Failed otherwise.
  */
uint8_t CAN_Sleep(CAN_TypeDef* CANx)
{
 8009268:	b480      	push	{r7}
 800926a:	b085      	sub	sp, #20
 800926c:	af00      	add	r7, sp, #0
 800926e:	6078      	str	r0, [r7, #4]
  uint8_t sleepstatus = CAN_Sleep_Failed;
 8009270:	2300      	movs	r3, #0
 8009272:	73fb      	strb	r3, [r7, #15]
  
  /* Check the parameters */
  assert_param(IS_CAN_ALL_PERIPH(CANx));
    
  /* Request Sleep mode */
   CANx->MCR = (((CANx->MCR) & (uint32_t)(~(uint32_t)CAN_MCR_INRQ)) | CAN_MCR_SLEEP);
 8009274:	687b      	ldr	r3, [r7, #4]
 8009276:	681b      	ldr	r3, [r3, #0]
 8009278:	f023 0303 	bic.w	r3, r3, #3
 800927c:	f043 0202 	orr.w	r2, r3, #2
 8009280:	687b      	ldr	r3, [r7, #4]
 8009282:	601a      	str	r2, [r3, #0]
   
  /* Sleep mode status */
  if ((CANx->MSR & (CAN_MSR_SLAK|CAN_MSR_INAK)) == CAN_MSR_SLAK)
 8009284:	687b      	ldr	r3, [r7, #4]
 8009286:	685b      	ldr	r3, [r3, #4]
 8009288:	f003 0303 	and.w	r3, r3, #3
 800928c:	2b02      	cmp	r3, #2
 800928e:	d101      	bne.n	8009294 <CAN_Sleep+0x2c>
  {
    /* Sleep mode not entered */
    sleepstatus =  CAN_Sleep_Ok;
 8009290:	2301      	movs	r3, #1
 8009292:	73fb      	strb	r3, [r7, #15]
  }
  /* return sleep mode status */
   return (uint8_t)sleepstatus;
 8009294:	7bfb      	ldrb	r3, [r7, #15]
}
 8009296:	4618      	mov	r0, r3
 8009298:	3714      	adds	r7, #20
 800929a:	46bd      	mov	sp, r7
 800929c:	f85d 7b04 	ldr.w	r7, [sp], #4
 80092a0:	4770      	bx	lr

080092a2 <CAN_WakeUp>:
  * @brief  Wakes up the CAN peripheral from sleep mode .
  * @param  CANx: where x can be 1 or 2 to select the CAN peripheral.
  * @retval CAN_WakeUp_Ok if sleep mode left, CAN_WakeUp_Failed otherwise.
  */
uint8_t CAN_WakeUp(CAN_TypeDef* CANx)
{
 80092a2:	b480      	push	{r7}
 80092a4:	b085      	sub	sp, #20
 80092a6:	af00      	add	r7, sp, #0
 80092a8:	6078      	str	r0, [r7, #4]
  uint32_t wait_slak = SLAK_TIMEOUT;
 80092aa:	f64f 73ff 	movw	r3, #65535	; 0xffff
 80092ae:	60fb      	str	r3, [r7, #12]
  uint8_t wakeupstatus = CAN_WakeUp_Failed;
 80092b0:	2300      	movs	r3, #0
 80092b2:	72fb      	strb	r3, [r7, #11]
  
  /* Check the parameters */
  assert_param(IS_CAN_ALL_PERIPH(CANx));
    
  /* Wake up request */
  CANx->MCR &= ~(uint32_t)CAN_MCR_SLEEP;
 80092b4:	687b      	ldr	r3, [r7, #4]
 80092b6:	681b      	ldr	r3, [r3, #0]
 80092b8:	f023 0202 	bic.w	r2, r3, #2
 80092bc:	687b      	ldr	r3, [r7, #4]
 80092be:	601a      	str	r2, [r3, #0]
    
  /* Sleep mode status */
  while(((CANx->MSR & CAN_MSR_SLAK) == CAN_MSR_SLAK)&&(wait_slak!=0x00))
 80092c0:	e002      	b.n	80092c8 <CAN_WakeUp+0x26>
  {
   wait_slak--;
 80092c2:	68fb      	ldr	r3, [r7, #12]
 80092c4:	3b01      	subs	r3, #1
 80092c6:	60fb      	str	r3, [r7, #12]
  while(((CANx->MSR & CAN_MSR_SLAK) == CAN_MSR_SLAK)&&(wait_slak!=0x00))
 80092c8:	687b      	ldr	r3, [r7, #4]
 80092ca:	685b      	ldr	r3, [r3, #4]
 80092cc:	f003 0302 	and.w	r3, r3, #2
 80092d0:	2b02      	cmp	r3, #2
 80092d2:	d102      	bne.n	80092da <CAN_WakeUp+0x38>
 80092d4:	68fb      	ldr	r3, [r7, #12]
 80092d6:	2b00      	cmp	r3, #0
 80092d8:	d1f3      	bne.n	80092c2 <CAN_WakeUp+0x20>
  }
  if((CANx->MSR & CAN_MSR_SLAK) != CAN_MSR_SLAK)
 80092da:	687b      	ldr	r3, [r7, #4]
 80092dc:	685b      	ldr	r3, [r3, #4]
 80092de:	f003 0302 	and.w	r3, r3, #2
 80092e2:	2b02      	cmp	r3, #2
 80092e4:	d001      	beq.n	80092ea <CAN_WakeUp+0x48>
  {
   /* wake up done : Sleep mode exited */
    wakeupstatus = CAN_WakeUp_Ok;
 80092e6:	2301      	movs	r3, #1
 80092e8:	72fb      	strb	r3, [r7, #11]
  }
  /* return wakeup status */
  return (uint8_t)wakeupstatus;
 80092ea:	7afb      	ldrb	r3, [r7, #11]
}
 80092ec:	4618      	mov	r0, r3
 80092ee:	3714      	adds	r7, #20
 80092f0:	46bd      	mov	sp, r7
 80092f2:	f85d 7b04 	ldr.w	r7, [sp], #4
 80092f6:	4770      	bx	lr

080092f8 <CAN_GetLastErrorCode>:
  *          - CAN_ERRORCODE_BitDominantErr: Bit Dominant Error
  *          - CAN_ERRORCODE_CRCErr: CRC Error
  *          - CAN_ERRORCODE_SoftwareSetErr: Software Set Error  
  */
uint8_t CAN_GetLastErrorCode(CAN_TypeDef* CANx)
{
 80092f8:	b480      	push	{r7}
 80092fa:	b085      	sub	sp, #20
 80092fc:	af00      	add	r7, sp, #0
 80092fe:	6078      	str	r0, [r7, #4]
  uint8_t errorcode=0;
 8009300:	2300      	movs	r3, #0
 8009302:	73fb      	strb	r3, [r7, #15]
  
  /* Check the parameters */
  assert_param(IS_CAN_ALL_PERIPH(CANx));
  
  /* Get the error code*/
  errorcode = (((uint8_t)CANx->ESR) & (uint8_t)CAN_ESR_LEC);
 8009304:	687b      	ldr	r3, [r7, #4]
 8009306:	699b      	ldr	r3, [r3, #24]
 8009308:	b2db      	uxtb	r3, r3
 800930a:	f003 0370 	and.w	r3, r3, #112	; 0x70
 800930e:	73fb      	strb	r3, [r7, #15]
  
  /* Return the error code*/
  return errorcode;
 8009310:	7bfb      	ldrb	r3, [r7, #15]
}
 8009312:	4618      	mov	r0, r3
 8009314:	3714      	adds	r7, #20
 8009316:	46bd      	mov	sp, r7
 8009318:	f85d 7b04 	ldr.w	r7, [sp], #4
 800931c:	4770      	bx	lr

0800931e <CAN_GetReceiveErrorCounter>:
  *         error passive state.  
  * @param  CANx: where x can be 1 or 2 to to select the CAN peripheral.  
  * @retval CAN Receive Error Counter. 
  */
uint8_t CAN_GetReceiveErrorCounter(CAN_TypeDef* CANx)
{
 800931e:	b480      	push	{r7}
 8009320:	b085      	sub	sp, #20
 8009322:	af00      	add	r7, sp, #0
 8009324:	6078      	str	r0, [r7, #4]
  uint8_t counter=0;
 8009326:	2300      	movs	r3, #0
 8009328:	73fb      	strb	r3, [r7, #15]
  
  /* Check the parameters */
  assert_param(IS_CAN_ALL_PERIPH(CANx));
  
  /* Get the Receive Error Counter*/
  counter = (uint8_t)((CANx->ESR & CAN_ESR_REC)>> 24);
 800932a:	687b      	ldr	r3, [r7, #4]
 800932c:	699b      	ldr	r3, [r3, #24]
 800932e:	0e1b      	lsrs	r3, r3, #24
 8009330:	73fb      	strb	r3, [r7, #15]
  
  /* Return the Receive Error Counter*/
  return counter;
 8009332:	7bfb      	ldrb	r3, [r7, #15]
}
 8009334:	4618      	mov	r0, r3
 8009336:	3714      	adds	r7, #20
 8009338:	46bd      	mov	sp, r7
 800933a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800933e:	4770      	bx	lr

08009340 <CAN_GetLSBTransmitErrorCounter>:
  * @brief  Returns the LSB of the 9-bit CANx Transmit Error Counter(TEC).
  * @param  CANx: where x can be 1 or 2 to to select the CAN peripheral.
  * @retval LSB of the 9-bit CAN Transmit Error Counter. 
  */
uint8_t CAN_GetLSBTransmitErrorCounter(CAN_TypeDef* CANx)
{
 8009340:	b480      	push	{r7}
 8009342:	b085      	sub	sp, #20
 8009344:	af00      	add	r7, sp, #0
 8009346:	6078      	str	r0, [r7, #4]
  uint8_t counter=0;
 8009348:	2300      	movs	r3, #0
 800934a:	73fb      	strb	r3, [r7, #15]
  
  /* Check the parameters */
  assert_param(IS_CAN_ALL_PERIPH(CANx));
  
  /* Get the LSB of the 9-bit CANx Transmit Error Counter(TEC) */
  counter = (uint8_t)((CANx->ESR & CAN_ESR_TEC)>> 16);
 800934c:	687b      	ldr	r3, [r7, #4]
 800934e:	699b      	ldr	r3, [r3, #24]
 8009350:	0c1b      	lsrs	r3, r3, #16
 8009352:	73fb      	strb	r3, [r7, #15]
  
  /* Return the LSB of the 9-bit CANx Transmit Error Counter(TEC) */
  return counter;
 8009354:	7bfb      	ldrb	r3, [r7, #15]
}
 8009356:	4618      	mov	r0, r3
 8009358:	3714      	adds	r7, #20
 800935a:	46bd      	mov	sp, r7
 800935c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8009360:	4770      	bx	lr

08009362 <CAN_ITConfig>:
  * @param  NewState: new state of the CAN interrupts.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void CAN_ITConfig(CAN_TypeDef* CANx, uint32_t CAN_IT, FunctionalState NewState)
{
 8009362:	b480      	push	{r7}
 8009364:	b085      	sub	sp, #20
 8009366:	af00      	add	r7, sp, #0
 8009368:	60f8      	str	r0, [r7, #12]
 800936a:	60b9      	str	r1, [r7, #8]
 800936c:	4613      	mov	r3, r2
 800936e:	71fb      	strb	r3, [r7, #7]
  /* Check the parameters */
  assert_param(IS_CAN_ALL_PERIPH(CANx));
  assert_param(IS_CAN_IT(CAN_IT));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 8009370:	79fb      	ldrb	r3, [r7, #7]
 8009372:	2b00      	cmp	r3, #0
 8009374:	d006      	beq.n	8009384 <CAN_ITConfig+0x22>
  {
    /* Enable the selected CANx interrupt */
    CANx->IER |= CAN_IT;
 8009376:	68fb      	ldr	r3, [r7, #12]
 8009378:	695a      	ldr	r2, [r3, #20]
 800937a:	68bb      	ldr	r3, [r7, #8]
 800937c:	431a      	orrs	r2, r3
 800937e:	68fb      	ldr	r3, [r7, #12]
 8009380:	615a      	str	r2, [r3, #20]
  else
  {
    /* Disable the selected CANx interrupt */
    CANx->IER &= ~CAN_IT;
  }
}
 8009382:	e006      	b.n	8009392 <CAN_ITConfig+0x30>
    CANx->IER &= ~CAN_IT;
 8009384:	68fb      	ldr	r3, [r7, #12]
 8009386:	695a      	ldr	r2, [r3, #20]
 8009388:	68bb      	ldr	r3, [r7, #8]
 800938a:	43db      	mvns	r3, r3
 800938c:	401a      	ands	r2, r3
 800938e:	68fb      	ldr	r3, [r7, #12]
 8009390:	615a      	str	r2, [r3, #20]
}
 8009392:	bf00      	nop
 8009394:	3714      	adds	r7, #20
 8009396:	46bd      	mov	sp, r7
 8009398:	f85d 7b04 	ldr.w	r7, [sp], #4
 800939c:	4770      	bx	lr

0800939e <CAN_GetFlagStatus>:
  *            @arg CAN_FLAG_BOF: Bus-Off Flag    
  *            @arg CAN_FLAG_LEC: Last error code Flag      
  * @retval The new state of CAN_FLAG (SET or RESET).
  */
FlagStatus CAN_GetFlagStatus(CAN_TypeDef* CANx, uint32_t CAN_FLAG)
{
 800939e:	b480      	push	{r7}
 80093a0:	b085      	sub	sp, #20
 80093a2:	af00      	add	r7, sp, #0
 80093a4:	6078      	str	r0, [r7, #4]
 80093a6:	6039      	str	r1, [r7, #0]
  FlagStatus bitstatus = RESET;
 80093a8:	2300      	movs	r3, #0
 80093aa:	73fb      	strb	r3, [r7, #15]
  /* Check the parameters */
  assert_param(IS_CAN_ALL_PERIPH(CANx));
  assert_param(IS_CAN_GET_FLAG(CAN_FLAG));
  

  if((CAN_FLAG & CAN_FLAGS_ESR) != (uint32_t)RESET)
 80093ac:	683b      	ldr	r3, [r7, #0]
 80093ae:	f403 0370 	and.w	r3, r3, #15728640	; 0xf00000
 80093b2:	2b00      	cmp	r3, #0
 80093b4:	d00d      	beq.n	80093d2 <CAN_GetFlagStatus+0x34>
  { 
    /* Check the status of the specified CAN flag */
    if ((CANx->ESR & (CAN_FLAG & 0x000FFFFF)) != (uint32_t)RESET)
 80093b6:	687b      	ldr	r3, [r7, #4]
 80093b8:	699a      	ldr	r2, [r3, #24]
 80093ba:	683b      	ldr	r3, [r7, #0]
 80093bc:	4013      	ands	r3, r2
 80093be:	f3c3 0313 	ubfx	r3, r3, #0, #20
 80093c2:	2b00      	cmp	r3, #0
 80093c4:	d002      	beq.n	80093cc <CAN_GetFlagStatus+0x2e>
    { 
      /* CAN_FLAG is set */
      bitstatus = SET;
 80093c6:	2301      	movs	r3, #1
 80093c8:	73fb      	strb	r3, [r7, #15]
 80093ca:	e048      	b.n	800945e <CAN_GetFlagStatus+0xc0>
    }
    else
    { 
      /* CAN_FLAG is reset */
      bitstatus = RESET;
 80093cc:	2300      	movs	r3, #0
 80093ce:	73fb      	strb	r3, [r7, #15]
 80093d0:	e045      	b.n	800945e <CAN_GetFlagStatus+0xc0>
    }
  }
  else if((CAN_FLAG & CAN_FLAGS_MSR) != (uint32_t)RESET)
 80093d2:	683b      	ldr	r3, [r7, #0]
 80093d4:	f003 7380 	and.w	r3, r3, #16777216	; 0x1000000
 80093d8:	2b00      	cmp	r3, #0
 80093da:	d00d      	beq.n	80093f8 <CAN_GetFlagStatus+0x5a>
  { 
    /* Check the status of the specified CAN flag */
    if ((CANx->MSR & (CAN_FLAG & 0x000FFFFF)) != (uint32_t)RESET)
 80093dc:	687b      	ldr	r3, [r7, #4]
 80093de:	685a      	ldr	r2, [r3, #4]
 80093e0:	683b      	ldr	r3, [r7, #0]
 80093e2:	4013      	ands	r3, r2
 80093e4:	f3c3 0313 	ubfx	r3, r3, #0, #20
 80093e8:	2b00      	cmp	r3, #0
 80093ea:	d002      	beq.n	80093f2 <CAN_GetFlagStatus+0x54>
    { 
      /* CAN_FLAG is set */
      bitstatus = SET;
 80093ec:	2301      	movs	r3, #1
 80093ee:	73fb      	strb	r3, [r7, #15]
 80093f0:	e035      	b.n	800945e <CAN_GetFlagStatus+0xc0>
    }
    else
    { 
      /* CAN_FLAG is reset */
      bitstatus = RESET;
 80093f2:	2300      	movs	r3, #0
 80093f4:	73fb      	strb	r3, [r7, #15]
 80093f6:	e032      	b.n	800945e <CAN_GetFlagStatus+0xc0>
    }
  }
  else if((CAN_FLAG & CAN_FLAGS_TSR) != (uint32_t)RESET)
 80093f8:	683b      	ldr	r3, [r7, #0]
 80093fa:	f003 6300 	and.w	r3, r3, #134217728	; 0x8000000
 80093fe:	2b00      	cmp	r3, #0
 8009400:	d00d      	beq.n	800941e <CAN_GetFlagStatus+0x80>
  { 
    /* Check the status of the specified CAN flag */
    if ((CANx->TSR & (CAN_FLAG & 0x000FFFFF)) != (uint32_t)RESET)
 8009402:	687b      	ldr	r3, [r7, #4]
 8009404:	689a      	ldr	r2, [r3, #8]
 8009406:	683b      	ldr	r3, [r7, #0]
 8009408:	4013      	ands	r3, r2
 800940a:	f3c3 0313 	ubfx	r3, r3, #0, #20
 800940e:	2b00      	cmp	r3, #0
 8009410:	d002      	beq.n	8009418 <CAN_GetFlagStatus+0x7a>
    { 
      /* CAN_FLAG is set */
      bitstatus = SET;
 8009412:	2301      	movs	r3, #1
 8009414:	73fb      	strb	r3, [r7, #15]
 8009416:	e022      	b.n	800945e <CAN_GetFlagStatus+0xc0>
    }
    else
    { 
      /* CAN_FLAG is reset */
      bitstatus = RESET;
 8009418:	2300      	movs	r3, #0
 800941a:	73fb      	strb	r3, [r7, #15]
 800941c:	e01f      	b.n	800945e <CAN_GetFlagStatus+0xc0>
    }
  }
  else if((CAN_FLAG & CAN_FLAGS_RF0R) != (uint32_t)RESET)
 800941e:	683b      	ldr	r3, [r7, #0]
 8009420:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
 8009424:	2b00      	cmp	r3, #0
 8009426:	d00d      	beq.n	8009444 <CAN_GetFlagStatus+0xa6>
  { 
    /* Check the status of the specified CAN flag */
    if ((CANx->RF0R & (CAN_FLAG & 0x000FFFFF)) != (uint32_t)RESET)
 8009428:	687b      	ldr	r3, [r7, #4]
 800942a:	68da      	ldr	r2, [r3, #12]
 800942c:	683b      	ldr	r3, [r7, #0]
 800942e:	4013      	ands	r3, r2
 8009430:	f3c3 0313 	ubfx	r3, r3, #0, #20
 8009434:	2b00      	cmp	r3, #0
 8009436:	d002      	beq.n	800943e <CAN_GetFlagStatus+0xa0>
    { 
      /* CAN_FLAG is set */
      bitstatus = SET;
 8009438:	2301      	movs	r3, #1
 800943a:	73fb      	strb	r3, [r7, #15]
 800943c:	e00f      	b.n	800945e <CAN_GetFlagStatus+0xc0>
    }
    else
    { 
      /* CAN_FLAG is reset */
      bitstatus = RESET;
 800943e:	2300      	movs	r3, #0
 8009440:	73fb      	strb	r3, [r7, #15]
 8009442:	e00c      	b.n	800945e <CAN_GetFlagStatus+0xc0>
    }
  }
  else /* If(CAN_FLAG & CAN_FLAGS_RF1R != (uint32_t)RESET) */
  { 
    /* Check the status of the specified CAN flag */
    if ((uint32_t)(CANx->RF1R & (CAN_FLAG & 0x000FFFFF)) != (uint32_t)RESET)
 8009444:	687b      	ldr	r3, [r7, #4]
 8009446:	691a      	ldr	r2, [r3, #16]
 8009448:	683b      	ldr	r3, [r7, #0]
 800944a:	4013      	ands	r3, r2
 800944c:	f3c3 0313 	ubfx	r3, r3, #0, #20
 8009450:	2b00      	cmp	r3, #0
 8009452:	d002      	beq.n	800945a <CAN_GetFlagStatus+0xbc>
    { 
      /* CAN_FLAG is set */
      bitstatus = SET;
 8009454:	2301      	movs	r3, #1
 8009456:	73fb      	strb	r3, [r7, #15]
 8009458:	e001      	b.n	800945e <CAN_GetFlagStatus+0xc0>
    }
    else
    { 
      /* CAN_FLAG is reset */
      bitstatus = RESET;
 800945a:	2300      	movs	r3, #0
 800945c:	73fb      	strb	r3, [r7, #15]
    }
  }
  /* Return the CAN_FLAG status */
  return  bitstatus;
 800945e:	7bfb      	ldrb	r3, [r7, #15]
}
 8009460:	4618      	mov	r0, r3
 8009462:	3714      	adds	r7, #20
 8009464:	46bd      	mov	sp, r7
 8009466:	f85d 7b04 	ldr.w	r7, [sp], #4
 800946a:	4770      	bx	lr

0800946c <CAN_ClearFlag>:
  *            @arg CAN_FLAG_SLAK: Sleep acknowledge Flag    
  *            @arg CAN_FLAG_LEC: Last error code Flag        
  * @retval None
  */
void CAN_ClearFlag(CAN_TypeDef* CANx, uint32_t CAN_FLAG)
{
 800946c:	b480      	push	{r7}
 800946e:	b085      	sub	sp, #20
 8009470:	af00      	add	r7, sp, #0
 8009472:	6078      	str	r0, [r7, #4]
 8009474:	6039      	str	r1, [r7, #0]
  uint32_t flagtmp=0;
 8009476:	2300      	movs	r3, #0
 8009478:	60fb      	str	r3, [r7, #12]
  /* Check the parameters */
  assert_param(IS_CAN_ALL_PERIPH(CANx));
  assert_param(IS_CAN_CLEAR_FLAG(CAN_FLAG));
  
  if (CAN_FLAG == CAN_FLAG_LEC) /* ESR register */
 800947a:	683b      	ldr	r3, [r7, #0]
 800947c:	4a17      	ldr	r2, [pc, #92]	; (80094dc <CAN_ClearFlag+0x70>)
 800947e:	4293      	cmp	r3, r2
 8009480:	d103      	bne.n	800948a <CAN_ClearFlag+0x1e>
  {
    /* Clear the selected CAN flags */
    CANx->ESR = (uint32_t)RESET;
 8009482:	687b      	ldr	r3, [r7, #4]
 8009484:	2200      	movs	r2, #0
 8009486:	619a      	str	r2, [r3, #24]
    {
      /* Operating mode Flags */
      CANx->MSR = (uint32_t)(flagtmp);
    }
  }
}
 8009488:	e021      	b.n	80094ce <CAN_ClearFlag+0x62>
    flagtmp = CAN_FLAG & 0x000FFFFF;
 800948a:	683b      	ldr	r3, [r7, #0]
 800948c:	f3c3 0313 	ubfx	r3, r3, #0, #20
 8009490:	60fb      	str	r3, [r7, #12]
    if ((CAN_FLAG & CAN_FLAGS_RF0R)!=(uint32_t)RESET)
 8009492:	683b      	ldr	r3, [r7, #0]
 8009494:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
 8009498:	2b00      	cmp	r3, #0
 800949a:	d003      	beq.n	80094a4 <CAN_ClearFlag+0x38>
      CANx->RF0R = (uint32_t)(flagtmp);
 800949c:	687b      	ldr	r3, [r7, #4]
 800949e:	68fa      	ldr	r2, [r7, #12]
 80094a0:	60da      	str	r2, [r3, #12]
}
 80094a2:	e014      	b.n	80094ce <CAN_ClearFlag+0x62>
    else if ((CAN_FLAG & CAN_FLAGS_RF1R)!=(uint32_t)RESET)
 80094a4:	683b      	ldr	r3, [r7, #0]
 80094a6:	f003 6380 	and.w	r3, r3, #67108864	; 0x4000000
 80094aa:	2b00      	cmp	r3, #0
 80094ac:	d003      	beq.n	80094b6 <CAN_ClearFlag+0x4a>
      CANx->RF1R = (uint32_t)(flagtmp);
 80094ae:	687b      	ldr	r3, [r7, #4]
 80094b0:	68fa      	ldr	r2, [r7, #12]
 80094b2:	611a      	str	r2, [r3, #16]
}
 80094b4:	e00b      	b.n	80094ce <CAN_ClearFlag+0x62>
    else if ((CAN_FLAG & CAN_FLAGS_TSR)!=(uint32_t)RESET)
 80094b6:	683b      	ldr	r3, [r7, #0]
 80094b8:	f003 6300 	and.w	r3, r3, #134217728	; 0x8000000
 80094bc:	2b00      	cmp	r3, #0
 80094be:	d003      	beq.n	80094c8 <CAN_ClearFlag+0x5c>
      CANx->TSR = (uint32_t)(flagtmp);
 80094c0:	687b      	ldr	r3, [r7, #4]
 80094c2:	68fa      	ldr	r2, [r7, #12]
 80094c4:	609a      	str	r2, [r3, #8]
}
 80094c6:	e002      	b.n	80094ce <CAN_ClearFlag+0x62>
      CANx->MSR = (uint32_t)(flagtmp);
 80094c8:	687b      	ldr	r3, [r7, #4]
 80094ca:	68fa      	ldr	r2, [r7, #12]
 80094cc:	605a      	str	r2, [r3, #4]
}
 80094ce:	bf00      	nop
 80094d0:	3714      	adds	r7, #20
 80094d2:	46bd      	mov	sp, r7
 80094d4:	f85d 7b04 	ldr.w	r7, [sp], #4
 80094d8:	4770      	bx	lr
 80094da:	bf00      	nop
 80094dc:	30f00070 	.word	0x30f00070

080094e0 <CAN_GetITStatus>:
  *            @arg CAN_IT_LEC: Last error code Interrupt
  *            @arg CAN_IT_ERR: Error Interrupt
  * @retval The current state of CAN_IT (SET or RESET).
  */
ITStatus CAN_GetITStatus(CAN_TypeDef* CANx, uint32_t CAN_IT)
{
 80094e0:	b580      	push	{r7, lr}
 80094e2:	b084      	sub	sp, #16
 80094e4:	af00      	add	r7, sp, #0
 80094e6:	6078      	str	r0, [r7, #4]
 80094e8:	6039      	str	r1, [r7, #0]
  ITStatus itstatus = RESET;
 80094ea:	2300      	movs	r3, #0
 80094ec:	73fb      	strb	r3, [r7, #15]
  /* Check the parameters */
  assert_param(IS_CAN_ALL_PERIPH(CANx));
  assert_param(IS_CAN_IT(CAN_IT));
  
  /* check the interrupt enable bit */
 if((CANx->IER & CAN_IT) != RESET)
 80094ee:	687b      	ldr	r3, [r7, #4]
 80094f0:	695a      	ldr	r2, [r3, #20]
 80094f2:	683b      	ldr	r3, [r7, #0]
 80094f4:	4013      	ands	r3, r2
 80094f6:	2b00      	cmp	r3, #0
 80094f8:	f000 80b2 	beq.w	8009660 <CAN_GetITStatus+0x180>
 {
   /* in case the Interrupt is enabled, .... */
    switch (CAN_IT)
 80094fc:	683b      	ldr	r3, [r7, #0]
 80094fe:	2b40      	cmp	r3, #64	; 0x40
 8009500:	d062      	beq.n	80095c8 <CAN_GetITStatus+0xe8>
 8009502:	2b40      	cmp	r3, #64	; 0x40
 8009504:	d80f      	bhi.n	8009526 <CAN_GetITStatus+0x46>
 8009506:	2b04      	cmp	r3, #4
 8009508:	d03a      	beq.n	8009580 <CAN_GetITStatus+0xa0>
 800950a:	2b04      	cmp	r3, #4
 800950c:	d804      	bhi.n	8009518 <CAN_GetITStatus+0x38>
 800950e:	2b01      	cmp	r3, #1
 8009510:	d024      	beq.n	800955c <CAN_GetITStatus+0x7c>
 8009512:	2b02      	cmp	r3, #2
 8009514:	d02b      	beq.n	800956e <CAN_GetITStatus+0x8e>
 8009516:	e09f      	b.n	8009658 <CAN_GetITStatus+0x178>
 8009518:	2b10      	cmp	r3, #16
 800951a:	d043      	beq.n	80095a4 <CAN_GetITStatus+0xc4>
 800951c:	2b20      	cmp	r3, #32
 800951e:	d04a      	beq.n	80095b6 <CAN_GetITStatus+0xd6>
 8009520:	2b08      	cmp	r3, #8
 8009522:	d036      	beq.n	8009592 <CAN_GetITStatus+0xb2>
 8009524:	e098      	b.n	8009658 <CAN_GetITStatus+0x178>
 8009526:	f5b3 6f00 	cmp.w	r3, #2048	; 0x800
 800952a:	f000 8083 	beq.w	8009634 <CAN_GetITStatus+0x154>
 800952e:	f5b3 6f00 	cmp.w	r3, #2048	; 0x800
 8009532:	d809      	bhi.n	8009548 <CAN_GetITStatus+0x68>
 8009534:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 8009538:	d06a      	beq.n	8009610 <CAN_GetITStatus+0x130>
 800953a:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
 800953e:	d070      	beq.n	8009622 <CAN_GetITStatus+0x142>
 8009540:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 8009544:	d05b      	beq.n	80095fe <CAN_GetITStatus+0x11e>
 8009546:	e087      	b.n	8009658 <CAN_GetITStatus+0x178>
 8009548:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 800954c:	d045      	beq.n	80095da <CAN_GetITStatus+0xfa>
 800954e:	f5b3 3f00 	cmp.w	r3, #131072	; 0x20000
 8009552:	d04b      	beq.n	80095ec <CAN_GetITStatus+0x10c>
 8009554:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
 8009558:	d075      	beq.n	8009646 <CAN_GetITStatus+0x166>
 800955a:	e07d      	b.n	8009658 <CAN_GetITStatus+0x178>
    {
      case CAN_IT_TME:
        /* Check CAN_TSR_RQCPx bits */
        itstatus = CheckITStatus(CANx->TSR, CAN_TSR_RQCP0|CAN_TSR_RQCP1|CAN_TSR_RQCP2);  
 800955c:	687b      	ldr	r3, [r7, #4]
 800955e:	689b      	ldr	r3, [r3, #8]
 8009560:	4943      	ldr	r1, [pc, #268]	; (8009670 <CAN_GetITStatus+0x190>)
 8009562:	4618      	mov	r0, r3
 8009564:	f000 f8f6 	bl	8009754 <CheckITStatus>
 8009568:	4603      	mov	r3, r0
 800956a:	73fb      	strb	r3, [r7, #15]
        break;
 800956c:	e07a      	b.n	8009664 <CAN_GetITStatus+0x184>
      case CAN_IT_FMP0:
        /* Check CAN_RF0R_FMP0 bit */
        itstatus = CheckITStatus(CANx->RF0R, CAN_RF0R_FMP0);  
 800956e:	687b      	ldr	r3, [r7, #4]
 8009570:	68db      	ldr	r3, [r3, #12]
 8009572:	2103      	movs	r1, #3
 8009574:	4618      	mov	r0, r3
 8009576:	f000 f8ed 	bl	8009754 <CheckITStatus>
 800957a:	4603      	mov	r3, r0
 800957c:	73fb      	strb	r3, [r7, #15]
        break;
 800957e:	e071      	b.n	8009664 <CAN_GetITStatus+0x184>
      case CAN_IT_FF0:
        /* Check CAN_RF0R_FULL0 bit */
        itstatus = CheckITStatus(CANx->RF0R, CAN_RF0R_FULL0);  
 8009580:	687b      	ldr	r3, [r7, #4]
 8009582:	68db      	ldr	r3, [r3, #12]
 8009584:	2108      	movs	r1, #8
 8009586:	4618      	mov	r0, r3
 8009588:	f000 f8e4 	bl	8009754 <CheckITStatus>
 800958c:	4603      	mov	r3, r0
 800958e:	73fb      	strb	r3, [r7, #15]
        break;
 8009590:	e068      	b.n	8009664 <CAN_GetITStatus+0x184>
      case CAN_IT_FOV0:
        /* Check CAN_RF0R_FOVR0 bit */
        itstatus = CheckITStatus(CANx->RF0R, CAN_RF0R_FOVR0);  
 8009592:	687b      	ldr	r3, [r7, #4]
 8009594:	68db      	ldr	r3, [r3, #12]
 8009596:	2110      	movs	r1, #16
 8009598:	4618      	mov	r0, r3
 800959a:	f000 f8db 	bl	8009754 <CheckITStatus>
 800959e:	4603      	mov	r3, r0
 80095a0:	73fb      	strb	r3, [r7, #15]
        break;
 80095a2:	e05f      	b.n	8009664 <CAN_GetITStatus+0x184>
      case CAN_IT_FMP1:
        /* Check CAN_RF1R_FMP1 bit */
        itstatus = CheckITStatus(CANx->RF1R, CAN_RF1R_FMP1);  
 80095a4:	687b      	ldr	r3, [r7, #4]
 80095a6:	691b      	ldr	r3, [r3, #16]
 80095a8:	2103      	movs	r1, #3
 80095aa:	4618      	mov	r0, r3
 80095ac:	f000 f8d2 	bl	8009754 <CheckITStatus>
 80095b0:	4603      	mov	r3, r0
 80095b2:	73fb      	strb	r3, [r7, #15]
        break;
 80095b4:	e056      	b.n	8009664 <CAN_GetITStatus+0x184>
      case CAN_IT_FF1:
        /* Check CAN_RF1R_FULL1 bit */
        itstatus = CheckITStatus(CANx->RF1R, CAN_RF1R_FULL1);  
 80095b6:	687b      	ldr	r3, [r7, #4]
 80095b8:	691b      	ldr	r3, [r3, #16]
 80095ba:	2108      	movs	r1, #8
 80095bc:	4618      	mov	r0, r3
 80095be:	f000 f8c9 	bl	8009754 <CheckITStatus>
 80095c2:	4603      	mov	r3, r0
 80095c4:	73fb      	strb	r3, [r7, #15]
        break;
 80095c6:	e04d      	b.n	8009664 <CAN_GetITStatus+0x184>
      case CAN_IT_FOV1:
        /* Check CAN_RF1R_FOVR1 bit */
        itstatus = CheckITStatus(CANx->RF1R, CAN_RF1R_FOVR1);  
 80095c8:	687b      	ldr	r3, [r7, #4]
 80095ca:	691b      	ldr	r3, [r3, #16]
 80095cc:	2110      	movs	r1, #16
 80095ce:	4618      	mov	r0, r3
 80095d0:	f000 f8c0 	bl	8009754 <CheckITStatus>
 80095d4:	4603      	mov	r3, r0
 80095d6:	73fb      	strb	r3, [r7, #15]
        break;
 80095d8:	e044      	b.n	8009664 <CAN_GetITStatus+0x184>
      case CAN_IT_WKU:
        /* Check CAN_MSR_WKUI bit */
        itstatus = CheckITStatus(CANx->MSR, CAN_MSR_WKUI);  
 80095da:	687b      	ldr	r3, [r7, #4]
 80095dc:	685b      	ldr	r3, [r3, #4]
 80095de:	2108      	movs	r1, #8
 80095e0:	4618      	mov	r0, r3
 80095e2:	f000 f8b7 	bl	8009754 <CheckITStatus>
 80095e6:	4603      	mov	r3, r0
 80095e8:	73fb      	strb	r3, [r7, #15]
        break;
 80095ea:	e03b      	b.n	8009664 <CAN_GetITStatus+0x184>
      case CAN_IT_SLK:
        /* Check CAN_MSR_SLAKI bit */
        itstatus = CheckITStatus(CANx->MSR, CAN_MSR_SLAKI);  
 80095ec:	687b      	ldr	r3, [r7, #4]
 80095ee:	685b      	ldr	r3, [r3, #4]
 80095f0:	2110      	movs	r1, #16
 80095f2:	4618      	mov	r0, r3
 80095f4:	f000 f8ae 	bl	8009754 <CheckITStatus>
 80095f8:	4603      	mov	r3, r0
 80095fa:	73fb      	strb	r3, [r7, #15]
        break;
 80095fc:	e032      	b.n	8009664 <CAN_GetITStatus+0x184>
      case CAN_IT_EWG:
        /* Check CAN_ESR_EWGF bit */
        itstatus = CheckITStatus(CANx->ESR, CAN_ESR_EWGF);  
 80095fe:	687b      	ldr	r3, [r7, #4]
 8009600:	699b      	ldr	r3, [r3, #24]
 8009602:	2101      	movs	r1, #1
 8009604:	4618      	mov	r0, r3
 8009606:	f000 f8a5 	bl	8009754 <CheckITStatus>
 800960a:	4603      	mov	r3, r0
 800960c:	73fb      	strb	r3, [r7, #15]
        break;
 800960e:	e029      	b.n	8009664 <CAN_GetITStatus+0x184>
      case CAN_IT_EPV:
        /* Check CAN_ESR_EPVF bit */
        itstatus = CheckITStatus(CANx->ESR, CAN_ESR_EPVF);  
 8009610:	687b      	ldr	r3, [r7, #4]
 8009612:	699b      	ldr	r3, [r3, #24]
 8009614:	2102      	movs	r1, #2
 8009616:	4618      	mov	r0, r3
 8009618:	f000 f89c 	bl	8009754 <CheckITStatus>
 800961c:	4603      	mov	r3, r0
 800961e:	73fb      	strb	r3, [r7, #15]
        break;
 8009620:	e020      	b.n	8009664 <CAN_GetITStatus+0x184>
      case CAN_IT_BOF:
        /* Check CAN_ESR_BOFF bit */
        itstatus = CheckITStatus(CANx->ESR, CAN_ESR_BOFF);  
 8009622:	687b      	ldr	r3, [r7, #4]
 8009624:	699b      	ldr	r3, [r3, #24]
 8009626:	2104      	movs	r1, #4
 8009628:	4618      	mov	r0, r3
 800962a:	f000 f893 	bl	8009754 <CheckITStatus>
 800962e:	4603      	mov	r3, r0
 8009630:	73fb      	strb	r3, [r7, #15]
        break;
 8009632:	e017      	b.n	8009664 <CAN_GetITStatus+0x184>
      case CAN_IT_LEC:
        /* Check CAN_ESR_LEC bit */
        itstatus = CheckITStatus(CANx->ESR, CAN_ESR_LEC);  
 8009634:	687b      	ldr	r3, [r7, #4]
 8009636:	699b      	ldr	r3, [r3, #24]
 8009638:	2170      	movs	r1, #112	; 0x70
 800963a:	4618      	mov	r0, r3
 800963c:	f000 f88a 	bl	8009754 <CheckITStatus>
 8009640:	4603      	mov	r3, r0
 8009642:	73fb      	strb	r3, [r7, #15]
        break;
 8009644:	e00e      	b.n	8009664 <CAN_GetITStatus+0x184>
      case CAN_IT_ERR:
        /* Check CAN_MSR_ERRI bit */ 
        itstatus = CheckITStatus(CANx->MSR, CAN_MSR_ERRI); 
 8009646:	687b      	ldr	r3, [r7, #4]
 8009648:	685b      	ldr	r3, [r3, #4]
 800964a:	2104      	movs	r1, #4
 800964c:	4618      	mov	r0, r3
 800964e:	f000 f881 	bl	8009754 <CheckITStatus>
 8009652:	4603      	mov	r3, r0
 8009654:	73fb      	strb	r3, [r7, #15]
        break;
 8009656:	e005      	b.n	8009664 <CAN_GetITStatus+0x184>
      default:
        /* in case of error, return RESET */
        itstatus = RESET;
 8009658:	2300      	movs	r3, #0
 800965a:	73fb      	strb	r3, [r7, #15]
        break;
 800965c:	bf00      	nop
 800965e:	e001      	b.n	8009664 <CAN_GetITStatus+0x184>
    }
  }
  else
  {
   /* in case the Interrupt is not enabled, return RESET */
    itstatus  = RESET;
 8009660:	2300      	movs	r3, #0
 8009662:	73fb      	strb	r3, [r7, #15]
  }
  
  /* Return the CAN_IT status */
  return  itstatus;
 8009664:	7bfb      	ldrb	r3, [r7, #15]
}
 8009666:	4618      	mov	r0, r3
 8009668:	3710      	adds	r7, #16
 800966a:	46bd      	mov	sp, r7
 800966c:	bd80      	pop	{r7, pc}
 800966e:	bf00      	nop
 8009670:	00010101 	.word	0x00010101

08009674 <CAN_ClearITPendingBit>:
  *            @arg CAN_IT_LEC: Last error code Interrupt
  *            @arg CAN_IT_ERR: Error Interrupt 
  * @retval None
  */
void CAN_ClearITPendingBit(CAN_TypeDef* CANx, uint32_t CAN_IT)
{
 8009674:	b480      	push	{r7}
 8009676:	b083      	sub	sp, #12
 8009678:	af00      	add	r7, sp, #0
 800967a:	6078      	str	r0, [r7, #4]
 800967c:	6039      	str	r1, [r7, #0]
  /* Check the parameters */
  assert_param(IS_CAN_ALL_PERIPH(CANx));
  assert_param(IS_CAN_CLEAR_IT(CAN_IT));

  switch (CAN_IT)
 800967e:	683b      	ldr	r3, [r7, #0]
 8009680:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 8009684:	d043      	beq.n	800970e <CAN_ClearITPendingBit+0x9a>
 8009686:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 800968a:	d80d      	bhi.n	80096a8 <CAN_ClearITPendingBit+0x34>
 800968c:	2b08      	cmp	r3, #8
 800968e:	d02a      	beq.n	80096e6 <CAN_ClearITPendingBit+0x72>
 8009690:	2b08      	cmp	r3, #8
 8009692:	d804      	bhi.n	800969e <CAN_ClearITPendingBit+0x2a>
 8009694:	2b01      	cmp	r3, #1
 8009696:	d01e      	beq.n	80096d6 <CAN_ClearITPendingBit+0x62>
 8009698:	2b04      	cmp	r3, #4
 800969a:	d020      	beq.n	80096de <CAN_ClearITPendingBit+0x6a>
      /* Clear CAN_MSR_ERRI (rc_w1) */
      CANx->MSR = CAN_MSR_ERRI; 
       /* @note BOFF, EPVF and EWGF Flags are cleared by hardware depending on the CAN Bus status*/
       break;
    default:
       break;
 800969c:	e051      	b.n	8009742 <CAN_ClearITPendingBit+0xce>
  switch (CAN_IT)
 800969e:	2b20      	cmp	r3, #32
 80096a0:	d025      	beq.n	80096ee <CAN_ClearITPendingBit+0x7a>
 80096a2:	2b40      	cmp	r3, #64	; 0x40
 80096a4:	d027      	beq.n	80096f6 <CAN_ClearITPendingBit+0x82>
       break;
 80096a6:	e04c      	b.n	8009742 <CAN_ClearITPendingBit+0xce>
  switch (CAN_IT)
 80096a8:	f5b3 6f00 	cmp.w	r3, #2048	; 0x800
 80096ac:	d03b      	beq.n	8009726 <CAN_ClearITPendingBit+0xb2>
 80096ae:	f5b3 6f00 	cmp.w	r3, #2048	; 0x800
 80096b2:	d806      	bhi.n	80096c2 <CAN_ClearITPendingBit+0x4e>
 80096b4:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 80096b8:	d02d      	beq.n	8009716 <CAN_ClearITPendingBit+0xa2>
 80096ba:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
 80096be:	d02e      	beq.n	800971e <CAN_ClearITPendingBit+0xaa>
       break;
 80096c0:	e03f      	b.n	8009742 <CAN_ClearITPendingBit+0xce>
  switch (CAN_IT)
 80096c2:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 80096c6:	d01a      	beq.n	80096fe <CAN_ClearITPendingBit+0x8a>
 80096c8:	f5b3 3f00 	cmp.w	r3, #131072	; 0x20000
 80096cc:	d01b      	beq.n	8009706 <CAN_ClearITPendingBit+0x92>
 80096ce:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
 80096d2:	d02f      	beq.n	8009734 <CAN_ClearITPendingBit+0xc0>
       break;
 80096d4:	e035      	b.n	8009742 <CAN_ClearITPendingBit+0xce>
      CANx->TSR = CAN_TSR_RQCP0|CAN_TSR_RQCP1|CAN_TSR_RQCP2;  
 80096d6:	687b      	ldr	r3, [r7, #4]
 80096d8:	4a1d      	ldr	r2, [pc, #116]	; (8009750 <CAN_ClearITPendingBit+0xdc>)
 80096da:	609a      	str	r2, [r3, #8]
      break;
 80096dc:	e031      	b.n	8009742 <CAN_ClearITPendingBit+0xce>
      CANx->RF0R = CAN_RF0R_FULL0; 
 80096de:	687b      	ldr	r3, [r7, #4]
 80096e0:	2208      	movs	r2, #8
 80096e2:	60da      	str	r2, [r3, #12]
      break;
 80096e4:	e02d      	b.n	8009742 <CAN_ClearITPendingBit+0xce>
      CANx->RF0R = CAN_RF0R_FOVR0; 
 80096e6:	687b      	ldr	r3, [r7, #4]
 80096e8:	2210      	movs	r2, #16
 80096ea:	60da      	str	r2, [r3, #12]
      break;
 80096ec:	e029      	b.n	8009742 <CAN_ClearITPendingBit+0xce>
      CANx->RF1R = CAN_RF1R_FULL1;  
 80096ee:	687b      	ldr	r3, [r7, #4]
 80096f0:	2208      	movs	r2, #8
 80096f2:	611a      	str	r2, [r3, #16]
      break;
 80096f4:	e025      	b.n	8009742 <CAN_ClearITPendingBit+0xce>
      CANx->RF1R = CAN_RF1R_FOVR1; 
 80096f6:	687b      	ldr	r3, [r7, #4]
 80096f8:	2210      	movs	r2, #16
 80096fa:	611a      	str	r2, [r3, #16]
      break;
 80096fc:	e021      	b.n	8009742 <CAN_ClearITPendingBit+0xce>
      CANx->MSR = CAN_MSR_WKUI;  
 80096fe:	687b      	ldr	r3, [r7, #4]
 8009700:	2208      	movs	r2, #8
 8009702:	605a      	str	r2, [r3, #4]
      break;
 8009704:	e01d      	b.n	8009742 <CAN_ClearITPendingBit+0xce>
      CANx->MSR = CAN_MSR_SLAKI;   
 8009706:	687b      	ldr	r3, [r7, #4]
 8009708:	2210      	movs	r2, #16
 800970a:	605a      	str	r2, [r3, #4]
      break;
 800970c:	e019      	b.n	8009742 <CAN_ClearITPendingBit+0xce>
      CANx->MSR = CAN_MSR_ERRI;
 800970e:	687b      	ldr	r3, [r7, #4]
 8009710:	2204      	movs	r2, #4
 8009712:	605a      	str	r2, [r3, #4]
      break;
 8009714:	e015      	b.n	8009742 <CAN_ClearITPendingBit+0xce>
      CANx->MSR = CAN_MSR_ERRI; 
 8009716:	687b      	ldr	r3, [r7, #4]
 8009718:	2204      	movs	r2, #4
 800971a:	605a      	str	r2, [r3, #4]
      break;
 800971c:	e011      	b.n	8009742 <CAN_ClearITPendingBit+0xce>
      CANx->MSR = CAN_MSR_ERRI; 
 800971e:	687b      	ldr	r3, [r7, #4]
 8009720:	2204      	movs	r2, #4
 8009722:	605a      	str	r2, [r3, #4]
       break;
 8009724:	e00d      	b.n	8009742 <CAN_ClearITPendingBit+0xce>
      CANx->ESR = RESET; 
 8009726:	687b      	ldr	r3, [r7, #4]
 8009728:	2200      	movs	r2, #0
 800972a:	619a      	str	r2, [r3, #24]
      CANx->MSR = CAN_MSR_ERRI; 
 800972c:	687b      	ldr	r3, [r7, #4]
 800972e:	2204      	movs	r2, #4
 8009730:	605a      	str	r2, [r3, #4]
      break;
 8009732:	e006      	b.n	8009742 <CAN_ClearITPendingBit+0xce>
      CANx->ESR = RESET; 
 8009734:	687b      	ldr	r3, [r7, #4]
 8009736:	2200      	movs	r2, #0
 8009738:	619a      	str	r2, [r3, #24]
      CANx->MSR = CAN_MSR_ERRI; 
 800973a:	687b      	ldr	r3, [r7, #4]
 800973c:	2204      	movs	r2, #4
 800973e:	605a      	str	r2, [r3, #4]
       break;
 8009740:	bf00      	nop
   }
}
 8009742:	bf00      	nop
 8009744:	370c      	adds	r7, #12
 8009746:	46bd      	mov	sp, r7
 8009748:	f85d 7b04 	ldr.w	r7, [sp], #4
 800974c:	4770      	bx	lr
 800974e:	bf00      	nop
 8009750:	00010101 	.word	0x00010101

08009754 <CheckITStatus>:
  * @param  CAN_Reg: specifies the CAN interrupt register to check.
  * @param  It_Bit: specifies the interrupt source bit to check.
  * @retval The new state of the CAN Interrupt (SET or RESET).
  */
static ITStatus CheckITStatus(uint32_t CAN_Reg, uint32_t It_Bit)
{
 8009754:	b480      	push	{r7}
 8009756:	b085      	sub	sp, #20
 8009758:	af00      	add	r7, sp, #0
 800975a:	6078      	str	r0, [r7, #4]
 800975c:	6039      	str	r1, [r7, #0]
  ITStatus pendingbitstatus = RESET;
 800975e:	2300      	movs	r3, #0
 8009760:	73fb      	strb	r3, [r7, #15]
  
  if ((CAN_Reg & It_Bit) != (uint32_t)RESET)
 8009762:	687a      	ldr	r2, [r7, #4]
 8009764:	683b      	ldr	r3, [r7, #0]
 8009766:	4013      	ands	r3, r2
 8009768:	2b00      	cmp	r3, #0
 800976a:	d002      	beq.n	8009772 <CheckITStatus+0x1e>
  {
    /* CAN_IT is set */
    pendingbitstatus = SET;
 800976c:	2301      	movs	r3, #1
 800976e:	73fb      	strb	r3, [r7, #15]
 8009770:	e001      	b.n	8009776 <CheckITStatus+0x22>
  }
  else
  {
    /* CAN_IT is reset */
    pendingbitstatus = RESET;
 8009772:	2300      	movs	r3, #0
 8009774:	73fb      	strb	r3, [r7, #15]
  }
  return pendingbitstatus;
 8009776:	7bfb      	ldrb	r3, [r7, #15]
}
 8009778:	4618      	mov	r0, r3
 800977a:	3714      	adds	r7, #20
 800977c:	46bd      	mov	sp, r7
 800977e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8009782:	4770      	bx	lr

08009784 <CRC_ResetDR>:
  * @brief  Resets the CRC Data register (DR).
  * @param  None
  * @retval None
  */
void CRC_ResetDR(void)
{
 8009784:	b480      	push	{r7}
 8009786:	af00      	add	r7, sp, #0
  /* Reset CRC generator */
  CRC->CR = CRC_CR_RESET;
 8009788:	4b03      	ldr	r3, [pc, #12]	; (8009798 <CRC_ResetDR+0x14>)
 800978a:	2201      	movs	r2, #1
 800978c:	609a      	str	r2, [r3, #8]
}
 800978e:	bf00      	nop
 8009790:	46bd      	mov	sp, r7
 8009792:	f85d 7b04 	ldr.w	r7, [sp], #4
 8009796:	4770      	bx	lr
 8009798:	40023000 	.word	0x40023000

0800979c <CRC_CalcCRC>:
  * @brief  Computes the 32-bit CRC of a given data word(32-bit).
  * @param  Data: data word(32-bit) to compute its CRC
  * @retval 32-bit CRC
  */
uint32_t CRC_CalcCRC(uint32_t Data)
{
 800979c:	b480      	push	{r7}
 800979e:	b083      	sub	sp, #12
 80097a0:	af00      	add	r7, sp, #0
 80097a2:	6078      	str	r0, [r7, #4]
  CRC->DR = Data;
 80097a4:	4a05      	ldr	r2, [pc, #20]	; (80097bc <CRC_CalcCRC+0x20>)
 80097a6:	687b      	ldr	r3, [r7, #4]
 80097a8:	6013      	str	r3, [r2, #0]
  
  return (CRC->DR);
 80097aa:	4b04      	ldr	r3, [pc, #16]	; (80097bc <CRC_CalcCRC+0x20>)
 80097ac:	681b      	ldr	r3, [r3, #0]
}
 80097ae:	4618      	mov	r0, r3
 80097b0:	370c      	adds	r7, #12
 80097b2:	46bd      	mov	sp, r7
 80097b4:	f85d 7b04 	ldr.w	r7, [sp], #4
 80097b8:	4770      	bx	lr
 80097ba:	bf00      	nop
 80097bc:	40023000 	.word	0x40023000

080097c0 <CRC_CalcBlockCRC>:
  * @param  pBuffer: pointer to the buffer containing the data to be computed
  * @param  BufferLength: length of the buffer to be computed					
  * @retval 32-bit CRC
  */
uint32_t CRC_CalcBlockCRC(uint32_t pBuffer[], uint32_t BufferLength)
{
 80097c0:	b480      	push	{r7}
 80097c2:	b085      	sub	sp, #20
 80097c4:	af00      	add	r7, sp, #0
 80097c6:	6078      	str	r0, [r7, #4]
 80097c8:	6039      	str	r1, [r7, #0]
  uint32_t index = 0;
 80097ca:	2300      	movs	r3, #0
 80097cc:	60fb      	str	r3, [r7, #12]
  
  for(index = 0; index < BufferLength; index++)
 80097ce:	2300      	movs	r3, #0
 80097d0:	60fb      	str	r3, [r7, #12]
 80097d2:	e009      	b.n	80097e8 <CRC_CalcBlockCRC+0x28>
  {
    CRC->DR = pBuffer[index];
 80097d4:	490a      	ldr	r1, [pc, #40]	; (8009800 <CRC_CalcBlockCRC+0x40>)
 80097d6:	68fb      	ldr	r3, [r7, #12]
 80097d8:	009b      	lsls	r3, r3, #2
 80097da:	687a      	ldr	r2, [r7, #4]
 80097dc:	4413      	add	r3, r2
 80097de:	681b      	ldr	r3, [r3, #0]
 80097e0:	600b      	str	r3, [r1, #0]
  for(index = 0; index < BufferLength; index++)
 80097e2:	68fb      	ldr	r3, [r7, #12]
 80097e4:	3301      	adds	r3, #1
 80097e6:	60fb      	str	r3, [r7, #12]
 80097e8:	68fa      	ldr	r2, [r7, #12]
 80097ea:	683b      	ldr	r3, [r7, #0]
 80097ec:	429a      	cmp	r2, r3
 80097ee:	d3f1      	bcc.n	80097d4 <CRC_CalcBlockCRC+0x14>
  }
  return (CRC->DR);
 80097f0:	4b03      	ldr	r3, [pc, #12]	; (8009800 <CRC_CalcBlockCRC+0x40>)
 80097f2:	681b      	ldr	r3, [r3, #0]
}
 80097f4:	4618      	mov	r0, r3
 80097f6:	3714      	adds	r7, #20
 80097f8:	46bd      	mov	sp, r7
 80097fa:	f85d 7b04 	ldr.w	r7, [sp], #4
 80097fe:	4770      	bx	lr
 8009800:	40023000 	.word	0x40023000

08009804 <CRC_GetCRC>:
  * @brief  Returns the current CRC value.
  * @param  None
  * @retval 32-bit CRC
  */
uint32_t CRC_GetCRC(void)
{
 8009804:	b480      	push	{r7}
 8009806:	af00      	add	r7, sp, #0
  return (CRC->DR);
 8009808:	4b03      	ldr	r3, [pc, #12]	; (8009818 <CRC_GetCRC+0x14>)
 800980a:	681b      	ldr	r3, [r3, #0]
}
 800980c:	4618      	mov	r0, r3
 800980e:	46bd      	mov	sp, r7
 8009810:	f85d 7b04 	ldr.w	r7, [sp], #4
 8009814:	4770      	bx	lr
 8009816:	bf00      	nop
 8009818:	40023000 	.word	0x40023000

0800981c <CRC_SetIDRegister>:
  * @brief  Stores a 8-bit data in the Independent Data(ID) register.
  * @param  IDValue: 8-bit value to be stored in the ID register 					
  * @retval None
  */
void CRC_SetIDRegister(uint8_t IDValue)
{
 800981c:	b480      	push	{r7}
 800981e:	b083      	sub	sp, #12
 8009820:	af00      	add	r7, sp, #0
 8009822:	4603      	mov	r3, r0
 8009824:	71fb      	strb	r3, [r7, #7]
  CRC->IDR = IDValue;
 8009826:	4a04      	ldr	r2, [pc, #16]	; (8009838 <CRC_SetIDRegister+0x1c>)
 8009828:	79fb      	ldrb	r3, [r7, #7]
 800982a:	7113      	strb	r3, [r2, #4]
}
 800982c:	bf00      	nop
 800982e:	370c      	adds	r7, #12
 8009830:	46bd      	mov	sp, r7
 8009832:	f85d 7b04 	ldr.w	r7, [sp], #4
 8009836:	4770      	bx	lr
 8009838:	40023000 	.word	0x40023000

0800983c <CRC_GetIDRegister>:
  * @brief  Returns the 8-bit data stored in the Independent Data(ID) register
  * @param  None
  * @retval 8-bit value of the ID register 
  */
uint8_t CRC_GetIDRegister(void)
{
 800983c:	b480      	push	{r7}
 800983e:	af00      	add	r7, sp, #0
  return (CRC->IDR);
 8009840:	4b03      	ldr	r3, [pc, #12]	; (8009850 <CRC_GetIDRegister+0x14>)
 8009842:	791b      	ldrb	r3, [r3, #4]
 8009844:	b2db      	uxtb	r3, r3
}
 8009846:	4618      	mov	r0, r3
 8009848:	46bd      	mov	sp, r7
 800984a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800984e:	4770      	bx	lr
 8009850:	40023000 	.word	0x40023000

08009854 <CRYP_DeInit>:
  * @brief  Deinitializes the CRYP peripheral registers to their default reset values
  * @param  None
  * @retval None
  */
void CRYP_DeInit(void)
{
 8009854:	b580      	push	{r7, lr}
 8009856:	af00      	add	r7, sp, #0
  /* Enable CRYP reset state */
  RCC_AHB2PeriphResetCmd(RCC_AHB2Periph_CRYP, ENABLE);
 8009858:	2101      	movs	r1, #1
 800985a:	2010      	movs	r0, #16
 800985c:	f006 f81a 	bl	800f894 <RCC_AHB2PeriphResetCmd>

  /* Release CRYP from reset state */
  RCC_AHB2PeriphResetCmd(RCC_AHB2Periph_CRYP, DISABLE);
 8009860:	2100      	movs	r1, #0
 8009862:	2010      	movs	r0, #16
 8009864:	f006 f816 	bl	800f894 <RCC_AHB2PeriphResetCmd>
}
 8009868:	bf00      	nop
 800986a:	bd80      	pop	{r7, pc}

0800986c <CRYP_Init>:
  * @param  CRYP_InitStruct: pointer to a CRYP_InitTypeDef structure that contains
  *         the configuration information for the CRYP peripheral.
  * @retval None
  */
void CRYP_Init(CRYP_InitTypeDef* CRYP_InitStruct)
{
 800986c:	b480      	push	{r7}
 800986e:	b083      	sub	sp, #12
 8009870:	af00      	add	r7, sp, #0
 8009872:	6078      	str	r0, [r7, #4]
  assert_param(IS_CRYP_ALGOMODE(CRYP_InitStruct->CRYP_AlgoMode));
  assert_param(IS_CRYP_DATATYPE(CRYP_InitStruct->CRYP_DataType));
  assert_param(IS_CRYP_ALGODIR(CRYP_InitStruct->CRYP_AlgoDir));

  /* Select Algorithm mode*/  
  CRYP->CR &= ~CRYP_CR_ALGOMODE;
 8009874:	4a24      	ldr	r2, [pc, #144]	; (8009908 <CRYP_Init+0x9c>)
 8009876:	4b24      	ldr	r3, [pc, #144]	; (8009908 <CRYP_Init+0x9c>)
 8009878:	681b      	ldr	r3, [r3, #0]
 800987a:	f023 0338 	bic.w	r3, r3, #56	; 0x38
 800987e:	6013      	str	r3, [r2, #0]
  CRYP->CR |= CRYP_InitStruct->CRYP_AlgoMode;
 8009880:	4921      	ldr	r1, [pc, #132]	; (8009908 <CRYP_Init+0x9c>)
 8009882:	4b21      	ldr	r3, [pc, #132]	; (8009908 <CRYP_Init+0x9c>)
 8009884:	681b      	ldr	r3, [r3, #0]
 8009886:	687a      	ldr	r2, [r7, #4]
 8009888:	8852      	ldrh	r2, [r2, #2]
 800988a:	4313      	orrs	r3, r2
 800988c:	600b      	str	r3, [r1, #0]

  /* Select dataType */ 
  CRYP->CR &= ~CRYP_CR_DATATYPE;
 800988e:	4a1e      	ldr	r2, [pc, #120]	; (8009908 <CRYP_Init+0x9c>)
 8009890:	4b1d      	ldr	r3, [pc, #116]	; (8009908 <CRYP_Init+0x9c>)
 8009892:	681b      	ldr	r3, [r3, #0]
 8009894:	f023 03c0 	bic.w	r3, r3, #192	; 0xc0
 8009898:	6013      	str	r3, [r2, #0]
  CRYP->CR |= CRYP_InitStruct->CRYP_DataType;
 800989a:	491b      	ldr	r1, [pc, #108]	; (8009908 <CRYP_Init+0x9c>)
 800989c:	4b1a      	ldr	r3, [pc, #104]	; (8009908 <CRYP_Init+0x9c>)
 800989e:	681b      	ldr	r3, [r3, #0]
 80098a0:	687a      	ldr	r2, [r7, #4]
 80098a2:	8892      	ldrh	r2, [r2, #4]
 80098a4:	4313      	orrs	r3, r2
 80098a6:	600b      	str	r3, [r1, #0]

  /* select Key size (used only with AES algorithm) */
  if ((CRYP_InitStruct->CRYP_AlgoMode == CRYP_AlgoMode_AES_ECB) ||
 80098a8:	687b      	ldr	r3, [r7, #4]
 80098aa:	885b      	ldrh	r3, [r3, #2]
 80098ac:	2b20      	cmp	r3, #32
 80098ae:	d00b      	beq.n	80098c8 <CRYP_Init+0x5c>
      (CRYP_InitStruct->CRYP_AlgoMode == CRYP_AlgoMode_AES_CBC) ||
 80098b0:	687b      	ldr	r3, [r7, #4]
 80098b2:	885b      	ldrh	r3, [r3, #2]
  if ((CRYP_InitStruct->CRYP_AlgoMode == CRYP_AlgoMode_AES_ECB) ||
 80098b4:	2b28      	cmp	r3, #40	; 0x28
 80098b6:	d007      	beq.n	80098c8 <CRYP_Init+0x5c>
      (CRYP_InitStruct->CRYP_AlgoMode == CRYP_AlgoMode_AES_CTR) ||
 80098b8:	687b      	ldr	r3, [r7, #4]
 80098ba:	885b      	ldrh	r3, [r3, #2]
      (CRYP_InitStruct->CRYP_AlgoMode == CRYP_AlgoMode_AES_CBC) ||
 80098bc:	2b30      	cmp	r3, #48	; 0x30
 80098be:	d003      	beq.n	80098c8 <CRYP_Init+0x5c>
      (CRYP_InitStruct->CRYP_AlgoMode == CRYP_AlgoMode_AES_Key))
 80098c0:	687b      	ldr	r3, [r7, #4]
 80098c2:	885b      	ldrh	r3, [r3, #2]
      (CRYP_InitStruct->CRYP_AlgoMode == CRYP_AlgoMode_AES_CTR) ||
 80098c4:	2b38      	cmp	r3, #56	; 0x38
 80098c6:	d10c      	bne.n	80098e2 <CRYP_Init+0x76>
  {
    assert_param(IS_CRYP_KEYSIZE(CRYP_InitStruct->CRYP_KeySize));
    CRYP->CR &= ~CRYP_CR_KEYSIZE;
 80098c8:	4a0f      	ldr	r2, [pc, #60]	; (8009908 <CRYP_Init+0x9c>)
 80098ca:	4b0f      	ldr	r3, [pc, #60]	; (8009908 <CRYP_Init+0x9c>)
 80098cc:	681b      	ldr	r3, [r3, #0]
 80098ce:	f423 7340 	bic.w	r3, r3, #768	; 0x300
 80098d2:	6013      	str	r3, [r2, #0]
    CRYP->CR |= CRYP_InitStruct->CRYP_KeySize; /* Key size and value must be 
 80098d4:	490c      	ldr	r1, [pc, #48]	; (8009908 <CRYP_Init+0x9c>)
 80098d6:	4b0c      	ldr	r3, [pc, #48]	; (8009908 <CRYP_Init+0x9c>)
 80098d8:	681b      	ldr	r3, [r3, #0]
 80098da:	687a      	ldr	r2, [r7, #4]
 80098dc:	88d2      	ldrh	r2, [r2, #6]
 80098de:	4313      	orrs	r3, r2
 80098e0:	600b      	str	r3, [r1, #0]
                                                  configured once the key has 
                                                  been prepared */
  }

  /* Select data Direction */ 
  CRYP->CR &= ~CRYP_CR_ALGODIR;
 80098e2:	4a09      	ldr	r2, [pc, #36]	; (8009908 <CRYP_Init+0x9c>)
 80098e4:	4b08      	ldr	r3, [pc, #32]	; (8009908 <CRYP_Init+0x9c>)
 80098e6:	681b      	ldr	r3, [r3, #0]
 80098e8:	f023 0304 	bic.w	r3, r3, #4
 80098ec:	6013      	str	r3, [r2, #0]
  CRYP->CR |= CRYP_InitStruct->CRYP_AlgoDir;
 80098ee:	4906      	ldr	r1, [pc, #24]	; (8009908 <CRYP_Init+0x9c>)
 80098f0:	4b05      	ldr	r3, [pc, #20]	; (8009908 <CRYP_Init+0x9c>)
 80098f2:	681b      	ldr	r3, [r3, #0]
 80098f4:	687a      	ldr	r2, [r7, #4]
 80098f6:	8812      	ldrh	r2, [r2, #0]
 80098f8:	4313      	orrs	r3, r2
 80098fa:	600b      	str	r3, [r1, #0]
}
 80098fc:	bf00      	nop
 80098fe:	370c      	adds	r7, #12
 8009900:	46bd      	mov	sp, r7
 8009902:	f85d 7b04 	ldr.w	r7, [sp], #4
 8009906:	4770      	bx	lr
 8009908:	50060000 	.word	0x50060000

0800990c <CRYP_StructInit>:
  * @param  CRYP_InitStruct: pointer to a CRYP_InitTypeDef structure which will
  *         be initialized.
  * @retval None
  */
void CRYP_StructInit(CRYP_InitTypeDef* CRYP_InitStruct)
{
 800990c:	b480      	push	{r7}
 800990e:	b083      	sub	sp, #12
 8009910:	af00      	add	r7, sp, #0
 8009912:	6078      	str	r0, [r7, #4]
  /* Initialize the CRYP_AlgoDir member */
  CRYP_InitStruct->CRYP_AlgoDir = CRYP_AlgoDir_Encrypt;
 8009914:	687b      	ldr	r3, [r7, #4]
 8009916:	2200      	movs	r2, #0
 8009918:	801a      	strh	r2, [r3, #0]

  /* initialize the CRYP_AlgoMode member */
  CRYP_InitStruct->CRYP_AlgoMode = CRYP_AlgoMode_TDES_ECB;
 800991a:	687b      	ldr	r3, [r7, #4]
 800991c:	2200      	movs	r2, #0
 800991e:	805a      	strh	r2, [r3, #2]

  /* initialize the CRYP_DataType member */
  CRYP_InitStruct->CRYP_DataType = CRYP_DataType_32b;
 8009920:	687b      	ldr	r3, [r7, #4]
 8009922:	2200      	movs	r2, #0
 8009924:	809a      	strh	r2, [r3, #4]
  
  /* Initialize the CRYP_KeySize member */
  CRYP_InitStruct->CRYP_KeySize = CRYP_KeySize_128b;
 8009926:	687b      	ldr	r3, [r7, #4]
 8009928:	2200      	movs	r2, #0
 800992a:	80da      	strh	r2, [r3, #6]
}
 800992c:	bf00      	nop
 800992e:	370c      	adds	r7, #12
 8009930:	46bd      	mov	sp, r7
 8009932:	f85d 7b04 	ldr.w	r7, [sp], #4
 8009936:	4770      	bx	lr

08009938 <CRYP_KeyInit>:
  * @param  CRYP_KeyInitStruct: pointer to a CRYP_KeyInitTypeDef structure that
  *         contains the configuration information for the CRYP Keys.
  * @retval None
  */
void CRYP_KeyInit(CRYP_KeyInitTypeDef* CRYP_KeyInitStruct)
{
 8009938:	b480      	push	{r7}
 800993a:	b083      	sub	sp, #12
 800993c:	af00      	add	r7, sp, #0
 800993e:	6078      	str	r0, [r7, #4]
  /* Key Initialisation */
  CRYP->K0LR = CRYP_KeyInitStruct->CRYP_Key0Left;
 8009940:	4a12      	ldr	r2, [pc, #72]	; (800998c <CRYP_KeyInit+0x54>)
 8009942:	687b      	ldr	r3, [r7, #4]
 8009944:	681b      	ldr	r3, [r3, #0]
 8009946:	6213      	str	r3, [r2, #32]
  CRYP->K0RR = CRYP_KeyInitStruct->CRYP_Key0Right;
 8009948:	4a10      	ldr	r2, [pc, #64]	; (800998c <CRYP_KeyInit+0x54>)
 800994a:	687b      	ldr	r3, [r7, #4]
 800994c:	685b      	ldr	r3, [r3, #4]
 800994e:	6253      	str	r3, [r2, #36]	; 0x24
  CRYP->K1LR = CRYP_KeyInitStruct->CRYP_Key1Left;
 8009950:	4a0e      	ldr	r2, [pc, #56]	; (800998c <CRYP_KeyInit+0x54>)
 8009952:	687b      	ldr	r3, [r7, #4]
 8009954:	689b      	ldr	r3, [r3, #8]
 8009956:	6293      	str	r3, [r2, #40]	; 0x28
  CRYP->K1RR = CRYP_KeyInitStruct->CRYP_Key1Right;
 8009958:	4a0c      	ldr	r2, [pc, #48]	; (800998c <CRYP_KeyInit+0x54>)
 800995a:	687b      	ldr	r3, [r7, #4]
 800995c:	68db      	ldr	r3, [r3, #12]
 800995e:	62d3      	str	r3, [r2, #44]	; 0x2c
  CRYP->K2LR = CRYP_KeyInitStruct->CRYP_Key2Left;
 8009960:	4a0a      	ldr	r2, [pc, #40]	; (800998c <CRYP_KeyInit+0x54>)
 8009962:	687b      	ldr	r3, [r7, #4]
 8009964:	691b      	ldr	r3, [r3, #16]
 8009966:	6313      	str	r3, [r2, #48]	; 0x30
  CRYP->K2RR = CRYP_KeyInitStruct->CRYP_Key2Right;
 8009968:	4a08      	ldr	r2, [pc, #32]	; (800998c <CRYP_KeyInit+0x54>)
 800996a:	687b      	ldr	r3, [r7, #4]
 800996c:	695b      	ldr	r3, [r3, #20]
 800996e:	6353      	str	r3, [r2, #52]	; 0x34
  CRYP->K3LR = CRYP_KeyInitStruct->CRYP_Key3Left;
 8009970:	4a06      	ldr	r2, [pc, #24]	; (800998c <CRYP_KeyInit+0x54>)
 8009972:	687b      	ldr	r3, [r7, #4]
 8009974:	699b      	ldr	r3, [r3, #24]
 8009976:	6393      	str	r3, [r2, #56]	; 0x38
  CRYP->K3RR = CRYP_KeyInitStruct->CRYP_Key3Right;
 8009978:	4a04      	ldr	r2, [pc, #16]	; (800998c <CRYP_KeyInit+0x54>)
 800997a:	687b      	ldr	r3, [r7, #4]
 800997c:	69db      	ldr	r3, [r3, #28]
 800997e:	63d3      	str	r3, [r2, #60]	; 0x3c
}
 8009980:	bf00      	nop
 8009982:	370c      	adds	r7, #12
 8009984:	46bd      	mov	sp, r7
 8009986:	f85d 7b04 	ldr.w	r7, [sp], #4
 800998a:	4770      	bx	lr
 800998c:	50060000 	.word	0x50060000

08009990 <CRYP_KeyStructInit>:
  * @param  CRYP_KeyInitStruct: pointer to a CRYP_KeyInitTypeDef structure 
  *         which will be initialized.
  * @retval None
  */
void CRYP_KeyStructInit(CRYP_KeyInitTypeDef* CRYP_KeyInitStruct)
{
 8009990:	b480      	push	{r7}
 8009992:	b083      	sub	sp, #12
 8009994:	af00      	add	r7, sp, #0
 8009996:	6078      	str	r0, [r7, #4]
  CRYP_KeyInitStruct->CRYP_Key0Left  = 0;
 8009998:	687b      	ldr	r3, [r7, #4]
 800999a:	2200      	movs	r2, #0
 800999c:	601a      	str	r2, [r3, #0]
  CRYP_KeyInitStruct->CRYP_Key0Right = 0;
 800999e:	687b      	ldr	r3, [r7, #4]
 80099a0:	2200      	movs	r2, #0
 80099a2:	605a      	str	r2, [r3, #4]
  CRYP_KeyInitStruct->CRYP_Key1Left  = 0;
 80099a4:	687b      	ldr	r3, [r7, #4]
 80099a6:	2200      	movs	r2, #0
 80099a8:	609a      	str	r2, [r3, #8]
  CRYP_KeyInitStruct->CRYP_Key1Right = 0;
 80099aa:	687b      	ldr	r3, [r7, #4]
 80099ac:	2200      	movs	r2, #0
 80099ae:	60da      	str	r2, [r3, #12]
  CRYP_KeyInitStruct->CRYP_Key2Left  = 0;
 80099b0:	687b      	ldr	r3, [r7, #4]
 80099b2:	2200      	movs	r2, #0
 80099b4:	611a      	str	r2, [r3, #16]
  CRYP_KeyInitStruct->CRYP_Key2Right = 0;
 80099b6:	687b      	ldr	r3, [r7, #4]
 80099b8:	2200      	movs	r2, #0
 80099ba:	615a      	str	r2, [r3, #20]
  CRYP_KeyInitStruct->CRYP_Key3Left  = 0;
 80099bc:	687b      	ldr	r3, [r7, #4]
 80099be:	2200      	movs	r2, #0
 80099c0:	619a      	str	r2, [r3, #24]
  CRYP_KeyInitStruct->CRYP_Key3Right = 0;
 80099c2:	687b      	ldr	r3, [r7, #4]
 80099c4:	2200      	movs	r2, #0
 80099c6:	61da      	str	r2, [r3, #28]
}
 80099c8:	bf00      	nop
 80099ca:	370c      	adds	r7, #12
 80099cc:	46bd      	mov	sp, r7
 80099ce:	f85d 7b04 	ldr.w	r7, [sp], #4
 80099d2:	4770      	bx	lr

080099d4 <CRYP_IVInit>:
  * @param  CRYP_IVInitStruct: pointer to a CRYP_IVInitTypeDef structure that contains
  *         the configuration information for the CRYP Initialization Vectors(IV).
  * @retval None
  */
void CRYP_IVInit(CRYP_IVInitTypeDef* CRYP_IVInitStruct)
{
 80099d4:	b480      	push	{r7}
 80099d6:	b083      	sub	sp, #12
 80099d8:	af00      	add	r7, sp, #0
 80099da:	6078      	str	r0, [r7, #4]
  CRYP->IV0LR = CRYP_IVInitStruct->CRYP_IV0Left;
 80099dc:	4a0a      	ldr	r2, [pc, #40]	; (8009a08 <CRYP_IVInit+0x34>)
 80099de:	687b      	ldr	r3, [r7, #4]
 80099e0:	681b      	ldr	r3, [r3, #0]
 80099e2:	6413      	str	r3, [r2, #64]	; 0x40
  CRYP->IV0RR = CRYP_IVInitStruct->CRYP_IV0Right;
 80099e4:	4a08      	ldr	r2, [pc, #32]	; (8009a08 <CRYP_IVInit+0x34>)
 80099e6:	687b      	ldr	r3, [r7, #4]
 80099e8:	685b      	ldr	r3, [r3, #4]
 80099ea:	6453      	str	r3, [r2, #68]	; 0x44
  CRYP->IV1LR = CRYP_IVInitStruct->CRYP_IV1Left;
 80099ec:	4a06      	ldr	r2, [pc, #24]	; (8009a08 <CRYP_IVInit+0x34>)
 80099ee:	687b      	ldr	r3, [r7, #4]
 80099f0:	689b      	ldr	r3, [r3, #8]
 80099f2:	6493      	str	r3, [r2, #72]	; 0x48
  CRYP->IV1RR = CRYP_IVInitStruct->CRYP_IV1Right;
 80099f4:	4a04      	ldr	r2, [pc, #16]	; (8009a08 <CRYP_IVInit+0x34>)
 80099f6:	687b      	ldr	r3, [r7, #4]
 80099f8:	68db      	ldr	r3, [r3, #12]
 80099fa:	64d3      	str	r3, [r2, #76]	; 0x4c
}
 80099fc:	bf00      	nop
 80099fe:	370c      	adds	r7, #12
 8009a00:	46bd      	mov	sp, r7
 8009a02:	f85d 7b04 	ldr.w	r7, [sp], #4
 8009a06:	4770      	bx	lr
 8009a08:	50060000 	.word	0x50060000

08009a0c <CRYP_IVStructInit>:
  * @param  CRYP_IVInitStruct: pointer to a CRYP_IVInitTypeDef Initialization 
  *         Vectors(IV) structure which will be initialized.
  * @retval None
  */
void CRYP_IVStructInit(CRYP_IVInitTypeDef* CRYP_IVInitStruct)
{
 8009a0c:	b480      	push	{r7}
 8009a0e:	b083      	sub	sp, #12
 8009a10:	af00      	add	r7, sp, #0
 8009a12:	6078      	str	r0, [r7, #4]
  CRYP_IVInitStruct->CRYP_IV0Left  = 0;
 8009a14:	687b      	ldr	r3, [r7, #4]
 8009a16:	2200      	movs	r2, #0
 8009a18:	601a      	str	r2, [r3, #0]
  CRYP_IVInitStruct->CRYP_IV0Right = 0;
 8009a1a:	687b      	ldr	r3, [r7, #4]
 8009a1c:	2200      	movs	r2, #0
 8009a1e:	605a      	str	r2, [r3, #4]
  CRYP_IVInitStruct->CRYP_IV1Left  = 0;
 8009a20:	687b      	ldr	r3, [r7, #4]
 8009a22:	2200      	movs	r2, #0
 8009a24:	609a      	str	r2, [r3, #8]
  CRYP_IVInitStruct->CRYP_IV1Right = 0;
 8009a26:	687b      	ldr	r3, [r7, #4]
 8009a28:	2200      	movs	r2, #0
 8009a2a:	60da      	str	r2, [r3, #12]
}
 8009a2c:	bf00      	nop
 8009a2e:	370c      	adds	r7, #12
 8009a30:	46bd      	mov	sp, r7
 8009a32:	f85d 7b04 	ldr.w	r7, [sp], #4
 8009a36:	4770      	bx	lr

08009a38 <CRYP_FIFOFlush>:
  * @note   The FIFOs must be flushed only when BUSY flag is reset.  
  * @param  None
  * @retval None
  */
void CRYP_FIFOFlush(void)
{
 8009a38:	b480      	push	{r7}
 8009a3a:	af00      	add	r7, sp, #0
  /* Reset the read and write pointers of the FIFOs */
  CRYP->CR |= CRYP_CR_FFLUSH;
 8009a3c:	4a05      	ldr	r2, [pc, #20]	; (8009a54 <CRYP_FIFOFlush+0x1c>)
 8009a3e:	4b05      	ldr	r3, [pc, #20]	; (8009a54 <CRYP_FIFOFlush+0x1c>)
 8009a40:	681b      	ldr	r3, [r3, #0]
 8009a42:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 8009a46:	6013      	str	r3, [r2, #0]
}
 8009a48:	bf00      	nop
 8009a4a:	46bd      	mov	sp, r7
 8009a4c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8009a50:	4770      	bx	lr
 8009a52:	bf00      	nop
 8009a54:	50060000 	.word	0x50060000

08009a58 <CRYP_Cmd>:
  * @param  NewState: new state of the CRYP peripheral.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void CRYP_Cmd(FunctionalState NewState)
{
 8009a58:	b480      	push	{r7}
 8009a5a:	b083      	sub	sp, #12
 8009a5c:	af00      	add	r7, sp, #0
 8009a5e:	4603      	mov	r3, r0
 8009a60:	71fb      	strb	r3, [r7, #7]
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 8009a62:	79fb      	ldrb	r3, [r7, #7]
 8009a64:	2b00      	cmp	r3, #0
 8009a66:	d006      	beq.n	8009a76 <CRYP_Cmd+0x1e>
  {
    /* Enable the Cryptographic processor */
    CRYP->CR |= CRYP_CR_CRYPEN;
 8009a68:	4a09      	ldr	r2, [pc, #36]	; (8009a90 <CRYP_Cmd+0x38>)
 8009a6a:	4b09      	ldr	r3, [pc, #36]	; (8009a90 <CRYP_Cmd+0x38>)
 8009a6c:	681b      	ldr	r3, [r3, #0]
 8009a6e:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 8009a72:	6013      	str	r3, [r2, #0]
  else
  {
    /* Disable the Cryptographic processor */
    CRYP->CR &= ~CRYP_CR_CRYPEN;
  }
}
 8009a74:	e005      	b.n	8009a82 <CRYP_Cmd+0x2a>
    CRYP->CR &= ~CRYP_CR_CRYPEN;
 8009a76:	4a06      	ldr	r2, [pc, #24]	; (8009a90 <CRYP_Cmd+0x38>)
 8009a78:	4b05      	ldr	r3, [pc, #20]	; (8009a90 <CRYP_Cmd+0x38>)
 8009a7a:	681b      	ldr	r3, [r3, #0]
 8009a7c:	f423 4300 	bic.w	r3, r3, #32768	; 0x8000
 8009a80:	6013      	str	r3, [r2, #0]
}
 8009a82:	bf00      	nop
 8009a84:	370c      	adds	r7, #12
 8009a86:	46bd      	mov	sp, r7
 8009a88:	f85d 7b04 	ldr.w	r7, [sp], #4
 8009a8c:	4770      	bx	lr
 8009a8e:	bf00      	nop
 8009a90:	50060000 	.word	0x50060000

08009a94 <CRYP_DataIn>:
  *         the FIFO must be flushed (using CRYP_FIFOFlush() function).  
  * @param  Data: data to write in Data Input register
  * @retval None
  */
void CRYP_DataIn(uint32_t Data)
{
 8009a94:	b480      	push	{r7}
 8009a96:	b083      	sub	sp, #12
 8009a98:	af00      	add	r7, sp, #0
 8009a9a:	6078      	str	r0, [r7, #4]
  CRYP->DR = Data;
 8009a9c:	4a04      	ldr	r2, [pc, #16]	; (8009ab0 <CRYP_DataIn+0x1c>)
 8009a9e:	687b      	ldr	r3, [r7, #4]
 8009aa0:	6093      	str	r3, [r2, #8]
}
 8009aa2:	bf00      	nop
 8009aa4:	370c      	adds	r7, #12
 8009aa6:	46bd      	mov	sp, r7
 8009aa8:	f85d 7b04 	ldr.w	r7, [sp], #4
 8009aac:	4770      	bx	lr
 8009aae:	bf00      	nop
 8009ab0:	50060000 	.word	0x50060000

08009ab4 <CRYP_DataOut>:
  * @brief  Returns the last data entered into the output FIFO.
  * @param  None
  * @retval Last data entered into the output FIFO.
  */
uint32_t CRYP_DataOut(void)
{
 8009ab4:	b480      	push	{r7}
 8009ab6:	af00      	add	r7, sp, #0
  return CRYP->DOUT;
 8009ab8:	4b03      	ldr	r3, [pc, #12]	; (8009ac8 <CRYP_DataOut+0x14>)
 8009aba:	68db      	ldr	r3, [r3, #12]
}
 8009abc:	4618      	mov	r0, r3
 8009abe:	46bd      	mov	sp, r7
 8009ac0:	f85d 7b04 	ldr.w	r7, [sp], #4
 8009ac4:	4770      	bx	lr
 8009ac6:	bf00      	nop
 8009ac8:	50060000 	.word	0x50060000

08009acc <CRYP_SaveContext>:
  *         contains the configuration information for the CRYP Keys.  
  * @retval None
  */
ErrorStatus CRYP_SaveContext(CRYP_Context* CRYP_ContextSave,
                             CRYP_KeyInitTypeDef* CRYP_KeyInitStruct)
{
 8009acc:	b480      	push	{r7}
 8009ace:	b087      	sub	sp, #28
 8009ad0:	af00      	add	r7, sp, #0
 8009ad2:	6078      	str	r0, [r7, #4]
 8009ad4:	6039      	str	r1, [r7, #0]
  __IO uint32_t timeout = 0;
 8009ad6:	2300      	movs	r3, #0
 8009ad8:	60bb      	str	r3, [r7, #8]
  uint32_t ckeckmask = 0, bitstatus;    
 8009ada:	2300      	movs	r3, #0
 8009adc:	617b      	str	r3, [r7, #20]
  ErrorStatus status = ERROR;
 8009ade:	2300      	movs	r3, #0
 8009ae0:	74fb      	strb	r3, [r7, #19]

  /* Stop DMA transfers on the IN FIFO by clearing the DIEN bit in the CRYP_DMACR */
  CRYP->DMACR &= ~(uint32_t)CRYP_DMACR_DIEN;
 8009ae2:	4a3a      	ldr	r2, [pc, #232]	; (8009bcc <CRYP_SaveContext+0x100>)
 8009ae4:	4b39      	ldr	r3, [pc, #228]	; (8009bcc <CRYP_SaveContext+0x100>)
 8009ae6:	691b      	ldr	r3, [r3, #16]
 8009ae8:	f023 0301 	bic.w	r3, r3, #1
 8009aec:	6113      	str	r3, [r2, #16]
    
  /* Wait until both the IN and OUT FIFOs are empty  
    (IFEM=1 and OFNE=0 in the CRYP_SR register) and the 
     BUSY bit is cleared. */

  if ((CRYP->CR & (uint32_t)(CRYP_CR_ALGOMODE_TDES_ECB | CRYP_CR_ALGOMODE_TDES_CBC)) != (uint32_t)0 )/* TDES */
 8009aee:	4b37      	ldr	r3, [pc, #220]	; (8009bcc <CRYP_SaveContext+0x100>)
 8009af0:	681b      	ldr	r3, [r3, #0]
 8009af2:	f003 0308 	and.w	r3, r3, #8
 8009af6:	2b00      	cmp	r3, #0
 8009af8:	d002      	beq.n	8009b00 <CRYP_SaveContext+0x34>
  { 
    ckeckmask =  CRYP_SR_IFEM | CRYP_SR_BUSY ;
 8009afa:	2311      	movs	r3, #17
 8009afc:	617b      	str	r3, [r7, #20]
 8009afe:	e001      	b.n	8009b04 <CRYP_SaveContext+0x38>
  }
  else /* AES or DES */
  {
    ckeckmask =  CRYP_SR_IFEM | CRYP_SR_BUSY | CRYP_SR_OFNE;
 8009b00:	2315      	movs	r3, #21
 8009b02:	617b      	str	r3, [r7, #20]
  }           
   
  do 
  {
    bitstatus = CRYP->SR & ckeckmask;
 8009b04:	4b31      	ldr	r3, [pc, #196]	; (8009bcc <CRYP_SaveContext+0x100>)
 8009b06:	685a      	ldr	r2, [r3, #4]
 8009b08:	697b      	ldr	r3, [r7, #20]
 8009b0a:	4013      	ands	r3, r2
 8009b0c:	60fb      	str	r3, [r7, #12]
    timeout++;
 8009b0e:	68bb      	ldr	r3, [r7, #8]
 8009b10:	3301      	adds	r3, #1
 8009b12:	60bb      	str	r3, [r7, #8]
  }
  while ((timeout != MAX_TIMEOUT) && (bitstatus != CRYP_SR_IFEM));
 8009b14:	68bb      	ldr	r3, [r7, #8]
 8009b16:	f64f 72ff 	movw	r2, #65535	; 0xffff
 8009b1a:	4293      	cmp	r3, r2
 8009b1c:	d002      	beq.n	8009b24 <CRYP_SaveContext+0x58>
 8009b1e:	68fb      	ldr	r3, [r7, #12]
 8009b20:	2b01      	cmp	r3, #1
 8009b22:	d1ef      	bne.n	8009b04 <CRYP_SaveContext+0x38>
     
  if ((CRYP->SR & ckeckmask) != CRYP_SR_IFEM)
 8009b24:	4b29      	ldr	r3, [pc, #164]	; (8009bcc <CRYP_SaveContext+0x100>)
 8009b26:	685a      	ldr	r2, [r3, #4]
 8009b28:	697b      	ldr	r3, [r7, #20]
 8009b2a:	4013      	ands	r3, r2
 8009b2c:	2b01      	cmp	r3, #1
 8009b2e:	d002      	beq.n	8009b36 <CRYP_SaveContext+0x6a>
  {
    status = ERROR;
 8009b30:	2300      	movs	r3, #0
 8009b32:	74fb      	strb	r3, [r7, #19]
 8009b34:	e043      	b.n	8009bbe <CRYP_SaveContext+0xf2>
  {      
    /* Stop DMA transfers on the OUT FIFO by 
       - writing the DOEN bit to 0 in the CRYP_DMACR register 
       - and clear the CRYPEN bit. */

    CRYP->DMACR &= ~(uint32_t)CRYP_DMACR_DOEN;
 8009b36:	4a25      	ldr	r2, [pc, #148]	; (8009bcc <CRYP_SaveContext+0x100>)
 8009b38:	4b24      	ldr	r3, [pc, #144]	; (8009bcc <CRYP_SaveContext+0x100>)
 8009b3a:	691b      	ldr	r3, [r3, #16]
 8009b3c:	f023 0302 	bic.w	r3, r3, #2
 8009b40:	6113      	str	r3, [r2, #16]
    CRYP->CR &= ~(uint32_t)CRYP_CR_CRYPEN;
 8009b42:	4a22      	ldr	r2, [pc, #136]	; (8009bcc <CRYP_SaveContext+0x100>)
 8009b44:	4b21      	ldr	r3, [pc, #132]	; (8009bcc <CRYP_SaveContext+0x100>)
 8009b46:	681b      	ldr	r3, [r3, #0]
 8009b48:	f423 4300 	bic.w	r3, r3, #32768	; 0x8000
 8009b4c:	6013      	str	r3, [r2, #0]

    /* Save the current configuration (bits [9:2] in the CRYP_CR register) */
    CRYP_ContextSave->CR_bits9to2  = CRYP->CR & (CRYP_CR_KEYSIZE  | 
 8009b4e:	4b1f      	ldr	r3, [pc, #124]	; (8009bcc <CRYP_SaveContext+0x100>)
 8009b50:	681b      	ldr	r3, [r3, #0]
 8009b52:	f403 727f 	and.w	r2, r3, #1020	; 0x3fc
 8009b56:	687b      	ldr	r3, [r7, #4]
 8009b58:	601a      	str	r2, [r3, #0]
                                                 CRYP_CR_DATATYPE | 
                                                 CRYP_CR_ALGOMODE |
                                                 CRYP_CR_ALGODIR); 

    /* and, if not in ECB mode, the initialization vectors. */
    CRYP_ContextSave->CRYP_IV0LR = CRYP->IV0LR;
 8009b5a:	4b1c      	ldr	r3, [pc, #112]	; (8009bcc <CRYP_SaveContext+0x100>)
 8009b5c:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 8009b5e:	687b      	ldr	r3, [r7, #4]
 8009b60:	605a      	str	r2, [r3, #4]
    CRYP_ContextSave->CRYP_IV0RR = CRYP->IV0RR;
 8009b62:	4b1a      	ldr	r3, [pc, #104]	; (8009bcc <CRYP_SaveContext+0x100>)
 8009b64:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 8009b66:	687b      	ldr	r3, [r7, #4]
 8009b68:	609a      	str	r2, [r3, #8]
    CRYP_ContextSave->CRYP_IV1LR = CRYP->IV1LR;
 8009b6a:	4b18      	ldr	r3, [pc, #96]	; (8009bcc <CRYP_SaveContext+0x100>)
 8009b6c:	6c9a      	ldr	r2, [r3, #72]	; 0x48
 8009b6e:	687b      	ldr	r3, [r7, #4]
 8009b70:	60da      	str	r2, [r3, #12]
    CRYP_ContextSave->CRYP_IV1RR = CRYP->IV1RR;
 8009b72:	4b16      	ldr	r3, [pc, #88]	; (8009bcc <CRYP_SaveContext+0x100>)
 8009b74:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 8009b76:	687b      	ldr	r3, [r7, #4]
 8009b78:	611a      	str	r2, [r3, #16]

    /* save The key value */
    CRYP_ContextSave->CRYP_K0LR = CRYP_KeyInitStruct->CRYP_Key0Left; 
 8009b7a:	683b      	ldr	r3, [r7, #0]
 8009b7c:	681a      	ldr	r2, [r3, #0]
 8009b7e:	687b      	ldr	r3, [r7, #4]
 8009b80:	615a      	str	r2, [r3, #20]
    CRYP_ContextSave->CRYP_K0RR = CRYP_KeyInitStruct->CRYP_Key0Right; 
 8009b82:	683b      	ldr	r3, [r7, #0]
 8009b84:	685a      	ldr	r2, [r3, #4]
 8009b86:	687b      	ldr	r3, [r7, #4]
 8009b88:	619a      	str	r2, [r3, #24]
    CRYP_ContextSave->CRYP_K1LR = CRYP_KeyInitStruct->CRYP_Key1Left; 
 8009b8a:	683b      	ldr	r3, [r7, #0]
 8009b8c:	689a      	ldr	r2, [r3, #8]
 8009b8e:	687b      	ldr	r3, [r7, #4]
 8009b90:	61da      	str	r2, [r3, #28]
    CRYP_ContextSave->CRYP_K1RR = CRYP_KeyInitStruct->CRYP_Key1Right; 
 8009b92:	683b      	ldr	r3, [r7, #0]
 8009b94:	68da      	ldr	r2, [r3, #12]
 8009b96:	687b      	ldr	r3, [r7, #4]
 8009b98:	621a      	str	r2, [r3, #32]
    CRYP_ContextSave->CRYP_K2LR = CRYP_KeyInitStruct->CRYP_Key2Left; 
 8009b9a:	683b      	ldr	r3, [r7, #0]
 8009b9c:	691a      	ldr	r2, [r3, #16]
 8009b9e:	687b      	ldr	r3, [r7, #4]
 8009ba0:	625a      	str	r2, [r3, #36]	; 0x24
    CRYP_ContextSave->CRYP_K2RR = CRYP_KeyInitStruct->CRYP_Key2Right; 
 8009ba2:	683b      	ldr	r3, [r7, #0]
 8009ba4:	695a      	ldr	r2, [r3, #20]
 8009ba6:	687b      	ldr	r3, [r7, #4]
 8009ba8:	629a      	str	r2, [r3, #40]	; 0x28
    CRYP_ContextSave->CRYP_K3LR = CRYP_KeyInitStruct->CRYP_Key3Left; 
 8009baa:	683b      	ldr	r3, [r7, #0]
 8009bac:	699a      	ldr	r2, [r3, #24]
 8009bae:	687b      	ldr	r3, [r7, #4]
 8009bb0:	62da      	str	r2, [r3, #44]	; 0x2c
    CRYP_ContextSave->CRYP_K3RR = CRYP_KeyInitStruct->CRYP_Key3Right; 
 8009bb2:	683b      	ldr	r3, [r7, #0]
 8009bb4:	69da      	ldr	r2, [r3, #28]
 8009bb6:	687b      	ldr	r3, [r7, #4]
 8009bb8:	631a      	str	r2, [r3, #48]	; 0x30

   /* When needed, save the DMA status (pointers for IN and OUT messages, 
      number of remaining bytes, etc.) */
     
    status = SUCCESS;
 8009bba:	2301      	movs	r3, #1
 8009bbc:	74fb      	strb	r3, [r7, #19]
  }

   return status;
 8009bbe:	7cfb      	ldrb	r3, [r7, #19]
}
 8009bc0:	4618      	mov	r0, r3
 8009bc2:	371c      	adds	r7, #28
 8009bc4:	46bd      	mov	sp, r7
 8009bc6:	f85d 7b04 	ldr.w	r7, [sp], #4
 8009bca:	4770      	bx	lr
 8009bcc:	50060000 	.word	0x50060000

08009bd0 <CRYP_RestoreContext>:
  * @note   The data that were saved during context saving must be rewrited into
  *         the IN FIFO.
  * @retval None
  */
void CRYP_RestoreContext(CRYP_Context* CRYP_ContextRestore)  
{
 8009bd0:	b480      	push	{r7}
 8009bd2:	b083      	sub	sp, #12
 8009bd4:	af00      	add	r7, sp, #0
 8009bd6:	6078      	str	r0, [r7, #4]

  /* Configure the processor with the saved configuration */
  CRYP->CR = CRYP_ContextRestore->CR_bits9to2;
 8009bd8:	4a1f      	ldr	r2, [pc, #124]	; (8009c58 <CRYP_RestoreContext+0x88>)
 8009bda:	687b      	ldr	r3, [r7, #4]
 8009bdc:	681b      	ldr	r3, [r3, #0]
 8009bde:	6013      	str	r3, [r2, #0]

  /* restore The key value */
  CRYP->K0LR = CRYP_ContextRestore->CRYP_K0LR; 
 8009be0:	4a1d      	ldr	r2, [pc, #116]	; (8009c58 <CRYP_RestoreContext+0x88>)
 8009be2:	687b      	ldr	r3, [r7, #4]
 8009be4:	695b      	ldr	r3, [r3, #20]
 8009be6:	6213      	str	r3, [r2, #32]
  CRYP->K0RR = CRYP_ContextRestore->CRYP_K0RR;
 8009be8:	4a1b      	ldr	r2, [pc, #108]	; (8009c58 <CRYP_RestoreContext+0x88>)
 8009bea:	687b      	ldr	r3, [r7, #4]
 8009bec:	699b      	ldr	r3, [r3, #24]
 8009bee:	6253      	str	r3, [r2, #36]	; 0x24
  CRYP->K1LR = CRYP_ContextRestore->CRYP_K1LR;
 8009bf0:	4a19      	ldr	r2, [pc, #100]	; (8009c58 <CRYP_RestoreContext+0x88>)
 8009bf2:	687b      	ldr	r3, [r7, #4]
 8009bf4:	69db      	ldr	r3, [r3, #28]
 8009bf6:	6293      	str	r3, [r2, #40]	; 0x28
  CRYP->K1RR = CRYP_ContextRestore->CRYP_K1RR;
 8009bf8:	4a17      	ldr	r2, [pc, #92]	; (8009c58 <CRYP_RestoreContext+0x88>)
 8009bfa:	687b      	ldr	r3, [r7, #4]
 8009bfc:	6a1b      	ldr	r3, [r3, #32]
 8009bfe:	62d3      	str	r3, [r2, #44]	; 0x2c
  CRYP->K2LR = CRYP_ContextRestore->CRYP_K2LR;
 8009c00:	4a15      	ldr	r2, [pc, #84]	; (8009c58 <CRYP_RestoreContext+0x88>)
 8009c02:	687b      	ldr	r3, [r7, #4]
 8009c04:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8009c06:	6313      	str	r3, [r2, #48]	; 0x30
  CRYP->K2RR = CRYP_ContextRestore->CRYP_K2RR;
 8009c08:	4a13      	ldr	r2, [pc, #76]	; (8009c58 <CRYP_RestoreContext+0x88>)
 8009c0a:	687b      	ldr	r3, [r7, #4]
 8009c0c:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8009c0e:	6353      	str	r3, [r2, #52]	; 0x34
  CRYP->K3LR = CRYP_ContextRestore->CRYP_K3LR;
 8009c10:	4a11      	ldr	r2, [pc, #68]	; (8009c58 <CRYP_RestoreContext+0x88>)
 8009c12:	687b      	ldr	r3, [r7, #4]
 8009c14:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8009c16:	6393      	str	r3, [r2, #56]	; 0x38
  CRYP->K3RR = CRYP_ContextRestore->CRYP_K3RR;
 8009c18:	4a0f      	ldr	r2, [pc, #60]	; (8009c58 <CRYP_RestoreContext+0x88>)
 8009c1a:	687b      	ldr	r3, [r7, #4]
 8009c1c:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8009c1e:	63d3      	str	r3, [r2, #60]	; 0x3c

  /* and the initialization vectors. */
  CRYP->IV0LR = CRYP_ContextRestore->CRYP_IV0LR;
 8009c20:	4a0d      	ldr	r2, [pc, #52]	; (8009c58 <CRYP_RestoreContext+0x88>)
 8009c22:	687b      	ldr	r3, [r7, #4]
 8009c24:	685b      	ldr	r3, [r3, #4]
 8009c26:	6413      	str	r3, [r2, #64]	; 0x40
  CRYP->IV0RR = CRYP_ContextRestore->CRYP_IV0RR;
 8009c28:	4a0b      	ldr	r2, [pc, #44]	; (8009c58 <CRYP_RestoreContext+0x88>)
 8009c2a:	687b      	ldr	r3, [r7, #4]
 8009c2c:	689b      	ldr	r3, [r3, #8]
 8009c2e:	6453      	str	r3, [r2, #68]	; 0x44
  CRYP->IV1LR = CRYP_ContextRestore->CRYP_IV1LR;
 8009c30:	4a09      	ldr	r2, [pc, #36]	; (8009c58 <CRYP_RestoreContext+0x88>)
 8009c32:	687b      	ldr	r3, [r7, #4]
 8009c34:	68db      	ldr	r3, [r3, #12]
 8009c36:	6493      	str	r3, [r2, #72]	; 0x48
  CRYP->IV1RR = CRYP_ContextRestore->CRYP_IV1RR;
 8009c38:	4a07      	ldr	r2, [pc, #28]	; (8009c58 <CRYP_RestoreContext+0x88>)
 8009c3a:	687b      	ldr	r3, [r7, #4]
 8009c3c:	691b      	ldr	r3, [r3, #16]
 8009c3e:	64d3      	str	r3, [r2, #76]	; 0x4c

  /* Enable the cryptographic processor */
  CRYP->CR |= CRYP_CR_CRYPEN;
 8009c40:	4a05      	ldr	r2, [pc, #20]	; (8009c58 <CRYP_RestoreContext+0x88>)
 8009c42:	4b05      	ldr	r3, [pc, #20]	; (8009c58 <CRYP_RestoreContext+0x88>)
 8009c44:	681b      	ldr	r3, [r3, #0]
 8009c46:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 8009c4a:	6013      	str	r3, [r2, #0]
}
 8009c4c:	bf00      	nop
 8009c4e:	370c      	adds	r7, #12
 8009c50:	46bd      	mov	sp, r7
 8009c52:	f85d 7b04 	ldr.w	r7, [sp], #4
 8009c56:	4770      	bx	lr
 8009c58:	50060000 	.word	0x50060000

08009c5c <CRYP_DMACmd>:
  * @param  NewState: new state of the selected CRYP DMA transfer request.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void CRYP_DMACmd(uint8_t CRYP_DMAReq, FunctionalState NewState)
{
 8009c5c:	b480      	push	{r7}
 8009c5e:	b083      	sub	sp, #12
 8009c60:	af00      	add	r7, sp, #0
 8009c62:	4603      	mov	r3, r0
 8009c64:	460a      	mov	r2, r1
 8009c66:	71fb      	strb	r3, [r7, #7]
 8009c68:	4613      	mov	r3, r2
 8009c6a:	71bb      	strb	r3, [r7, #6]
  /* Check the parameters */
  assert_param(IS_CRYP_DMAREQ(CRYP_DMAReq));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 8009c6c:	79bb      	ldrb	r3, [r7, #6]
 8009c6e:	2b00      	cmp	r3, #0
 8009c70:	d006      	beq.n	8009c80 <CRYP_DMACmd+0x24>
  {
    /* Enable the selected CRYP DMA request */
    CRYP->DMACR |= CRYP_DMAReq;
 8009c72:	490a      	ldr	r1, [pc, #40]	; (8009c9c <CRYP_DMACmd+0x40>)
 8009c74:	4b09      	ldr	r3, [pc, #36]	; (8009c9c <CRYP_DMACmd+0x40>)
 8009c76:	691a      	ldr	r2, [r3, #16]
 8009c78:	79fb      	ldrb	r3, [r7, #7]
 8009c7a:	4313      	orrs	r3, r2
 8009c7c:	610b      	str	r3, [r1, #16]
  else
  {
    /* Disable the selected CRYP DMA request */
    CRYP->DMACR &= (uint8_t)~CRYP_DMAReq;
  }
}
 8009c7e:	e007      	b.n	8009c90 <CRYP_DMACmd+0x34>
    CRYP->DMACR &= (uint8_t)~CRYP_DMAReq;
 8009c80:	4906      	ldr	r1, [pc, #24]	; (8009c9c <CRYP_DMACmd+0x40>)
 8009c82:	4b06      	ldr	r3, [pc, #24]	; (8009c9c <CRYP_DMACmd+0x40>)
 8009c84:	691b      	ldr	r3, [r3, #16]
 8009c86:	79fa      	ldrb	r2, [r7, #7]
 8009c88:	43d2      	mvns	r2, r2
 8009c8a:	b2d2      	uxtb	r2, r2
 8009c8c:	4013      	ands	r3, r2
 8009c8e:	610b      	str	r3, [r1, #16]
}
 8009c90:	bf00      	nop
 8009c92:	370c      	adds	r7, #12
 8009c94:	46bd      	mov	sp, r7
 8009c96:	f85d 7b04 	ldr.w	r7, [sp], #4
 8009c9a:	4770      	bx	lr
 8009c9c:	50060000 	.word	0x50060000

08009ca0 <CRYP_ITConfig>:
  * @param  NewState: new state of the specified CRYP interrupt.
  *           This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void CRYP_ITConfig(uint8_t CRYP_IT, FunctionalState NewState)
{
 8009ca0:	b480      	push	{r7}
 8009ca2:	b083      	sub	sp, #12
 8009ca4:	af00      	add	r7, sp, #0
 8009ca6:	4603      	mov	r3, r0
 8009ca8:	460a      	mov	r2, r1
 8009caa:	71fb      	strb	r3, [r7, #7]
 8009cac:	4613      	mov	r3, r2
 8009cae:	71bb      	strb	r3, [r7, #6]
  /* Check the parameters */
  assert_param(IS_CRYP_CONFIG_IT(CRYP_IT));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 8009cb0:	79bb      	ldrb	r3, [r7, #6]
 8009cb2:	2b00      	cmp	r3, #0
 8009cb4:	d006      	beq.n	8009cc4 <CRYP_ITConfig+0x24>
  {
    /* Enable the selected CRYP interrupt */
    CRYP->IMSCR |= CRYP_IT;
 8009cb6:	490a      	ldr	r1, [pc, #40]	; (8009ce0 <CRYP_ITConfig+0x40>)
 8009cb8:	4b09      	ldr	r3, [pc, #36]	; (8009ce0 <CRYP_ITConfig+0x40>)
 8009cba:	695a      	ldr	r2, [r3, #20]
 8009cbc:	79fb      	ldrb	r3, [r7, #7]
 8009cbe:	4313      	orrs	r3, r2
 8009cc0:	614b      	str	r3, [r1, #20]
  else
  {
    /* Disable the selected CRYP interrupt */
    CRYP->IMSCR &= (uint8_t)~CRYP_IT;
  }
}
 8009cc2:	e007      	b.n	8009cd4 <CRYP_ITConfig+0x34>
    CRYP->IMSCR &= (uint8_t)~CRYP_IT;
 8009cc4:	4906      	ldr	r1, [pc, #24]	; (8009ce0 <CRYP_ITConfig+0x40>)
 8009cc6:	4b06      	ldr	r3, [pc, #24]	; (8009ce0 <CRYP_ITConfig+0x40>)
 8009cc8:	695b      	ldr	r3, [r3, #20]
 8009cca:	79fa      	ldrb	r2, [r7, #7]
 8009ccc:	43d2      	mvns	r2, r2
 8009cce:	b2d2      	uxtb	r2, r2
 8009cd0:	4013      	ands	r3, r2
 8009cd2:	614b      	str	r3, [r1, #20]
}
 8009cd4:	bf00      	nop
 8009cd6:	370c      	adds	r7, #12
 8009cd8:	46bd      	mov	sp, r7
 8009cda:	f85d 7b04 	ldr.w	r7, [sp], #4
 8009cde:	4770      	bx	lr
 8009ce0:	50060000 	.word	0x50060000

08009ce4 <CRYP_GetITStatus>:
  *            @arg CRYP_IT_INI: Input FIFO interrupt
  *            @arg CRYP_IT_OUTI: Output FIFO interrupt
  * @retval The new state of CRYP_IT (SET or RESET).
  */
ITStatus CRYP_GetITStatus(uint8_t CRYP_IT)
{
 8009ce4:	b480      	push	{r7}
 8009ce6:	b085      	sub	sp, #20
 8009ce8:	af00      	add	r7, sp, #0
 8009cea:	4603      	mov	r3, r0
 8009cec:	71fb      	strb	r3, [r7, #7]
  ITStatus bitstatus = RESET;
 8009cee:	2300      	movs	r3, #0
 8009cf0:	73fb      	strb	r3, [r7, #15]
  /* Check the parameters */
  assert_param(IS_CRYP_GET_IT(CRYP_IT));

  /* Check the status of the specified CRYP interrupt */
  if ((CRYP->MISR &  CRYP_IT) != (uint8_t)RESET)
 8009cf2:	4b09      	ldr	r3, [pc, #36]	; (8009d18 <CRYP_GetITStatus+0x34>)
 8009cf4:	69da      	ldr	r2, [r3, #28]
 8009cf6:	79fb      	ldrb	r3, [r7, #7]
 8009cf8:	4013      	ands	r3, r2
 8009cfa:	2b00      	cmp	r3, #0
 8009cfc:	d002      	beq.n	8009d04 <CRYP_GetITStatus+0x20>
  {
    /* CRYP_IT is set */
    bitstatus = SET;
 8009cfe:	2301      	movs	r3, #1
 8009d00:	73fb      	strb	r3, [r7, #15]
 8009d02:	e001      	b.n	8009d08 <CRYP_GetITStatus+0x24>
  }
  else
  {
    /* CRYP_IT is reset */
    bitstatus = RESET;
 8009d04:	2300      	movs	r3, #0
 8009d06:	73fb      	strb	r3, [r7, #15]
  }
  /* Return the CRYP_IT status */
  return bitstatus;
 8009d08:	7bfb      	ldrb	r3, [r7, #15]
}
 8009d0a:	4618      	mov	r0, r3
 8009d0c:	3714      	adds	r7, #20
 8009d0e:	46bd      	mov	sp, r7
 8009d10:	f85d 7b04 	ldr.w	r7, [sp], #4
 8009d14:	4770      	bx	lr
 8009d16:	bf00      	nop
 8009d18:	50060000 	.word	0x50060000

08009d1c <CRYP_GetFlagStatus>:
  *            @arg CRYP_FLAG_OUTRIS: Output FIFO raw interrupt flag.
  *            @arg CRYP_FLAG_INRIS: Input FIFO raw interrupt flag.
  * @retval The new state of CRYP_FLAG (SET or RESET).
  */
FlagStatus CRYP_GetFlagStatus(uint8_t CRYP_FLAG)
{
 8009d1c:	b480      	push	{r7}
 8009d1e:	b085      	sub	sp, #20
 8009d20:	af00      	add	r7, sp, #0
 8009d22:	4603      	mov	r3, r0
 8009d24:	71fb      	strb	r3, [r7, #7]
  FlagStatus bitstatus = RESET;
 8009d26:	2300      	movs	r3, #0
 8009d28:	73fb      	strb	r3, [r7, #15]
  uint32_t tempreg = 0;
 8009d2a:	2300      	movs	r3, #0
 8009d2c:	60bb      	str	r3, [r7, #8]

  /* Check the parameters */
  assert_param(IS_CRYP_GET_FLAG(CRYP_FLAG));

  /* check if the FLAG is in RISR register */
  if ((CRYP_FLAG & FLAG_MASK) != 0x00) 
 8009d2e:	79fb      	ldrb	r3, [r7, #7]
 8009d30:	f003 0320 	and.w	r3, r3, #32
 8009d34:	2b00      	cmp	r3, #0
 8009d36:	d003      	beq.n	8009d40 <CRYP_GetFlagStatus+0x24>
  {
    tempreg = CRYP->RISR;
 8009d38:	4b0b      	ldr	r3, [pc, #44]	; (8009d68 <CRYP_GetFlagStatus+0x4c>)
 8009d3a:	699b      	ldr	r3, [r3, #24]
 8009d3c:	60bb      	str	r3, [r7, #8]
 8009d3e:	e002      	b.n	8009d46 <CRYP_GetFlagStatus+0x2a>
  }
  else  /* The FLAG is in SR register */
  {
    tempreg = CRYP->SR;
 8009d40:	4b09      	ldr	r3, [pc, #36]	; (8009d68 <CRYP_GetFlagStatus+0x4c>)
 8009d42:	685b      	ldr	r3, [r3, #4]
 8009d44:	60bb      	str	r3, [r7, #8]
  }


  /* Check the status of the specified CRYP flag */
  if ((tempreg & CRYP_FLAG ) != (uint8_t)RESET)
 8009d46:	79fa      	ldrb	r2, [r7, #7]
 8009d48:	68bb      	ldr	r3, [r7, #8]
 8009d4a:	4013      	ands	r3, r2
 8009d4c:	2b00      	cmp	r3, #0
 8009d4e:	d002      	beq.n	8009d56 <CRYP_GetFlagStatus+0x3a>
  {
    /* CRYP_FLAG is set */
    bitstatus = SET;
 8009d50:	2301      	movs	r3, #1
 8009d52:	73fb      	strb	r3, [r7, #15]
 8009d54:	e001      	b.n	8009d5a <CRYP_GetFlagStatus+0x3e>
  }
  else
  {
    /* CRYP_FLAG is reset */
    bitstatus = RESET;
 8009d56:	2300      	movs	r3, #0
 8009d58:	73fb      	strb	r3, [r7, #15]
  }

  /* Return the CRYP_FLAG status */
  return  bitstatus;
 8009d5a:	7bfb      	ldrb	r3, [r7, #15]
}
 8009d5c:	4618      	mov	r0, r3
 8009d5e:	3714      	adds	r7, #20
 8009d60:	46bd      	mov	sp, r7
 8009d62:	f85d 7b04 	ldr.w	r7, [sp], #4
 8009d66:	4770      	bx	lr
 8009d68:	50060000 	.word	0x50060000

08009d6c <CRYP_AES_ECB>:
  *          - SUCCESS: Operation done
  *          - ERROR: Operation failed
  */
ErrorStatus CRYP_AES_ECB(uint8_t Mode, uint8_t* Key, uint16_t Keysize,
                         uint8_t* Input, uint32_t Ilength, uint8_t* Output)
{
 8009d6c:	b590      	push	{r4, r7, lr}
 8009d6e:	b0bb      	sub	sp, #236	; 0xec
 8009d70:	af00      	add	r7, sp, #0
 8009d72:	60b9      	str	r1, [r7, #8]
 8009d74:	607b      	str	r3, [r7, #4]
 8009d76:	4603      	mov	r3, r0
 8009d78:	73fb      	strb	r3, [r7, #15]
 8009d7a:	4613      	mov	r3, r2
 8009d7c:	81bb      	strh	r3, [r7, #12]
  CRYP_InitTypeDef AES_CRYP_InitStructure;
  CRYP_KeyInitTypeDef AES_CRYP_KeyInitStructure;
  __IO uint32_t counter = 0;
 8009d7e:	2300      	movs	r3, #0
 8009d80:	617b      	str	r3, [r7, #20]
  uint32_t busystatus = 0;
 8009d82:	2300      	movs	r3, #0
 8009d84:	f8c7 30d4 	str.w	r3, [r7, #212]	; 0xd4
  ErrorStatus status = SUCCESS;
 8009d88:	2301      	movs	r3, #1
 8009d8a:	f887 30e7 	strb.w	r3, [r7, #231]	; 0xe7
  uint32_t keyaddr    = (uint32_t)Key;
 8009d8e:	68bb      	ldr	r3, [r7, #8]
 8009d90:	f8c7 30d0 	str.w	r3, [r7, #208]	; 0xd0
  uint32_t inputaddr  = (uint32_t)Input;
 8009d94:	687b      	ldr	r3, [r7, #4]
 8009d96:	f8c7 30e0 	str.w	r3, [r7, #224]	; 0xe0
  uint32_t outputaddr = (uint32_t)Output;
 8009d9a:	f8d7 30fc 	ldr.w	r3, [r7, #252]	; 0xfc
 8009d9e:	f8c7 30dc 	str.w	r3, [r7, #220]	; 0xdc
  uint32_t i = 0;
 8009da2:	2300      	movs	r3, #0
 8009da4:	f8c7 30d8 	str.w	r3, [r7, #216]	; 0xd8

  /* Crypto structures initialisation*/
  CRYP_KeyStructInit(&AES_CRYP_KeyInitStructure);
 8009da8:	f107 0318 	add.w	r3, r7, #24
 8009dac:	4618      	mov	r0, r3
 8009dae:	f7ff fdef 	bl	8009990 <CRYP_KeyStructInit>

  switch(Keysize)
 8009db2:	89bb      	ldrh	r3, [r7, #12]
 8009db4:	2bc0      	cmp	r3, #192	; 0xc0
 8009db6:	d04c      	beq.n	8009e52 <CRYP_AES_ECB+0xe6>
 8009db8:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 8009dbc:	f000 80b4 	beq.w	8009f28 <CRYP_AES_ECB+0x1bc>
 8009dc0:	2b80      	cmp	r3, #128	; 0x80
 8009dc2:	d000      	beq.n	8009dc6 <CRYP_AES_ECB+0x5a>
    AES_CRYP_KeyInitStructure.CRYP_Key3Left = __REV(*(uint32_t*)(keyaddr));
    keyaddr+=4;
    AES_CRYP_KeyInitStructure.CRYP_Key3Right= __REV(*(uint32_t*)(keyaddr));
    break;
    default:
    break;
 8009dc4:	e11f      	b.n	800a006 <CRYP_AES_ECB+0x29a>
    AES_CRYP_InitStructure.CRYP_KeySize = CRYP_KeySize_128b;
 8009dc6:	2300      	movs	r3, #0
 8009dc8:	87fb      	strh	r3, [r7, #62]	; 0x3e
    AES_CRYP_KeyInitStructure.CRYP_Key2Left = __REV(*(uint32_t*)(keyaddr));
 8009dca:	f8d7 30d0 	ldr.w	r3, [r7, #208]	; 0xd0
 8009dce:	681b      	ldr	r3, [r3, #0]
 8009dd0:	f8c7 30b4 	str.w	r3, [r7, #180]	; 0xb4
 */
__attribute__( ( always_inline ) ) static __INLINE uint32_t __REV(uint32_t value)
{
  uint32_t result;
  
  __ASM volatile ("rev %0, %1" : "=r" (result) : "r" (value) );
 8009dd4:	f8d7 30b4 	ldr.w	r3, [r7, #180]	; 0xb4
 8009dd8:	ba1b      	rev	r3, r3
 8009dda:	f8c7 30b0 	str.w	r3, [r7, #176]	; 0xb0
  return(result);
 8009dde:	f8d7 30b0 	ldr.w	r3, [r7, #176]	; 0xb0
 8009de2:	62bb      	str	r3, [r7, #40]	; 0x28
    keyaddr+=4;
 8009de4:	f8d7 30d0 	ldr.w	r3, [r7, #208]	; 0xd0
 8009de8:	3304      	adds	r3, #4
 8009dea:	f8c7 30d0 	str.w	r3, [r7, #208]	; 0xd0
    AES_CRYP_KeyInitStructure.CRYP_Key2Right= __REV(*(uint32_t*)(keyaddr));
 8009dee:	f8d7 30d0 	ldr.w	r3, [r7, #208]	; 0xd0
 8009df2:	681b      	ldr	r3, [r3, #0]
 8009df4:	f8c7 30bc 	str.w	r3, [r7, #188]	; 0xbc
  __ASM volatile ("rev %0, %1" : "=r" (result) : "r" (value) );
 8009df8:	f8d7 30bc 	ldr.w	r3, [r7, #188]	; 0xbc
 8009dfc:	ba1b      	rev	r3, r3
 8009dfe:	f8c7 30b8 	str.w	r3, [r7, #184]	; 0xb8
  return(result);
 8009e02:	f8d7 30b8 	ldr.w	r3, [r7, #184]	; 0xb8
 8009e06:	62fb      	str	r3, [r7, #44]	; 0x2c
    keyaddr+=4;
 8009e08:	f8d7 30d0 	ldr.w	r3, [r7, #208]	; 0xd0
 8009e0c:	3304      	adds	r3, #4
 8009e0e:	f8c7 30d0 	str.w	r3, [r7, #208]	; 0xd0
    AES_CRYP_KeyInitStructure.CRYP_Key3Left = __REV(*(uint32_t*)(keyaddr));
 8009e12:	f8d7 30d0 	ldr.w	r3, [r7, #208]	; 0xd0
 8009e16:	681b      	ldr	r3, [r3, #0]
 8009e18:	f8c7 30c4 	str.w	r3, [r7, #196]	; 0xc4
  __ASM volatile ("rev %0, %1" : "=r" (result) : "r" (value) );
 8009e1c:	f8d7 30c4 	ldr.w	r3, [r7, #196]	; 0xc4
 8009e20:	ba1b      	rev	r3, r3
 8009e22:	f8c7 30c0 	str.w	r3, [r7, #192]	; 0xc0
  return(result);
 8009e26:	f8d7 30c0 	ldr.w	r3, [r7, #192]	; 0xc0
 8009e2a:	633b      	str	r3, [r7, #48]	; 0x30
    keyaddr+=4;
 8009e2c:	f8d7 30d0 	ldr.w	r3, [r7, #208]	; 0xd0
 8009e30:	3304      	adds	r3, #4
 8009e32:	f8c7 30d0 	str.w	r3, [r7, #208]	; 0xd0
    AES_CRYP_KeyInitStructure.CRYP_Key3Right= __REV(*(uint32_t*)(keyaddr));
 8009e36:	f8d7 30d0 	ldr.w	r3, [r7, #208]	; 0xd0
 8009e3a:	681b      	ldr	r3, [r3, #0]
 8009e3c:	f8c7 30cc 	str.w	r3, [r7, #204]	; 0xcc
  __ASM volatile ("rev %0, %1" : "=r" (result) : "r" (value) );
 8009e40:	f8d7 30cc 	ldr.w	r3, [r7, #204]	; 0xcc
 8009e44:	ba1b      	rev	r3, r3
 8009e46:	f8c7 30c8 	str.w	r3, [r7, #200]	; 0xc8
  return(result);
 8009e4a:	f8d7 30c8 	ldr.w	r3, [r7, #200]	; 0xc8
 8009e4e:	637b      	str	r3, [r7, #52]	; 0x34
    break;
 8009e50:	e0d9      	b.n	800a006 <CRYP_AES_ECB+0x29a>
    AES_CRYP_InitStructure.CRYP_KeySize  = CRYP_KeySize_192b;
 8009e52:	f44f 7380 	mov.w	r3, #256	; 0x100
 8009e56:	87fb      	strh	r3, [r7, #62]	; 0x3e
    AES_CRYP_KeyInitStructure.CRYP_Key1Left = __REV(*(uint32_t*)(keyaddr));
 8009e58:	f8d7 30d0 	ldr.w	r3, [r7, #208]	; 0xd0
 8009e5c:	681b      	ldr	r3, [r3, #0]
 8009e5e:	f8c7 3084 	str.w	r3, [r7, #132]	; 0x84
  __ASM volatile ("rev %0, %1" : "=r" (result) : "r" (value) );
 8009e62:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
 8009e66:	ba1b      	rev	r3, r3
 8009e68:	f8c7 3080 	str.w	r3, [r7, #128]	; 0x80
  return(result);
 8009e6c:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
 8009e70:	623b      	str	r3, [r7, #32]
    keyaddr+=4;
 8009e72:	f8d7 30d0 	ldr.w	r3, [r7, #208]	; 0xd0
 8009e76:	3304      	adds	r3, #4
 8009e78:	f8c7 30d0 	str.w	r3, [r7, #208]	; 0xd0
    AES_CRYP_KeyInitStructure.CRYP_Key1Right= __REV(*(uint32_t*)(keyaddr));
 8009e7c:	f8d7 30d0 	ldr.w	r3, [r7, #208]	; 0xd0
 8009e80:	681b      	ldr	r3, [r3, #0]
 8009e82:	f8c7 308c 	str.w	r3, [r7, #140]	; 0x8c
  __ASM volatile ("rev %0, %1" : "=r" (result) : "r" (value) );
 8009e86:	f8d7 308c 	ldr.w	r3, [r7, #140]	; 0x8c
 8009e8a:	ba1b      	rev	r3, r3
 8009e8c:	f8c7 3088 	str.w	r3, [r7, #136]	; 0x88
  return(result);
 8009e90:	f8d7 3088 	ldr.w	r3, [r7, #136]	; 0x88
 8009e94:	627b      	str	r3, [r7, #36]	; 0x24
    keyaddr+=4;
 8009e96:	f8d7 30d0 	ldr.w	r3, [r7, #208]	; 0xd0
 8009e9a:	3304      	adds	r3, #4
 8009e9c:	f8c7 30d0 	str.w	r3, [r7, #208]	; 0xd0
    AES_CRYP_KeyInitStructure.CRYP_Key2Left = __REV(*(uint32_t*)(keyaddr));
 8009ea0:	f8d7 30d0 	ldr.w	r3, [r7, #208]	; 0xd0
 8009ea4:	681b      	ldr	r3, [r3, #0]
 8009ea6:	f8c7 3094 	str.w	r3, [r7, #148]	; 0x94
  __ASM volatile ("rev %0, %1" : "=r" (result) : "r" (value) );
 8009eaa:	f8d7 3094 	ldr.w	r3, [r7, #148]	; 0x94
 8009eae:	ba1b      	rev	r3, r3
 8009eb0:	f8c7 3090 	str.w	r3, [r7, #144]	; 0x90
  return(result);
 8009eb4:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
 8009eb8:	62bb      	str	r3, [r7, #40]	; 0x28
    keyaddr+=4;
 8009eba:	f8d7 30d0 	ldr.w	r3, [r7, #208]	; 0xd0
 8009ebe:	3304      	adds	r3, #4
 8009ec0:	f8c7 30d0 	str.w	r3, [r7, #208]	; 0xd0
    AES_CRYP_KeyInitStructure.CRYP_Key2Right= __REV(*(uint32_t*)(keyaddr));
 8009ec4:	f8d7 30d0 	ldr.w	r3, [r7, #208]	; 0xd0
 8009ec8:	681b      	ldr	r3, [r3, #0]
 8009eca:	f8c7 309c 	str.w	r3, [r7, #156]	; 0x9c
  __ASM volatile ("rev %0, %1" : "=r" (result) : "r" (value) );
 8009ece:	f8d7 309c 	ldr.w	r3, [r7, #156]	; 0x9c
 8009ed2:	ba1b      	rev	r3, r3
 8009ed4:	f8c7 3098 	str.w	r3, [r7, #152]	; 0x98
  return(result);
 8009ed8:	f8d7 3098 	ldr.w	r3, [r7, #152]	; 0x98
 8009edc:	62fb      	str	r3, [r7, #44]	; 0x2c
    keyaddr+=4;
 8009ede:	f8d7 30d0 	ldr.w	r3, [r7, #208]	; 0xd0
 8009ee2:	3304      	adds	r3, #4
 8009ee4:	f8c7 30d0 	str.w	r3, [r7, #208]	; 0xd0
    AES_CRYP_KeyInitStructure.CRYP_Key3Left = __REV(*(uint32_t*)(keyaddr));
 8009ee8:	f8d7 30d0 	ldr.w	r3, [r7, #208]	; 0xd0
 8009eec:	681b      	ldr	r3, [r3, #0]
 8009eee:	f8c7 30a4 	str.w	r3, [r7, #164]	; 0xa4
  __ASM volatile ("rev %0, %1" : "=r" (result) : "r" (value) );
 8009ef2:	f8d7 30a4 	ldr.w	r3, [r7, #164]	; 0xa4
 8009ef6:	ba1b      	rev	r3, r3
 8009ef8:	f8c7 30a0 	str.w	r3, [r7, #160]	; 0xa0
  return(result);
 8009efc:	f8d7 30a0 	ldr.w	r3, [r7, #160]	; 0xa0
 8009f00:	633b      	str	r3, [r7, #48]	; 0x30
    keyaddr+=4;
 8009f02:	f8d7 30d0 	ldr.w	r3, [r7, #208]	; 0xd0
 8009f06:	3304      	adds	r3, #4
 8009f08:	f8c7 30d0 	str.w	r3, [r7, #208]	; 0xd0
    AES_CRYP_KeyInitStructure.CRYP_Key3Right= __REV(*(uint32_t*)(keyaddr));
 8009f0c:	f8d7 30d0 	ldr.w	r3, [r7, #208]	; 0xd0
 8009f10:	681b      	ldr	r3, [r3, #0]
 8009f12:	f8c7 30ac 	str.w	r3, [r7, #172]	; 0xac
  __ASM volatile ("rev %0, %1" : "=r" (result) : "r" (value) );
 8009f16:	f8d7 30ac 	ldr.w	r3, [r7, #172]	; 0xac
 8009f1a:	ba1b      	rev	r3, r3
 8009f1c:	f8c7 30a8 	str.w	r3, [r7, #168]	; 0xa8
  return(result);
 8009f20:	f8d7 30a8 	ldr.w	r3, [r7, #168]	; 0xa8
 8009f24:	637b      	str	r3, [r7, #52]	; 0x34
    break;
 8009f26:	e06e      	b.n	800a006 <CRYP_AES_ECB+0x29a>
    AES_CRYP_InitStructure.CRYP_KeySize  = CRYP_KeySize_256b;
 8009f28:	f44f 7300 	mov.w	r3, #512	; 0x200
 8009f2c:	87fb      	strh	r3, [r7, #62]	; 0x3e
    AES_CRYP_KeyInitStructure.CRYP_Key0Left = __REV(*(uint32_t*)(keyaddr));
 8009f2e:	f8d7 30d0 	ldr.w	r3, [r7, #208]	; 0xd0
 8009f32:	681b      	ldr	r3, [r3, #0]
 8009f34:	647b      	str	r3, [r7, #68]	; 0x44
  __ASM volatile ("rev %0, %1" : "=r" (result) : "r" (value) );
 8009f36:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8009f38:	ba1b      	rev	r3, r3
 8009f3a:	643b      	str	r3, [r7, #64]	; 0x40
  return(result);
 8009f3c:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8009f3e:	61bb      	str	r3, [r7, #24]
    keyaddr+=4;
 8009f40:	f8d7 30d0 	ldr.w	r3, [r7, #208]	; 0xd0
 8009f44:	3304      	adds	r3, #4
 8009f46:	f8c7 30d0 	str.w	r3, [r7, #208]	; 0xd0
    AES_CRYP_KeyInitStructure.CRYP_Key0Right= __REV(*(uint32_t*)(keyaddr));
 8009f4a:	f8d7 30d0 	ldr.w	r3, [r7, #208]	; 0xd0
 8009f4e:	681b      	ldr	r3, [r3, #0]
 8009f50:	64fb      	str	r3, [r7, #76]	; 0x4c
  __ASM volatile ("rev %0, %1" : "=r" (result) : "r" (value) );
 8009f52:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8009f54:	ba1b      	rev	r3, r3
 8009f56:	64bb      	str	r3, [r7, #72]	; 0x48
  return(result);
 8009f58:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8009f5a:	61fb      	str	r3, [r7, #28]
    keyaddr+=4;
 8009f5c:	f8d7 30d0 	ldr.w	r3, [r7, #208]	; 0xd0
 8009f60:	3304      	adds	r3, #4
 8009f62:	f8c7 30d0 	str.w	r3, [r7, #208]	; 0xd0
    AES_CRYP_KeyInitStructure.CRYP_Key1Left = __REV(*(uint32_t*)(keyaddr));
 8009f66:	f8d7 30d0 	ldr.w	r3, [r7, #208]	; 0xd0
 8009f6a:	681b      	ldr	r3, [r3, #0]
 8009f6c:	657b      	str	r3, [r7, #84]	; 0x54
  __ASM volatile ("rev %0, %1" : "=r" (result) : "r" (value) );
 8009f6e:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8009f70:	ba1b      	rev	r3, r3
 8009f72:	653b      	str	r3, [r7, #80]	; 0x50
  return(result);
 8009f74:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8009f76:	623b      	str	r3, [r7, #32]
    keyaddr+=4;
 8009f78:	f8d7 30d0 	ldr.w	r3, [r7, #208]	; 0xd0
 8009f7c:	3304      	adds	r3, #4
 8009f7e:	f8c7 30d0 	str.w	r3, [r7, #208]	; 0xd0
    AES_CRYP_KeyInitStructure.CRYP_Key1Right= __REV(*(uint32_t*)(keyaddr));
 8009f82:	f8d7 30d0 	ldr.w	r3, [r7, #208]	; 0xd0
 8009f86:	681b      	ldr	r3, [r3, #0]
 8009f88:	65fb      	str	r3, [r7, #92]	; 0x5c
  __ASM volatile ("rev %0, %1" : "=r" (result) : "r" (value) );
 8009f8a:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 8009f8c:	ba1b      	rev	r3, r3
 8009f8e:	65bb      	str	r3, [r7, #88]	; 0x58
  return(result);
 8009f90:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8009f92:	627b      	str	r3, [r7, #36]	; 0x24
    keyaddr+=4;
 8009f94:	f8d7 30d0 	ldr.w	r3, [r7, #208]	; 0xd0
 8009f98:	3304      	adds	r3, #4
 8009f9a:	f8c7 30d0 	str.w	r3, [r7, #208]	; 0xd0
    AES_CRYP_KeyInitStructure.CRYP_Key2Left = __REV(*(uint32_t*)(keyaddr));
 8009f9e:	f8d7 30d0 	ldr.w	r3, [r7, #208]	; 0xd0
 8009fa2:	681b      	ldr	r3, [r3, #0]
 8009fa4:	667b      	str	r3, [r7, #100]	; 0x64
  __ASM volatile ("rev %0, %1" : "=r" (result) : "r" (value) );
 8009fa6:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8009fa8:	ba1b      	rev	r3, r3
 8009faa:	663b      	str	r3, [r7, #96]	; 0x60
  return(result);
 8009fac:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 8009fae:	62bb      	str	r3, [r7, #40]	; 0x28
    keyaddr+=4;
 8009fb0:	f8d7 30d0 	ldr.w	r3, [r7, #208]	; 0xd0
 8009fb4:	3304      	adds	r3, #4
 8009fb6:	f8c7 30d0 	str.w	r3, [r7, #208]	; 0xd0
    AES_CRYP_KeyInitStructure.CRYP_Key2Right= __REV(*(uint32_t*)(keyaddr));
 8009fba:	f8d7 30d0 	ldr.w	r3, [r7, #208]	; 0xd0
 8009fbe:	681b      	ldr	r3, [r3, #0]
 8009fc0:	66fb      	str	r3, [r7, #108]	; 0x6c
  __ASM volatile ("rev %0, %1" : "=r" (result) : "r" (value) );
 8009fc2:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 8009fc4:	ba1b      	rev	r3, r3
 8009fc6:	66bb      	str	r3, [r7, #104]	; 0x68
  return(result);
 8009fc8:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 8009fca:	62fb      	str	r3, [r7, #44]	; 0x2c
    keyaddr+=4;
 8009fcc:	f8d7 30d0 	ldr.w	r3, [r7, #208]	; 0xd0
 8009fd0:	3304      	adds	r3, #4
 8009fd2:	f8c7 30d0 	str.w	r3, [r7, #208]	; 0xd0
    AES_CRYP_KeyInitStructure.CRYP_Key3Left = __REV(*(uint32_t*)(keyaddr));
 8009fd6:	f8d7 30d0 	ldr.w	r3, [r7, #208]	; 0xd0
 8009fda:	681b      	ldr	r3, [r3, #0]
 8009fdc:	677b      	str	r3, [r7, #116]	; 0x74
  __ASM volatile ("rev %0, %1" : "=r" (result) : "r" (value) );
 8009fde:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 8009fe0:	ba1b      	rev	r3, r3
 8009fe2:	673b      	str	r3, [r7, #112]	; 0x70
  return(result);
 8009fe4:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 8009fe6:	633b      	str	r3, [r7, #48]	; 0x30
    keyaddr+=4;
 8009fe8:	f8d7 30d0 	ldr.w	r3, [r7, #208]	; 0xd0
 8009fec:	3304      	adds	r3, #4
 8009fee:	f8c7 30d0 	str.w	r3, [r7, #208]	; 0xd0
    AES_CRYP_KeyInitStructure.CRYP_Key3Right= __REV(*(uint32_t*)(keyaddr));
 8009ff2:	f8d7 30d0 	ldr.w	r3, [r7, #208]	; 0xd0
 8009ff6:	681b      	ldr	r3, [r3, #0]
 8009ff8:	67fb      	str	r3, [r7, #124]	; 0x7c
  __ASM volatile ("rev %0, %1" : "=r" (result) : "r" (value) );
 8009ffa:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
 8009ffc:	ba1b      	rev	r3, r3
 8009ffe:	67bb      	str	r3, [r7, #120]	; 0x78
  return(result);
 800a000:	6fbb      	ldr	r3, [r7, #120]	; 0x78
 800a002:	637b      	str	r3, [r7, #52]	; 0x34
    break;
 800a004:	bf00      	nop
  }

  /*------------------ AES Decryption ------------------*/
  if(Mode == MODE_DECRYPT) /* AES decryption */
 800a006:	7bfb      	ldrb	r3, [r7, #15]
 800a008:	2b00      	cmp	r3, #0
 800a00a:	d130      	bne.n	800a06e <CRYP_AES_ECB+0x302>
  {
    /* Flush IN/OUT FIFOs */
    CRYP_FIFOFlush();
 800a00c:	f7ff fd14 	bl	8009a38 <CRYP_FIFOFlush>

    /* Crypto Init for Key preparation for decryption process */
    AES_CRYP_InitStructure.CRYP_AlgoDir = CRYP_AlgoDir_Decrypt;
 800a010:	2304      	movs	r3, #4
 800a012:	873b      	strh	r3, [r7, #56]	; 0x38
    AES_CRYP_InitStructure.CRYP_AlgoMode = CRYP_AlgoMode_AES_Key;
 800a014:	2338      	movs	r3, #56	; 0x38
 800a016:	877b      	strh	r3, [r7, #58]	; 0x3a
    AES_CRYP_InitStructure.CRYP_DataType = CRYP_DataType_32b;
 800a018:	2300      	movs	r3, #0
 800a01a:	87bb      	strh	r3, [r7, #60]	; 0x3c
    CRYP_Init(&AES_CRYP_InitStructure);
 800a01c:	f107 0338 	add.w	r3, r7, #56	; 0x38
 800a020:	4618      	mov	r0, r3
 800a022:	f7ff fc23 	bl	800986c <CRYP_Init>

    /* Key Initialisation */
    CRYP_KeyInit(&AES_CRYP_KeyInitStructure);
 800a026:	f107 0318 	add.w	r3, r7, #24
 800a02a:	4618      	mov	r0, r3
 800a02c:	f7ff fc84 	bl	8009938 <CRYP_KeyInit>

    /* Enable Crypto processor */
    CRYP_Cmd(ENABLE);
 800a030:	2001      	movs	r0, #1
 800a032:	f7ff fd11 	bl	8009a58 <CRYP_Cmd>

    /* wait until the Busy flag is RESET */
    do
    {
      busystatus = CRYP_GetFlagStatus(CRYP_FLAG_BUSY);
 800a036:	2010      	movs	r0, #16
 800a038:	f7ff fe70 	bl	8009d1c <CRYP_GetFlagStatus>
 800a03c:	4603      	mov	r3, r0
 800a03e:	f8c7 30d4 	str.w	r3, [r7, #212]	; 0xd4
      counter++;
 800a042:	697b      	ldr	r3, [r7, #20]
 800a044:	3301      	adds	r3, #1
 800a046:	617b      	str	r3, [r7, #20]
    }while ((counter != AESBUSY_TIMEOUT) && (busystatus != RESET));
 800a048:	697b      	ldr	r3, [r7, #20]
 800a04a:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 800a04e:	d003      	beq.n	800a058 <CRYP_AES_ECB+0x2ec>
 800a050:	f8d7 30d4 	ldr.w	r3, [r7, #212]	; 0xd4
 800a054:	2b00      	cmp	r3, #0
 800a056:	d1ee      	bne.n	800a036 <CRYP_AES_ECB+0x2ca>

    if (busystatus != RESET)
 800a058:	f8d7 30d4 	ldr.w	r3, [r7, #212]	; 0xd4
 800a05c:	2b00      	cmp	r3, #0
 800a05e:	d003      	beq.n	800a068 <CRYP_AES_ECB+0x2fc>
   {
       status = ERROR;
 800a060:	2300      	movs	r3, #0
 800a062:	f887 30e7 	strb.w	r3, [r7, #231]	; 0xe7
 800a066:	e009      	b.n	800a07c <CRYP_AES_ECB+0x310>
    }
    else
    {
      /* Crypto Init for decryption process */  
      AES_CRYP_InitStructure.CRYP_AlgoDir = CRYP_AlgoDir_Decrypt;
 800a068:	2304      	movs	r3, #4
 800a06a:	873b      	strh	r3, [r7, #56]	; 0x38
 800a06c:	e006      	b.n	800a07c <CRYP_AES_ECB+0x310>
  }
  /*------------------ AES Encryption ------------------*/
  else /* AES encryption */
  {

    CRYP_KeyInit(&AES_CRYP_KeyInitStructure);
 800a06e:	f107 0318 	add.w	r3, r7, #24
 800a072:	4618      	mov	r0, r3
 800a074:	f7ff fc60 	bl	8009938 <CRYP_KeyInit>

    /* Crypto Init for Encryption process */
    AES_CRYP_InitStructure.CRYP_AlgoDir  = CRYP_AlgoDir_Encrypt;
 800a078:	2300      	movs	r3, #0
 800a07a:	873b      	strh	r3, [r7, #56]	; 0x38
  }

  AES_CRYP_InitStructure.CRYP_AlgoMode = CRYP_AlgoMode_AES_ECB;
 800a07c:	2320      	movs	r3, #32
 800a07e:	877b      	strh	r3, [r7, #58]	; 0x3a
  AES_CRYP_InitStructure.CRYP_DataType = CRYP_DataType_8b;
 800a080:	2380      	movs	r3, #128	; 0x80
 800a082:	87bb      	strh	r3, [r7, #60]	; 0x3c
  CRYP_Init(&AES_CRYP_InitStructure);
 800a084:	f107 0338 	add.w	r3, r7, #56	; 0x38
 800a088:	4618      	mov	r0, r3
 800a08a:	f7ff fbef 	bl	800986c <CRYP_Init>

  /* Flush IN/OUT FIFOs */
  CRYP_FIFOFlush();
 800a08e:	f7ff fcd3 	bl	8009a38 <CRYP_FIFOFlush>

  /* Enable Crypto processor */
  CRYP_Cmd(ENABLE);
 800a092:	2001      	movs	r0, #1
 800a094:	f7ff fce0 	bl	8009a58 <CRYP_Cmd>

  for(i=0; ((i<Ilength) && (status != ERROR)); i+=16)
 800a098:	2300      	movs	r3, #0
 800a09a:	f8c7 30d8 	str.w	r3, [r7, #216]	; 0xd8
 800a09e:	e077      	b.n	800a190 <CRYP_AES_ECB+0x424>
  {

    /* Write the Input block in the IN FIFO */
    CRYP_DataIn(*(uint32_t*)(inputaddr));
 800a0a0:	f8d7 30e0 	ldr.w	r3, [r7, #224]	; 0xe0
 800a0a4:	681b      	ldr	r3, [r3, #0]
 800a0a6:	4618      	mov	r0, r3
 800a0a8:	f7ff fcf4 	bl	8009a94 <CRYP_DataIn>
    inputaddr+=4;
 800a0ac:	f8d7 30e0 	ldr.w	r3, [r7, #224]	; 0xe0
 800a0b0:	3304      	adds	r3, #4
 800a0b2:	f8c7 30e0 	str.w	r3, [r7, #224]	; 0xe0
    CRYP_DataIn(*(uint32_t*)(inputaddr));
 800a0b6:	f8d7 30e0 	ldr.w	r3, [r7, #224]	; 0xe0
 800a0ba:	681b      	ldr	r3, [r3, #0]
 800a0bc:	4618      	mov	r0, r3
 800a0be:	f7ff fce9 	bl	8009a94 <CRYP_DataIn>
    inputaddr+=4;
 800a0c2:	f8d7 30e0 	ldr.w	r3, [r7, #224]	; 0xe0
 800a0c6:	3304      	adds	r3, #4
 800a0c8:	f8c7 30e0 	str.w	r3, [r7, #224]	; 0xe0
    CRYP_DataIn(*(uint32_t*)(inputaddr));
 800a0cc:	f8d7 30e0 	ldr.w	r3, [r7, #224]	; 0xe0
 800a0d0:	681b      	ldr	r3, [r3, #0]
 800a0d2:	4618      	mov	r0, r3
 800a0d4:	f7ff fcde 	bl	8009a94 <CRYP_DataIn>
    inputaddr+=4;
 800a0d8:	f8d7 30e0 	ldr.w	r3, [r7, #224]	; 0xe0
 800a0dc:	3304      	adds	r3, #4
 800a0de:	f8c7 30e0 	str.w	r3, [r7, #224]	; 0xe0
    CRYP_DataIn(*(uint32_t*)(inputaddr));
 800a0e2:	f8d7 30e0 	ldr.w	r3, [r7, #224]	; 0xe0
 800a0e6:	681b      	ldr	r3, [r3, #0]
 800a0e8:	4618      	mov	r0, r3
 800a0ea:	f7ff fcd3 	bl	8009a94 <CRYP_DataIn>
    inputaddr+=4;
 800a0ee:	f8d7 30e0 	ldr.w	r3, [r7, #224]	; 0xe0
 800a0f2:	3304      	adds	r3, #4
 800a0f4:	f8c7 30e0 	str.w	r3, [r7, #224]	; 0xe0

    /* Wait until the complete message has been processed */
    counter = 0;
 800a0f8:	2300      	movs	r3, #0
 800a0fa:	617b      	str	r3, [r7, #20]
    do
    {
      busystatus = CRYP_GetFlagStatus(CRYP_FLAG_BUSY);
 800a0fc:	2010      	movs	r0, #16
 800a0fe:	f7ff fe0d 	bl	8009d1c <CRYP_GetFlagStatus>
 800a102:	4603      	mov	r3, r0
 800a104:	f8c7 30d4 	str.w	r3, [r7, #212]	; 0xd4
      counter++;
 800a108:	697b      	ldr	r3, [r7, #20]
 800a10a:	3301      	adds	r3, #1
 800a10c:	617b      	str	r3, [r7, #20]
    }while ((counter != AESBUSY_TIMEOUT) && (busystatus != RESET));
 800a10e:	697b      	ldr	r3, [r7, #20]
 800a110:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 800a114:	d003      	beq.n	800a11e <CRYP_AES_ECB+0x3b2>
 800a116:	f8d7 30d4 	ldr.w	r3, [r7, #212]	; 0xd4
 800a11a:	2b00      	cmp	r3, #0
 800a11c:	d1ee      	bne.n	800a0fc <CRYP_AES_ECB+0x390>

    if (busystatus != RESET)
 800a11e:	f8d7 30d4 	ldr.w	r3, [r7, #212]	; 0xd4
 800a122:	2b00      	cmp	r3, #0
 800a124:	d003      	beq.n	800a12e <CRYP_AES_ECB+0x3c2>
   {
       status = ERROR;
 800a126:	2300      	movs	r3, #0
 800a128:	f887 30e7 	strb.w	r3, [r7, #231]	; 0xe7
 800a12c:	e02b      	b.n	800a186 <CRYP_AES_ECB+0x41a>
    }
    else
    {

      /* Read the Output block from the Output FIFO */
      *(uint32_t*)(outputaddr) = CRYP_DataOut();
 800a12e:	f8d7 40dc 	ldr.w	r4, [r7, #220]	; 0xdc
 800a132:	f7ff fcbf 	bl	8009ab4 <CRYP_DataOut>
 800a136:	4603      	mov	r3, r0
 800a138:	6023      	str	r3, [r4, #0]
      outputaddr+=4;
 800a13a:	f8d7 30dc 	ldr.w	r3, [r7, #220]	; 0xdc
 800a13e:	3304      	adds	r3, #4
 800a140:	f8c7 30dc 	str.w	r3, [r7, #220]	; 0xdc
      *(uint32_t*)(outputaddr) = CRYP_DataOut();
 800a144:	f8d7 40dc 	ldr.w	r4, [r7, #220]	; 0xdc
 800a148:	f7ff fcb4 	bl	8009ab4 <CRYP_DataOut>
 800a14c:	4603      	mov	r3, r0
 800a14e:	6023      	str	r3, [r4, #0]
      outputaddr+=4;
 800a150:	f8d7 30dc 	ldr.w	r3, [r7, #220]	; 0xdc
 800a154:	3304      	adds	r3, #4
 800a156:	f8c7 30dc 	str.w	r3, [r7, #220]	; 0xdc
      *(uint32_t*)(outputaddr) = CRYP_DataOut();
 800a15a:	f8d7 40dc 	ldr.w	r4, [r7, #220]	; 0xdc
 800a15e:	f7ff fca9 	bl	8009ab4 <CRYP_DataOut>
 800a162:	4603      	mov	r3, r0
 800a164:	6023      	str	r3, [r4, #0]
      outputaddr+=4;
 800a166:	f8d7 30dc 	ldr.w	r3, [r7, #220]	; 0xdc
 800a16a:	3304      	adds	r3, #4
 800a16c:	f8c7 30dc 	str.w	r3, [r7, #220]	; 0xdc
      *(uint32_t*)(outputaddr) = CRYP_DataOut(); 
 800a170:	f8d7 40dc 	ldr.w	r4, [r7, #220]	; 0xdc
 800a174:	f7ff fc9e 	bl	8009ab4 <CRYP_DataOut>
 800a178:	4603      	mov	r3, r0
 800a17a:	6023      	str	r3, [r4, #0]
      outputaddr+=4;
 800a17c:	f8d7 30dc 	ldr.w	r3, [r7, #220]	; 0xdc
 800a180:	3304      	adds	r3, #4
 800a182:	f8c7 30dc 	str.w	r3, [r7, #220]	; 0xdc
  for(i=0; ((i<Ilength) && (status != ERROR)); i+=16)
 800a186:	f8d7 30d8 	ldr.w	r3, [r7, #216]	; 0xd8
 800a18a:	3310      	adds	r3, #16
 800a18c:	f8c7 30d8 	str.w	r3, [r7, #216]	; 0xd8
 800a190:	f8d7 20d8 	ldr.w	r2, [r7, #216]	; 0xd8
 800a194:	f8d7 30f8 	ldr.w	r3, [r7, #248]	; 0xf8
 800a198:	429a      	cmp	r2, r3
 800a19a:	d204      	bcs.n	800a1a6 <CRYP_AES_ECB+0x43a>
 800a19c:	f897 30e7 	ldrb.w	r3, [r7, #231]	; 0xe7
 800a1a0:	2b00      	cmp	r3, #0
 800a1a2:	f47f af7d 	bne.w	800a0a0 <CRYP_AES_ECB+0x334>
    }
  }

  /* Disable Crypto */
  CRYP_Cmd(DISABLE);
 800a1a6:	2000      	movs	r0, #0
 800a1a8:	f7ff fc56 	bl	8009a58 <CRYP_Cmd>

  return status; 
 800a1ac:	f897 30e7 	ldrb.w	r3, [r7, #231]	; 0xe7
}
 800a1b0:	4618      	mov	r0, r3
 800a1b2:	37ec      	adds	r7, #236	; 0xec
 800a1b4:	46bd      	mov	sp, r7
 800a1b6:	bd90      	pop	{r4, r7, pc}

0800a1b8 <CRYP_AES_CBC>:
  *          - ERROR: Operation failed
  */
ErrorStatus CRYP_AES_CBC(uint8_t Mode, uint8_t InitVectors[16], uint8_t *Key,
                         uint16_t Keysize, uint8_t *Input, uint32_t Ilength,
                         uint8_t *Output)
{
 800a1b8:	b590      	push	{r4, r7, lr}
 800a1ba:	b0c7      	sub	sp, #284	; 0x11c
 800a1bc:	af00      	add	r7, sp, #0
 800a1be:	4604      	mov	r4, r0
 800a1c0:	f107 0008 	add.w	r0, r7, #8
 800a1c4:	6001      	str	r1, [r0, #0]
 800a1c6:	1d39      	adds	r1, r7, #4
 800a1c8:	600a      	str	r2, [r1, #0]
 800a1ca:	4619      	mov	r1, r3
 800a1cc:	f107 030f 	add.w	r3, r7, #15
 800a1d0:	4622      	mov	r2, r4
 800a1d2:	701a      	strb	r2, [r3, #0]
 800a1d4:	f107 030c 	add.w	r3, r7, #12
 800a1d8:	460a      	mov	r2, r1
 800a1da:	801a      	strh	r2, [r3, #0]
  CRYP_InitTypeDef AES_CRYP_InitStructure;
  CRYP_KeyInitTypeDef AES_CRYP_KeyInitStructure;
  CRYP_IVInitTypeDef AES_CRYP_IVInitStructure;
  __IO uint32_t counter = 0;
 800a1dc:	f107 0310 	add.w	r3, r7, #16
 800a1e0:	2200      	movs	r2, #0
 800a1e2:	601a      	str	r2, [r3, #0]
  uint32_t busystatus = 0;
 800a1e4:	2300      	movs	r3, #0
 800a1e6:	f8c7 3104 	str.w	r3, [r7, #260]	; 0x104
  ErrorStatus status = SUCCESS;
 800a1ea:	2301      	movs	r3, #1
 800a1ec:	f887 3117 	strb.w	r3, [r7, #279]	; 0x117
  uint32_t keyaddr    = (uint32_t)Key;
 800a1f0:	1d3b      	adds	r3, r7, #4
 800a1f2:	681b      	ldr	r3, [r3, #0]
 800a1f4:	f8c7 3100 	str.w	r3, [r7, #256]	; 0x100
  uint32_t inputaddr  = (uint32_t)Input;
 800a1f8:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 800a1fc:	f8c7 3110 	str.w	r3, [r7, #272]	; 0x110
  uint32_t outputaddr = (uint32_t)Output;
 800a200:	f8d7 3130 	ldr.w	r3, [r7, #304]	; 0x130
 800a204:	f8c7 310c 	str.w	r3, [r7, #268]	; 0x10c
  uint32_t ivaddr     = (uint32_t)InitVectors;
 800a208:	f107 0308 	add.w	r3, r7, #8
 800a20c:	681b      	ldr	r3, [r3, #0]
 800a20e:	f8c7 30fc 	str.w	r3, [r7, #252]	; 0xfc
  uint32_t i = 0;
 800a212:	2300      	movs	r3, #0
 800a214:	f8c7 3108 	str.w	r3, [r7, #264]	; 0x108

  /* Crypto structures initialisation*/
  CRYP_KeyStructInit(&AES_CRYP_KeyInitStructure);
 800a218:	f107 0324 	add.w	r3, r7, #36	; 0x24
 800a21c:	4618      	mov	r0, r3
 800a21e:	f7ff fbb7 	bl	8009990 <CRYP_KeyStructInit>

  switch(Keysize)
 800a222:	f107 030c 	add.w	r3, r7, #12
 800a226:	881b      	ldrh	r3, [r3, #0]
 800a228:	2bc0      	cmp	r3, #192	; 0xc0
 800a22a:	d04d      	beq.n	800a2c8 <CRYP_AES_CBC+0x110>
 800a22c:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 800a230:	f000 80b6 	beq.w	800a3a0 <CRYP_AES_CBC+0x1e8>
 800a234:	2b80      	cmp	r3, #128	; 0x80
 800a236:	d000      	beq.n	800a23a <CRYP_AES_CBC+0x82>
    AES_CRYP_KeyInitStructure.CRYP_Key3Left = __REV(*(uint32_t*)(keyaddr));
    keyaddr+=4;
    AES_CRYP_KeyInitStructure.CRYP_Key3Right= __REV(*(uint32_t*)(keyaddr));
    break;
    default:
    break;
 800a238:	e138      	b.n	800a4ac <CRYP_AES_CBC+0x2f4>
    AES_CRYP_InitStructure.CRYP_KeySize = CRYP_KeySize_128b;
 800a23a:	2300      	movs	r3, #0
 800a23c:	f8a7 304a 	strh.w	r3, [r7, #74]	; 0x4a
    AES_CRYP_KeyInitStructure.CRYP_Key2Left = __REV(*(uint32_t*)(keyaddr));
 800a240:	f8d7 3100 	ldr.w	r3, [r7, #256]	; 0x100
 800a244:	681b      	ldr	r3, [r3, #0]
 800a246:	f8c7 30e0 	str.w	r3, [r7, #224]	; 0xe0
  __ASM volatile ("rev %0, %1" : "=r" (result) : "r" (value) );
 800a24a:	f8d7 30e0 	ldr.w	r3, [r7, #224]	; 0xe0
 800a24e:	ba1b      	rev	r3, r3
 800a250:	f8c7 30dc 	str.w	r3, [r7, #220]	; 0xdc
  return(result);
 800a254:	f8d7 30dc 	ldr.w	r3, [r7, #220]	; 0xdc
 800a258:	637b      	str	r3, [r7, #52]	; 0x34
    keyaddr+=4;
 800a25a:	f8d7 3100 	ldr.w	r3, [r7, #256]	; 0x100
 800a25e:	3304      	adds	r3, #4
 800a260:	f8c7 3100 	str.w	r3, [r7, #256]	; 0x100
    AES_CRYP_KeyInitStructure.CRYP_Key2Right= __REV(*(uint32_t*)(keyaddr));
 800a264:	f8d7 3100 	ldr.w	r3, [r7, #256]	; 0x100
 800a268:	681b      	ldr	r3, [r3, #0]
 800a26a:	f8c7 30e8 	str.w	r3, [r7, #232]	; 0xe8
  __ASM volatile ("rev %0, %1" : "=r" (result) : "r" (value) );
 800a26e:	f8d7 30e8 	ldr.w	r3, [r7, #232]	; 0xe8
 800a272:	ba1b      	rev	r3, r3
 800a274:	f8c7 30e4 	str.w	r3, [r7, #228]	; 0xe4
  return(result);
 800a278:	f8d7 30e4 	ldr.w	r3, [r7, #228]	; 0xe4
 800a27c:	63bb      	str	r3, [r7, #56]	; 0x38
    keyaddr+=4;
 800a27e:	f8d7 3100 	ldr.w	r3, [r7, #256]	; 0x100
 800a282:	3304      	adds	r3, #4
 800a284:	f8c7 3100 	str.w	r3, [r7, #256]	; 0x100
    AES_CRYP_KeyInitStructure.CRYP_Key3Left = __REV(*(uint32_t*)(keyaddr));
 800a288:	f8d7 3100 	ldr.w	r3, [r7, #256]	; 0x100
 800a28c:	681b      	ldr	r3, [r3, #0]
 800a28e:	f8c7 30f0 	str.w	r3, [r7, #240]	; 0xf0
  __ASM volatile ("rev %0, %1" : "=r" (result) : "r" (value) );
 800a292:	f8d7 30f0 	ldr.w	r3, [r7, #240]	; 0xf0
 800a296:	ba1b      	rev	r3, r3
 800a298:	f8c7 30ec 	str.w	r3, [r7, #236]	; 0xec
  return(result);
 800a29c:	f8d7 30ec 	ldr.w	r3, [r7, #236]	; 0xec
 800a2a0:	63fb      	str	r3, [r7, #60]	; 0x3c
    keyaddr+=4;
 800a2a2:	f8d7 3100 	ldr.w	r3, [r7, #256]	; 0x100
 800a2a6:	3304      	adds	r3, #4
 800a2a8:	f8c7 3100 	str.w	r3, [r7, #256]	; 0x100
    AES_CRYP_KeyInitStructure.CRYP_Key3Right= __REV(*(uint32_t*)(keyaddr));
 800a2ac:	f8d7 3100 	ldr.w	r3, [r7, #256]	; 0x100
 800a2b0:	681b      	ldr	r3, [r3, #0]
 800a2b2:	f8c7 30f8 	str.w	r3, [r7, #248]	; 0xf8
  __ASM volatile ("rev %0, %1" : "=r" (result) : "r" (value) );
 800a2b6:	f8d7 30f8 	ldr.w	r3, [r7, #248]	; 0xf8
 800a2ba:	ba1b      	rev	r3, r3
 800a2bc:	f8c7 30f4 	str.w	r3, [r7, #244]	; 0xf4
  return(result);
 800a2c0:	f8d7 30f4 	ldr.w	r3, [r7, #244]	; 0xf4
 800a2c4:	643b      	str	r3, [r7, #64]	; 0x40
    break;
 800a2c6:	e0f1      	b.n	800a4ac <CRYP_AES_CBC+0x2f4>
    AES_CRYP_InitStructure.CRYP_KeySize  = CRYP_KeySize_192b;
 800a2c8:	f44f 7380 	mov.w	r3, #256	; 0x100
 800a2cc:	f8a7 304a 	strh.w	r3, [r7, #74]	; 0x4a
    AES_CRYP_KeyInitStructure.CRYP_Key1Left = __REV(*(uint32_t*)(keyaddr));
 800a2d0:	f8d7 3100 	ldr.w	r3, [r7, #256]	; 0x100
 800a2d4:	681b      	ldr	r3, [r3, #0]
 800a2d6:	f8c7 30b0 	str.w	r3, [r7, #176]	; 0xb0
  __ASM volatile ("rev %0, %1" : "=r" (result) : "r" (value) );
 800a2da:	f8d7 30b0 	ldr.w	r3, [r7, #176]	; 0xb0
 800a2de:	ba1b      	rev	r3, r3
 800a2e0:	f8c7 30ac 	str.w	r3, [r7, #172]	; 0xac
  return(result);
 800a2e4:	f8d7 30ac 	ldr.w	r3, [r7, #172]	; 0xac
 800a2e8:	62fb      	str	r3, [r7, #44]	; 0x2c
    keyaddr+=4;
 800a2ea:	f8d7 3100 	ldr.w	r3, [r7, #256]	; 0x100
 800a2ee:	3304      	adds	r3, #4
 800a2f0:	f8c7 3100 	str.w	r3, [r7, #256]	; 0x100
    AES_CRYP_KeyInitStructure.CRYP_Key1Right= __REV(*(uint32_t*)(keyaddr));
 800a2f4:	f8d7 3100 	ldr.w	r3, [r7, #256]	; 0x100
 800a2f8:	681b      	ldr	r3, [r3, #0]
 800a2fa:	f8c7 30b8 	str.w	r3, [r7, #184]	; 0xb8
  __ASM volatile ("rev %0, %1" : "=r" (result) : "r" (value) );
 800a2fe:	f8d7 30b8 	ldr.w	r3, [r7, #184]	; 0xb8
 800a302:	ba1b      	rev	r3, r3
 800a304:	f8c7 30b4 	str.w	r3, [r7, #180]	; 0xb4
  return(result);
 800a308:	f8d7 30b4 	ldr.w	r3, [r7, #180]	; 0xb4
 800a30c:	633b      	str	r3, [r7, #48]	; 0x30
    keyaddr+=4;
 800a30e:	f8d7 3100 	ldr.w	r3, [r7, #256]	; 0x100
 800a312:	3304      	adds	r3, #4
 800a314:	f8c7 3100 	str.w	r3, [r7, #256]	; 0x100
    AES_CRYP_KeyInitStructure.CRYP_Key2Left = __REV(*(uint32_t*)(keyaddr));
 800a318:	f8d7 3100 	ldr.w	r3, [r7, #256]	; 0x100
 800a31c:	681b      	ldr	r3, [r3, #0]
 800a31e:	f8c7 30c0 	str.w	r3, [r7, #192]	; 0xc0
  __ASM volatile ("rev %0, %1" : "=r" (result) : "r" (value) );
 800a322:	f8d7 30c0 	ldr.w	r3, [r7, #192]	; 0xc0
 800a326:	ba1b      	rev	r3, r3
 800a328:	f8c7 30bc 	str.w	r3, [r7, #188]	; 0xbc
  return(result);
 800a32c:	f8d7 30bc 	ldr.w	r3, [r7, #188]	; 0xbc
 800a330:	637b      	str	r3, [r7, #52]	; 0x34
    keyaddr+=4;
 800a332:	f8d7 3100 	ldr.w	r3, [r7, #256]	; 0x100
 800a336:	3304      	adds	r3, #4
 800a338:	f8c7 3100 	str.w	r3, [r7, #256]	; 0x100
    AES_CRYP_KeyInitStructure.CRYP_Key2Right= __REV(*(uint32_t*)(keyaddr));
 800a33c:	f8d7 3100 	ldr.w	r3, [r7, #256]	; 0x100
 800a340:	681b      	ldr	r3, [r3, #0]
 800a342:	f8c7 30c8 	str.w	r3, [r7, #200]	; 0xc8
  __ASM volatile ("rev %0, %1" : "=r" (result) : "r" (value) );
 800a346:	f8d7 30c8 	ldr.w	r3, [r7, #200]	; 0xc8
 800a34a:	ba1b      	rev	r3, r3
 800a34c:	f8c7 30c4 	str.w	r3, [r7, #196]	; 0xc4
  return(result);
 800a350:	f8d7 30c4 	ldr.w	r3, [r7, #196]	; 0xc4
 800a354:	63bb      	str	r3, [r7, #56]	; 0x38
    keyaddr+=4;
 800a356:	f8d7 3100 	ldr.w	r3, [r7, #256]	; 0x100
 800a35a:	3304      	adds	r3, #4
 800a35c:	f8c7 3100 	str.w	r3, [r7, #256]	; 0x100
    AES_CRYP_KeyInitStructure.CRYP_Key3Left = __REV(*(uint32_t*)(keyaddr));
 800a360:	f8d7 3100 	ldr.w	r3, [r7, #256]	; 0x100
 800a364:	681b      	ldr	r3, [r3, #0]
 800a366:	f8c7 30d0 	str.w	r3, [r7, #208]	; 0xd0
  __ASM volatile ("rev %0, %1" : "=r" (result) : "r" (value) );
 800a36a:	f8d7 30d0 	ldr.w	r3, [r7, #208]	; 0xd0
 800a36e:	ba1b      	rev	r3, r3
 800a370:	f8c7 30cc 	str.w	r3, [r7, #204]	; 0xcc
  return(result);
 800a374:	f8d7 30cc 	ldr.w	r3, [r7, #204]	; 0xcc
 800a378:	63fb      	str	r3, [r7, #60]	; 0x3c
    keyaddr+=4;
 800a37a:	f8d7 3100 	ldr.w	r3, [r7, #256]	; 0x100
 800a37e:	3304      	adds	r3, #4
 800a380:	f8c7 3100 	str.w	r3, [r7, #256]	; 0x100
    AES_CRYP_KeyInitStructure.CRYP_Key3Right= __REV(*(uint32_t*)(keyaddr));
 800a384:	f8d7 3100 	ldr.w	r3, [r7, #256]	; 0x100
 800a388:	681b      	ldr	r3, [r3, #0]
 800a38a:	f8c7 30d8 	str.w	r3, [r7, #216]	; 0xd8
  __ASM volatile ("rev %0, %1" : "=r" (result) : "r" (value) );
 800a38e:	f8d7 30d8 	ldr.w	r3, [r7, #216]	; 0xd8
 800a392:	ba1b      	rev	r3, r3
 800a394:	f8c7 30d4 	str.w	r3, [r7, #212]	; 0xd4
  return(result);
 800a398:	f8d7 30d4 	ldr.w	r3, [r7, #212]	; 0xd4
 800a39c:	643b      	str	r3, [r7, #64]	; 0x40
    break;
 800a39e:	e085      	b.n	800a4ac <CRYP_AES_CBC+0x2f4>
    AES_CRYP_InitStructure.CRYP_KeySize  = CRYP_KeySize_256b;
 800a3a0:	f44f 7300 	mov.w	r3, #512	; 0x200
 800a3a4:	f8a7 304a 	strh.w	r3, [r7, #74]	; 0x4a
    AES_CRYP_KeyInitStructure.CRYP_Key0Left = __REV(*(uint32_t*)(keyaddr));
 800a3a8:	f8d7 3100 	ldr.w	r3, [r7, #256]	; 0x100
 800a3ac:	681b      	ldr	r3, [r3, #0]
 800a3ae:	673b      	str	r3, [r7, #112]	; 0x70
  __ASM volatile ("rev %0, %1" : "=r" (result) : "r" (value) );
 800a3b0:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 800a3b2:	ba1b      	rev	r3, r3
 800a3b4:	66fb      	str	r3, [r7, #108]	; 0x6c
  return(result);
 800a3b6:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 800a3b8:	627b      	str	r3, [r7, #36]	; 0x24
    keyaddr+=4;
 800a3ba:	f8d7 3100 	ldr.w	r3, [r7, #256]	; 0x100
 800a3be:	3304      	adds	r3, #4
 800a3c0:	f8c7 3100 	str.w	r3, [r7, #256]	; 0x100
    AES_CRYP_KeyInitStructure.CRYP_Key0Right= __REV(*(uint32_t*)(keyaddr));
 800a3c4:	f8d7 3100 	ldr.w	r3, [r7, #256]	; 0x100
 800a3c8:	681b      	ldr	r3, [r3, #0]
 800a3ca:	67bb      	str	r3, [r7, #120]	; 0x78
  __ASM volatile ("rev %0, %1" : "=r" (result) : "r" (value) );
 800a3cc:	6fbb      	ldr	r3, [r7, #120]	; 0x78
 800a3ce:	ba1b      	rev	r3, r3
 800a3d0:	677b      	str	r3, [r7, #116]	; 0x74
  return(result);
 800a3d2:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 800a3d4:	62bb      	str	r3, [r7, #40]	; 0x28
    keyaddr+=4;
 800a3d6:	f8d7 3100 	ldr.w	r3, [r7, #256]	; 0x100
 800a3da:	3304      	adds	r3, #4
 800a3dc:	f8c7 3100 	str.w	r3, [r7, #256]	; 0x100
    AES_CRYP_KeyInitStructure.CRYP_Key1Left = __REV(*(uint32_t*)(keyaddr));
 800a3e0:	f8d7 3100 	ldr.w	r3, [r7, #256]	; 0x100
 800a3e4:	681b      	ldr	r3, [r3, #0]
 800a3e6:	f8c7 3080 	str.w	r3, [r7, #128]	; 0x80
  __ASM volatile ("rev %0, %1" : "=r" (result) : "r" (value) );
 800a3ea:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
 800a3ee:	ba1b      	rev	r3, r3
 800a3f0:	67fb      	str	r3, [r7, #124]	; 0x7c
  return(result);
 800a3f2:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
 800a3f4:	62fb      	str	r3, [r7, #44]	; 0x2c
    keyaddr+=4;
 800a3f6:	f8d7 3100 	ldr.w	r3, [r7, #256]	; 0x100
 800a3fa:	3304      	adds	r3, #4
 800a3fc:	f8c7 3100 	str.w	r3, [r7, #256]	; 0x100
    AES_CRYP_KeyInitStructure.CRYP_Key1Right= __REV(*(uint32_t*)(keyaddr));
 800a400:	f8d7 3100 	ldr.w	r3, [r7, #256]	; 0x100
 800a404:	681b      	ldr	r3, [r3, #0]
 800a406:	f8c7 3088 	str.w	r3, [r7, #136]	; 0x88
  __ASM volatile ("rev %0, %1" : "=r" (result) : "r" (value) );
 800a40a:	f8d7 3088 	ldr.w	r3, [r7, #136]	; 0x88
 800a40e:	ba1b      	rev	r3, r3
 800a410:	f8c7 3084 	str.w	r3, [r7, #132]	; 0x84
  return(result);
 800a414:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
 800a418:	633b      	str	r3, [r7, #48]	; 0x30
    keyaddr+=4;
 800a41a:	f8d7 3100 	ldr.w	r3, [r7, #256]	; 0x100
 800a41e:	3304      	adds	r3, #4
 800a420:	f8c7 3100 	str.w	r3, [r7, #256]	; 0x100
    AES_CRYP_KeyInitStructure.CRYP_Key2Left = __REV(*(uint32_t*)(keyaddr));
 800a424:	f8d7 3100 	ldr.w	r3, [r7, #256]	; 0x100
 800a428:	681b      	ldr	r3, [r3, #0]
 800a42a:	f8c7 3090 	str.w	r3, [r7, #144]	; 0x90
  __ASM volatile ("rev %0, %1" : "=r" (result) : "r" (value) );
 800a42e:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
 800a432:	ba1b      	rev	r3, r3
 800a434:	f8c7 308c 	str.w	r3, [r7, #140]	; 0x8c
  return(result);
 800a438:	f8d7 308c 	ldr.w	r3, [r7, #140]	; 0x8c
 800a43c:	637b      	str	r3, [r7, #52]	; 0x34
    keyaddr+=4;
 800a43e:	f8d7 3100 	ldr.w	r3, [r7, #256]	; 0x100
 800a442:	3304      	adds	r3, #4
 800a444:	f8c7 3100 	str.w	r3, [r7, #256]	; 0x100
    AES_CRYP_KeyInitStructure.CRYP_Key2Right= __REV(*(uint32_t*)(keyaddr));
 800a448:	f8d7 3100 	ldr.w	r3, [r7, #256]	; 0x100
 800a44c:	681b      	ldr	r3, [r3, #0]
 800a44e:	f8c7 3098 	str.w	r3, [r7, #152]	; 0x98
  __ASM volatile ("rev %0, %1" : "=r" (result) : "r" (value) );
 800a452:	f8d7 3098 	ldr.w	r3, [r7, #152]	; 0x98
 800a456:	ba1b      	rev	r3, r3
 800a458:	f8c7 3094 	str.w	r3, [r7, #148]	; 0x94
  return(result);
 800a45c:	f8d7 3094 	ldr.w	r3, [r7, #148]	; 0x94
 800a460:	63bb      	str	r3, [r7, #56]	; 0x38
    keyaddr+=4;
 800a462:	f8d7 3100 	ldr.w	r3, [r7, #256]	; 0x100
 800a466:	3304      	adds	r3, #4
 800a468:	f8c7 3100 	str.w	r3, [r7, #256]	; 0x100
    AES_CRYP_KeyInitStructure.CRYP_Key3Left = __REV(*(uint32_t*)(keyaddr));
 800a46c:	f8d7 3100 	ldr.w	r3, [r7, #256]	; 0x100
 800a470:	681b      	ldr	r3, [r3, #0]
 800a472:	f8c7 30a0 	str.w	r3, [r7, #160]	; 0xa0
  __ASM volatile ("rev %0, %1" : "=r" (result) : "r" (value) );
 800a476:	f8d7 30a0 	ldr.w	r3, [r7, #160]	; 0xa0
 800a47a:	ba1b      	rev	r3, r3
 800a47c:	f8c7 309c 	str.w	r3, [r7, #156]	; 0x9c
  return(result);
 800a480:	f8d7 309c 	ldr.w	r3, [r7, #156]	; 0x9c
 800a484:	63fb      	str	r3, [r7, #60]	; 0x3c
    keyaddr+=4;
 800a486:	f8d7 3100 	ldr.w	r3, [r7, #256]	; 0x100
 800a48a:	3304      	adds	r3, #4
 800a48c:	f8c7 3100 	str.w	r3, [r7, #256]	; 0x100
    AES_CRYP_KeyInitStructure.CRYP_Key3Right= __REV(*(uint32_t*)(keyaddr));
 800a490:	f8d7 3100 	ldr.w	r3, [r7, #256]	; 0x100
 800a494:	681b      	ldr	r3, [r3, #0]
 800a496:	f8c7 30a8 	str.w	r3, [r7, #168]	; 0xa8
  __ASM volatile ("rev %0, %1" : "=r" (result) : "r" (value) );
 800a49a:	f8d7 30a8 	ldr.w	r3, [r7, #168]	; 0xa8
 800a49e:	ba1b      	rev	r3, r3
 800a4a0:	f8c7 30a4 	str.w	r3, [r7, #164]	; 0xa4
  return(result);
 800a4a4:	f8d7 30a4 	ldr.w	r3, [r7, #164]	; 0xa4
 800a4a8:	643b      	str	r3, [r7, #64]	; 0x40
    break;
 800a4aa:	bf00      	nop
  }

  /* CRYP Initialization Vectors */
  AES_CRYP_IVInitStructure.CRYP_IV0Left = __REV(*(uint32_t*)(ivaddr));
 800a4ac:	f8d7 30fc 	ldr.w	r3, [r7, #252]	; 0xfc
 800a4b0:	681b      	ldr	r3, [r3, #0]
 800a4b2:	653b      	str	r3, [r7, #80]	; 0x50
  __ASM volatile ("rev %0, %1" : "=r" (result) : "r" (value) );
 800a4b4:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 800a4b6:	ba1b      	rev	r3, r3
 800a4b8:	64fb      	str	r3, [r7, #76]	; 0x4c
  return(result);
 800a4ba:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
 800a4bc:	f107 0314 	add.w	r3, r7, #20
 800a4c0:	601a      	str	r2, [r3, #0]
  ivaddr+=4;
 800a4c2:	f8d7 30fc 	ldr.w	r3, [r7, #252]	; 0xfc
 800a4c6:	3304      	adds	r3, #4
 800a4c8:	f8c7 30fc 	str.w	r3, [r7, #252]	; 0xfc
  AES_CRYP_IVInitStructure.CRYP_IV0Right= __REV(*(uint32_t*)(ivaddr));
 800a4cc:	f8d7 30fc 	ldr.w	r3, [r7, #252]	; 0xfc
 800a4d0:	681b      	ldr	r3, [r3, #0]
 800a4d2:	65bb      	str	r3, [r7, #88]	; 0x58
  __ASM volatile ("rev %0, %1" : "=r" (result) : "r" (value) );
 800a4d4:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 800a4d6:	ba1b      	rev	r3, r3
 800a4d8:	657b      	str	r3, [r7, #84]	; 0x54
  return(result);
 800a4da:	6d7a      	ldr	r2, [r7, #84]	; 0x54
 800a4dc:	f107 0314 	add.w	r3, r7, #20
 800a4e0:	605a      	str	r2, [r3, #4]
  ivaddr+=4;
 800a4e2:	f8d7 30fc 	ldr.w	r3, [r7, #252]	; 0xfc
 800a4e6:	3304      	adds	r3, #4
 800a4e8:	f8c7 30fc 	str.w	r3, [r7, #252]	; 0xfc
  AES_CRYP_IVInitStructure.CRYP_IV1Left = __REV(*(uint32_t*)(ivaddr));
 800a4ec:	f8d7 30fc 	ldr.w	r3, [r7, #252]	; 0xfc
 800a4f0:	681b      	ldr	r3, [r3, #0]
 800a4f2:	663b      	str	r3, [r7, #96]	; 0x60
  __ASM volatile ("rev %0, %1" : "=r" (result) : "r" (value) );
 800a4f4:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 800a4f6:	ba1b      	rev	r3, r3
 800a4f8:	65fb      	str	r3, [r7, #92]	; 0x5c
  return(result);
 800a4fa:	6dfa      	ldr	r2, [r7, #92]	; 0x5c
 800a4fc:	f107 0314 	add.w	r3, r7, #20
 800a500:	609a      	str	r2, [r3, #8]
  ivaddr+=4;
 800a502:	f8d7 30fc 	ldr.w	r3, [r7, #252]	; 0xfc
 800a506:	3304      	adds	r3, #4
 800a508:	f8c7 30fc 	str.w	r3, [r7, #252]	; 0xfc
  AES_CRYP_IVInitStructure.CRYP_IV1Right= __REV(*(uint32_t*)(ivaddr));
 800a50c:	f8d7 30fc 	ldr.w	r3, [r7, #252]	; 0xfc
 800a510:	681b      	ldr	r3, [r3, #0]
 800a512:	66bb      	str	r3, [r7, #104]	; 0x68
  __ASM volatile ("rev %0, %1" : "=r" (result) : "r" (value) );
 800a514:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 800a516:	ba1b      	rev	r3, r3
 800a518:	667b      	str	r3, [r7, #100]	; 0x64
  return(result);
 800a51a:	6e7a      	ldr	r2, [r7, #100]	; 0x64
 800a51c:	f107 0314 	add.w	r3, r7, #20
 800a520:	60da      	str	r2, [r3, #12]


  /*------------------ AES Decryption ------------------*/
  if(Mode == MODE_DECRYPT) /* AES decryption */
 800a522:	f107 030f 	add.w	r3, r7, #15
 800a526:	781b      	ldrb	r3, [r3, #0]
 800a528:	2b00      	cmp	r3, #0
 800a52a:	d13a      	bne.n	800a5a2 <CRYP_AES_CBC+0x3ea>
  {
    /* Flush IN/OUT FIFOs */
    CRYP_FIFOFlush();
 800a52c:	f7ff fa84 	bl	8009a38 <CRYP_FIFOFlush>

    /* Crypto Init for Key preparation for decryption process */
    AES_CRYP_InitStructure.CRYP_AlgoDir = CRYP_AlgoDir_Decrypt;
 800a530:	2304      	movs	r3, #4
 800a532:	f8a7 3044 	strh.w	r3, [r7, #68]	; 0x44
    AES_CRYP_InitStructure.CRYP_AlgoMode = CRYP_AlgoMode_AES_Key;
 800a536:	2338      	movs	r3, #56	; 0x38
 800a538:	f8a7 3046 	strh.w	r3, [r7, #70]	; 0x46
    AES_CRYP_InitStructure.CRYP_DataType = CRYP_DataType_32b;
 800a53c:	2300      	movs	r3, #0
 800a53e:	f8a7 3048 	strh.w	r3, [r7, #72]	; 0x48

    CRYP_Init(&AES_CRYP_InitStructure);
 800a542:	f107 0344 	add.w	r3, r7, #68	; 0x44
 800a546:	4618      	mov	r0, r3
 800a548:	f7ff f990 	bl	800986c <CRYP_Init>

    /* Key Initialisation */
    CRYP_KeyInit(&AES_CRYP_KeyInitStructure);
 800a54c:	f107 0324 	add.w	r3, r7, #36	; 0x24
 800a550:	4618      	mov	r0, r3
 800a552:	f7ff f9f1 	bl	8009938 <CRYP_KeyInit>

    /* Enable Crypto processor */
    CRYP_Cmd(ENABLE);
 800a556:	2001      	movs	r0, #1
 800a558:	f7ff fa7e 	bl	8009a58 <CRYP_Cmd>

    /* wait until the Busy flag is RESET */
    do
    {
      busystatus = CRYP_GetFlagStatus(CRYP_FLAG_BUSY);
 800a55c:	2010      	movs	r0, #16
 800a55e:	f7ff fbdd 	bl	8009d1c <CRYP_GetFlagStatus>
 800a562:	4603      	mov	r3, r0
 800a564:	f8c7 3104 	str.w	r3, [r7, #260]	; 0x104
      counter++;
 800a568:	f107 0310 	add.w	r3, r7, #16
 800a56c:	681b      	ldr	r3, [r3, #0]
 800a56e:	1c5a      	adds	r2, r3, #1
 800a570:	f107 0310 	add.w	r3, r7, #16
 800a574:	601a      	str	r2, [r3, #0]
    }while ((counter != AESBUSY_TIMEOUT) && (busystatus != RESET));
 800a576:	f107 0310 	add.w	r3, r7, #16
 800a57a:	681b      	ldr	r3, [r3, #0]
 800a57c:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 800a580:	d003      	beq.n	800a58a <CRYP_AES_CBC+0x3d2>
 800a582:	f8d7 3104 	ldr.w	r3, [r7, #260]	; 0x104
 800a586:	2b00      	cmp	r3, #0
 800a588:	d1e8      	bne.n	800a55c <CRYP_AES_CBC+0x3a4>

    if (busystatus != RESET)
 800a58a:	f8d7 3104 	ldr.w	r3, [r7, #260]	; 0x104
 800a58e:	2b00      	cmp	r3, #0
 800a590:	d003      	beq.n	800a59a <CRYP_AES_CBC+0x3e2>
   {
       status = ERROR;
 800a592:	2300      	movs	r3, #0
 800a594:	f887 3117 	strb.w	r3, [r7, #279]	; 0x117
 800a598:	e00b      	b.n	800a5b2 <CRYP_AES_CBC+0x3fa>
    }
    else
    {
      /* Crypto Init for decryption process */  
      AES_CRYP_InitStructure.CRYP_AlgoDir = CRYP_AlgoDir_Decrypt;
 800a59a:	2304      	movs	r3, #4
 800a59c:	f8a7 3044 	strh.w	r3, [r7, #68]	; 0x44
 800a5a0:	e007      	b.n	800a5b2 <CRYP_AES_CBC+0x3fa>
    }
  }
  /*------------------ AES Encryption ------------------*/
  else /* AES encryption */
  {
    CRYP_KeyInit(&AES_CRYP_KeyInitStructure);
 800a5a2:	f107 0324 	add.w	r3, r7, #36	; 0x24
 800a5a6:	4618      	mov	r0, r3
 800a5a8:	f7ff f9c6 	bl	8009938 <CRYP_KeyInit>

    /* Crypto Init for Encryption process */
    AES_CRYP_InitStructure.CRYP_AlgoDir  = CRYP_AlgoDir_Encrypt;
 800a5ac:	2300      	movs	r3, #0
 800a5ae:	f8a7 3044 	strh.w	r3, [r7, #68]	; 0x44
  }
  AES_CRYP_InitStructure.CRYP_AlgoMode = CRYP_AlgoMode_AES_CBC;
 800a5b2:	2328      	movs	r3, #40	; 0x28
 800a5b4:	f8a7 3046 	strh.w	r3, [r7, #70]	; 0x46
  AES_CRYP_InitStructure.CRYP_DataType = CRYP_DataType_8b;
 800a5b8:	2380      	movs	r3, #128	; 0x80
 800a5ba:	f8a7 3048 	strh.w	r3, [r7, #72]	; 0x48
  CRYP_Init(&AES_CRYP_InitStructure);
 800a5be:	f107 0344 	add.w	r3, r7, #68	; 0x44
 800a5c2:	4618      	mov	r0, r3
 800a5c4:	f7ff f952 	bl	800986c <CRYP_Init>

  /* CRYP Initialization Vectors */
  CRYP_IVInit(&AES_CRYP_IVInitStructure);
 800a5c8:	f107 0314 	add.w	r3, r7, #20
 800a5cc:	4618      	mov	r0, r3
 800a5ce:	f7ff fa01 	bl	80099d4 <CRYP_IVInit>

  /* Flush IN/OUT FIFOs */
  CRYP_FIFOFlush();
 800a5d2:	f7ff fa31 	bl	8009a38 <CRYP_FIFOFlush>

  /* Enable Crypto processor */
  CRYP_Cmd(ENABLE);
 800a5d6:	2001      	movs	r0, #1
 800a5d8:	f7ff fa3e 	bl	8009a58 <CRYP_Cmd>


  for(i=0; ((i<Ilength) && (status != ERROR)); i+=16)
 800a5dc:	2300      	movs	r3, #0
 800a5de:	f8c7 3108 	str.w	r3, [r7, #264]	; 0x108
 800a5e2:	e07f      	b.n	800a6e4 <CRYP_AES_CBC+0x52c>
  {

    /* Write the Input block in the IN FIFO */
    CRYP_DataIn(*(uint32_t*)(inputaddr));
 800a5e4:	f8d7 3110 	ldr.w	r3, [r7, #272]	; 0x110
 800a5e8:	681b      	ldr	r3, [r3, #0]
 800a5ea:	4618      	mov	r0, r3
 800a5ec:	f7ff fa52 	bl	8009a94 <CRYP_DataIn>
    inputaddr+=4;
 800a5f0:	f8d7 3110 	ldr.w	r3, [r7, #272]	; 0x110
 800a5f4:	3304      	adds	r3, #4
 800a5f6:	f8c7 3110 	str.w	r3, [r7, #272]	; 0x110
    CRYP_DataIn(*(uint32_t*)(inputaddr));
 800a5fa:	f8d7 3110 	ldr.w	r3, [r7, #272]	; 0x110
 800a5fe:	681b      	ldr	r3, [r3, #0]
 800a600:	4618      	mov	r0, r3
 800a602:	f7ff fa47 	bl	8009a94 <CRYP_DataIn>
    inputaddr+=4;
 800a606:	f8d7 3110 	ldr.w	r3, [r7, #272]	; 0x110
 800a60a:	3304      	adds	r3, #4
 800a60c:	f8c7 3110 	str.w	r3, [r7, #272]	; 0x110
    CRYP_DataIn(*(uint32_t*)(inputaddr));
 800a610:	f8d7 3110 	ldr.w	r3, [r7, #272]	; 0x110
 800a614:	681b      	ldr	r3, [r3, #0]
 800a616:	4618      	mov	r0, r3
 800a618:	f7ff fa3c 	bl	8009a94 <CRYP_DataIn>
    inputaddr+=4;
 800a61c:	f8d7 3110 	ldr.w	r3, [r7, #272]	; 0x110
 800a620:	3304      	adds	r3, #4
 800a622:	f8c7 3110 	str.w	r3, [r7, #272]	; 0x110
    CRYP_DataIn(*(uint32_t*)(inputaddr));
 800a626:	f8d7 3110 	ldr.w	r3, [r7, #272]	; 0x110
 800a62a:	681b      	ldr	r3, [r3, #0]
 800a62c:	4618      	mov	r0, r3
 800a62e:	f7ff fa31 	bl	8009a94 <CRYP_DataIn>
    inputaddr+=4;
 800a632:	f8d7 3110 	ldr.w	r3, [r7, #272]	; 0x110
 800a636:	3304      	adds	r3, #4
 800a638:	f8c7 3110 	str.w	r3, [r7, #272]	; 0x110
    /* Wait until the complete message has been processed */
    counter = 0;
 800a63c:	f107 0310 	add.w	r3, r7, #16
 800a640:	2200      	movs	r2, #0
 800a642:	601a      	str	r2, [r3, #0]
    do
    {
      busystatus = CRYP_GetFlagStatus(CRYP_FLAG_BUSY);
 800a644:	2010      	movs	r0, #16
 800a646:	f7ff fb69 	bl	8009d1c <CRYP_GetFlagStatus>
 800a64a:	4603      	mov	r3, r0
 800a64c:	f8c7 3104 	str.w	r3, [r7, #260]	; 0x104
      counter++;
 800a650:	f107 0310 	add.w	r3, r7, #16
 800a654:	681b      	ldr	r3, [r3, #0]
 800a656:	1c5a      	adds	r2, r3, #1
 800a658:	f107 0310 	add.w	r3, r7, #16
 800a65c:	601a      	str	r2, [r3, #0]
    }while ((counter != AESBUSY_TIMEOUT) && (busystatus != RESET));
 800a65e:	f107 0310 	add.w	r3, r7, #16
 800a662:	681b      	ldr	r3, [r3, #0]
 800a664:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 800a668:	d003      	beq.n	800a672 <CRYP_AES_CBC+0x4ba>
 800a66a:	f8d7 3104 	ldr.w	r3, [r7, #260]	; 0x104
 800a66e:	2b00      	cmp	r3, #0
 800a670:	d1e8      	bne.n	800a644 <CRYP_AES_CBC+0x48c>

    if (busystatus != RESET)
 800a672:	f8d7 3104 	ldr.w	r3, [r7, #260]	; 0x104
 800a676:	2b00      	cmp	r3, #0
 800a678:	d003      	beq.n	800a682 <CRYP_AES_CBC+0x4ca>
   {
       status = ERROR;
 800a67a:	2300      	movs	r3, #0
 800a67c:	f887 3117 	strb.w	r3, [r7, #279]	; 0x117
 800a680:	e02b      	b.n	800a6da <CRYP_AES_CBC+0x522>
    }
    else
    {

      /* Read the Output block from the Output FIFO */
      *(uint32_t*)(outputaddr) = CRYP_DataOut();
 800a682:	f8d7 410c 	ldr.w	r4, [r7, #268]	; 0x10c
 800a686:	f7ff fa15 	bl	8009ab4 <CRYP_DataOut>
 800a68a:	4603      	mov	r3, r0
 800a68c:	6023      	str	r3, [r4, #0]
      outputaddr+=4;
 800a68e:	f8d7 310c 	ldr.w	r3, [r7, #268]	; 0x10c
 800a692:	3304      	adds	r3, #4
 800a694:	f8c7 310c 	str.w	r3, [r7, #268]	; 0x10c
      *(uint32_t*)(outputaddr) = CRYP_DataOut();
 800a698:	f8d7 410c 	ldr.w	r4, [r7, #268]	; 0x10c
 800a69c:	f7ff fa0a 	bl	8009ab4 <CRYP_DataOut>
 800a6a0:	4603      	mov	r3, r0
 800a6a2:	6023      	str	r3, [r4, #0]
      outputaddr+=4;
 800a6a4:	f8d7 310c 	ldr.w	r3, [r7, #268]	; 0x10c
 800a6a8:	3304      	adds	r3, #4
 800a6aa:	f8c7 310c 	str.w	r3, [r7, #268]	; 0x10c
      *(uint32_t*)(outputaddr) = CRYP_DataOut();
 800a6ae:	f8d7 410c 	ldr.w	r4, [r7, #268]	; 0x10c
 800a6b2:	f7ff f9ff 	bl	8009ab4 <CRYP_DataOut>
 800a6b6:	4603      	mov	r3, r0
 800a6b8:	6023      	str	r3, [r4, #0]
      outputaddr+=4;
 800a6ba:	f8d7 310c 	ldr.w	r3, [r7, #268]	; 0x10c
 800a6be:	3304      	adds	r3, #4
 800a6c0:	f8c7 310c 	str.w	r3, [r7, #268]	; 0x10c
      *(uint32_t*)(outputaddr) = CRYP_DataOut();
 800a6c4:	f8d7 410c 	ldr.w	r4, [r7, #268]	; 0x10c
 800a6c8:	f7ff f9f4 	bl	8009ab4 <CRYP_DataOut>
 800a6cc:	4603      	mov	r3, r0
 800a6ce:	6023      	str	r3, [r4, #0]
      outputaddr+=4;
 800a6d0:	f8d7 310c 	ldr.w	r3, [r7, #268]	; 0x10c
 800a6d4:	3304      	adds	r3, #4
 800a6d6:	f8c7 310c 	str.w	r3, [r7, #268]	; 0x10c
  for(i=0; ((i<Ilength) && (status != ERROR)); i+=16)
 800a6da:	f8d7 3108 	ldr.w	r3, [r7, #264]	; 0x108
 800a6de:	3310      	adds	r3, #16
 800a6e0:	f8c7 3108 	str.w	r3, [r7, #264]	; 0x108
 800a6e4:	f8d7 2108 	ldr.w	r2, [r7, #264]	; 0x108
 800a6e8:	f8d7 312c 	ldr.w	r3, [r7, #300]	; 0x12c
 800a6ec:	429a      	cmp	r2, r3
 800a6ee:	d204      	bcs.n	800a6fa <CRYP_AES_CBC+0x542>
 800a6f0:	f897 3117 	ldrb.w	r3, [r7, #279]	; 0x117
 800a6f4:	2b00      	cmp	r3, #0
 800a6f6:	f47f af75 	bne.w	800a5e4 <CRYP_AES_CBC+0x42c>
    }
  }

  /* Disable Crypto */
  CRYP_Cmd(DISABLE);
 800a6fa:	2000      	movs	r0, #0
 800a6fc:	f7ff f9ac 	bl	8009a58 <CRYP_Cmd>

  return status;
 800a700:	f897 3117 	ldrb.w	r3, [r7, #279]	; 0x117
}
 800a704:	4618      	mov	r0, r3
 800a706:	f507 778e 	add.w	r7, r7, #284	; 0x11c
 800a70a:	46bd      	mov	sp, r7
 800a70c:	bd90      	pop	{r4, r7, pc}

0800a70e <CRYP_AES_CTR>:
  *          - ERROR: Operation failed
  */
ErrorStatus CRYP_AES_CTR(uint8_t Mode, uint8_t InitVectors[16], uint8_t *Key, 
                         uint16_t Keysize, uint8_t *Input, uint32_t Ilength,
                         uint8_t *Output)
{
 800a70e:	b590      	push	{r4, r7, lr}
 800a710:	b0c7      	sub	sp, #284	; 0x11c
 800a712:	af00      	add	r7, sp, #0
 800a714:	4604      	mov	r4, r0
 800a716:	f107 0008 	add.w	r0, r7, #8
 800a71a:	6001      	str	r1, [r0, #0]
 800a71c:	1d39      	adds	r1, r7, #4
 800a71e:	600a      	str	r2, [r1, #0]
 800a720:	4619      	mov	r1, r3
 800a722:	f107 030f 	add.w	r3, r7, #15
 800a726:	4622      	mov	r2, r4
 800a728:	701a      	strb	r2, [r3, #0]
 800a72a:	f107 030c 	add.w	r3, r7, #12
 800a72e:	460a      	mov	r2, r1
 800a730:	801a      	strh	r2, [r3, #0]
  CRYP_InitTypeDef AES_CRYP_InitStructure;
  CRYP_KeyInitTypeDef AES_CRYP_KeyInitStructure;
  CRYP_IVInitTypeDef AES_CRYP_IVInitStructure;
  __IO uint32_t counter = 0;
 800a732:	f107 0310 	add.w	r3, r7, #16
 800a736:	2200      	movs	r2, #0
 800a738:	601a      	str	r2, [r3, #0]
  uint32_t busystatus = 0;
 800a73a:	2300      	movs	r3, #0
 800a73c:	f8c7 3104 	str.w	r3, [r7, #260]	; 0x104
  ErrorStatus status = SUCCESS;
 800a740:	2301      	movs	r3, #1
 800a742:	f887 3117 	strb.w	r3, [r7, #279]	; 0x117
  uint32_t keyaddr    = (uint32_t)Key;
 800a746:	1d3b      	adds	r3, r7, #4
 800a748:	681b      	ldr	r3, [r3, #0]
 800a74a:	f8c7 3100 	str.w	r3, [r7, #256]	; 0x100
  uint32_t inputaddr  = (uint32_t)Input;
 800a74e:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 800a752:	f8c7 3110 	str.w	r3, [r7, #272]	; 0x110
  uint32_t outputaddr = (uint32_t)Output;
 800a756:	f8d7 3130 	ldr.w	r3, [r7, #304]	; 0x130
 800a75a:	f8c7 310c 	str.w	r3, [r7, #268]	; 0x10c
  uint32_t ivaddr     = (uint32_t)InitVectors;
 800a75e:	f107 0308 	add.w	r3, r7, #8
 800a762:	681b      	ldr	r3, [r3, #0]
 800a764:	f8c7 30fc 	str.w	r3, [r7, #252]	; 0xfc
  uint32_t i = 0;
 800a768:	2300      	movs	r3, #0
 800a76a:	f8c7 3108 	str.w	r3, [r7, #264]	; 0x108

  /* Crypto structures initialisation*/
  CRYP_KeyStructInit(&AES_CRYP_KeyInitStructure);
 800a76e:	f107 0324 	add.w	r3, r7, #36	; 0x24
 800a772:	4618      	mov	r0, r3
 800a774:	f7ff f90c 	bl	8009990 <CRYP_KeyStructInit>

  switch(Keysize)
 800a778:	f107 030c 	add.w	r3, r7, #12
 800a77c:	881b      	ldrh	r3, [r3, #0]
 800a77e:	2bc0      	cmp	r3, #192	; 0xc0
 800a780:	d04d      	beq.n	800a81e <CRYP_AES_CTR+0x110>
 800a782:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 800a786:	f000 80b6 	beq.w	800a8f6 <CRYP_AES_CTR+0x1e8>
 800a78a:	2b80      	cmp	r3, #128	; 0x80
 800a78c:	d000      	beq.n	800a790 <CRYP_AES_CTR+0x82>
    AES_CRYP_KeyInitStructure.CRYP_Key3Left = __REV(*(uint32_t*)(keyaddr));
    keyaddr+=4;
    AES_CRYP_KeyInitStructure.CRYP_Key3Right= __REV(*(uint32_t*)(keyaddr));
    break;
    default:
    break;
 800a78e:	e138      	b.n	800aa02 <CRYP_AES_CTR+0x2f4>
    AES_CRYP_InitStructure.CRYP_KeySize = CRYP_KeySize_128b;
 800a790:	2300      	movs	r3, #0
 800a792:	f8a7 304a 	strh.w	r3, [r7, #74]	; 0x4a
    AES_CRYP_KeyInitStructure.CRYP_Key2Left = __REV(*(uint32_t*)(keyaddr));
 800a796:	f8d7 3100 	ldr.w	r3, [r7, #256]	; 0x100
 800a79a:	681b      	ldr	r3, [r3, #0]
 800a79c:	f8c7 30e0 	str.w	r3, [r7, #224]	; 0xe0
  __ASM volatile ("rev %0, %1" : "=r" (result) : "r" (value) );
 800a7a0:	f8d7 30e0 	ldr.w	r3, [r7, #224]	; 0xe0
 800a7a4:	ba1b      	rev	r3, r3
 800a7a6:	f8c7 30dc 	str.w	r3, [r7, #220]	; 0xdc
  return(result);
 800a7aa:	f8d7 30dc 	ldr.w	r3, [r7, #220]	; 0xdc
 800a7ae:	637b      	str	r3, [r7, #52]	; 0x34
    keyaddr+=4;
 800a7b0:	f8d7 3100 	ldr.w	r3, [r7, #256]	; 0x100
 800a7b4:	3304      	adds	r3, #4
 800a7b6:	f8c7 3100 	str.w	r3, [r7, #256]	; 0x100
    AES_CRYP_KeyInitStructure.CRYP_Key2Right= __REV(*(uint32_t*)(keyaddr));
 800a7ba:	f8d7 3100 	ldr.w	r3, [r7, #256]	; 0x100
 800a7be:	681b      	ldr	r3, [r3, #0]
 800a7c0:	f8c7 30e8 	str.w	r3, [r7, #232]	; 0xe8
  __ASM volatile ("rev %0, %1" : "=r" (result) : "r" (value) );
 800a7c4:	f8d7 30e8 	ldr.w	r3, [r7, #232]	; 0xe8
 800a7c8:	ba1b      	rev	r3, r3
 800a7ca:	f8c7 30e4 	str.w	r3, [r7, #228]	; 0xe4
  return(result);
 800a7ce:	f8d7 30e4 	ldr.w	r3, [r7, #228]	; 0xe4
 800a7d2:	63bb      	str	r3, [r7, #56]	; 0x38
    keyaddr+=4;
 800a7d4:	f8d7 3100 	ldr.w	r3, [r7, #256]	; 0x100
 800a7d8:	3304      	adds	r3, #4
 800a7da:	f8c7 3100 	str.w	r3, [r7, #256]	; 0x100
    AES_CRYP_KeyInitStructure.CRYP_Key3Left = __REV(*(uint32_t*)(keyaddr));
 800a7de:	f8d7 3100 	ldr.w	r3, [r7, #256]	; 0x100
 800a7e2:	681b      	ldr	r3, [r3, #0]
 800a7e4:	f8c7 30f0 	str.w	r3, [r7, #240]	; 0xf0
  __ASM volatile ("rev %0, %1" : "=r" (result) : "r" (value) );
 800a7e8:	f8d7 30f0 	ldr.w	r3, [r7, #240]	; 0xf0
 800a7ec:	ba1b      	rev	r3, r3
 800a7ee:	f8c7 30ec 	str.w	r3, [r7, #236]	; 0xec
  return(result);
 800a7f2:	f8d7 30ec 	ldr.w	r3, [r7, #236]	; 0xec
 800a7f6:	63fb      	str	r3, [r7, #60]	; 0x3c
    keyaddr+=4;
 800a7f8:	f8d7 3100 	ldr.w	r3, [r7, #256]	; 0x100
 800a7fc:	3304      	adds	r3, #4
 800a7fe:	f8c7 3100 	str.w	r3, [r7, #256]	; 0x100
    AES_CRYP_KeyInitStructure.CRYP_Key3Right= __REV(*(uint32_t*)(keyaddr));
 800a802:	f8d7 3100 	ldr.w	r3, [r7, #256]	; 0x100
 800a806:	681b      	ldr	r3, [r3, #0]
 800a808:	f8c7 30f8 	str.w	r3, [r7, #248]	; 0xf8
  __ASM volatile ("rev %0, %1" : "=r" (result) : "r" (value) );
 800a80c:	f8d7 30f8 	ldr.w	r3, [r7, #248]	; 0xf8
 800a810:	ba1b      	rev	r3, r3
 800a812:	f8c7 30f4 	str.w	r3, [r7, #244]	; 0xf4
  return(result);
 800a816:	f8d7 30f4 	ldr.w	r3, [r7, #244]	; 0xf4
 800a81a:	643b      	str	r3, [r7, #64]	; 0x40
    break;
 800a81c:	e0f1      	b.n	800aa02 <CRYP_AES_CTR+0x2f4>
    AES_CRYP_InitStructure.CRYP_KeySize  = CRYP_KeySize_192b;
 800a81e:	f44f 7380 	mov.w	r3, #256	; 0x100
 800a822:	f8a7 304a 	strh.w	r3, [r7, #74]	; 0x4a
    AES_CRYP_KeyInitStructure.CRYP_Key1Left = __REV(*(uint32_t*)(keyaddr));
 800a826:	f8d7 3100 	ldr.w	r3, [r7, #256]	; 0x100
 800a82a:	681b      	ldr	r3, [r3, #0]
 800a82c:	f8c7 30b0 	str.w	r3, [r7, #176]	; 0xb0
  __ASM volatile ("rev %0, %1" : "=r" (result) : "r" (value) );
 800a830:	f8d7 30b0 	ldr.w	r3, [r7, #176]	; 0xb0
 800a834:	ba1b      	rev	r3, r3
 800a836:	f8c7 30ac 	str.w	r3, [r7, #172]	; 0xac
  return(result);
 800a83a:	f8d7 30ac 	ldr.w	r3, [r7, #172]	; 0xac
 800a83e:	62fb      	str	r3, [r7, #44]	; 0x2c
    keyaddr+=4;
 800a840:	f8d7 3100 	ldr.w	r3, [r7, #256]	; 0x100
 800a844:	3304      	adds	r3, #4
 800a846:	f8c7 3100 	str.w	r3, [r7, #256]	; 0x100
    AES_CRYP_KeyInitStructure.CRYP_Key1Right= __REV(*(uint32_t*)(keyaddr));
 800a84a:	f8d7 3100 	ldr.w	r3, [r7, #256]	; 0x100
 800a84e:	681b      	ldr	r3, [r3, #0]
 800a850:	f8c7 30b8 	str.w	r3, [r7, #184]	; 0xb8
  __ASM volatile ("rev %0, %1" : "=r" (result) : "r" (value) );
 800a854:	f8d7 30b8 	ldr.w	r3, [r7, #184]	; 0xb8
 800a858:	ba1b      	rev	r3, r3
 800a85a:	f8c7 30b4 	str.w	r3, [r7, #180]	; 0xb4
  return(result);
 800a85e:	f8d7 30b4 	ldr.w	r3, [r7, #180]	; 0xb4
 800a862:	633b      	str	r3, [r7, #48]	; 0x30
    keyaddr+=4;
 800a864:	f8d7 3100 	ldr.w	r3, [r7, #256]	; 0x100
 800a868:	3304      	adds	r3, #4
 800a86a:	f8c7 3100 	str.w	r3, [r7, #256]	; 0x100
    AES_CRYP_KeyInitStructure.CRYP_Key2Left = __REV(*(uint32_t*)(keyaddr));
 800a86e:	f8d7 3100 	ldr.w	r3, [r7, #256]	; 0x100
 800a872:	681b      	ldr	r3, [r3, #0]
 800a874:	f8c7 30c0 	str.w	r3, [r7, #192]	; 0xc0
  __ASM volatile ("rev %0, %1" : "=r" (result) : "r" (value) );
 800a878:	f8d7 30c0 	ldr.w	r3, [r7, #192]	; 0xc0
 800a87c:	ba1b      	rev	r3, r3
 800a87e:	f8c7 30bc 	str.w	r3, [r7, #188]	; 0xbc
  return(result);
 800a882:	f8d7 30bc 	ldr.w	r3, [r7, #188]	; 0xbc
 800a886:	637b      	str	r3, [r7, #52]	; 0x34
    keyaddr+=4;
 800a888:	f8d7 3100 	ldr.w	r3, [r7, #256]	; 0x100
 800a88c:	3304      	adds	r3, #4
 800a88e:	f8c7 3100 	str.w	r3, [r7, #256]	; 0x100
    AES_CRYP_KeyInitStructure.CRYP_Key2Right= __REV(*(uint32_t*)(keyaddr));
 800a892:	f8d7 3100 	ldr.w	r3, [r7, #256]	; 0x100
 800a896:	681b      	ldr	r3, [r3, #0]
 800a898:	f8c7 30c8 	str.w	r3, [r7, #200]	; 0xc8
  __ASM volatile ("rev %0, %1" : "=r" (result) : "r" (value) );
 800a89c:	f8d7 30c8 	ldr.w	r3, [r7, #200]	; 0xc8
 800a8a0:	ba1b      	rev	r3, r3
 800a8a2:	f8c7 30c4 	str.w	r3, [r7, #196]	; 0xc4
  return(result);
 800a8a6:	f8d7 30c4 	ldr.w	r3, [r7, #196]	; 0xc4
 800a8aa:	63bb      	str	r3, [r7, #56]	; 0x38
    keyaddr+=4;
 800a8ac:	f8d7 3100 	ldr.w	r3, [r7, #256]	; 0x100
 800a8b0:	3304      	adds	r3, #4
 800a8b2:	f8c7 3100 	str.w	r3, [r7, #256]	; 0x100
    AES_CRYP_KeyInitStructure.CRYP_Key3Left = __REV(*(uint32_t*)(keyaddr));
 800a8b6:	f8d7 3100 	ldr.w	r3, [r7, #256]	; 0x100
 800a8ba:	681b      	ldr	r3, [r3, #0]
 800a8bc:	f8c7 30d0 	str.w	r3, [r7, #208]	; 0xd0
  __ASM volatile ("rev %0, %1" : "=r" (result) : "r" (value) );
 800a8c0:	f8d7 30d0 	ldr.w	r3, [r7, #208]	; 0xd0
 800a8c4:	ba1b      	rev	r3, r3
 800a8c6:	f8c7 30cc 	str.w	r3, [r7, #204]	; 0xcc
  return(result);
 800a8ca:	f8d7 30cc 	ldr.w	r3, [r7, #204]	; 0xcc
 800a8ce:	63fb      	str	r3, [r7, #60]	; 0x3c
    keyaddr+=4;
 800a8d0:	f8d7 3100 	ldr.w	r3, [r7, #256]	; 0x100
 800a8d4:	3304      	adds	r3, #4
 800a8d6:	f8c7 3100 	str.w	r3, [r7, #256]	; 0x100
    AES_CRYP_KeyInitStructure.CRYP_Key3Right= __REV(*(uint32_t*)(keyaddr));
 800a8da:	f8d7 3100 	ldr.w	r3, [r7, #256]	; 0x100
 800a8de:	681b      	ldr	r3, [r3, #0]
 800a8e0:	f8c7 30d8 	str.w	r3, [r7, #216]	; 0xd8
  __ASM volatile ("rev %0, %1" : "=r" (result) : "r" (value) );
 800a8e4:	f8d7 30d8 	ldr.w	r3, [r7, #216]	; 0xd8
 800a8e8:	ba1b      	rev	r3, r3
 800a8ea:	f8c7 30d4 	str.w	r3, [r7, #212]	; 0xd4
  return(result);
 800a8ee:	f8d7 30d4 	ldr.w	r3, [r7, #212]	; 0xd4
 800a8f2:	643b      	str	r3, [r7, #64]	; 0x40
    break;
 800a8f4:	e085      	b.n	800aa02 <CRYP_AES_CTR+0x2f4>
    AES_CRYP_InitStructure.CRYP_KeySize  = CRYP_KeySize_256b;
 800a8f6:	f44f 7300 	mov.w	r3, #512	; 0x200
 800a8fa:	f8a7 304a 	strh.w	r3, [r7, #74]	; 0x4a
    AES_CRYP_KeyInitStructure.CRYP_Key0Left = __REV(*(uint32_t*)(keyaddr));
 800a8fe:	f8d7 3100 	ldr.w	r3, [r7, #256]	; 0x100
 800a902:	681b      	ldr	r3, [r3, #0]
 800a904:	673b      	str	r3, [r7, #112]	; 0x70
  __ASM volatile ("rev %0, %1" : "=r" (result) : "r" (value) );
 800a906:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 800a908:	ba1b      	rev	r3, r3
 800a90a:	66fb      	str	r3, [r7, #108]	; 0x6c
  return(result);
 800a90c:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 800a90e:	627b      	str	r3, [r7, #36]	; 0x24
    keyaddr+=4;
 800a910:	f8d7 3100 	ldr.w	r3, [r7, #256]	; 0x100
 800a914:	3304      	adds	r3, #4
 800a916:	f8c7 3100 	str.w	r3, [r7, #256]	; 0x100
    AES_CRYP_KeyInitStructure.CRYP_Key0Right= __REV(*(uint32_t*)(keyaddr));
 800a91a:	f8d7 3100 	ldr.w	r3, [r7, #256]	; 0x100
 800a91e:	681b      	ldr	r3, [r3, #0]
 800a920:	67bb      	str	r3, [r7, #120]	; 0x78
  __ASM volatile ("rev %0, %1" : "=r" (result) : "r" (value) );
 800a922:	6fbb      	ldr	r3, [r7, #120]	; 0x78
 800a924:	ba1b      	rev	r3, r3
 800a926:	677b      	str	r3, [r7, #116]	; 0x74
  return(result);
 800a928:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 800a92a:	62bb      	str	r3, [r7, #40]	; 0x28
    keyaddr+=4;
 800a92c:	f8d7 3100 	ldr.w	r3, [r7, #256]	; 0x100
 800a930:	3304      	adds	r3, #4
 800a932:	f8c7 3100 	str.w	r3, [r7, #256]	; 0x100
    AES_CRYP_KeyInitStructure.CRYP_Key1Left = __REV(*(uint32_t*)(keyaddr));
 800a936:	f8d7 3100 	ldr.w	r3, [r7, #256]	; 0x100
 800a93a:	681b      	ldr	r3, [r3, #0]
 800a93c:	f8c7 3080 	str.w	r3, [r7, #128]	; 0x80
  __ASM volatile ("rev %0, %1" : "=r" (result) : "r" (value) );
 800a940:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
 800a944:	ba1b      	rev	r3, r3
 800a946:	67fb      	str	r3, [r7, #124]	; 0x7c
  return(result);
 800a948:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
 800a94a:	62fb      	str	r3, [r7, #44]	; 0x2c
    keyaddr+=4;
 800a94c:	f8d7 3100 	ldr.w	r3, [r7, #256]	; 0x100
 800a950:	3304      	adds	r3, #4
 800a952:	f8c7 3100 	str.w	r3, [r7, #256]	; 0x100
    AES_CRYP_KeyInitStructure.CRYP_Key1Right= __REV(*(uint32_t*)(keyaddr));
 800a956:	f8d7 3100 	ldr.w	r3, [r7, #256]	; 0x100
 800a95a:	681b      	ldr	r3, [r3, #0]
 800a95c:	f8c7 3088 	str.w	r3, [r7, #136]	; 0x88
  __ASM volatile ("rev %0, %1" : "=r" (result) : "r" (value) );
 800a960:	f8d7 3088 	ldr.w	r3, [r7, #136]	; 0x88
 800a964:	ba1b      	rev	r3, r3
 800a966:	f8c7 3084 	str.w	r3, [r7, #132]	; 0x84
  return(result);
 800a96a:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
 800a96e:	633b      	str	r3, [r7, #48]	; 0x30
    keyaddr+=4;
 800a970:	f8d7 3100 	ldr.w	r3, [r7, #256]	; 0x100
 800a974:	3304      	adds	r3, #4
 800a976:	f8c7 3100 	str.w	r3, [r7, #256]	; 0x100
    AES_CRYP_KeyInitStructure.CRYP_Key2Left = __REV(*(uint32_t*)(keyaddr));
 800a97a:	f8d7 3100 	ldr.w	r3, [r7, #256]	; 0x100
 800a97e:	681b      	ldr	r3, [r3, #0]
 800a980:	f8c7 3090 	str.w	r3, [r7, #144]	; 0x90
  __ASM volatile ("rev %0, %1" : "=r" (result) : "r" (value) );
 800a984:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
 800a988:	ba1b      	rev	r3, r3
 800a98a:	f8c7 308c 	str.w	r3, [r7, #140]	; 0x8c
  return(result);
 800a98e:	f8d7 308c 	ldr.w	r3, [r7, #140]	; 0x8c
 800a992:	637b      	str	r3, [r7, #52]	; 0x34
    keyaddr+=4;
 800a994:	f8d7 3100 	ldr.w	r3, [r7, #256]	; 0x100
 800a998:	3304      	adds	r3, #4
 800a99a:	f8c7 3100 	str.w	r3, [r7, #256]	; 0x100
    AES_CRYP_KeyInitStructure.CRYP_Key2Right= __REV(*(uint32_t*)(keyaddr));
 800a99e:	f8d7 3100 	ldr.w	r3, [r7, #256]	; 0x100
 800a9a2:	681b      	ldr	r3, [r3, #0]
 800a9a4:	f8c7 3098 	str.w	r3, [r7, #152]	; 0x98
  __ASM volatile ("rev %0, %1" : "=r" (result) : "r" (value) );
 800a9a8:	f8d7 3098 	ldr.w	r3, [r7, #152]	; 0x98
 800a9ac:	ba1b      	rev	r3, r3
 800a9ae:	f8c7 3094 	str.w	r3, [r7, #148]	; 0x94
  return(result);
 800a9b2:	f8d7 3094 	ldr.w	r3, [r7, #148]	; 0x94
 800a9b6:	63bb      	str	r3, [r7, #56]	; 0x38
    keyaddr+=4;
 800a9b8:	f8d7 3100 	ldr.w	r3, [r7, #256]	; 0x100
 800a9bc:	3304      	adds	r3, #4
 800a9be:	f8c7 3100 	str.w	r3, [r7, #256]	; 0x100
    AES_CRYP_KeyInitStructure.CRYP_Key3Left = __REV(*(uint32_t*)(keyaddr));
 800a9c2:	f8d7 3100 	ldr.w	r3, [r7, #256]	; 0x100
 800a9c6:	681b      	ldr	r3, [r3, #0]
 800a9c8:	f8c7 30a0 	str.w	r3, [r7, #160]	; 0xa0
  __ASM volatile ("rev %0, %1" : "=r" (result) : "r" (value) );
 800a9cc:	f8d7 30a0 	ldr.w	r3, [r7, #160]	; 0xa0
 800a9d0:	ba1b      	rev	r3, r3
 800a9d2:	f8c7 309c 	str.w	r3, [r7, #156]	; 0x9c
  return(result);
 800a9d6:	f8d7 309c 	ldr.w	r3, [r7, #156]	; 0x9c
 800a9da:	63fb      	str	r3, [r7, #60]	; 0x3c
    keyaddr+=4;
 800a9dc:	f8d7 3100 	ldr.w	r3, [r7, #256]	; 0x100
 800a9e0:	3304      	adds	r3, #4
 800a9e2:	f8c7 3100 	str.w	r3, [r7, #256]	; 0x100
    AES_CRYP_KeyInitStructure.CRYP_Key3Right= __REV(*(uint32_t*)(keyaddr));
 800a9e6:	f8d7 3100 	ldr.w	r3, [r7, #256]	; 0x100
 800a9ea:	681b      	ldr	r3, [r3, #0]
 800a9ec:	f8c7 30a8 	str.w	r3, [r7, #168]	; 0xa8
  __ASM volatile ("rev %0, %1" : "=r" (result) : "r" (value) );
 800a9f0:	f8d7 30a8 	ldr.w	r3, [r7, #168]	; 0xa8
 800a9f4:	ba1b      	rev	r3, r3
 800a9f6:	f8c7 30a4 	str.w	r3, [r7, #164]	; 0xa4
  return(result);
 800a9fa:	f8d7 30a4 	ldr.w	r3, [r7, #164]	; 0xa4
 800a9fe:	643b      	str	r3, [r7, #64]	; 0x40
    break;
 800aa00:	bf00      	nop
  }
  /* CRYP Initialization Vectors */
  AES_CRYP_IVInitStructure.CRYP_IV0Left = __REV(*(uint32_t*)(ivaddr));
 800aa02:	f8d7 30fc 	ldr.w	r3, [r7, #252]	; 0xfc
 800aa06:	681b      	ldr	r3, [r3, #0]
 800aa08:	653b      	str	r3, [r7, #80]	; 0x50
  __ASM volatile ("rev %0, %1" : "=r" (result) : "r" (value) );
 800aa0a:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 800aa0c:	ba1b      	rev	r3, r3
 800aa0e:	64fb      	str	r3, [r7, #76]	; 0x4c
  return(result);
 800aa10:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
 800aa12:	f107 0314 	add.w	r3, r7, #20
 800aa16:	601a      	str	r2, [r3, #0]
  ivaddr+=4;
 800aa18:	f8d7 30fc 	ldr.w	r3, [r7, #252]	; 0xfc
 800aa1c:	3304      	adds	r3, #4
 800aa1e:	f8c7 30fc 	str.w	r3, [r7, #252]	; 0xfc
  AES_CRYP_IVInitStructure.CRYP_IV0Right= __REV(*(uint32_t*)(ivaddr));
 800aa22:	f8d7 30fc 	ldr.w	r3, [r7, #252]	; 0xfc
 800aa26:	681b      	ldr	r3, [r3, #0]
 800aa28:	65bb      	str	r3, [r7, #88]	; 0x58
  __ASM volatile ("rev %0, %1" : "=r" (result) : "r" (value) );
 800aa2a:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 800aa2c:	ba1b      	rev	r3, r3
 800aa2e:	657b      	str	r3, [r7, #84]	; 0x54
  return(result);
 800aa30:	6d7a      	ldr	r2, [r7, #84]	; 0x54
 800aa32:	f107 0314 	add.w	r3, r7, #20
 800aa36:	605a      	str	r2, [r3, #4]
  ivaddr+=4;
 800aa38:	f8d7 30fc 	ldr.w	r3, [r7, #252]	; 0xfc
 800aa3c:	3304      	adds	r3, #4
 800aa3e:	f8c7 30fc 	str.w	r3, [r7, #252]	; 0xfc
  AES_CRYP_IVInitStructure.CRYP_IV1Left = __REV(*(uint32_t*)(ivaddr));
 800aa42:	f8d7 30fc 	ldr.w	r3, [r7, #252]	; 0xfc
 800aa46:	681b      	ldr	r3, [r3, #0]
 800aa48:	663b      	str	r3, [r7, #96]	; 0x60
  __ASM volatile ("rev %0, %1" : "=r" (result) : "r" (value) );
 800aa4a:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 800aa4c:	ba1b      	rev	r3, r3
 800aa4e:	65fb      	str	r3, [r7, #92]	; 0x5c
  return(result);
 800aa50:	6dfa      	ldr	r2, [r7, #92]	; 0x5c
 800aa52:	f107 0314 	add.w	r3, r7, #20
 800aa56:	609a      	str	r2, [r3, #8]
  ivaddr+=4;
 800aa58:	f8d7 30fc 	ldr.w	r3, [r7, #252]	; 0xfc
 800aa5c:	3304      	adds	r3, #4
 800aa5e:	f8c7 30fc 	str.w	r3, [r7, #252]	; 0xfc
  AES_CRYP_IVInitStructure.CRYP_IV1Right= __REV(*(uint32_t*)(ivaddr));
 800aa62:	f8d7 30fc 	ldr.w	r3, [r7, #252]	; 0xfc
 800aa66:	681b      	ldr	r3, [r3, #0]
 800aa68:	66bb      	str	r3, [r7, #104]	; 0x68
  __ASM volatile ("rev %0, %1" : "=r" (result) : "r" (value) );
 800aa6a:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 800aa6c:	ba1b      	rev	r3, r3
 800aa6e:	667b      	str	r3, [r7, #100]	; 0x64
  return(result);
 800aa70:	6e7a      	ldr	r2, [r7, #100]	; 0x64
 800aa72:	f107 0314 	add.w	r3, r7, #20
 800aa76:	60da      	str	r2, [r3, #12]

  /* Key Initialisation */
  CRYP_KeyInit(&AES_CRYP_KeyInitStructure);
 800aa78:	f107 0324 	add.w	r3, r7, #36	; 0x24
 800aa7c:	4618      	mov	r0, r3
 800aa7e:	f7fe ff5b 	bl	8009938 <CRYP_KeyInit>

  /*------------------ AES Decryption ------------------*/
  if(Mode == MODE_DECRYPT) /* AES decryption */
 800aa82:	f107 030f 	add.w	r3, r7, #15
 800aa86:	781b      	ldrb	r3, [r3, #0]
 800aa88:	2b00      	cmp	r3, #0
 800aa8a:	d103      	bne.n	800aa94 <CRYP_AES_CTR+0x386>
  {
    /* Crypto Init for decryption process */
    AES_CRYP_InitStructure.CRYP_AlgoDir = CRYP_AlgoDir_Decrypt;
 800aa8c:	2304      	movs	r3, #4
 800aa8e:	f8a7 3044 	strh.w	r3, [r7, #68]	; 0x44
 800aa92:	e002      	b.n	800aa9a <CRYP_AES_CTR+0x38c>
  }
  /*------------------ AES Encryption ------------------*/
  else /* AES encryption */
  {
    /* Crypto Init for Encryption process */
    AES_CRYP_InitStructure.CRYP_AlgoDir = CRYP_AlgoDir_Encrypt;
 800aa94:	2300      	movs	r3, #0
 800aa96:	f8a7 3044 	strh.w	r3, [r7, #68]	; 0x44
  }
  AES_CRYP_InitStructure.CRYP_AlgoMode = CRYP_AlgoMode_AES_CTR;
 800aa9a:	2330      	movs	r3, #48	; 0x30
 800aa9c:	f8a7 3046 	strh.w	r3, [r7, #70]	; 0x46
  AES_CRYP_InitStructure.CRYP_DataType = CRYP_DataType_8b;
 800aaa0:	2380      	movs	r3, #128	; 0x80
 800aaa2:	f8a7 3048 	strh.w	r3, [r7, #72]	; 0x48
  CRYP_Init(&AES_CRYP_InitStructure);
 800aaa6:	f107 0344 	add.w	r3, r7, #68	; 0x44
 800aaaa:	4618      	mov	r0, r3
 800aaac:	f7fe fede 	bl	800986c <CRYP_Init>

  /* CRYP Initialization Vectors */
  CRYP_IVInit(&AES_CRYP_IVInitStructure);
 800aab0:	f107 0314 	add.w	r3, r7, #20
 800aab4:	4618      	mov	r0, r3
 800aab6:	f7fe ff8d 	bl	80099d4 <CRYP_IVInit>

  /* Flush IN/OUT FIFOs */
  CRYP_FIFOFlush();
 800aaba:	f7fe ffbd 	bl	8009a38 <CRYP_FIFOFlush>

  /* Enable Crypto processor */
  CRYP_Cmd(ENABLE);
 800aabe:	2001      	movs	r0, #1
 800aac0:	f7fe ffca 	bl	8009a58 <CRYP_Cmd>

  for(i=0; ((i<Ilength) && (status != ERROR)); i+=16)
 800aac4:	2300      	movs	r3, #0
 800aac6:	f8c7 3108 	str.w	r3, [r7, #264]	; 0x108
 800aaca:	e07f      	b.n	800abcc <CRYP_AES_CTR+0x4be>
  {

    /* Write the Input block in the IN FIFO */
    CRYP_DataIn(*(uint32_t*)(inputaddr));
 800aacc:	f8d7 3110 	ldr.w	r3, [r7, #272]	; 0x110
 800aad0:	681b      	ldr	r3, [r3, #0]
 800aad2:	4618      	mov	r0, r3
 800aad4:	f7fe ffde 	bl	8009a94 <CRYP_DataIn>
    inputaddr+=4;
 800aad8:	f8d7 3110 	ldr.w	r3, [r7, #272]	; 0x110
 800aadc:	3304      	adds	r3, #4
 800aade:	f8c7 3110 	str.w	r3, [r7, #272]	; 0x110
    CRYP_DataIn(*(uint32_t*)(inputaddr));
 800aae2:	f8d7 3110 	ldr.w	r3, [r7, #272]	; 0x110
 800aae6:	681b      	ldr	r3, [r3, #0]
 800aae8:	4618      	mov	r0, r3
 800aaea:	f7fe ffd3 	bl	8009a94 <CRYP_DataIn>
    inputaddr+=4;
 800aaee:	f8d7 3110 	ldr.w	r3, [r7, #272]	; 0x110
 800aaf2:	3304      	adds	r3, #4
 800aaf4:	f8c7 3110 	str.w	r3, [r7, #272]	; 0x110
    CRYP_DataIn(*(uint32_t*)(inputaddr));
 800aaf8:	f8d7 3110 	ldr.w	r3, [r7, #272]	; 0x110
 800aafc:	681b      	ldr	r3, [r3, #0]
 800aafe:	4618      	mov	r0, r3
 800ab00:	f7fe ffc8 	bl	8009a94 <CRYP_DataIn>
    inputaddr+=4;
 800ab04:	f8d7 3110 	ldr.w	r3, [r7, #272]	; 0x110
 800ab08:	3304      	adds	r3, #4
 800ab0a:	f8c7 3110 	str.w	r3, [r7, #272]	; 0x110
    CRYP_DataIn(*(uint32_t*)(inputaddr));
 800ab0e:	f8d7 3110 	ldr.w	r3, [r7, #272]	; 0x110
 800ab12:	681b      	ldr	r3, [r3, #0]
 800ab14:	4618      	mov	r0, r3
 800ab16:	f7fe ffbd 	bl	8009a94 <CRYP_DataIn>
    inputaddr+=4;
 800ab1a:	f8d7 3110 	ldr.w	r3, [r7, #272]	; 0x110
 800ab1e:	3304      	adds	r3, #4
 800ab20:	f8c7 3110 	str.w	r3, [r7, #272]	; 0x110
    /* Wait until the complete message has been processed */
    counter = 0;
 800ab24:	f107 0310 	add.w	r3, r7, #16
 800ab28:	2200      	movs	r2, #0
 800ab2a:	601a      	str	r2, [r3, #0]
    do
    {
      busystatus = CRYP_GetFlagStatus(CRYP_FLAG_BUSY);
 800ab2c:	2010      	movs	r0, #16
 800ab2e:	f7ff f8f5 	bl	8009d1c <CRYP_GetFlagStatus>
 800ab32:	4603      	mov	r3, r0
 800ab34:	f8c7 3104 	str.w	r3, [r7, #260]	; 0x104
      counter++;
 800ab38:	f107 0310 	add.w	r3, r7, #16
 800ab3c:	681b      	ldr	r3, [r3, #0]
 800ab3e:	1c5a      	adds	r2, r3, #1
 800ab40:	f107 0310 	add.w	r3, r7, #16
 800ab44:	601a      	str	r2, [r3, #0]
    }while ((counter != AESBUSY_TIMEOUT) && (busystatus != RESET));
 800ab46:	f107 0310 	add.w	r3, r7, #16
 800ab4a:	681b      	ldr	r3, [r3, #0]
 800ab4c:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 800ab50:	d003      	beq.n	800ab5a <CRYP_AES_CTR+0x44c>
 800ab52:	f8d7 3104 	ldr.w	r3, [r7, #260]	; 0x104
 800ab56:	2b00      	cmp	r3, #0
 800ab58:	d1e8      	bne.n	800ab2c <CRYP_AES_CTR+0x41e>

    if (busystatus != RESET)
 800ab5a:	f8d7 3104 	ldr.w	r3, [r7, #260]	; 0x104
 800ab5e:	2b00      	cmp	r3, #0
 800ab60:	d003      	beq.n	800ab6a <CRYP_AES_CTR+0x45c>
   {
       status = ERROR;
 800ab62:	2300      	movs	r3, #0
 800ab64:	f887 3117 	strb.w	r3, [r7, #279]	; 0x117
 800ab68:	e02b      	b.n	800abc2 <CRYP_AES_CTR+0x4b4>
    }
    else
    {

      /* Read the Output block from the Output FIFO */
      *(uint32_t*)(outputaddr) = CRYP_DataOut();
 800ab6a:	f8d7 410c 	ldr.w	r4, [r7, #268]	; 0x10c
 800ab6e:	f7fe ffa1 	bl	8009ab4 <CRYP_DataOut>
 800ab72:	4603      	mov	r3, r0
 800ab74:	6023      	str	r3, [r4, #0]
      outputaddr+=4;
 800ab76:	f8d7 310c 	ldr.w	r3, [r7, #268]	; 0x10c
 800ab7a:	3304      	adds	r3, #4
 800ab7c:	f8c7 310c 	str.w	r3, [r7, #268]	; 0x10c
      *(uint32_t*)(outputaddr) = CRYP_DataOut();
 800ab80:	f8d7 410c 	ldr.w	r4, [r7, #268]	; 0x10c
 800ab84:	f7fe ff96 	bl	8009ab4 <CRYP_DataOut>
 800ab88:	4603      	mov	r3, r0
 800ab8a:	6023      	str	r3, [r4, #0]
      outputaddr+=4;
 800ab8c:	f8d7 310c 	ldr.w	r3, [r7, #268]	; 0x10c
 800ab90:	3304      	adds	r3, #4
 800ab92:	f8c7 310c 	str.w	r3, [r7, #268]	; 0x10c
      *(uint32_t*)(outputaddr) = CRYP_DataOut();
 800ab96:	f8d7 410c 	ldr.w	r4, [r7, #268]	; 0x10c
 800ab9a:	f7fe ff8b 	bl	8009ab4 <CRYP_DataOut>
 800ab9e:	4603      	mov	r3, r0
 800aba0:	6023      	str	r3, [r4, #0]
      outputaddr+=4;
 800aba2:	f8d7 310c 	ldr.w	r3, [r7, #268]	; 0x10c
 800aba6:	3304      	adds	r3, #4
 800aba8:	f8c7 310c 	str.w	r3, [r7, #268]	; 0x10c
      *(uint32_t*)(outputaddr) = CRYP_DataOut();
 800abac:	f8d7 410c 	ldr.w	r4, [r7, #268]	; 0x10c
 800abb0:	f7fe ff80 	bl	8009ab4 <CRYP_DataOut>
 800abb4:	4603      	mov	r3, r0
 800abb6:	6023      	str	r3, [r4, #0]
      outputaddr+=4;
 800abb8:	f8d7 310c 	ldr.w	r3, [r7, #268]	; 0x10c
 800abbc:	3304      	adds	r3, #4
 800abbe:	f8c7 310c 	str.w	r3, [r7, #268]	; 0x10c
  for(i=0; ((i<Ilength) && (status != ERROR)); i+=16)
 800abc2:	f8d7 3108 	ldr.w	r3, [r7, #264]	; 0x108
 800abc6:	3310      	adds	r3, #16
 800abc8:	f8c7 3108 	str.w	r3, [r7, #264]	; 0x108
 800abcc:	f8d7 2108 	ldr.w	r2, [r7, #264]	; 0x108
 800abd0:	f8d7 312c 	ldr.w	r3, [r7, #300]	; 0x12c
 800abd4:	429a      	cmp	r2, r3
 800abd6:	d204      	bcs.n	800abe2 <CRYP_AES_CTR+0x4d4>
 800abd8:	f897 3117 	ldrb.w	r3, [r7, #279]	; 0x117
 800abdc:	2b00      	cmp	r3, #0
 800abde:	f47f af75 	bne.w	800aacc <CRYP_AES_CTR+0x3be>
    }
  }
  /* Disable Crypto */
  CRYP_Cmd(DISABLE);
 800abe2:	2000      	movs	r0, #0
 800abe4:	f7fe ff38 	bl	8009a58 <CRYP_Cmd>

  return status;
 800abe8:	f897 3117 	ldrb.w	r3, [r7, #279]	; 0x117
}
 800abec:	4618      	mov	r0, r3
 800abee:	f507 778e 	add.w	r7, r7, #284	; 0x11c
 800abf2:	46bd      	mov	sp, r7
 800abf4:	bd90      	pop	{r4, r7, pc}

0800abf6 <CRYP_DES_ECB>:
  *          - SUCCESS: Operation done
  *          - ERROR: Operation failed
  */
ErrorStatus CRYP_DES_ECB(uint8_t Mode, uint8_t Key[8], uint8_t *Input, 
                         uint32_t Ilength, uint8_t *Output)
{
 800abf6:	b590      	push	{r4, r7, lr}
 800abf8:	b09b      	sub	sp, #108	; 0x6c
 800abfa:	af00      	add	r7, sp, #0
 800abfc:	60b9      	str	r1, [r7, #8]
 800abfe:	607a      	str	r2, [r7, #4]
 800ac00:	603b      	str	r3, [r7, #0]
 800ac02:	4603      	mov	r3, r0
 800ac04:	73fb      	strb	r3, [r7, #15]
  CRYP_InitTypeDef DES_CRYP_InitStructure;
  CRYP_KeyInitTypeDef DES_CRYP_KeyInitStructure;
  __IO uint32_t counter = 0;
 800ac06:	2300      	movs	r3, #0
 800ac08:	617b      	str	r3, [r7, #20]
  uint32_t busystatus = 0;
 800ac0a:	2300      	movs	r3, #0
 800ac0c:	657b      	str	r3, [r7, #84]	; 0x54
  ErrorStatus status = SUCCESS;
 800ac0e:	2301      	movs	r3, #1
 800ac10:	f887 3067 	strb.w	r3, [r7, #103]	; 0x67
  uint32_t keyaddr    = (uint32_t)Key;
 800ac14:	68bb      	ldr	r3, [r7, #8]
 800ac16:	653b      	str	r3, [r7, #80]	; 0x50
  uint32_t inputaddr  = (uint32_t)Input;
 800ac18:	687b      	ldr	r3, [r7, #4]
 800ac1a:	663b      	str	r3, [r7, #96]	; 0x60
  uint32_t outputaddr = (uint32_t)Output;
 800ac1c:	6fbb      	ldr	r3, [r7, #120]	; 0x78
 800ac1e:	65fb      	str	r3, [r7, #92]	; 0x5c
  uint32_t i = 0;
 800ac20:	2300      	movs	r3, #0
 800ac22:	65bb      	str	r3, [r7, #88]	; 0x58

  /* Crypto structures initialisation*/
  CRYP_KeyStructInit(&DES_CRYP_KeyInitStructure);
 800ac24:	f107 0318 	add.w	r3, r7, #24
 800ac28:	4618      	mov	r0, r3
 800ac2a:	f7fe feb1 	bl	8009990 <CRYP_KeyStructInit>

  /* Crypto Init for Encryption process */
  if( Mode == MODE_ENCRYPT ) /* DES encryption */
 800ac2e:	7bfb      	ldrb	r3, [r7, #15]
 800ac30:	2b01      	cmp	r3, #1
 800ac32:	d102      	bne.n	800ac3a <CRYP_DES_ECB+0x44>
  {
     DES_CRYP_InitStructure.CRYP_AlgoDir  = CRYP_AlgoDir_Encrypt;
 800ac34:	2300      	movs	r3, #0
 800ac36:	873b      	strh	r3, [r7, #56]	; 0x38
 800ac38:	e001      	b.n	800ac3e <CRYP_DES_ECB+0x48>
  }
  else/* if( Mode == MODE_DECRYPT )*/ /* DES decryption */
  {      
     DES_CRYP_InitStructure.CRYP_AlgoDir  = CRYP_AlgoDir_Decrypt;
 800ac3a:	2304      	movs	r3, #4
 800ac3c:	873b      	strh	r3, [r7, #56]	; 0x38
  }

  DES_CRYP_InitStructure.CRYP_AlgoMode = CRYP_AlgoMode_DES_ECB;
 800ac3e:	2310      	movs	r3, #16
 800ac40:	877b      	strh	r3, [r7, #58]	; 0x3a
  DES_CRYP_InitStructure.CRYP_DataType = CRYP_DataType_8b;
 800ac42:	2380      	movs	r3, #128	; 0x80
 800ac44:	87bb      	strh	r3, [r7, #60]	; 0x3c
  CRYP_Init(&DES_CRYP_InitStructure);
 800ac46:	f107 0338 	add.w	r3, r7, #56	; 0x38
 800ac4a:	4618      	mov	r0, r3
 800ac4c:	f7fe fe0e 	bl	800986c <CRYP_Init>

  /* Key Initialisation */
  DES_CRYP_KeyInitStructure.CRYP_Key1Left = __REV(*(uint32_t*)(keyaddr));
 800ac50:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 800ac52:	681b      	ldr	r3, [r3, #0]
 800ac54:	647b      	str	r3, [r7, #68]	; 0x44
  __ASM volatile ("rev %0, %1" : "=r" (result) : "r" (value) );
 800ac56:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800ac58:	ba1b      	rev	r3, r3
 800ac5a:	643b      	str	r3, [r7, #64]	; 0x40
  return(result);
 800ac5c:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800ac5e:	623b      	str	r3, [r7, #32]
  keyaddr+=4;
 800ac60:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 800ac62:	3304      	adds	r3, #4
 800ac64:	653b      	str	r3, [r7, #80]	; 0x50
  DES_CRYP_KeyInitStructure.CRYP_Key1Right= __REV(*(uint32_t*)(keyaddr));
 800ac66:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 800ac68:	681b      	ldr	r3, [r3, #0]
 800ac6a:	64fb      	str	r3, [r7, #76]	; 0x4c
  __ASM volatile ("rev %0, %1" : "=r" (result) : "r" (value) );
 800ac6c:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800ac6e:	ba1b      	rev	r3, r3
 800ac70:	64bb      	str	r3, [r7, #72]	; 0x48
  return(result);
 800ac72:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 800ac74:	627b      	str	r3, [r7, #36]	; 0x24
  CRYP_KeyInit(& DES_CRYP_KeyInitStructure);
 800ac76:	f107 0318 	add.w	r3, r7, #24
 800ac7a:	4618      	mov	r0, r3
 800ac7c:	f7fe fe5c 	bl	8009938 <CRYP_KeyInit>

  /* Flush IN/OUT FIFO */
  CRYP_FIFOFlush();
 800ac80:	f7fe feda 	bl	8009a38 <CRYP_FIFOFlush>

  /* Enable Crypto processor */
  CRYP_Cmd(ENABLE);
 800ac84:	2001      	movs	r0, #1
 800ac86:	f7fe fee7 	bl	8009a58 <CRYP_Cmd>

  for(i=0; ((i<Ilength) && (status != ERROR)); i+=8)
 800ac8a:	2300      	movs	r3, #0
 800ac8c:	65bb      	str	r3, [r7, #88]	; 0x58
 800ac8e:	e03a      	b.n	800ad06 <CRYP_DES_ECB+0x110>
  {

    /* Write the Input block in the Input FIFO */
    CRYP_DataIn(*(uint32_t*)(inputaddr));
 800ac90:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 800ac92:	681b      	ldr	r3, [r3, #0]
 800ac94:	4618      	mov	r0, r3
 800ac96:	f7fe fefd 	bl	8009a94 <CRYP_DataIn>
    inputaddr+=4;
 800ac9a:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 800ac9c:	3304      	adds	r3, #4
 800ac9e:	663b      	str	r3, [r7, #96]	; 0x60
    CRYP_DataIn(*(uint32_t*)(inputaddr));
 800aca0:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 800aca2:	681b      	ldr	r3, [r3, #0]
 800aca4:	4618      	mov	r0, r3
 800aca6:	f7fe fef5 	bl	8009a94 <CRYP_DataIn>
    inputaddr+=4;
 800acaa:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 800acac:	3304      	adds	r3, #4
 800acae:	663b      	str	r3, [r7, #96]	; 0x60

/* Wait until the complete message has been processed */
    counter = 0;
 800acb0:	2300      	movs	r3, #0
 800acb2:	617b      	str	r3, [r7, #20]
    do
    {
      busystatus = CRYP_GetFlagStatus(CRYP_FLAG_BUSY);
 800acb4:	2010      	movs	r0, #16
 800acb6:	f7ff f831 	bl	8009d1c <CRYP_GetFlagStatus>
 800acba:	4603      	mov	r3, r0
 800acbc:	657b      	str	r3, [r7, #84]	; 0x54
      counter++;
 800acbe:	697b      	ldr	r3, [r7, #20]
 800acc0:	3301      	adds	r3, #1
 800acc2:	617b      	str	r3, [r7, #20]
    }while ((counter != DESBUSY_TIMEOUT) && (busystatus != RESET));
 800acc4:	697b      	ldr	r3, [r7, #20]
 800acc6:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 800acca:	d002      	beq.n	800acd2 <CRYP_DES_ECB+0xdc>
 800accc:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 800acce:	2b00      	cmp	r3, #0
 800acd0:	d1f0      	bne.n	800acb4 <CRYP_DES_ECB+0xbe>

    if (busystatus != RESET)
 800acd2:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 800acd4:	2b00      	cmp	r3, #0
 800acd6:	d003      	beq.n	800ace0 <CRYP_DES_ECB+0xea>
   {
       status = ERROR;
 800acd8:	2300      	movs	r3, #0
 800acda:	f887 3067 	strb.w	r3, [r7, #103]	; 0x67
 800acde:	e00f      	b.n	800ad00 <CRYP_DES_ECB+0x10a>
    }
    else
    {

      /* Read the Output block from the Output FIFO */
      *(uint32_t*)(outputaddr) = CRYP_DataOut();
 800ace0:	6dfc      	ldr	r4, [r7, #92]	; 0x5c
 800ace2:	f7fe fee7 	bl	8009ab4 <CRYP_DataOut>
 800ace6:	4603      	mov	r3, r0
 800ace8:	6023      	str	r3, [r4, #0]
      outputaddr+=4;
 800acea:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 800acec:	3304      	adds	r3, #4
 800acee:	65fb      	str	r3, [r7, #92]	; 0x5c
      *(uint32_t*)(outputaddr) = CRYP_DataOut();
 800acf0:	6dfc      	ldr	r4, [r7, #92]	; 0x5c
 800acf2:	f7fe fedf 	bl	8009ab4 <CRYP_DataOut>
 800acf6:	4603      	mov	r3, r0
 800acf8:	6023      	str	r3, [r4, #0]
      outputaddr+=4;
 800acfa:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 800acfc:	3304      	adds	r3, #4
 800acfe:	65fb      	str	r3, [r7, #92]	; 0x5c
  for(i=0; ((i<Ilength) && (status != ERROR)); i+=8)
 800ad00:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 800ad02:	3308      	adds	r3, #8
 800ad04:	65bb      	str	r3, [r7, #88]	; 0x58
 800ad06:	6dba      	ldr	r2, [r7, #88]	; 0x58
 800ad08:	683b      	ldr	r3, [r7, #0]
 800ad0a:	429a      	cmp	r2, r3
 800ad0c:	d203      	bcs.n	800ad16 <CRYP_DES_ECB+0x120>
 800ad0e:	f897 3067 	ldrb.w	r3, [r7, #103]	; 0x67
 800ad12:	2b00      	cmp	r3, #0
 800ad14:	d1bc      	bne.n	800ac90 <CRYP_DES_ECB+0x9a>
    }
  }

  /* Disable Crypto */
  CRYP_Cmd(DISABLE);
 800ad16:	2000      	movs	r0, #0
 800ad18:	f7fe fe9e 	bl	8009a58 <CRYP_Cmd>

  return status; 
 800ad1c:	f897 3067 	ldrb.w	r3, [r7, #103]	; 0x67
}
 800ad20:	4618      	mov	r0, r3
 800ad22:	376c      	adds	r7, #108	; 0x6c
 800ad24:	46bd      	mov	sp, r7
 800ad26:	bd90      	pop	{r4, r7, pc}

0800ad28 <CRYP_DES_CBC>:
  *          - SUCCESS: Operation done
  *          - ERROR: Operation failed
  */
ErrorStatus CRYP_DES_CBC(uint8_t Mode, uint8_t Key[8], uint8_t InitVectors[8],
                         uint8_t *Input, uint32_t Ilength, uint8_t *Output)
{
 800ad28:	b590      	push	{r4, r7, lr}
 800ad2a:	b0a3      	sub	sp, #140	; 0x8c
 800ad2c:	af00      	add	r7, sp, #0
 800ad2e:	60b9      	str	r1, [r7, #8]
 800ad30:	607a      	str	r2, [r7, #4]
 800ad32:	603b      	str	r3, [r7, #0]
 800ad34:	4603      	mov	r3, r0
 800ad36:	73fb      	strb	r3, [r7, #15]
  CRYP_InitTypeDef DES_CRYP_InitStructure;
  CRYP_KeyInitTypeDef DES_CRYP_KeyInitStructure;
  CRYP_IVInitTypeDef DES_CRYP_IVInitStructure;
  __IO uint32_t counter = 0;
 800ad38:	2300      	movs	r3, #0
 800ad3a:	613b      	str	r3, [r7, #16]
  uint32_t busystatus = 0;
 800ad3c:	2300      	movs	r3, #0
 800ad3e:	677b      	str	r3, [r7, #116]	; 0x74
  ErrorStatus status = SUCCESS;
 800ad40:	2301      	movs	r3, #1
 800ad42:	f887 3087 	strb.w	r3, [r7, #135]	; 0x87
  uint32_t keyaddr    = (uint32_t)Key;
 800ad46:	68bb      	ldr	r3, [r7, #8]
 800ad48:	673b      	str	r3, [r7, #112]	; 0x70
  uint32_t inputaddr  = (uint32_t)Input;
 800ad4a:	683b      	ldr	r3, [r7, #0]
 800ad4c:	f8c7 3080 	str.w	r3, [r7, #128]	; 0x80
  uint32_t outputaddr = (uint32_t)Output;
 800ad50:	f8d7 309c 	ldr.w	r3, [r7, #156]	; 0x9c
 800ad54:	67fb      	str	r3, [r7, #124]	; 0x7c
  uint32_t ivaddr     = (uint32_t)InitVectors;
 800ad56:	687b      	ldr	r3, [r7, #4]
 800ad58:	66fb      	str	r3, [r7, #108]	; 0x6c
  uint32_t i = 0;
 800ad5a:	2300      	movs	r3, #0
 800ad5c:	67bb      	str	r3, [r7, #120]	; 0x78

  /* Crypto structures initialisation*/
  CRYP_KeyStructInit(&DES_CRYP_KeyInitStructure);
 800ad5e:	f107 0324 	add.w	r3, r7, #36	; 0x24
 800ad62:	4618      	mov	r0, r3
 800ad64:	f7fe fe14 	bl	8009990 <CRYP_KeyStructInit>

  /* Crypto Init for Encryption process */
  if(Mode == MODE_ENCRYPT) /* DES encryption */
 800ad68:	7bfb      	ldrb	r3, [r7, #15]
 800ad6a:	2b01      	cmp	r3, #1
 800ad6c:	d103      	bne.n	800ad76 <CRYP_DES_CBC+0x4e>
  {
     DES_CRYP_InitStructure.CRYP_AlgoDir  = CRYP_AlgoDir_Encrypt;
 800ad6e:	2300      	movs	r3, #0
 800ad70:	f8a7 3044 	strh.w	r3, [r7, #68]	; 0x44
 800ad74:	e002      	b.n	800ad7c <CRYP_DES_CBC+0x54>
  }
  else /*if(Mode == MODE_DECRYPT)*/ /* DES decryption */
  {
     DES_CRYP_InitStructure.CRYP_AlgoDir  = CRYP_AlgoDir_Decrypt;
 800ad76:	2304      	movs	r3, #4
 800ad78:	f8a7 3044 	strh.w	r3, [r7, #68]	; 0x44
  }

  DES_CRYP_InitStructure.CRYP_AlgoMode = CRYP_AlgoMode_DES_CBC;
 800ad7c:	2318      	movs	r3, #24
 800ad7e:	f8a7 3046 	strh.w	r3, [r7, #70]	; 0x46
  DES_CRYP_InitStructure.CRYP_DataType = CRYP_DataType_8b;
 800ad82:	2380      	movs	r3, #128	; 0x80
 800ad84:	f8a7 3048 	strh.w	r3, [r7, #72]	; 0x48
  CRYP_Init(&DES_CRYP_InitStructure);
 800ad88:	f107 0344 	add.w	r3, r7, #68	; 0x44
 800ad8c:	4618      	mov	r0, r3
 800ad8e:	f7fe fd6d 	bl	800986c <CRYP_Init>

  /* Key Initialisation */
  DES_CRYP_KeyInitStructure.CRYP_Key1Left = __REV(*(uint32_t*)(keyaddr));
 800ad92:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 800ad94:	681b      	ldr	r3, [r3, #0]
 800ad96:	653b      	str	r3, [r7, #80]	; 0x50
  __ASM volatile ("rev %0, %1" : "=r" (result) : "r" (value) );
 800ad98:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 800ad9a:	ba1b      	rev	r3, r3
 800ad9c:	64fb      	str	r3, [r7, #76]	; 0x4c
  return(result);
 800ad9e:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800ada0:	62fb      	str	r3, [r7, #44]	; 0x2c
  keyaddr+=4;
 800ada2:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 800ada4:	3304      	adds	r3, #4
 800ada6:	673b      	str	r3, [r7, #112]	; 0x70
  DES_CRYP_KeyInitStructure.CRYP_Key1Right= __REV(*(uint32_t*)(keyaddr));
 800ada8:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 800adaa:	681b      	ldr	r3, [r3, #0]
 800adac:	65bb      	str	r3, [r7, #88]	; 0x58
  __ASM volatile ("rev %0, %1" : "=r" (result) : "r" (value) );
 800adae:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 800adb0:	ba1b      	rev	r3, r3
 800adb2:	657b      	str	r3, [r7, #84]	; 0x54
  return(result);
 800adb4:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 800adb6:	633b      	str	r3, [r7, #48]	; 0x30
  CRYP_KeyInit(& DES_CRYP_KeyInitStructure);
 800adb8:	f107 0324 	add.w	r3, r7, #36	; 0x24
 800adbc:	4618      	mov	r0, r3
 800adbe:	f7fe fdbb 	bl	8009938 <CRYP_KeyInit>

  /* Initialization Vectors */
  DES_CRYP_IVInitStructure.CRYP_IV0Left = __REV(*(uint32_t*)(ivaddr));
 800adc2:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 800adc4:	681b      	ldr	r3, [r3, #0]
 800adc6:	663b      	str	r3, [r7, #96]	; 0x60
  __ASM volatile ("rev %0, %1" : "=r" (result) : "r" (value) );
 800adc8:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 800adca:	ba1b      	rev	r3, r3
 800adcc:	65fb      	str	r3, [r7, #92]	; 0x5c
  return(result);
 800adce:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 800add0:	617b      	str	r3, [r7, #20]
  ivaddr+=4;
 800add2:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 800add4:	3304      	adds	r3, #4
 800add6:	66fb      	str	r3, [r7, #108]	; 0x6c
  DES_CRYP_IVInitStructure.CRYP_IV0Right= __REV(*(uint32_t*)(ivaddr));
 800add8:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 800adda:	681b      	ldr	r3, [r3, #0]
 800addc:	66bb      	str	r3, [r7, #104]	; 0x68
  __ASM volatile ("rev %0, %1" : "=r" (result) : "r" (value) );
 800adde:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 800ade0:	ba1b      	rev	r3, r3
 800ade2:	667b      	str	r3, [r7, #100]	; 0x64
  return(result);
 800ade4:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 800ade6:	61bb      	str	r3, [r7, #24]
  CRYP_IVInit(&DES_CRYP_IVInitStructure);
 800ade8:	f107 0314 	add.w	r3, r7, #20
 800adec:	4618      	mov	r0, r3
 800adee:	f7fe fdf1 	bl	80099d4 <CRYP_IVInit>

  /* Flush IN/OUT FIFO */
  CRYP_FIFOFlush();
 800adf2:	f7fe fe21 	bl	8009a38 <CRYP_FIFOFlush>
  
  /* Enable Crypto processor */
  CRYP_Cmd(ENABLE);
 800adf6:	2001      	movs	r0, #1
 800adf8:	f7fe fe2e 	bl	8009a58 <CRYP_Cmd>

  for(i=0; ((i<Ilength) && (status != ERROR)); i+=8)
 800adfc:	2300      	movs	r3, #0
 800adfe:	67bb      	str	r3, [r7, #120]	; 0x78
 800ae00:	e040      	b.n	800ae84 <CRYP_DES_CBC+0x15c>
  {
    /* Write the Input block in the Input FIFO */
    CRYP_DataIn(*(uint32_t*)(inputaddr));
 800ae02:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
 800ae06:	681b      	ldr	r3, [r3, #0]
 800ae08:	4618      	mov	r0, r3
 800ae0a:	f7fe fe43 	bl	8009a94 <CRYP_DataIn>
    inputaddr+=4;
 800ae0e:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
 800ae12:	3304      	adds	r3, #4
 800ae14:	f8c7 3080 	str.w	r3, [r7, #128]	; 0x80
    CRYP_DataIn(*(uint32_t*)(inputaddr));
 800ae18:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
 800ae1c:	681b      	ldr	r3, [r3, #0]
 800ae1e:	4618      	mov	r0, r3
 800ae20:	f7fe fe38 	bl	8009a94 <CRYP_DataIn>
    inputaddr+=4;
 800ae24:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
 800ae28:	3304      	adds	r3, #4
 800ae2a:	f8c7 3080 	str.w	r3, [r7, #128]	; 0x80

    /* Wait until the complete message has been processed */
    counter = 0;
 800ae2e:	2300      	movs	r3, #0
 800ae30:	613b      	str	r3, [r7, #16]
    do
    {
      busystatus = CRYP_GetFlagStatus(CRYP_FLAG_BUSY);
 800ae32:	2010      	movs	r0, #16
 800ae34:	f7fe ff72 	bl	8009d1c <CRYP_GetFlagStatus>
 800ae38:	4603      	mov	r3, r0
 800ae3a:	677b      	str	r3, [r7, #116]	; 0x74
      counter++;
 800ae3c:	693b      	ldr	r3, [r7, #16]
 800ae3e:	3301      	adds	r3, #1
 800ae40:	613b      	str	r3, [r7, #16]
    }while ((counter != DESBUSY_TIMEOUT) && (busystatus != RESET));
 800ae42:	693b      	ldr	r3, [r7, #16]
 800ae44:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 800ae48:	d002      	beq.n	800ae50 <CRYP_DES_CBC+0x128>
 800ae4a:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 800ae4c:	2b00      	cmp	r3, #0
 800ae4e:	d1f0      	bne.n	800ae32 <CRYP_DES_CBC+0x10a>

    if (busystatus != RESET)
 800ae50:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 800ae52:	2b00      	cmp	r3, #0
 800ae54:	d003      	beq.n	800ae5e <CRYP_DES_CBC+0x136>
   {
       status = ERROR;
 800ae56:	2300      	movs	r3, #0
 800ae58:	f887 3087 	strb.w	r3, [r7, #135]	; 0x87
 800ae5c:	e00f      	b.n	800ae7e <CRYP_DES_CBC+0x156>
    }
    else
    {
      /* Read the Output block from the Output FIFO */
      *(uint32_t*)(outputaddr) = CRYP_DataOut();
 800ae5e:	6ffc      	ldr	r4, [r7, #124]	; 0x7c
 800ae60:	f7fe fe28 	bl	8009ab4 <CRYP_DataOut>
 800ae64:	4603      	mov	r3, r0
 800ae66:	6023      	str	r3, [r4, #0]
      outputaddr+=4;
 800ae68:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
 800ae6a:	3304      	adds	r3, #4
 800ae6c:	67fb      	str	r3, [r7, #124]	; 0x7c
      *(uint32_t*)(outputaddr) = CRYP_DataOut();
 800ae6e:	6ffc      	ldr	r4, [r7, #124]	; 0x7c
 800ae70:	f7fe fe20 	bl	8009ab4 <CRYP_DataOut>
 800ae74:	4603      	mov	r3, r0
 800ae76:	6023      	str	r3, [r4, #0]
      outputaddr+=4;
 800ae78:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
 800ae7a:	3304      	adds	r3, #4
 800ae7c:	67fb      	str	r3, [r7, #124]	; 0x7c
  for(i=0; ((i<Ilength) && (status != ERROR)); i+=8)
 800ae7e:	6fbb      	ldr	r3, [r7, #120]	; 0x78
 800ae80:	3308      	adds	r3, #8
 800ae82:	67bb      	str	r3, [r7, #120]	; 0x78
 800ae84:	6fba      	ldr	r2, [r7, #120]	; 0x78
 800ae86:	f8d7 3098 	ldr.w	r3, [r7, #152]	; 0x98
 800ae8a:	429a      	cmp	r2, r3
 800ae8c:	d203      	bcs.n	800ae96 <CRYP_DES_CBC+0x16e>
 800ae8e:	f897 3087 	ldrb.w	r3, [r7, #135]	; 0x87
 800ae92:	2b00      	cmp	r3, #0
 800ae94:	d1b5      	bne.n	800ae02 <CRYP_DES_CBC+0xda>
    }
  }

  /* Disable Crypto */
  CRYP_Cmd(DISABLE);
 800ae96:	2000      	movs	r0, #0
 800ae98:	f7fe fdde 	bl	8009a58 <CRYP_Cmd>

  return status; 
 800ae9c:	f897 3087 	ldrb.w	r3, [r7, #135]	; 0x87
}
 800aea0:	4618      	mov	r0, r3
 800aea2:	378c      	adds	r7, #140	; 0x8c
 800aea4:	46bd      	mov	sp, r7
 800aea6:	bd90      	pop	{r4, r7, pc}

0800aea8 <CRYP_TDES_ECB>:
  *          - SUCCESS: Operation done
  *          - ERROR: Operation failed
  */
ErrorStatus CRYP_TDES_ECB(uint8_t Mode, uint8_t Key[24], uint8_t *Input, 
                          uint32_t Ilength, uint8_t *Output)
{
 800aea8:	b590      	push	{r4, r7, lr}
 800aeaa:	b0a3      	sub	sp, #140	; 0x8c
 800aeac:	af00      	add	r7, sp, #0
 800aeae:	60b9      	str	r1, [r7, #8]
 800aeb0:	607a      	str	r2, [r7, #4]
 800aeb2:	603b      	str	r3, [r7, #0]
 800aeb4:	4603      	mov	r3, r0
 800aeb6:	73fb      	strb	r3, [r7, #15]
  CRYP_InitTypeDef TDES_CRYP_InitStructure;
  CRYP_KeyInitTypeDef TDES_CRYP_KeyInitStructure;
  __IO uint32_t counter = 0;
 800aeb8:	2300      	movs	r3, #0
 800aeba:	617b      	str	r3, [r7, #20]
  uint32_t busystatus = 0;
 800aebc:	2300      	movs	r3, #0
 800aebe:	677b      	str	r3, [r7, #116]	; 0x74
  ErrorStatus status = SUCCESS;
 800aec0:	2301      	movs	r3, #1
 800aec2:	f887 3087 	strb.w	r3, [r7, #135]	; 0x87
  uint32_t keyaddr    = (uint32_t)Key;
 800aec6:	68bb      	ldr	r3, [r7, #8]
 800aec8:	673b      	str	r3, [r7, #112]	; 0x70
  uint32_t inputaddr  = (uint32_t)Input;
 800aeca:	687b      	ldr	r3, [r7, #4]
 800aecc:	f8c7 3080 	str.w	r3, [r7, #128]	; 0x80
  uint32_t outputaddr = (uint32_t)Output;
 800aed0:	f8d7 3098 	ldr.w	r3, [r7, #152]	; 0x98
 800aed4:	67fb      	str	r3, [r7, #124]	; 0x7c
  uint32_t i = 0;
 800aed6:	2300      	movs	r3, #0
 800aed8:	67bb      	str	r3, [r7, #120]	; 0x78

  /* Crypto structures initialisation*/
  CRYP_KeyStructInit(&TDES_CRYP_KeyInitStructure);
 800aeda:	f107 0318 	add.w	r3, r7, #24
 800aede:	4618      	mov	r0, r3
 800aee0:	f7fe fd56 	bl	8009990 <CRYP_KeyStructInit>

  /* Crypto Init for Encryption process */
  if(Mode == MODE_ENCRYPT) /* TDES encryption */
 800aee4:	7bfb      	ldrb	r3, [r7, #15]
 800aee6:	2b01      	cmp	r3, #1
 800aee8:	d102      	bne.n	800aef0 <CRYP_TDES_ECB+0x48>
  {
     TDES_CRYP_InitStructure.CRYP_AlgoDir = CRYP_AlgoDir_Encrypt;
 800aeea:	2300      	movs	r3, #0
 800aeec:	873b      	strh	r3, [r7, #56]	; 0x38
 800aeee:	e001      	b.n	800aef4 <CRYP_TDES_ECB+0x4c>
  }
  else /*if(Mode == MODE_DECRYPT)*/ /* TDES decryption */
  {
     TDES_CRYP_InitStructure.CRYP_AlgoDir = CRYP_AlgoDir_Decrypt;
 800aef0:	2304      	movs	r3, #4
 800aef2:	873b      	strh	r3, [r7, #56]	; 0x38
  }

  TDES_CRYP_InitStructure.CRYP_AlgoMode = CRYP_AlgoMode_TDES_ECB;
 800aef4:	2300      	movs	r3, #0
 800aef6:	877b      	strh	r3, [r7, #58]	; 0x3a
  TDES_CRYP_InitStructure.CRYP_DataType = CRYP_DataType_8b;
 800aef8:	2380      	movs	r3, #128	; 0x80
 800aefa:	87bb      	strh	r3, [r7, #60]	; 0x3c
  CRYP_Init(&TDES_CRYP_InitStructure);
 800aefc:	f107 0338 	add.w	r3, r7, #56	; 0x38
 800af00:	4618      	mov	r0, r3
 800af02:	f7fe fcb3 	bl	800986c <CRYP_Init>

  /* Key Initialisation */
  TDES_CRYP_KeyInitStructure.CRYP_Key1Left = __REV(*(uint32_t*)(keyaddr));
 800af06:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 800af08:	681b      	ldr	r3, [r3, #0]
 800af0a:	647b      	str	r3, [r7, #68]	; 0x44
  __ASM volatile ("rev %0, %1" : "=r" (result) : "r" (value) );
 800af0c:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800af0e:	ba1b      	rev	r3, r3
 800af10:	643b      	str	r3, [r7, #64]	; 0x40
  return(result);
 800af12:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800af14:	623b      	str	r3, [r7, #32]
  keyaddr+=4;
 800af16:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 800af18:	3304      	adds	r3, #4
 800af1a:	673b      	str	r3, [r7, #112]	; 0x70
  TDES_CRYP_KeyInitStructure.CRYP_Key1Right= __REV(*(uint32_t*)(keyaddr));
 800af1c:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 800af1e:	681b      	ldr	r3, [r3, #0]
 800af20:	64fb      	str	r3, [r7, #76]	; 0x4c
  __ASM volatile ("rev %0, %1" : "=r" (result) : "r" (value) );
 800af22:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800af24:	ba1b      	rev	r3, r3
 800af26:	64bb      	str	r3, [r7, #72]	; 0x48
  return(result);
 800af28:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 800af2a:	627b      	str	r3, [r7, #36]	; 0x24
  keyaddr+=4;
 800af2c:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 800af2e:	3304      	adds	r3, #4
 800af30:	673b      	str	r3, [r7, #112]	; 0x70
  TDES_CRYP_KeyInitStructure.CRYP_Key2Left = __REV(*(uint32_t*)(keyaddr));
 800af32:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 800af34:	681b      	ldr	r3, [r3, #0]
 800af36:	657b      	str	r3, [r7, #84]	; 0x54
  __ASM volatile ("rev %0, %1" : "=r" (result) : "r" (value) );
 800af38:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 800af3a:	ba1b      	rev	r3, r3
 800af3c:	653b      	str	r3, [r7, #80]	; 0x50
  return(result);
 800af3e:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 800af40:	62bb      	str	r3, [r7, #40]	; 0x28
  keyaddr+=4;
 800af42:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 800af44:	3304      	adds	r3, #4
 800af46:	673b      	str	r3, [r7, #112]	; 0x70
  TDES_CRYP_KeyInitStructure.CRYP_Key2Right= __REV(*(uint32_t*)(keyaddr));
 800af48:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 800af4a:	681b      	ldr	r3, [r3, #0]
 800af4c:	65fb      	str	r3, [r7, #92]	; 0x5c
  __ASM volatile ("rev %0, %1" : "=r" (result) : "r" (value) );
 800af4e:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 800af50:	ba1b      	rev	r3, r3
 800af52:	65bb      	str	r3, [r7, #88]	; 0x58
  return(result);
 800af54:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 800af56:	62fb      	str	r3, [r7, #44]	; 0x2c
  keyaddr+=4;
 800af58:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 800af5a:	3304      	adds	r3, #4
 800af5c:	673b      	str	r3, [r7, #112]	; 0x70
  TDES_CRYP_KeyInitStructure.CRYP_Key3Left = __REV(*(uint32_t*)(keyaddr));
 800af5e:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 800af60:	681b      	ldr	r3, [r3, #0]
 800af62:	667b      	str	r3, [r7, #100]	; 0x64
  __ASM volatile ("rev %0, %1" : "=r" (result) : "r" (value) );
 800af64:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 800af66:	ba1b      	rev	r3, r3
 800af68:	663b      	str	r3, [r7, #96]	; 0x60
  return(result);
 800af6a:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 800af6c:	633b      	str	r3, [r7, #48]	; 0x30
  keyaddr+=4;
 800af6e:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 800af70:	3304      	adds	r3, #4
 800af72:	673b      	str	r3, [r7, #112]	; 0x70
  TDES_CRYP_KeyInitStructure.CRYP_Key3Right= __REV(*(uint32_t*)(keyaddr));
 800af74:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 800af76:	681b      	ldr	r3, [r3, #0]
 800af78:	66fb      	str	r3, [r7, #108]	; 0x6c
  __ASM volatile ("rev %0, %1" : "=r" (result) : "r" (value) );
 800af7a:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 800af7c:	ba1b      	rev	r3, r3
 800af7e:	66bb      	str	r3, [r7, #104]	; 0x68
  return(result);
 800af80:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 800af82:	637b      	str	r3, [r7, #52]	; 0x34
  CRYP_KeyInit(& TDES_CRYP_KeyInitStructure);
 800af84:	f107 0318 	add.w	r3, r7, #24
 800af88:	4618      	mov	r0, r3
 800af8a:	f7fe fcd5 	bl	8009938 <CRYP_KeyInit>

  /* Flush IN/OUT FIFO */
  CRYP_FIFOFlush();
 800af8e:	f7fe fd53 	bl	8009a38 <CRYP_FIFOFlush>

  /* Enable Crypto processor */
  CRYP_Cmd(ENABLE);
 800af92:	2001      	movs	r0, #1
 800af94:	f7fe fd60 	bl	8009a58 <CRYP_Cmd>

  for(i=0; ((i<Ilength) && (status != ERROR)); i+=8)
 800af98:	2300      	movs	r3, #0
 800af9a:	67bb      	str	r3, [r7, #120]	; 0x78
 800af9c:	e040      	b.n	800b020 <CRYP_TDES_ECB+0x178>
  {
    /* Write the Input block in the Input FIFO */
    CRYP_DataIn(*(uint32_t*)(inputaddr));
 800af9e:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
 800afa2:	681b      	ldr	r3, [r3, #0]
 800afa4:	4618      	mov	r0, r3
 800afa6:	f7fe fd75 	bl	8009a94 <CRYP_DataIn>
    inputaddr+=4;
 800afaa:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
 800afae:	3304      	adds	r3, #4
 800afb0:	f8c7 3080 	str.w	r3, [r7, #128]	; 0x80
    CRYP_DataIn(*(uint32_t*)(inputaddr));
 800afb4:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
 800afb8:	681b      	ldr	r3, [r3, #0]
 800afba:	4618      	mov	r0, r3
 800afbc:	f7fe fd6a 	bl	8009a94 <CRYP_DataIn>
    inputaddr+=4;
 800afc0:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
 800afc4:	3304      	adds	r3, #4
 800afc6:	f8c7 3080 	str.w	r3, [r7, #128]	; 0x80

    /* Wait until the complete message has been processed */
    counter = 0;
 800afca:	2300      	movs	r3, #0
 800afcc:	617b      	str	r3, [r7, #20]
    do
    {
      busystatus = CRYP_GetFlagStatus(CRYP_FLAG_BUSY);
 800afce:	2010      	movs	r0, #16
 800afd0:	f7fe fea4 	bl	8009d1c <CRYP_GetFlagStatus>
 800afd4:	4603      	mov	r3, r0
 800afd6:	677b      	str	r3, [r7, #116]	; 0x74
      counter++;
 800afd8:	697b      	ldr	r3, [r7, #20]
 800afda:	3301      	adds	r3, #1
 800afdc:	617b      	str	r3, [r7, #20]
    }while ((counter != TDESBUSY_TIMEOUT) && (busystatus != RESET));
 800afde:	697b      	ldr	r3, [r7, #20]
 800afe0:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 800afe4:	d002      	beq.n	800afec <CRYP_TDES_ECB+0x144>
 800afe6:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 800afe8:	2b00      	cmp	r3, #0
 800afea:	d1f0      	bne.n	800afce <CRYP_TDES_ECB+0x126>

    if (busystatus != RESET)
 800afec:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 800afee:	2b00      	cmp	r3, #0
 800aff0:	d003      	beq.n	800affa <CRYP_TDES_ECB+0x152>
    {
       status = ERROR;
 800aff2:	2300      	movs	r3, #0
 800aff4:	f887 3087 	strb.w	r3, [r7, #135]	; 0x87
 800aff8:	e00f      	b.n	800b01a <CRYP_TDES_ECB+0x172>
    }
    else
    {

      /* Read the Output block from the Output FIFO */
      *(uint32_t*)(outputaddr) = CRYP_DataOut();
 800affa:	6ffc      	ldr	r4, [r7, #124]	; 0x7c
 800affc:	f7fe fd5a 	bl	8009ab4 <CRYP_DataOut>
 800b000:	4603      	mov	r3, r0
 800b002:	6023      	str	r3, [r4, #0]
      outputaddr+=4;
 800b004:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
 800b006:	3304      	adds	r3, #4
 800b008:	67fb      	str	r3, [r7, #124]	; 0x7c
      *(uint32_t*)(outputaddr) = CRYP_DataOut();
 800b00a:	6ffc      	ldr	r4, [r7, #124]	; 0x7c
 800b00c:	f7fe fd52 	bl	8009ab4 <CRYP_DataOut>
 800b010:	4603      	mov	r3, r0
 800b012:	6023      	str	r3, [r4, #0]
      outputaddr+=4;
 800b014:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
 800b016:	3304      	adds	r3, #4
 800b018:	67fb      	str	r3, [r7, #124]	; 0x7c
  for(i=0; ((i<Ilength) && (status != ERROR)); i+=8)
 800b01a:	6fbb      	ldr	r3, [r7, #120]	; 0x78
 800b01c:	3308      	adds	r3, #8
 800b01e:	67bb      	str	r3, [r7, #120]	; 0x78
 800b020:	6fba      	ldr	r2, [r7, #120]	; 0x78
 800b022:	683b      	ldr	r3, [r7, #0]
 800b024:	429a      	cmp	r2, r3
 800b026:	d203      	bcs.n	800b030 <CRYP_TDES_ECB+0x188>
 800b028:	f897 3087 	ldrb.w	r3, [r7, #135]	; 0x87
 800b02c:	2b00      	cmp	r3, #0
 800b02e:	d1b6      	bne.n	800af9e <CRYP_TDES_ECB+0xf6>
    }
  }

  /* Disable Crypto */
  CRYP_Cmd(DISABLE);
 800b030:	2000      	movs	r0, #0
 800b032:	f7fe fd11 	bl	8009a58 <CRYP_Cmd>

  return status; 
 800b036:	f897 3087 	ldrb.w	r3, [r7, #135]	; 0x87
}
 800b03a:	4618      	mov	r0, r3
 800b03c:	378c      	adds	r7, #140	; 0x8c
 800b03e:	46bd      	mov	sp, r7
 800b040:	bd90      	pop	{r4, r7, pc}

0800b042 <CRYP_TDES_CBC>:
  *          - SUCCESS: Operation done
  *          - ERROR: Operation failed
  */
ErrorStatus CRYP_TDES_CBC(uint8_t Mode, uint8_t Key[24], uint8_t InitVectors[8],
                          uint8_t *Input, uint32_t Ilength, uint8_t *Output)
{
 800b042:	b590      	push	{r4, r7, lr}
 800b044:	b0ab      	sub	sp, #172	; 0xac
 800b046:	af00      	add	r7, sp, #0
 800b048:	60b9      	str	r1, [r7, #8]
 800b04a:	607a      	str	r2, [r7, #4]
 800b04c:	603b      	str	r3, [r7, #0]
 800b04e:	4603      	mov	r3, r0
 800b050:	73fb      	strb	r3, [r7, #15]
  CRYP_InitTypeDef TDES_CRYP_InitStructure;
  CRYP_KeyInitTypeDef TDES_CRYP_KeyInitStructure;
  CRYP_IVInitTypeDef TDES_CRYP_IVInitStructure;
  __IO uint32_t counter = 0;
 800b052:	2300      	movs	r3, #0
 800b054:	613b      	str	r3, [r7, #16]
  uint32_t busystatus = 0;
 800b056:	2300      	movs	r3, #0
 800b058:	f8c7 3094 	str.w	r3, [r7, #148]	; 0x94
  ErrorStatus status = SUCCESS;
 800b05c:	2301      	movs	r3, #1
 800b05e:	f887 30a7 	strb.w	r3, [r7, #167]	; 0xa7
  uint32_t keyaddr    = (uint32_t)Key;
 800b062:	68bb      	ldr	r3, [r7, #8]
 800b064:	f8c7 3090 	str.w	r3, [r7, #144]	; 0x90
  uint32_t inputaddr  = (uint32_t)Input;
 800b068:	683b      	ldr	r3, [r7, #0]
 800b06a:	f8c7 30a0 	str.w	r3, [r7, #160]	; 0xa0
  uint32_t outputaddr = (uint32_t)Output;
 800b06e:	f8d7 30bc 	ldr.w	r3, [r7, #188]	; 0xbc
 800b072:	f8c7 309c 	str.w	r3, [r7, #156]	; 0x9c
  uint32_t ivaddr     = (uint32_t)InitVectors;
 800b076:	687b      	ldr	r3, [r7, #4]
 800b078:	f8c7 308c 	str.w	r3, [r7, #140]	; 0x8c
  uint32_t i = 0;
 800b07c:	2300      	movs	r3, #0
 800b07e:	f8c7 3098 	str.w	r3, [r7, #152]	; 0x98

  /* Crypto structures initialisation*/
  CRYP_KeyStructInit(&TDES_CRYP_KeyInitStructure);
 800b082:	f107 0324 	add.w	r3, r7, #36	; 0x24
 800b086:	4618      	mov	r0, r3
 800b088:	f7fe fc82 	bl	8009990 <CRYP_KeyStructInit>

  /* Crypto Init for Encryption process */
  if(Mode == MODE_ENCRYPT) /* TDES encryption */
 800b08c:	7bfb      	ldrb	r3, [r7, #15]
 800b08e:	2b01      	cmp	r3, #1
 800b090:	d103      	bne.n	800b09a <CRYP_TDES_CBC+0x58>
  {
    TDES_CRYP_InitStructure.CRYP_AlgoDir = CRYP_AlgoDir_Encrypt;
 800b092:	2300      	movs	r3, #0
 800b094:	f8a7 3044 	strh.w	r3, [r7, #68]	; 0x44
 800b098:	e002      	b.n	800b0a0 <CRYP_TDES_CBC+0x5e>
  }
  else
  {
    TDES_CRYP_InitStructure.CRYP_AlgoDir = CRYP_AlgoDir_Decrypt;
 800b09a:	2304      	movs	r3, #4
 800b09c:	f8a7 3044 	strh.w	r3, [r7, #68]	; 0x44
  }
  TDES_CRYP_InitStructure.CRYP_AlgoMode = CRYP_AlgoMode_TDES_CBC;
 800b0a0:	2308      	movs	r3, #8
 800b0a2:	f8a7 3046 	strh.w	r3, [r7, #70]	; 0x46
  TDES_CRYP_InitStructure.CRYP_DataType = CRYP_DataType_8b;
 800b0a6:	2380      	movs	r3, #128	; 0x80
 800b0a8:	f8a7 3048 	strh.w	r3, [r7, #72]	; 0x48

  CRYP_Init(&TDES_CRYP_InitStructure);
 800b0ac:	f107 0344 	add.w	r3, r7, #68	; 0x44
 800b0b0:	4618      	mov	r0, r3
 800b0b2:	f7fe fbdb 	bl	800986c <CRYP_Init>

  /* Key Initialisation */
  TDES_CRYP_KeyInitStructure.CRYP_Key1Left = __REV(*(uint32_t*)(keyaddr));
 800b0b6:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
 800b0ba:	681b      	ldr	r3, [r3, #0]
 800b0bc:	653b      	str	r3, [r7, #80]	; 0x50
  __ASM volatile ("rev %0, %1" : "=r" (result) : "r" (value) );
 800b0be:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 800b0c0:	ba1b      	rev	r3, r3
 800b0c2:	64fb      	str	r3, [r7, #76]	; 0x4c
  return(result);
 800b0c4:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800b0c6:	62fb      	str	r3, [r7, #44]	; 0x2c
  keyaddr+=4;
 800b0c8:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
 800b0cc:	3304      	adds	r3, #4
 800b0ce:	f8c7 3090 	str.w	r3, [r7, #144]	; 0x90
  TDES_CRYP_KeyInitStructure.CRYP_Key1Right= __REV(*(uint32_t*)(keyaddr));
 800b0d2:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
 800b0d6:	681b      	ldr	r3, [r3, #0]
 800b0d8:	65bb      	str	r3, [r7, #88]	; 0x58
  __ASM volatile ("rev %0, %1" : "=r" (result) : "r" (value) );
 800b0da:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 800b0dc:	ba1b      	rev	r3, r3
 800b0de:	657b      	str	r3, [r7, #84]	; 0x54
  return(result);
 800b0e0:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 800b0e2:	633b      	str	r3, [r7, #48]	; 0x30
  keyaddr+=4;
 800b0e4:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
 800b0e8:	3304      	adds	r3, #4
 800b0ea:	f8c7 3090 	str.w	r3, [r7, #144]	; 0x90
  TDES_CRYP_KeyInitStructure.CRYP_Key2Left = __REV(*(uint32_t*)(keyaddr));
 800b0ee:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
 800b0f2:	681b      	ldr	r3, [r3, #0]
 800b0f4:	663b      	str	r3, [r7, #96]	; 0x60
  __ASM volatile ("rev %0, %1" : "=r" (result) : "r" (value) );
 800b0f6:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 800b0f8:	ba1b      	rev	r3, r3
 800b0fa:	65fb      	str	r3, [r7, #92]	; 0x5c
  return(result);
 800b0fc:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 800b0fe:	637b      	str	r3, [r7, #52]	; 0x34
  keyaddr+=4;
 800b100:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
 800b104:	3304      	adds	r3, #4
 800b106:	f8c7 3090 	str.w	r3, [r7, #144]	; 0x90
  TDES_CRYP_KeyInitStructure.CRYP_Key2Right= __REV(*(uint32_t*)(keyaddr));
 800b10a:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
 800b10e:	681b      	ldr	r3, [r3, #0]
 800b110:	66bb      	str	r3, [r7, #104]	; 0x68
  __ASM volatile ("rev %0, %1" : "=r" (result) : "r" (value) );
 800b112:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 800b114:	ba1b      	rev	r3, r3
 800b116:	667b      	str	r3, [r7, #100]	; 0x64
  return(result);
 800b118:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 800b11a:	63bb      	str	r3, [r7, #56]	; 0x38
  keyaddr+=4;
 800b11c:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
 800b120:	3304      	adds	r3, #4
 800b122:	f8c7 3090 	str.w	r3, [r7, #144]	; 0x90
  TDES_CRYP_KeyInitStructure.CRYP_Key3Left = __REV(*(uint32_t*)(keyaddr));
 800b126:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
 800b12a:	681b      	ldr	r3, [r3, #0]
 800b12c:	673b      	str	r3, [r7, #112]	; 0x70
  __ASM volatile ("rev %0, %1" : "=r" (result) : "r" (value) );
 800b12e:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 800b130:	ba1b      	rev	r3, r3
 800b132:	66fb      	str	r3, [r7, #108]	; 0x6c
  return(result);
 800b134:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 800b136:	63fb      	str	r3, [r7, #60]	; 0x3c
  keyaddr+=4;
 800b138:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
 800b13c:	3304      	adds	r3, #4
 800b13e:	f8c7 3090 	str.w	r3, [r7, #144]	; 0x90
  TDES_CRYP_KeyInitStructure.CRYP_Key3Right= __REV(*(uint32_t*)(keyaddr));
 800b142:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
 800b146:	681b      	ldr	r3, [r3, #0]
 800b148:	67bb      	str	r3, [r7, #120]	; 0x78
  __ASM volatile ("rev %0, %1" : "=r" (result) : "r" (value) );
 800b14a:	6fbb      	ldr	r3, [r7, #120]	; 0x78
 800b14c:	ba1b      	rev	r3, r3
 800b14e:	677b      	str	r3, [r7, #116]	; 0x74
  return(result);
 800b150:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 800b152:	643b      	str	r3, [r7, #64]	; 0x40
  CRYP_KeyInit(& TDES_CRYP_KeyInitStructure);
 800b154:	f107 0324 	add.w	r3, r7, #36	; 0x24
 800b158:	4618      	mov	r0, r3
 800b15a:	f7fe fbed 	bl	8009938 <CRYP_KeyInit>

  /* Initialization Vectors */
  TDES_CRYP_IVInitStructure.CRYP_IV0Left = __REV(*(uint32_t*)(ivaddr));
 800b15e:	f8d7 308c 	ldr.w	r3, [r7, #140]	; 0x8c
 800b162:	681b      	ldr	r3, [r3, #0]
 800b164:	f8c7 3080 	str.w	r3, [r7, #128]	; 0x80
  __ASM volatile ("rev %0, %1" : "=r" (result) : "r" (value) );
 800b168:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
 800b16c:	ba1b      	rev	r3, r3
 800b16e:	67fb      	str	r3, [r7, #124]	; 0x7c
  return(result);
 800b170:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
 800b172:	617b      	str	r3, [r7, #20]
  ivaddr+=4;
 800b174:	f8d7 308c 	ldr.w	r3, [r7, #140]	; 0x8c
 800b178:	3304      	adds	r3, #4
 800b17a:	f8c7 308c 	str.w	r3, [r7, #140]	; 0x8c
  TDES_CRYP_IVInitStructure.CRYP_IV0Right= __REV(*(uint32_t*)(ivaddr));
 800b17e:	f8d7 308c 	ldr.w	r3, [r7, #140]	; 0x8c
 800b182:	681b      	ldr	r3, [r3, #0]
 800b184:	f8c7 3088 	str.w	r3, [r7, #136]	; 0x88
  __ASM volatile ("rev %0, %1" : "=r" (result) : "r" (value) );
 800b188:	f8d7 3088 	ldr.w	r3, [r7, #136]	; 0x88
 800b18c:	ba1b      	rev	r3, r3
 800b18e:	f8c7 3084 	str.w	r3, [r7, #132]	; 0x84
  return(result);
 800b192:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
 800b196:	61bb      	str	r3, [r7, #24]
  CRYP_IVInit(&TDES_CRYP_IVInitStructure);
 800b198:	f107 0314 	add.w	r3, r7, #20
 800b19c:	4618      	mov	r0, r3
 800b19e:	f7fe fc19 	bl	80099d4 <CRYP_IVInit>

  /* Flush IN/OUT FIFO */
  CRYP_FIFOFlush();
 800b1a2:	f7fe fc49 	bl	8009a38 <CRYP_FIFOFlush>

  /* Enable Crypto processor */
  CRYP_Cmd(ENABLE);
 800b1a6:	2001      	movs	r0, #1
 800b1a8:	f7fe fc56 	bl	8009a58 <CRYP_Cmd>

  for(i=0; ((i<Ilength) && (status != ERROR)); i+=8)
 800b1ac:	2300      	movs	r3, #0
 800b1ae:	f8c7 3098 	str.w	r3, [r7, #152]	; 0x98
 800b1b2:	e04b      	b.n	800b24c <CRYP_TDES_CBC+0x20a>
  {
    /* Write the Input block in the Input FIFO */
    CRYP_DataIn(*(uint32_t*)(inputaddr));
 800b1b4:	f8d7 30a0 	ldr.w	r3, [r7, #160]	; 0xa0
 800b1b8:	681b      	ldr	r3, [r3, #0]
 800b1ba:	4618      	mov	r0, r3
 800b1bc:	f7fe fc6a 	bl	8009a94 <CRYP_DataIn>
    inputaddr+=4;
 800b1c0:	f8d7 30a0 	ldr.w	r3, [r7, #160]	; 0xa0
 800b1c4:	3304      	adds	r3, #4
 800b1c6:	f8c7 30a0 	str.w	r3, [r7, #160]	; 0xa0
    CRYP_DataIn(*(uint32_t*)(inputaddr));
 800b1ca:	f8d7 30a0 	ldr.w	r3, [r7, #160]	; 0xa0
 800b1ce:	681b      	ldr	r3, [r3, #0]
 800b1d0:	4618      	mov	r0, r3
 800b1d2:	f7fe fc5f 	bl	8009a94 <CRYP_DataIn>
    inputaddr+=4;
 800b1d6:	f8d7 30a0 	ldr.w	r3, [r7, #160]	; 0xa0
 800b1da:	3304      	adds	r3, #4
 800b1dc:	f8c7 30a0 	str.w	r3, [r7, #160]	; 0xa0

    /* Wait until the complete message has been processed */
    counter = 0;
 800b1e0:	2300      	movs	r3, #0
 800b1e2:	613b      	str	r3, [r7, #16]
    do
    {
      busystatus = CRYP_GetFlagStatus(CRYP_FLAG_BUSY);
 800b1e4:	2010      	movs	r0, #16
 800b1e6:	f7fe fd99 	bl	8009d1c <CRYP_GetFlagStatus>
 800b1ea:	4603      	mov	r3, r0
 800b1ec:	f8c7 3094 	str.w	r3, [r7, #148]	; 0x94
      counter++;
 800b1f0:	693b      	ldr	r3, [r7, #16]
 800b1f2:	3301      	adds	r3, #1
 800b1f4:	613b      	str	r3, [r7, #16]
    }while ((counter != TDESBUSY_TIMEOUT) && (busystatus != RESET));
 800b1f6:	693b      	ldr	r3, [r7, #16]
 800b1f8:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 800b1fc:	d003      	beq.n	800b206 <CRYP_TDES_CBC+0x1c4>
 800b1fe:	f8d7 3094 	ldr.w	r3, [r7, #148]	; 0x94
 800b202:	2b00      	cmp	r3, #0
 800b204:	d1ee      	bne.n	800b1e4 <CRYP_TDES_CBC+0x1a2>

    if (busystatus != RESET)
 800b206:	f8d7 3094 	ldr.w	r3, [r7, #148]	; 0x94
 800b20a:	2b00      	cmp	r3, #0
 800b20c:	d003      	beq.n	800b216 <CRYP_TDES_CBC+0x1d4>
   {
       status = ERROR;
 800b20e:	2300      	movs	r3, #0
 800b210:	f887 30a7 	strb.w	r3, [r7, #167]	; 0xa7
 800b214:	e015      	b.n	800b242 <CRYP_TDES_CBC+0x200>
    }
    else
    {

      /* Read the Output block from the Output FIFO */
      *(uint32_t*)(outputaddr) = CRYP_DataOut();
 800b216:	f8d7 409c 	ldr.w	r4, [r7, #156]	; 0x9c
 800b21a:	f7fe fc4b 	bl	8009ab4 <CRYP_DataOut>
 800b21e:	4603      	mov	r3, r0
 800b220:	6023      	str	r3, [r4, #0]
      outputaddr+=4;
 800b222:	f8d7 309c 	ldr.w	r3, [r7, #156]	; 0x9c
 800b226:	3304      	adds	r3, #4
 800b228:	f8c7 309c 	str.w	r3, [r7, #156]	; 0x9c
      *(uint32_t*)(outputaddr) = CRYP_DataOut();
 800b22c:	f8d7 409c 	ldr.w	r4, [r7, #156]	; 0x9c
 800b230:	f7fe fc40 	bl	8009ab4 <CRYP_DataOut>
 800b234:	4603      	mov	r3, r0
 800b236:	6023      	str	r3, [r4, #0]
      outputaddr+=4;
 800b238:	f8d7 309c 	ldr.w	r3, [r7, #156]	; 0x9c
 800b23c:	3304      	adds	r3, #4
 800b23e:	f8c7 309c 	str.w	r3, [r7, #156]	; 0x9c
  for(i=0; ((i<Ilength) && (status != ERROR)); i+=8)
 800b242:	f8d7 3098 	ldr.w	r3, [r7, #152]	; 0x98
 800b246:	3308      	adds	r3, #8
 800b248:	f8c7 3098 	str.w	r3, [r7, #152]	; 0x98
 800b24c:	f8d7 2098 	ldr.w	r2, [r7, #152]	; 0x98
 800b250:	f8d7 30b8 	ldr.w	r3, [r7, #184]	; 0xb8
 800b254:	429a      	cmp	r2, r3
 800b256:	d203      	bcs.n	800b260 <CRYP_TDES_CBC+0x21e>
 800b258:	f897 30a7 	ldrb.w	r3, [r7, #167]	; 0xa7
 800b25c:	2b00      	cmp	r3, #0
 800b25e:	d1a9      	bne.n	800b1b4 <CRYP_TDES_CBC+0x172>
    }
  }

  /* Disable Crypto */
  CRYP_Cmd(DISABLE);
 800b260:	2000      	movs	r0, #0
 800b262:	f7fe fbf9 	bl	8009a58 <CRYP_Cmd>

  return status; 
 800b266:	f897 30a7 	ldrb.w	r3, [r7, #167]	; 0xa7
}
 800b26a:	4618      	mov	r0, r3
 800b26c:	37ac      	adds	r7, #172	; 0xac
 800b26e:	46bd      	mov	sp, r7
 800b270:	bd90      	pop	{r4, r7, pc}
	...

0800b274 <DAC_DeInit>:
  * @brief  Deinitializes the DAC peripheral registers to their default reset values.
  * @param  None
  * @retval None
  */
void DAC_DeInit(void)
{
 800b274:	b580      	push	{r7, lr}
 800b276:	af00      	add	r7, sp, #0
  /* Enable DAC reset state */
  RCC_APB1PeriphResetCmd(RCC_APB1Periph_DAC, ENABLE);
 800b278:	2101      	movs	r1, #1
 800b27a:	f04f 5000 	mov.w	r0, #536870912	; 0x20000000
 800b27e:	f004 fb49 	bl	800f914 <RCC_APB1PeriphResetCmd>
  /* Release DAC from reset state */
  RCC_APB1PeriphResetCmd(RCC_APB1Periph_DAC, DISABLE);
 800b282:	2100      	movs	r1, #0
 800b284:	f04f 5000 	mov.w	r0, #536870912	; 0x20000000
 800b288:	f004 fb44 	bl	800f914 <RCC_APB1PeriphResetCmd>
}
 800b28c:	bf00      	nop
 800b28e:	bd80      	pop	{r7, pc}

0800b290 <DAC_Init>:
  * @param  DAC_InitStruct: pointer to a DAC_InitTypeDef structure that contains
  *         the configuration information for the  specified DAC channel.
  * @retval None
  */
void DAC_Init(uint32_t DAC_Channel, DAC_InitTypeDef* DAC_InitStruct)
{
 800b290:	b480      	push	{r7}
 800b292:	b085      	sub	sp, #20
 800b294:	af00      	add	r7, sp, #0
 800b296:	6078      	str	r0, [r7, #4]
 800b298:	6039      	str	r1, [r7, #0]
  uint32_t tmpreg1 = 0, tmpreg2 = 0;
 800b29a:	2300      	movs	r3, #0
 800b29c:	60fb      	str	r3, [r7, #12]
 800b29e:	2300      	movs	r3, #0
 800b2a0:	60bb      	str	r3, [r7, #8]
  assert_param(IS_DAC_LFSR_UNMASK_TRIANGLE_AMPLITUDE(DAC_InitStruct->DAC_LFSRUnmask_TriangleAmplitude));
  assert_param(IS_DAC_OUTPUT_BUFFER_STATE(DAC_InitStruct->DAC_OutputBuffer));

/*---------------------------- DAC CR Configuration --------------------------*/
  /* Get the DAC CR value */
  tmpreg1 = DAC->CR;
 800b2a2:	4b14      	ldr	r3, [pc, #80]	; (800b2f4 <DAC_Init+0x64>)
 800b2a4:	681b      	ldr	r3, [r3, #0]
 800b2a6:	60fb      	str	r3, [r7, #12]
  /* Clear BOFFx, TENx, TSELx, WAVEx and MAMPx bits */
  tmpreg1 &= ~(CR_CLEAR_MASK << DAC_Channel);
 800b2a8:	f640 72fe 	movw	r2, #4094	; 0xffe
 800b2ac:	687b      	ldr	r3, [r7, #4]
 800b2ae:	fa02 f303 	lsl.w	r3, r2, r3
 800b2b2:	43db      	mvns	r3, r3
 800b2b4:	68fa      	ldr	r2, [r7, #12]
 800b2b6:	4013      	ands	r3, r2
 800b2b8:	60fb      	str	r3, [r7, #12]
     wave generation, mask/amplitude for wave generation */
  /* Set TSELx and TENx bits according to DAC_Trigger value */
  /* Set WAVEx bits according to DAC_WaveGeneration value */
  /* Set MAMPx bits according to DAC_LFSRUnmask_TriangleAmplitude value */ 
  /* Set BOFFx bit according to DAC_OutputBuffer value */   
  tmpreg2 = (DAC_InitStruct->DAC_Trigger | DAC_InitStruct->DAC_WaveGeneration |
 800b2ba:	683b      	ldr	r3, [r7, #0]
 800b2bc:	681a      	ldr	r2, [r3, #0]
 800b2be:	683b      	ldr	r3, [r7, #0]
 800b2c0:	685b      	ldr	r3, [r3, #4]
 800b2c2:	431a      	orrs	r2, r3
             DAC_InitStruct->DAC_LFSRUnmask_TriangleAmplitude | \
 800b2c4:	683b      	ldr	r3, [r7, #0]
 800b2c6:	689b      	ldr	r3, [r3, #8]
  tmpreg2 = (DAC_InitStruct->DAC_Trigger | DAC_InitStruct->DAC_WaveGeneration |
 800b2c8:	431a      	orrs	r2, r3
             DAC_InitStruct->DAC_OutputBuffer);
 800b2ca:	683b      	ldr	r3, [r7, #0]
 800b2cc:	68db      	ldr	r3, [r3, #12]
  tmpreg2 = (DAC_InitStruct->DAC_Trigger | DAC_InitStruct->DAC_WaveGeneration |
 800b2ce:	4313      	orrs	r3, r2
 800b2d0:	60bb      	str	r3, [r7, #8]
  /* Calculate CR register value depending on DAC_Channel */
  tmpreg1 |= tmpreg2 << DAC_Channel;
 800b2d2:	68ba      	ldr	r2, [r7, #8]
 800b2d4:	687b      	ldr	r3, [r7, #4]
 800b2d6:	fa02 f303 	lsl.w	r3, r2, r3
 800b2da:	68fa      	ldr	r2, [r7, #12]
 800b2dc:	4313      	orrs	r3, r2
 800b2de:	60fb      	str	r3, [r7, #12]
  /* Write to DAC CR */
  DAC->CR = tmpreg1;
 800b2e0:	4a04      	ldr	r2, [pc, #16]	; (800b2f4 <DAC_Init+0x64>)
 800b2e2:	68fb      	ldr	r3, [r7, #12]
 800b2e4:	6013      	str	r3, [r2, #0]
}
 800b2e6:	bf00      	nop
 800b2e8:	3714      	adds	r7, #20
 800b2ea:	46bd      	mov	sp, r7
 800b2ec:	f85d 7b04 	ldr.w	r7, [sp], #4
 800b2f0:	4770      	bx	lr
 800b2f2:	bf00      	nop
 800b2f4:	40007400 	.word	0x40007400

0800b2f8 <DAC_StructInit>:
  * @param  DAC_InitStruct: pointer to a DAC_InitTypeDef structure which will 
  *         be initialized.
  * @retval None
  */
void DAC_StructInit(DAC_InitTypeDef* DAC_InitStruct)
{
 800b2f8:	b480      	push	{r7}
 800b2fa:	b083      	sub	sp, #12
 800b2fc:	af00      	add	r7, sp, #0
 800b2fe:	6078      	str	r0, [r7, #4]
/*--------------- Reset DAC init structure parameters values -----------------*/
  /* Initialize the DAC_Trigger member */
  DAC_InitStruct->DAC_Trigger = DAC_Trigger_None;
 800b300:	687b      	ldr	r3, [r7, #4]
 800b302:	2200      	movs	r2, #0
 800b304:	601a      	str	r2, [r3, #0]
  /* Initialize the DAC_WaveGeneration member */
  DAC_InitStruct->DAC_WaveGeneration = DAC_WaveGeneration_None;
 800b306:	687b      	ldr	r3, [r7, #4]
 800b308:	2200      	movs	r2, #0
 800b30a:	605a      	str	r2, [r3, #4]
  /* Initialize the DAC_LFSRUnmask_TriangleAmplitude member */
  DAC_InitStruct->DAC_LFSRUnmask_TriangleAmplitude = DAC_LFSRUnmask_Bit0;
 800b30c:	687b      	ldr	r3, [r7, #4]
 800b30e:	2200      	movs	r2, #0
 800b310:	609a      	str	r2, [r3, #8]
  /* Initialize the DAC_OutputBuffer member */
  DAC_InitStruct->DAC_OutputBuffer = DAC_OutputBuffer_Enable;
 800b312:	687b      	ldr	r3, [r7, #4]
 800b314:	2200      	movs	r2, #0
 800b316:	60da      	str	r2, [r3, #12]
}
 800b318:	bf00      	nop
 800b31a:	370c      	adds	r7, #12
 800b31c:	46bd      	mov	sp, r7
 800b31e:	f85d 7b04 	ldr.w	r7, [sp], #4
 800b322:	4770      	bx	lr

0800b324 <DAC_Cmd>:
  *          This parameter can be: ENABLE or DISABLE.
  * @note   When the DAC channel is enabled the trigger source can no more be modified.
  * @retval None
  */
void DAC_Cmd(uint32_t DAC_Channel, FunctionalState NewState)
{
 800b324:	b480      	push	{r7}
 800b326:	b083      	sub	sp, #12
 800b328:	af00      	add	r7, sp, #0
 800b32a:	6078      	str	r0, [r7, #4]
 800b32c:	460b      	mov	r3, r1
 800b32e:	70fb      	strb	r3, [r7, #3]
  /* Check the parameters */
  assert_param(IS_DAC_CHANNEL(DAC_Channel));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 800b330:	78fb      	ldrb	r3, [r7, #3]
 800b332:	2b00      	cmp	r3, #0
 800b334:	d009      	beq.n	800b34a <DAC_Cmd+0x26>
  {
    /* Enable the selected DAC channel */
    DAC->CR |= (DAC_CR_EN1 << DAC_Channel);
 800b336:	490d      	ldr	r1, [pc, #52]	; (800b36c <DAC_Cmd+0x48>)
 800b338:	4b0c      	ldr	r3, [pc, #48]	; (800b36c <DAC_Cmd+0x48>)
 800b33a:	681a      	ldr	r2, [r3, #0]
 800b33c:	2001      	movs	r0, #1
 800b33e:	687b      	ldr	r3, [r7, #4]
 800b340:	fa00 f303 	lsl.w	r3, r0, r3
 800b344:	4313      	orrs	r3, r2
 800b346:	600b      	str	r3, [r1, #0]
  else
  {
    /* Disable the selected DAC channel */
    DAC->CR &= (~(DAC_CR_EN1 << DAC_Channel));
  }
}
 800b348:	e009      	b.n	800b35e <DAC_Cmd+0x3a>
    DAC->CR &= (~(DAC_CR_EN1 << DAC_Channel));
 800b34a:	4908      	ldr	r1, [pc, #32]	; (800b36c <DAC_Cmd+0x48>)
 800b34c:	4b07      	ldr	r3, [pc, #28]	; (800b36c <DAC_Cmd+0x48>)
 800b34e:	681a      	ldr	r2, [r3, #0]
 800b350:	2001      	movs	r0, #1
 800b352:	687b      	ldr	r3, [r7, #4]
 800b354:	fa00 f303 	lsl.w	r3, r0, r3
 800b358:	43db      	mvns	r3, r3
 800b35a:	4013      	ands	r3, r2
 800b35c:	600b      	str	r3, [r1, #0]
}
 800b35e:	bf00      	nop
 800b360:	370c      	adds	r7, #12
 800b362:	46bd      	mov	sp, r7
 800b364:	f85d 7b04 	ldr.w	r7, [sp], #4
 800b368:	4770      	bx	lr
 800b36a:	bf00      	nop
 800b36c:	40007400 	.word	0x40007400

0800b370 <DAC_SoftwareTriggerCmd>:
  * @param  NewState: new state of the selected DAC channel software trigger.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void DAC_SoftwareTriggerCmd(uint32_t DAC_Channel, FunctionalState NewState)
{
 800b370:	b480      	push	{r7}
 800b372:	b083      	sub	sp, #12
 800b374:	af00      	add	r7, sp, #0
 800b376:	6078      	str	r0, [r7, #4]
 800b378:	460b      	mov	r3, r1
 800b37a:	70fb      	strb	r3, [r7, #3]
  /* Check the parameters */
  assert_param(IS_DAC_CHANNEL(DAC_Channel));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 800b37c:	78fb      	ldrb	r3, [r7, #3]
 800b37e:	2b00      	cmp	r3, #0
 800b380:	d00a      	beq.n	800b398 <DAC_SoftwareTriggerCmd+0x28>
  {
    /* Enable software trigger for the selected DAC channel */
    DAC->SWTRIGR |= (uint32_t)DAC_SWTRIGR_SWTRIG1 << (DAC_Channel >> 4);
 800b382:	490e      	ldr	r1, [pc, #56]	; (800b3bc <DAC_SoftwareTriggerCmd+0x4c>)
 800b384:	4b0d      	ldr	r3, [pc, #52]	; (800b3bc <DAC_SoftwareTriggerCmd+0x4c>)
 800b386:	685a      	ldr	r2, [r3, #4]
 800b388:	687b      	ldr	r3, [r7, #4]
 800b38a:	091b      	lsrs	r3, r3, #4
 800b38c:	2001      	movs	r0, #1
 800b38e:	fa00 f303 	lsl.w	r3, r0, r3
 800b392:	4313      	orrs	r3, r2
 800b394:	604b      	str	r3, [r1, #4]
  else
  {
    /* Disable software trigger for the selected DAC channel */
    DAC->SWTRIGR &= ~((uint32_t)DAC_SWTRIGR_SWTRIG1 << (DAC_Channel >> 4));
  }
}
 800b396:	e00a      	b.n	800b3ae <DAC_SoftwareTriggerCmd+0x3e>
    DAC->SWTRIGR &= ~((uint32_t)DAC_SWTRIGR_SWTRIG1 << (DAC_Channel >> 4));
 800b398:	4908      	ldr	r1, [pc, #32]	; (800b3bc <DAC_SoftwareTriggerCmd+0x4c>)
 800b39a:	4b08      	ldr	r3, [pc, #32]	; (800b3bc <DAC_SoftwareTriggerCmd+0x4c>)
 800b39c:	685a      	ldr	r2, [r3, #4]
 800b39e:	687b      	ldr	r3, [r7, #4]
 800b3a0:	091b      	lsrs	r3, r3, #4
 800b3a2:	2001      	movs	r0, #1
 800b3a4:	fa00 f303 	lsl.w	r3, r0, r3
 800b3a8:	43db      	mvns	r3, r3
 800b3aa:	4013      	ands	r3, r2
 800b3ac:	604b      	str	r3, [r1, #4]
}
 800b3ae:	bf00      	nop
 800b3b0:	370c      	adds	r7, #12
 800b3b2:	46bd      	mov	sp, r7
 800b3b4:	f85d 7b04 	ldr.w	r7, [sp], #4
 800b3b8:	4770      	bx	lr
 800b3ba:	bf00      	nop
 800b3bc:	40007400 	.word	0x40007400

0800b3c0 <DAC_DualSoftwareTriggerCmd>:
  * @param  NewState: new state of the DAC channels software triggers.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void DAC_DualSoftwareTriggerCmd(FunctionalState NewState)
{
 800b3c0:	b480      	push	{r7}
 800b3c2:	b083      	sub	sp, #12
 800b3c4:	af00      	add	r7, sp, #0
 800b3c6:	4603      	mov	r3, r0
 800b3c8:	71fb      	strb	r3, [r7, #7]
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 800b3ca:	79fb      	ldrb	r3, [r7, #7]
 800b3cc:	2b00      	cmp	r3, #0
 800b3ce:	d006      	beq.n	800b3de <DAC_DualSoftwareTriggerCmd+0x1e>
  {
    /* Enable software trigger for both DAC channels */
    DAC->SWTRIGR |= DUAL_SWTRIG_SET;
 800b3d0:	4a09      	ldr	r2, [pc, #36]	; (800b3f8 <DAC_DualSoftwareTriggerCmd+0x38>)
 800b3d2:	4b09      	ldr	r3, [pc, #36]	; (800b3f8 <DAC_DualSoftwareTriggerCmd+0x38>)
 800b3d4:	685b      	ldr	r3, [r3, #4]
 800b3d6:	f043 0303 	orr.w	r3, r3, #3
 800b3da:	6053      	str	r3, [r2, #4]
  else
  {
    /* Disable software trigger for both DAC channels */
    DAC->SWTRIGR &= DUAL_SWTRIG_RESET;
  }
}
 800b3dc:	e005      	b.n	800b3ea <DAC_DualSoftwareTriggerCmd+0x2a>
    DAC->SWTRIGR &= DUAL_SWTRIG_RESET;
 800b3de:	4a06      	ldr	r2, [pc, #24]	; (800b3f8 <DAC_DualSoftwareTriggerCmd+0x38>)
 800b3e0:	4b05      	ldr	r3, [pc, #20]	; (800b3f8 <DAC_DualSoftwareTriggerCmd+0x38>)
 800b3e2:	685b      	ldr	r3, [r3, #4]
 800b3e4:	f023 0303 	bic.w	r3, r3, #3
 800b3e8:	6053      	str	r3, [r2, #4]
}
 800b3ea:	bf00      	nop
 800b3ec:	370c      	adds	r7, #12
 800b3ee:	46bd      	mov	sp, r7
 800b3f0:	f85d 7b04 	ldr.w	r7, [sp], #4
 800b3f4:	4770      	bx	lr
 800b3f6:	bf00      	nop
 800b3f8:	40007400 	.word	0x40007400

0800b3fc <DAC_WaveGenerationCmd>:
  * @param  NewState: new state of the selected DAC channel wave generation.
  *          This parameter can be: ENABLE or DISABLE.  
  * @retval None
  */
void DAC_WaveGenerationCmd(uint32_t DAC_Channel, uint32_t DAC_Wave, FunctionalState NewState)
{
 800b3fc:	b480      	push	{r7}
 800b3fe:	b085      	sub	sp, #20
 800b400:	af00      	add	r7, sp, #0
 800b402:	60f8      	str	r0, [r7, #12]
 800b404:	60b9      	str	r1, [r7, #8]
 800b406:	4613      	mov	r3, r2
 800b408:	71fb      	strb	r3, [r7, #7]
  /* Check the parameters */
  assert_param(IS_DAC_CHANNEL(DAC_Channel));
  assert_param(IS_DAC_WAVE(DAC_Wave)); 
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 800b40a:	79fb      	ldrb	r3, [r7, #7]
 800b40c:	2b00      	cmp	r3, #0
 800b40e:	d009      	beq.n	800b424 <DAC_WaveGenerationCmd+0x28>
  {
    /* Enable the selected wave generation for the selected DAC channel */
    DAC->CR |= DAC_Wave << DAC_Channel;
 800b410:	480c      	ldr	r0, [pc, #48]	; (800b444 <DAC_WaveGenerationCmd+0x48>)
 800b412:	4b0c      	ldr	r3, [pc, #48]	; (800b444 <DAC_WaveGenerationCmd+0x48>)
 800b414:	681a      	ldr	r2, [r3, #0]
 800b416:	68b9      	ldr	r1, [r7, #8]
 800b418:	68fb      	ldr	r3, [r7, #12]
 800b41a:	fa01 f303 	lsl.w	r3, r1, r3
 800b41e:	4313      	orrs	r3, r2
 800b420:	6003      	str	r3, [r0, #0]
  else
  {
    /* Disable the selected wave generation for the selected DAC channel */
    DAC->CR &= ~(DAC_Wave << DAC_Channel);
  }
}
 800b422:	e009      	b.n	800b438 <DAC_WaveGenerationCmd+0x3c>
    DAC->CR &= ~(DAC_Wave << DAC_Channel);
 800b424:	4807      	ldr	r0, [pc, #28]	; (800b444 <DAC_WaveGenerationCmd+0x48>)
 800b426:	4b07      	ldr	r3, [pc, #28]	; (800b444 <DAC_WaveGenerationCmd+0x48>)
 800b428:	681a      	ldr	r2, [r3, #0]
 800b42a:	68b9      	ldr	r1, [r7, #8]
 800b42c:	68fb      	ldr	r3, [r7, #12]
 800b42e:	fa01 f303 	lsl.w	r3, r1, r3
 800b432:	43db      	mvns	r3, r3
 800b434:	4013      	ands	r3, r2
 800b436:	6003      	str	r3, [r0, #0]
}
 800b438:	bf00      	nop
 800b43a:	3714      	adds	r7, #20
 800b43c:	46bd      	mov	sp, r7
 800b43e:	f85d 7b04 	ldr.w	r7, [sp], #4
 800b442:	4770      	bx	lr
 800b444:	40007400 	.word	0x40007400

0800b448 <DAC_SetChannel1Data>:
  *            @arg DAC_Align_12b_R: 12bit right data alignment selected
  * @param  Data: Data to be loaded in the selected data holding register.
  * @retval None
  */
void DAC_SetChannel1Data(uint32_t DAC_Align, uint16_t Data)
{  
 800b448:	b480      	push	{r7}
 800b44a:	b085      	sub	sp, #20
 800b44c:	af00      	add	r7, sp, #0
 800b44e:	6078      	str	r0, [r7, #4]
 800b450:	460b      	mov	r3, r1
 800b452:	807b      	strh	r3, [r7, #2]
  __IO uint32_t tmp = 0;
 800b454:	2300      	movs	r3, #0
 800b456:	60fb      	str	r3, [r7, #12]
  
  /* Check the parameters */
  assert_param(IS_DAC_ALIGN(DAC_Align));
  assert_param(IS_DAC_DATA(Data));
  
  tmp = (uint32_t)DAC_BASE; 
 800b458:	4b08      	ldr	r3, [pc, #32]	; (800b47c <DAC_SetChannel1Data+0x34>)
 800b45a:	60fb      	str	r3, [r7, #12]
  tmp += DHR12R1_OFFSET + DAC_Align;
 800b45c:	68fa      	ldr	r2, [r7, #12]
 800b45e:	687b      	ldr	r3, [r7, #4]
 800b460:	4413      	add	r3, r2
 800b462:	3308      	adds	r3, #8
 800b464:	60fb      	str	r3, [r7, #12]

  /* Set the DAC channel1 selected data holding register */
  *(__IO uint32_t *) tmp = Data;
 800b466:	68fb      	ldr	r3, [r7, #12]
 800b468:	461a      	mov	r2, r3
 800b46a:	887b      	ldrh	r3, [r7, #2]
 800b46c:	6013      	str	r3, [r2, #0]
}
 800b46e:	bf00      	nop
 800b470:	3714      	adds	r7, #20
 800b472:	46bd      	mov	sp, r7
 800b474:	f85d 7b04 	ldr.w	r7, [sp], #4
 800b478:	4770      	bx	lr
 800b47a:	bf00      	nop
 800b47c:	40007400 	.word	0x40007400

0800b480 <DAC_SetChannel2Data>:
  *            @arg DAC_Align_12b_R: 12bit right data alignment selected
  * @param  Data: Data to be loaded in the selected data holding register.
  * @retval None
  */
void DAC_SetChannel2Data(uint32_t DAC_Align, uint16_t Data)
{
 800b480:	b480      	push	{r7}
 800b482:	b085      	sub	sp, #20
 800b484:	af00      	add	r7, sp, #0
 800b486:	6078      	str	r0, [r7, #4]
 800b488:	460b      	mov	r3, r1
 800b48a:	807b      	strh	r3, [r7, #2]
  __IO uint32_t tmp = 0;
 800b48c:	2300      	movs	r3, #0
 800b48e:	60fb      	str	r3, [r7, #12]

  /* Check the parameters */
  assert_param(IS_DAC_ALIGN(DAC_Align));
  assert_param(IS_DAC_DATA(Data));
  
  tmp = (uint32_t)DAC_BASE;
 800b490:	4b08      	ldr	r3, [pc, #32]	; (800b4b4 <DAC_SetChannel2Data+0x34>)
 800b492:	60fb      	str	r3, [r7, #12]
  tmp += DHR12R2_OFFSET + DAC_Align;
 800b494:	68fa      	ldr	r2, [r7, #12]
 800b496:	687b      	ldr	r3, [r7, #4]
 800b498:	4413      	add	r3, r2
 800b49a:	3314      	adds	r3, #20
 800b49c:	60fb      	str	r3, [r7, #12]

  /* Set the DAC channel2 selected data holding register */
  *(__IO uint32_t *)tmp = Data;
 800b49e:	68fb      	ldr	r3, [r7, #12]
 800b4a0:	461a      	mov	r2, r3
 800b4a2:	887b      	ldrh	r3, [r7, #2]
 800b4a4:	6013      	str	r3, [r2, #0]
}
 800b4a6:	bf00      	nop
 800b4a8:	3714      	adds	r7, #20
 800b4aa:	46bd      	mov	sp, r7
 800b4ac:	f85d 7b04 	ldr.w	r7, [sp], #4
 800b4b0:	4770      	bx	lr
 800b4b2:	bf00      	nop
 800b4b4:	40007400 	.word	0x40007400

0800b4b8 <DAC_SetDualChannelData>:
  * @note   In dual mode, a unique register access is required to write in both
  *          DAC channels at the same time.
  * @retval None
  */
void DAC_SetDualChannelData(uint32_t DAC_Align, uint16_t Data2, uint16_t Data1)
{
 800b4b8:	b480      	push	{r7}
 800b4ba:	b085      	sub	sp, #20
 800b4bc:	af00      	add	r7, sp, #0
 800b4be:	6078      	str	r0, [r7, #4]
 800b4c0:	460b      	mov	r3, r1
 800b4c2:	807b      	strh	r3, [r7, #2]
 800b4c4:	4613      	mov	r3, r2
 800b4c6:	803b      	strh	r3, [r7, #0]
  uint32_t data = 0, tmp = 0;
 800b4c8:	2300      	movs	r3, #0
 800b4ca:	60fb      	str	r3, [r7, #12]
 800b4cc:	2300      	movs	r3, #0
 800b4ce:	60bb      	str	r3, [r7, #8]
  assert_param(IS_DAC_ALIGN(DAC_Align));
  assert_param(IS_DAC_DATA(Data1));
  assert_param(IS_DAC_DATA(Data2));
  
  /* Calculate and set dual DAC data holding register value */
  if (DAC_Align == DAC_Align_8b_R)
 800b4d0:	687b      	ldr	r3, [r7, #4]
 800b4d2:	2b08      	cmp	r3, #8
 800b4d4:	d105      	bne.n	800b4e2 <DAC_SetDualChannelData+0x2a>
  {
    data = ((uint32_t)Data2 << 8) | Data1; 
 800b4d6:	887b      	ldrh	r3, [r7, #2]
 800b4d8:	021a      	lsls	r2, r3, #8
 800b4da:	883b      	ldrh	r3, [r7, #0]
 800b4dc:	4313      	orrs	r3, r2
 800b4de:	60fb      	str	r3, [r7, #12]
 800b4e0:	e004      	b.n	800b4ec <DAC_SetDualChannelData+0x34>
  }
  else
  {
    data = ((uint32_t)Data2 << 16) | Data1;
 800b4e2:	887b      	ldrh	r3, [r7, #2]
 800b4e4:	041a      	lsls	r2, r3, #16
 800b4e6:	883b      	ldrh	r3, [r7, #0]
 800b4e8:	4313      	orrs	r3, r2
 800b4ea:	60fb      	str	r3, [r7, #12]
  }
  
  tmp = (uint32_t)DAC_BASE;
 800b4ec:	4b07      	ldr	r3, [pc, #28]	; (800b50c <DAC_SetDualChannelData+0x54>)
 800b4ee:	60bb      	str	r3, [r7, #8]
  tmp += DHR12RD_OFFSET + DAC_Align;
 800b4f0:	687a      	ldr	r2, [r7, #4]
 800b4f2:	68bb      	ldr	r3, [r7, #8]
 800b4f4:	4413      	add	r3, r2
 800b4f6:	3320      	adds	r3, #32
 800b4f8:	60bb      	str	r3, [r7, #8]

  /* Set the dual DAC selected data holding register */
  *(__IO uint32_t *)tmp = data;
 800b4fa:	68bb      	ldr	r3, [r7, #8]
 800b4fc:	68fa      	ldr	r2, [r7, #12]
 800b4fe:	601a      	str	r2, [r3, #0]
}
 800b500:	bf00      	nop
 800b502:	3714      	adds	r7, #20
 800b504:	46bd      	mov	sp, r7
 800b506:	f85d 7b04 	ldr.w	r7, [sp], #4
 800b50a:	4770      	bx	lr
 800b50c:	40007400 	.word	0x40007400

0800b510 <DAC_GetDataOutputValue>:
  *            @arg DAC_Channel_1: DAC Channel1 selected
  *            @arg DAC_Channel_2: DAC Channel2 selected
  * @retval The selected DAC channel data output value.
  */
uint16_t DAC_GetDataOutputValue(uint32_t DAC_Channel)
{
 800b510:	b480      	push	{r7}
 800b512:	b085      	sub	sp, #20
 800b514:	af00      	add	r7, sp, #0
 800b516:	6078      	str	r0, [r7, #4]
  __IO uint32_t tmp = 0;
 800b518:	2300      	movs	r3, #0
 800b51a:	60fb      	str	r3, [r7, #12]
  
  /* Check the parameters */
  assert_param(IS_DAC_CHANNEL(DAC_Channel));
  
  tmp = (uint32_t) DAC_BASE ;
 800b51c:	4b08      	ldr	r3, [pc, #32]	; (800b540 <DAC_GetDataOutputValue+0x30>)
 800b51e:	60fb      	str	r3, [r7, #12]
  tmp += DOR_OFFSET + ((uint32_t)DAC_Channel >> 2);
 800b520:	687b      	ldr	r3, [r7, #4]
 800b522:	089a      	lsrs	r2, r3, #2
 800b524:	68fb      	ldr	r3, [r7, #12]
 800b526:	4413      	add	r3, r2
 800b528:	332c      	adds	r3, #44	; 0x2c
 800b52a:	60fb      	str	r3, [r7, #12]
  
  /* Returns the DAC channel data output register value */
  return (uint16_t) (*(__IO uint32_t*) tmp);
 800b52c:	68fb      	ldr	r3, [r7, #12]
 800b52e:	681b      	ldr	r3, [r3, #0]
 800b530:	b29b      	uxth	r3, r3
}
 800b532:	4618      	mov	r0, r3
 800b534:	3714      	adds	r7, #20
 800b536:	46bd      	mov	sp, r7
 800b538:	f85d 7b04 	ldr.w	r7, [sp], #4
 800b53c:	4770      	bx	lr
 800b53e:	bf00      	nop
 800b540:	40007400 	.word	0x40007400

0800b544 <DAC_DMACmd>:
  * @note   The DAC channel2 is mapped on DMA1 Stream 6 channel7 which must be
  *          already configured.    
  * @retval None
  */
void DAC_DMACmd(uint32_t DAC_Channel, FunctionalState NewState)
{
 800b544:	b480      	push	{r7}
 800b546:	b083      	sub	sp, #12
 800b548:	af00      	add	r7, sp, #0
 800b54a:	6078      	str	r0, [r7, #4]
 800b54c:	460b      	mov	r3, r1
 800b54e:	70fb      	strb	r3, [r7, #3]
  /* Check the parameters */
  assert_param(IS_DAC_CHANNEL(DAC_Channel));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 800b550:	78fb      	ldrb	r3, [r7, #3]
 800b552:	2b00      	cmp	r3, #0
 800b554:	d00a      	beq.n	800b56c <DAC_DMACmd+0x28>
  {
    /* Enable the selected DAC channel DMA request */
    DAC->CR |= (DAC_CR_DMAEN1 << DAC_Channel);
 800b556:	490e      	ldr	r1, [pc, #56]	; (800b590 <DAC_DMACmd+0x4c>)
 800b558:	4b0d      	ldr	r3, [pc, #52]	; (800b590 <DAC_DMACmd+0x4c>)
 800b55a:	681a      	ldr	r2, [r3, #0]
 800b55c:	f44f 5080 	mov.w	r0, #4096	; 0x1000
 800b560:	687b      	ldr	r3, [r7, #4]
 800b562:	fa00 f303 	lsl.w	r3, r0, r3
 800b566:	4313      	orrs	r3, r2
 800b568:	600b      	str	r3, [r1, #0]
  else
  {
    /* Disable the selected DAC channel DMA request */
    DAC->CR &= (~(DAC_CR_DMAEN1 << DAC_Channel));
  }
}
 800b56a:	e00a      	b.n	800b582 <DAC_DMACmd+0x3e>
    DAC->CR &= (~(DAC_CR_DMAEN1 << DAC_Channel));
 800b56c:	4908      	ldr	r1, [pc, #32]	; (800b590 <DAC_DMACmd+0x4c>)
 800b56e:	4b08      	ldr	r3, [pc, #32]	; (800b590 <DAC_DMACmd+0x4c>)
 800b570:	681a      	ldr	r2, [r3, #0]
 800b572:	f44f 5080 	mov.w	r0, #4096	; 0x1000
 800b576:	687b      	ldr	r3, [r7, #4]
 800b578:	fa00 f303 	lsl.w	r3, r0, r3
 800b57c:	43db      	mvns	r3, r3
 800b57e:	4013      	ands	r3, r2
 800b580:	600b      	str	r3, [r1, #0]
}
 800b582:	bf00      	nop
 800b584:	370c      	adds	r7, #12
 800b586:	46bd      	mov	sp, r7
 800b588:	f85d 7b04 	ldr.w	r7, [sp], #4
 800b58c:	4770      	bx	lr
 800b58e:	bf00      	nop
 800b590:	40007400 	.word	0x40007400

0800b594 <DAC_ITConfig>:
  * @param  NewState: new state of the specified DAC interrupts.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */ 
void DAC_ITConfig(uint32_t DAC_Channel, uint32_t DAC_IT, FunctionalState NewState)  
{
 800b594:	b480      	push	{r7}
 800b596:	b085      	sub	sp, #20
 800b598:	af00      	add	r7, sp, #0
 800b59a:	60f8      	str	r0, [r7, #12]
 800b59c:	60b9      	str	r1, [r7, #8]
 800b59e:	4613      	mov	r3, r2
 800b5a0:	71fb      	strb	r3, [r7, #7]
  /* Check the parameters */
  assert_param(IS_DAC_CHANNEL(DAC_Channel));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  assert_param(IS_DAC_IT(DAC_IT)); 

  if (NewState != DISABLE)
 800b5a2:	79fb      	ldrb	r3, [r7, #7]
 800b5a4:	2b00      	cmp	r3, #0
 800b5a6:	d009      	beq.n	800b5bc <DAC_ITConfig+0x28>
  {
    /* Enable the selected DAC interrupts */
    DAC->CR |=  (DAC_IT << DAC_Channel);
 800b5a8:	480c      	ldr	r0, [pc, #48]	; (800b5dc <DAC_ITConfig+0x48>)
 800b5aa:	4b0c      	ldr	r3, [pc, #48]	; (800b5dc <DAC_ITConfig+0x48>)
 800b5ac:	681a      	ldr	r2, [r3, #0]
 800b5ae:	68b9      	ldr	r1, [r7, #8]
 800b5b0:	68fb      	ldr	r3, [r7, #12]
 800b5b2:	fa01 f303 	lsl.w	r3, r1, r3
 800b5b6:	4313      	orrs	r3, r2
 800b5b8:	6003      	str	r3, [r0, #0]
  else
  {
    /* Disable the selected DAC interrupts */
    DAC->CR &= (~(uint32_t)(DAC_IT << DAC_Channel));
  }
}
 800b5ba:	e009      	b.n	800b5d0 <DAC_ITConfig+0x3c>
    DAC->CR &= (~(uint32_t)(DAC_IT << DAC_Channel));
 800b5bc:	4807      	ldr	r0, [pc, #28]	; (800b5dc <DAC_ITConfig+0x48>)
 800b5be:	4b07      	ldr	r3, [pc, #28]	; (800b5dc <DAC_ITConfig+0x48>)
 800b5c0:	681a      	ldr	r2, [r3, #0]
 800b5c2:	68b9      	ldr	r1, [r7, #8]
 800b5c4:	68fb      	ldr	r3, [r7, #12]
 800b5c6:	fa01 f303 	lsl.w	r3, r1, r3
 800b5ca:	43db      	mvns	r3, r3
 800b5cc:	4013      	ands	r3, r2
 800b5ce:	6003      	str	r3, [r0, #0]
}
 800b5d0:	bf00      	nop
 800b5d2:	3714      	adds	r7, #20
 800b5d4:	46bd      	mov	sp, r7
 800b5d6:	f85d 7b04 	ldr.w	r7, [sp], #4
 800b5da:	4770      	bx	lr
 800b5dc:	40007400 	.word	0x40007400

0800b5e0 <DAC_GetFlagStatus>:
  * @note   The DMA underrun occurs when a second external trigger arrives before the 
  *         acknowledgement for the first external trigger is received (first request).
  * @retval The new state of DAC_FLAG (SET or RESET).
  */
FlagStatus DAC_GetFlagStatus(uint32_t DAC_Channel, uint32_t DAC_FLAG)
{
 800b5e0:	b480      	push	{r7}
 800b5e2:	b085      	sub	sp, #20
 800b5e4:	af00      	add	r7, sp, #0
 800b5e6:	6078      	str	r0, [r7, #4]
 800b5e8:	6039      	str	r1, [r7, #0]
  FlagStatus bitstatus = RESET;
 800b5ea:	2300      	movs	r3, #0
 800b5ec:	73fb      	strb	r3, [r7, #15]
  /* Check the parameters */
  assert_param(IS_DAC_CHANNEL(DAC_Channel));
  assert_param(IS_DAC_FLAG(DAC_FLAG));

  /* Check the status of the specified DAC flag */
  if ((DAC->SR & (DAC_FLAG << DAC_Channel)) != (uint8_t)RESET)
 800b5ee:	4b0a      	ldr	r3, [pc, #40]	; (800b618 <DAC_GetFlagStatus+0x38>)
 800b5f0:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 800b5f2:	6839      	ldr	r1, [r7, #0]
 800b5f4:	687b      	ldr	r3, [r7, #4]
 800b5f6:	fa01 f303 	lsl.w	r3, r1, r3
 800b5fa:	4013      	ands	r3, r2
 800b5fc:	2b00      	cmp	r3, #0
 800b5fe:	d002      	beq.n	800b606 <DAC_GetFlagStatus+0x26>
  {
    /* DAC_FLAG is set */
    bitstatus = SET;
 800b600:	2301      	movs	r3, #1
 800b602:	73fb      	strb	r3, [r7, #15]
 800b604:	e001      	b.n	800b60a <DAC_GetFlagStatus+0x2a>
  }
  else
  {
    /* DAC_FLAG is reset */
    bitstatus = RESET;
 800b606:	2300      	movs	r3, #0
 800b608:	73fb      	strb	r3, [r7, #15]
  }
  /* Return the DAC_FLAG status */
  return  bitstatus;
 800b60a:	7bfb      	ldrb	r3, [r7, #15]
}
 800b60c:	4618      	mov	r0, r3
 800b60e:	3714      	adds	r7, #20
 800b610:	46bd      	mov	sp, r7
 800b612:	f85d 7b04 	ldr.w	r7, [sp], #4
 800b616:	4770      	bx	lr
 800b618:	40007400 	.word	0x40007400

0800b61c <DAC_ClearFlag>:
  * @note   The DMA underrun occurs when a second external trigger arrives before the 
  *         acknowledgement for the first external trigger is received (first request).                           
  * @retval None
  */
void DAC_ClearFlag(uint32_t DAC_Channel, uint32_t DAC_FLAG)
{
 800b61c:	b480      	push	{r7}
 800b61e:	b083      	sub	sp, #12
 800b620:	af00      	add	r7, sp, #0
 800b622:	6078      	str	r0, [r7, #4]
 800b624:	6039      	str	r1, [r7, #0]
  /* Check the parameters */
  assert_param(IS_DAC_CHANNEL(DAC_Channel));
  assert_param(IS_DAC_FLAG(DAC_FLAG));

  /* Clear the selected DAC flags */
  DAC->SR = (DAC_FLAG << DAC_Channel);
 800b626:	4906      	ldr	r1, [pc, #24]	; (800b640 <DAC_ClearFlag+0x24>)
 800b628:	683a      	ldr	r2, [r7, #0]
 800b62a:	687b      	ldr	r3, [r7, #4]
 800b62c:	fa02 f303 	lsl.w	r3, r2, r3
 800b630:	634b      	str	r3, [r1, #52]	; 0x34
}
 800b632:	bf00      	nop
 800b634:	370c      	adds	r7, #12
 800b636:	46bd      	mov	sp, r7
 800b638:	f85d 7b04 	ldr.w	r7, [sp], #4
 800b63c:	4770      	bx	lr
 800b63e:	bf00      	nop
 800b640:	40007400 	.word	0x40007400

0800b644 <DAC_GetITStatus>:
  * @note   The DMA underrun occurs when a second external trigger arrives before the 
  *         acknowledgement for the first external trigger is received (first request).
  * @retval The new state of DAC_IT (SET or RESET).
  */
ITStatus DAC_GetITStatus(uint32_t DAC_Channel, uint32_t DAC_IT)
{
 800b644:	b480      	push	{r7}
 800b646:	b085      	sub	sp, #20
 800b648:	af00      	add	r7, sp, #0
 800b64a:	6078      	str	r0, [r7, #4]
 800b64c:	6039      	str	r1, [r7, #0]
  ITStatus bitstatus = RESET;
 800b64e:	2300      	movs	r3, #0
 800b650:	73fb      	strb	r3, [r7, #15]
  uint32_t enablestatus = 0;
 800b652:	2300      	movs	r3, #0
 800b654:	60bb      	str	r3, [r7, #8]
  /* Check the parameters */
  assert_param(IS_DAC_CHANNEL(DAC_Channel));
  assert_param(IS_DAC_IT(DAC_IT));

  /* Get the DAC_IT enable bit status */
  enablestatus = (DAC->CR & (DAC_IT << DAC_Channel)) ;
 800b656:	4b10      	ldr	r3, [pc, #64]	; (800b698 <DAC_GetITStatus+0x54>)
 800b658:	681a      	ldr	r2, [r3, #0]
 800b65a:	6839      	ldr	r1, [r7, #0]
 800b65c:	687b      	ldr	r3, [r7, #4]
 800b65e:	fa01 f303 	lsl.w	r3, r1, r3
 800b662:	4013      	ands	r3, r2
 800b664:	60bb      	str	r3, [r7, #8]
  
  /* Check the status of the specified DAC interrupt */
  if (((DAC->SR & (DAC_IT << DAC_Channel)) != (uint32_t)RESET) && enablestatus)
 800b666:	4b0c      	ldr	r3, [pc, #48]	; (800b698 <DAC_GetITStatus+0x54>)
 800b668:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 800b66a:	6839      	ldr	r1, [r7, #0]
 800b66c:	687b      	ldr	r3, [r7, #4]
 800b66e:	fa01 f303 	lsl.w	r3, r1, r3
 800b672:	4013      	ands	r3, r2
 800b674:	2b00      	cmp	r3, #0
 800b676:	d005      	beq.n	800b684 <DAC_GetITStatus+0x40>
 800b678:	68bb      	ldr	r3, [r7, #8]
 800b67a:	2b00      	cmp	r3, #0
 800b67c:	d002      	beq.n	800b684 <DAC_GetITStatus+0x40>
  {
    /* DAC_IT is set */
    bitstatus = SET;
 800b67e:	2301      	movs	r3, #1
 800b680:	73fb      	strb	r3, [r7, #15]
 800b682:	e001      	b.n	800b688 <DAC_GetITStatus+0x44>
  }
  else
  {
    /* DAC_IT is reset */
    bitstatus = RESET;
 800b684:	2300      	movs	r3, #0
 800b686:	73fb      	strb	r3, [r7, #15]
  }
  /* Return the DAC_IT status */
  return  bitstatus;
 800b688:	7bfb      	ldrb	r3, [r7, #15]
}
 800b68a:	4618      	mov	r0, r3
 800b68c:	3714      	adds	r7, #20
 800b68e:	46bd      	mov	sp, r7
 800b690:	f85d 7b04 	ldr.w	r7, [sp], #4
 800b694:	4770      	bx	lr
 800b696:	bf00      	nop
 800b698:	40007400 	.word	0x40007400

0800b69c <DAC_ClearITPendingBit>:
  * @note   The DMA underrun occurs when a second external trigger arrives before the 
  *         acknowledgement for the first external trigger is received (first request).                           
  * @retval None
  */
void DAC_ClearITPendingBit(uint32_t DAC_Channel, uint32_t DAC_IT)
{
 800b69c:	b480      	push	{r7}
 800b69e:	b083      	sub	sp, #12
 800b6a0:	af00      	add	r7, sp, #0
 800b6a2:	6078      	str	r0, [r7, #4]
 800b6a4:	6039      	str	r1, [r7, #0]
  /* Check the parameters */
  assert_param(IS_DAC_CHANNEL(DAC_Channel));
  assert_param(IS_DAC_IT(DAC_IT)); 

  /* Clear the selected DAC interrupt pending bits */
  DAC->SR = (DAC_IT << DAC_Channel);
 800b6a6:	4906      	ldr	r1, [pc, #24]	; (800b6c0 <DAC_ClearITPendingBit+0x24>)
 800b6a8:	683a      	ldr	r2, [r7, #0]
 800b6aa:	687b      	ldr	r3, [r7, #4]
 800b6ac:	fa02 f303 	lsl.w	r3, r2, r3
 800b6b0:	634b      	str	r3, [r1, #52]	; 0x34
}
 800b6b2:	bf00      	nop
 800b6b4:	370c      	adds	r7, #12
 800b6b6:	46bd      	mov	sp, r7
 800b6b8:	f85d 7b04 	ldr.w	r7, [sp], #4
 800b6bc:	4770      	bx	lr
 800b6be:	bf00      	nop
 800b6c0:	40007400 	.word	0x40007400

0800b6c4 <DBGMCU_GetREVID>:
  * @brief  Returns the device revision identifier.
  * @param  None
  * @retval Device revision identifier
  */
uint32_t DBGMCU_GetREVID(void)
{
 800b6c4:	b480      	push	{r7}
 800b6c6:	af00      	add	r7, sp, #0
   return(DBGMCU->IDCODE >> 16);
 800b6c8:	4b03      	ldr	r3, [pc, #12]	; (800b6d8 <DBGMCU_GetREVID+0x14>)
 800b6ca:	681b      	ldr	r3, [r3, #0]
 800b6cc:	0c1b      	lsrs	r3, r3, #16
}
 800b6ce:	4618      	mov	r0, r3
 800b6d0:	46bd      	mov	sp, r7
 800b6d2:	f85d 7b04 	ldr.w	r7, [sp], #4
 800b6d6:	4770      	bx	lr
 800b6d8:	e0042000 	.word	0xe0042000

0800b6dc <DBGMCU_GetDEVID>:
  * @brief  Returns the device identifier.
  * @param  None
  * @retval Device identifier
  */
uint32_t DBGMCU_GetDEVID(void)
{
 800b6dc:	b480      	push	{r7}
 800b6de:	af00      	add	r7, sp, #0
   return(DBGMCU->IDCODE & IDCODE_DEVID_MASK);
 800b6e0:	4b04      	ldr	r3, [pc, #16]	; (800b6f4 <DBGMCU_GetDEVID+0x18>)
 800b6e2:	681b      	ldr	r3, [r3, #0]
 800b6e4:	f3c3 030b 	ubfx	r3, r3, #0, #12
}
 800b6e8:	4618      	mov	r0, r3
 800b6ea:	46bd      	mov	sp, r7
 800b6ec:	f85d 7b04 	ldr.w	r7, [sp], #4
 800b6f0:	4770      	bx	lr
 800b6f2:	bf00      	nop
 800b6f4:	e0042000 	.word	0xe0042000

0800b6f8 <DBGMCU_Config>:
  * @param  NewState: new state of the specified low power mode in Debug mode.
  *   This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void DBGMCU_Config(uint32_t DBGMCU_Periph, FunctionalState NewState)
{
 800b6f8:	b480      	push	{r7}
 800b6fa:	b083      	sub	sp, #12
 800b6fc:	af00      	add	r7, sp, #0
 800b6fe:	6078      	str	r0, [r7, #4]
 800b700:	460b      	mov	r3, r1
 800b702:	70fb      	strb	r3, [r7, #3]
  /* Check the parameters */
  assert_param(IS_DBGMCU_PERIPH(DBGMCU_Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 800b704:	78fb      	ldrb	r3, [r7, #3]
 800b706:	2b00      	cmp	r3, #0
 800b708:	d006      	beq.n	800b718 <DBGMCU_Config+0x20>
  {
    DBGMCU->CR |= DBGMCU_Periph;
 800b70a:	490a      	ldr	r1, [pc, #40]	; (800b734 <DBGMCU_Config+0x3c>)
 800b70c:	4b09      	ldr	r3, [pc, #36]	; (800b734 <DBGMCU_Config+0x3c>)
 800b70e:	685a      	ldr	r2, [r3, #4]
 800b710:	687b      	ldr	r3, [r7, #4]
 800b712:	4313      	orrs	r3, r2
 800b714:	604b      	str	r3, [r1, #4]
  }
  else
  {
    DBGMCU->CR &= ~DBGMCU_Periph;
  }
}
 800b716:	e006      	b.n	800b726 <DBGMCU_Config+0x2e>
    DBGMCU->CR &= ~DBGMCU_Periph;
 800b718:	4906      	ldr	r1, [pc, #24]	; (800b734 <DBGMCU_Config+0x3c>)
 800b71a:	4b06      	ldr	r3, [pc, #24]	; (800b734 <DBGMCU_Config+0x3c>)
 800b71c:	685a      	ldr	r2, [r3, #4]
 800b71e:	687b      	ldr	r3, [r7, #4]
 800b720:	43db      	mvns	r3, r3
 800b722:	4013      	ands	r3, r2
 800b724:	604b      	str	r3, [r1, #4]
}
 800b726:	bf00      	nop
 800b728:	370c      	adds	r7, #12
 800b72a:	46bd      	mov	sp, r7
 800b72c:	f85d 7b04 	ldr.w	r7, [sp], #4
 800b730:	4770      	bx	lr
 800b732:	bf00      	nop
 800b734:	e0042000 	.word	0xe0042000

0800b738 <DBGMCU_APB1PeriphConfig>:
  *     @arg DBGMCU_CAN1_STOP: Debug CAN2 stopped when Core is halted        
  *   This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void DBGMCU_APB1PeriphConfig(uint32_t DBGMCU_Periph, FunctionalState NewState)
{
 800b738:	b480      	push	{r7}
 800b73a:	b083      	sub	sp, #12
 800b73c:	af00      	add	r7, sp, #0
 800b73e:	6078      	str	r0, [r7, #4]
 800b740:	460b      	mov	r3, r1
 800b742:	70fb      	strb	r3, [r7, #3]
  /* Check the parameters */
  assert_param(IS_DBGMCU_APB1PERIPH(DBGMCU_Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 800b744:	78fb      	ldrb	r3, [r7, #3]
 800b746:	2b00      	cmp	r3, #0
 800b748:	d006      	beq.n	800b758 <DBGMCU_APB1PeriphConfig+0x20>
  {
    DBGMCU->APB1FZ |= DBGMCU_Periph;
 800b74a:	490a      	ldr	r1, [pc, #40]	; (800b774 <DBGMCU_APB1PeriphConfig+0x3c>)
 800b74c:	4b09      	ldr	r3, [pc, #36]	; (800b774 <DBGMCU_APB1PeriphConfig+0x3c>)
 800b74e:	689a      	ldr	r2, [r3, #8]
 800b750:	687b      	ldr	r3, [r7, #4]
 800b752:	4313      	orrs	r3, r2
 800b754:	608b      	str	r3, [r1, #8]
  }
  else
  {
    DBGMCU->APB1FZ &= ~DBGMCU_Periph;
  }
}
 800b756:	e006      	b.n	800b766 <DBGMCU_APB1PeriphConfig+0x2e>
    DBGMCU->APB1FZ &= ~DBGMCU_Periph;
 800b758:	4906      	ldr	r1, [pc, #24]	; (800b774 <DBGMCU_APB1PeriphConfig+0x3c>)
 800b75a:	4b06      	ldr	r3, [pc, #24]	; (800b774 <DBGMCU_APB1PeriphConfig+0x3c>)
 800b75c:	689a      	ldr	r2, [r3, #8]
 800b75e:	687b      	ldr	r3, [r7, #4]
 800b760:	43db      	mvns	r3, r3
 800b762:	4013      	ands	r3, r2
 800b764:	608b      	str	r3, [r1, #8]
}
 800b766:	bf00      	nop
 800b768:	370c      	adds	r7, #12
 800b76a:	46bd      	mov	sp, r7
 800b76c:	f85d 7b04 	ldr.w	r7, [sp], #4
 800b770:	4770      	bx	lr
 800b772:	bf00      	nop
 800b774:	e0042000 	.word	0xe0042000

0800b778 <DBGMCU_APB2PeriphConfig>:
  * @param  NewState: new state of the specified peripheral in Debug mode.
  *   This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void DBGMCU_APB2PeriphConfig(uint32_t DBGMCU_Periph, FunctionalState NewState)
{
 800b778:	b480      	push	{r7}
 800b77a:	b083      	sub	sp, #12
 800b77c:	af00      	add	r7, sp, #0
 800b77e:	6078      	str	r0, [r7, #4]
 800b780:	460b      	mov	r3, r1
 800b782:	70fb      	strb	r3, [r7, #3]
  /* Check the parameters */
  assert_param(IS_DBGMCU_APB2PERIPH(DBGMCU_Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 800b784:	78fb      	ldrb	r3, [r7, #3]
 800b786:	2b00      	cmp	r3, #0
 800b788:	d006      	beq.n	800b798 <DBGMCU_APB2PeriphConfig+0x20>
  {
    DBGMCU->APB2FZ |= DBGMCU_Periph;
 800b78a:	490a      	ldr	r1, [pc, #40]	; (800b7b4 <DBGMCU_APB2PeriphConfig+0x3c>)
 800b78c:	4b09      	ldr	r3, [pc, #36]	; (800b7b4 <DBGMCU_APB2PeriphConfig+0x3c>)
 800b78e:	68da      	ldr	r2, [r3, #12]
 800b790:	687b      	ldr	r3, [r7, #4]
 800b792:	4313      	orrs	r3, r2
 800b794:	60cb      	str	r3, [r1, #12]
  }
  else
  {
    DBGMCU->APB2FZ &= ~DBGMCU_Periph;
  }
}
 800b796:	e006      	b.n	800b7a6 <DBGMCU_APB2PeriphConfig+0x2e>
    DBGMCU->APB2FZ &= ~DBGMCU_Periph;
 800b798:	4906      	ldr	r1, [pc, #24]	; (800b7b4 <DBGMCU_APB2PeriphConfig+0x3c>)
 800b79a:	4b06      	ldr	r3, [pc, #24]	; (800b7b4 <DBGMCU_APB2PeriphConfig+0x3c>)
 800b79c:	68da      	ldr	r2, [r3, #12]
 800b79e:	687b      	ldr	r3, [r7, #4]
 800b7a0:	43db      	mvns	r3, r3
 800b7a2:	4013      	ands	r3, r2
 800b7a4:	60cb      	str	r3, [r1, #12]
}
 800b7a6:	bf00      	nop
 800b7a8:	370c      	adds	r7, #12
 800b7aa:	46bd      	mov	sp, r7
 800b7ac:	f85d 7b04 	ldr.w	r7, [sp], #4
 800b7b0:	4770      	bx	lr
 800b7b2:	bf00      	nop
 800b7b4:	e0042000 	.word	0xe0042000

0800b7b8 <DCMI_DeInit>:
  * @brief  Deinitializes the DCMI registers to their default reset values.
  * @param  None
  * @retval None
  */
void DCMI_DeInit(void)
{
 800b7b8:	b480      	push	{r7}
 800b7ba:	af00      	add	r7, sp, #0
  DCMI->CR = 0x0;
 800b7bc:	4b0c      	ldr	r3, [pc, #48]	; (800b7f0 <DCMI_DeInit+0x38>)
 800b7be:	2200      	movs	r2, #0
 800b7c0:	601a      	str	r2, [r3, #0]
  DCMI->IER = 0x0;
 800b7c2:	4b0b      	ldr	r3, [pc, #44]	; (800b7f0 <DCMI_DeInit+0x38>)
 800b7c4:	2200      	movs	r2, #0
 800b7c6:	60da      	str	r2, [r3, #12]
  DCMI->ICR = 0x1F;
 800b7c8:	4b09      	ldr	r3, [pc, #36]	; (800b7f0 <DCMI_DeInit+0x38>)
 800b7ca:	221f      	movs	r2, #31
 800b7cc:	615a      	str	r2, [r3, #20]
  DCMI->ESCR = 0x0;
 800b7ce:	4b08      	ldr	r3, [pc, #32]	; (800b7f0 <DCMI_DeInit+0x38>)
 800b7d0:	2200      	movs	r2, #0
 800b7d2:	619a      	str	r2, [r3, #24]
  DCMI->ESUR = 0x0;
 800b7d4:	4b06      	ldr	r3, [pc, #24]	; (800b7f0 <DCMI_DeInit+0x38>)
 800b7d6:	2200      	movs	r2, #0
 800b7d8:	61da      	str	r2, [r3, #28]
  DCMI->CWSTRTR = 0x0;
 800b7da:	4b05      	ldr	r3, [pc, #20]	; (800b7f0 <DCMI_DeInit+0x38>)
 800b7dc:	2200      	movs	r2, #0
 800b7de:	621a      	str	r2, [r3, #32]
  DCMI->CWSIZER = 0x0;
 800b7e0:	4b03      	ldr	r3, [pc, #12]	; (800b7f0 <DCMI_DeInit+0x38>)
 800b7e2:	2200      	movs	r2, #0
 800b7e4:	625a      	str	r2, [r3, #36]	; 0x24
}
 800b7e6:	bf00      	nop
 800b7e8:	46bd      	mov	sp, r7
 800b7ea:	f85d 7b04 	ldr.w	r7, [sp], #4
 800b7ee:	4770      	bx	lr
 800b7f0:	50050000 	.word	0x50050000

0800b7f4 <DCMI_Init>:
  * @param  DCMI_InitStruct: pointer to a DCMI_InitTypeDef structure that contains 
  *         the configuration information for the DCMI.
  * @retval None
  */
void DCMI_Init(DCMI_InitTypeDef* DCMI_InitStruct)
{
 800b7f4:	b480      	push	{r7}
 800b7f6:	b085      	sub	sp, #20
 800b7f8:	af00      	add	r7, sp, #0
 800b7fa:	6078      	str	r0, [r7, #4]
  uint32_t temp = 0x0;
 800b7fc:	2300      	movs	r3, #0
 800b7fe:	60fb      	str	r3, [r7, #12]
  assert_param(IS_DCMI_CAPTURE_RATE(DCMI_InitStruct->DCMI_CaptureRate));
  assert_param(IS_DCMI_EXTENDED_DATA(DCMI_InitStruct->DCMI_ExtendedDataMode));

  /* The DCMI configuration registers should be programmed correctly before 
  enabling the CR_ENABLE Bit and the CR_CAPTURE Bit */
  DCMI->CR &= ~(DCMI_CR_ENABLE | DCMI_CR_CAPTURE);
 800b800:	4a1b      	ldr	r2, [pc, #108]	; (800b870 <DCMI_Init+0x7c>)
 800b802:	4b1b      	ldr	r3, [pc, #108]	; (800b870 <DCMI_Init+0x7c>)
 800b804:	681b      	ldr	r3, [r3, #0]
 800b806:	f423 4380 	bic.w	r3, r3, #16384	; 0x4000
 800b80a:	f023 0301 	bic.w	r3, r3, #1
 800b80e:	6013      	str	r3, [r2, #0]
   
  /* Reset the old DCMI configuration */
  temp = DCMI->CR;
 800b810:	4b17      	ldr	r3, [pc, #92]	; (800b870 <DCMI_Init+0x7c>)
 800b812:	681b      	ldr	r3, [r3, #0]
 800b814:	60fb      	str	r3, [r7, #12]
  
  temp &= ~((uint32_t)DCMI_CR_CM     | DCMI_CR_ESS   | DCMI_CR_PCKPOL |
 800b816:	68fb      	ldr	r3, [r7, #12]
 800b818:	f423 637f 	bic.w	r3, r3, #4080	; 0xff0
 800b81c:	f023 0302 	bic.w	r3, r3, #2
 800b820:	60fb      	str	r3, [r7, #12]
                      DCMI_CR_HSPOL  | DCMI_CR_VSPOL | DCMI_CR_FCRC_0 | 
                      DCMI_CR_FCRC_1 | DCMI_CR_EDM_0 | DCMI_CR_EDM_1); 
                  
  /* Sets the new configuration of the DCMI peripheral */
  temp |= ((uint32_t)DCMI_InitStruct->DCMI_CaptureMode |
 800b822:	687b      	ldr	r3, [r7, #4]
 800b824:	881a      	ldrh	r2, [r3, #0]
                     DCMI_InitStruct->DCMI_SynchroMode |
 800b826:	687b      	ldr	r3, [r7, #4]
 800b828:	885b      	ldrh	r3, [r3, #2]
                     DCMI_InitStruct->DCMI_PCKPolarity |
                     DCMI_InitStruct->DCMI_VSPolarity |
                     DCMI_InitStruct->DCMI_HSPolarity |
                     DCMI_InitStruct->DCMI_CaptureRate |
 800b82a:	4313      	orrs	r3, r2
 800b82c:	b29a      	uxth	r2, r3
                     DCMI_InitStruct->DCMI_PCKPolarity |
 800b82e:	687b      	ldr	r3, [r7, #4]
 800b830:	889b      	ldrh	r3, [r3, #4]
                     DCMI_InitStruct->DCMI_CaptureRate |
 800b832:	4313      	orrs	r3, r2
 800b834:	b29a      	uxth	r2, r3
                     DCMI_InitStruct->DCMI_VSPolarity |
 800b836:	687b      	ldr	r3, [r7, #4]
 800b838:	88db      	ldrh	r3, [r3, #6]
                     DCMI_InitStruct->DCMI_CaptureRate |
 800b83a:	4313      	orrs	r3, r2
 800b83c:	b29a      	uxth	r2, r3
                     DCMI_InitStruct->DCMI_HSPolarity |
 800b83e:	687b      	ldr	r3, [r7, #4]
 800b840:	891b      	ldrh	r3, [r3, #8]
                     DCMI_InitStruct->DCMI_CaptureRate |
 800b842:	4313      	orrs	r3, r2
 800b844:	b29a      	uxth	r2, r3
 800b846:	687b      	ldr	r3, [r7, #4]
 800b848:	895b      	ldrh	r3, [r3, #10]
 800b84a:	4313      	orrs	r3, r2
 800b84c:	b29a      	uxth	r2, r3
                     DCMI_InitStruct->DCMI_ExtendedDataMode);
 800b84e:	687b      	ldr	r3, [r7, #4]
 800b850:	899b      	ldrh	r3, [r3, #12]
                     DCMI_InitStruct->DCMI_CaptureRate |
 800b852:	4313      	orrs	r3, r2
 800b854:	b29b      	uxth	r3, r3
 800b856:	461a      	mov	r2, r3
  temp |= ((uint32_t)DCMI_InitStruct->DCMI_CaptureMode |
 800b858:	68fb      	ldr	r3, [r7, #12]
 800b85a:	4313      	orrs	r3, r2
 800b85c:	60fb      	str	r3, [r7, #12]

  DCMI->CR = temp;                              
 800b85e:	4a04      	ldr	r2, [pc, #16]	; (800b870 <DCMI_Init+0x7c>)
 800b860:	68fb      	ldr	r3, [r7, #12]
 800b862:	6013      	str	r3, [r2, #0]
}
 800b864:	bf00      	nop
 800b866:	3714      	adds	r7, #20
 800b868:	46bd      	mov	sp, r7
 800b86a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800b86e:	4770      	bx	lr
 800b870:	50050000 	.word	0x50050000

0800b874 <DCMI_StructInit>:
  * @param  DCMI_InitStruct : pointer to a DCMI_InitTypeDef structure which will
  *         be initialized.
  * @retval None
  */
void DCMI_StructInit(DCMI_InitTypeDef* DCMI_InitStruct)
{
 800b874:	b480      	push	{r7}
 800b876:	b083      	sub	sp, #12
 800b878:	af00      	add	r7, sp, #0
 800b87a:	6078      	str	r0, [r7, #4]
  /* Set the default configuration */
  DCMI_InitStruct->DCMI_CaptureMode = DCMI_CaptureMode_Continuous;
 800b87c:	687b      	ldr	r3, [r7, #4]
 800b87e:	2200      	movs	r2, #0
 800b880:	801a      	strh	r2, [r3, #0]
  DCMI_InitStruct->DCMI_SynchroMode = DCMI_SynchroMode_Hardware;
 800b882:	687b      	ldr	r3, [r7, #4]
 800b884:	2200      	movs	r2, #0
 800b886:	805a      	strh	r2, [r3, #2]
  DCMI_InitStruct->DCMI_PCKPolarity = DCMI_PCKPolarity_Falling;
 800b888:	687b      	ldr	r3, [r7, #4]
 800b88a:	2200      	movs	r2, #0
 800b88c:	809a      	strh	r2, [r3, #4]
  DCMI_InitStruct->DCMI_VSPolarity = DCMI_VSPolarity_Low;
 800b88e:	687b      	ldr	r3, [r7, #4]
 800b890:	2200      	movs	r2, #0
 800b892:	80da      	strh	r2, [r3, #6]
  DCMI_InitStruct->DCMI_HSPolarity = DCMI_HSPolarity_Low;
 800b894:	687b      	ldr	r3, [r7, #4]
 800b896:	2200      	movs	r2, #0
 800b898:	811a      	strh	r2, [r3, #8]
  DCMI_InitStruct->DCMI_CaptureRate = DCMI_CaptureRate_All_Frame;
 800b89a:	687b      	ldr	r3, [r7, #4]
 800b89c:	2200      	movs	r2, #0
 800b89e:	815a      	strh	r2, [r3, #10]
  DCMI_InitStruct->DCMI_ExtendedDataMode = DCMI_ExtendedDataMode_8b;
 800b8a0:	687b      	ldr	r3, [r7, #4]
 800b8a2:	2200      	movs	r2, #0
 800b8a4:	819a      	strh	r2, [r3, #12]
}
 800b8a6:	bf00      	nop
 800b8a8:	370c      	adds	r7, #12
 800b8aa:	46bd      	mov	sp, r7
 800b8ac:	f85d 7b04 	ldr.w	r7, [sp], #4
 800b8b0:	4770      	bx	lr

0800b8b2 <DCMI_CROPConfig>:
  * @param  DCMI_CROPInitStruct:  pointer to a DCMI_CROPInitTypeDef structure that 
  *         contains the configuration information for the DCMI peripheral CROP mode.
  * @retval None
  */
void DCMI_CROPConfig(DCMI_CROPInitTypeDef* DCMI_CROPInitStruct)
{  
 800b8b2:	b480      	push	{r7}
 800b8b4:	b083      	sub	sp, #12
 800b8b6:	af00      	add	r7, sp, #0
 800b8b8:	6078      	str	r0, [r7, #4]
  /* Sets the CROP window coordinates */
  DCMI->CWSTRTR = (uint32_t)((uint32_t)DCMI_CROPInitStruct->DCMI_HorizontalOffsetCount |
 800b8ba:	4a0c      	ldr	r2, [pc, #48]	; (800b8ec <DCMI_CROPConfig+0x3a>)
 800b8bc:	687b      	ldr	r3, [r7, #4]
 800b8be:	885b      	ldrh	r3, [r3, #2]
 800b8c0:	4619      	mov	r1, r3
                  ((uint32_t)DCMI_CROPInitStruct->DCMI_VerticalStartLine << 16));
 800b8c2:	687b      	ldr	r3, [r7, #4]
 800b8c4:	881b      	ldrh	r3, [r3, #0]
 800b8c6:	041b      	lsls	r3, r3, #16
  DCMI->CWSTRTR = (uint32_t)((uint32_t)DCMI_CROPInitStruct->DCMI_HorizontalOffsetCount |
 800b8c8:	430b      	orrs	r3, r1
 800b8ca:	6213      	str	r3, [r2, #32]

  /* Sets the CROP window size */
  DCMI->CWSIZER = (uint32_t)(DCMI_CROPInitStruct->DCMI_CaptureCount |
 800b8cc:	4a07      	ldr	r2, [pc, #28]	; (800b8ec <DCMI_CROPConfig+0x3a>)
 800b8ce:	687b      	ldr	r3, [r7, #4]
 800b8d0:	88db      	ldrh	r3, [r3, #6]
 800b8d2:	4619      	mov	r1, r3
                  ((uint32_t)DCMI_CROPInitStruct->DCMI_VerticalLineCount << 16));
 800b8d4:	687b      	ldr	r3, [r7, #4]
 800b8d6:	889b      	ldrh	r3, [r3, #4]
 800b8d8:	041b      	lsls	r3, r3, #16
  DCMI->CWSIZER = (uint32_t)(DCMI_CROPInitStruct->DCMI_CaptureCount |
 800b8da:	430b      	orrs	r3, r1
 800b8dc:	6253      	str	r3, [r2, #36]	; 0x24
}
 800b8de:	bf00      	nop
 800b8e0:	370c      	adds	r7, #12
 800b8e2:	46bd      	mov	sp, r7
 800b8e4:	f85d 7b04 	ldr.w	r7, [sp], #4
 800b8e8:	4770      	bx	lr
 800b8ea:	bf00      	nop
 800b8ec:	50050000 	.word	0x50050000

0800b8f0 <DCMI_CROPCmd>:
  * @param  NewState: new state of the DCMI Crop feature. 
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void DCMI_CROPCmd(FunctionalState NewState)
{
 800b8f0:	b480      	push	{r7}
 800b8f2:	b083      	sub	sp, #12
 800b8f4:	af00      	add	r7, sp, #0
 800b8f6:	4603      	mov	r3, r0
 800b8f8:	71fb      	strb	r3, [r7, #7]
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
    
  if (NewState != DISABLE)
 800b8fa:	79fb      	ldrb	r3, [r7, #7]
 800b8fc:	2b00      	cmp	r3, #0
 800b8fe:	d006      	beq.n	800b90e <DCMI_CROPCmd+0x1e>
  {
    /* Enable the DCMI Crop feature */
    DCMI->CR |= (uint32_t)DCMI_CR_CROP;
 800b900:	4a09      	ldr	r2, [pc, #36]	; (800b928 <DCMI_CROPCmd+0x38>)
 800b902:	4b09      	ldr	r3, [pc, #36]	; (800b928 <DCMI_CROPCmd+0x38>)
 800b904:	681b      	ldr	r3, [r3, #0]
 800b906:	f043 0304 	orr.w	r3, r3, #4
 800b90a:	6013      	str	r3, [r2, #0]
  else
  {
    /* Disable the DCMI Crop feature */
    DCMI->CR &= ~(uint32_t)DCMI_CR_CROP;
  }
}
 800b90c:	e005      	b.n	800b91a <DCMI_CROPCmd+0x2a>
    DCMI->CR &= ~(uint32_t)DCMI_CR_CROP;
 800b90e:	4a06      	ldr	r2, [pc, #24]	; (800b928 <DCMI_CROPCmd+0x38>)
 800b910:	4b05      	ldr	r3, [pc, #20]	; (800b928 <DCMI_CROPCmd+0x38>)
 800b912:	681b      	ldr	r3, [r3, #0]
 800b914:	f023 0304 	bic.w	r3, r3, #4
 800b918:	6013      	str	r3, [r2, #0]
}
 800b91a:	bf00      	nop
 800b91c:	370c      	adds	r7, #12
 800b91e:	46bd      	mov	sp, r7
 800b920:	f85d 7b04 	ldr.w	r7, [sp], #4
 800b924:	4770      	bx	lr
 800b926:	bf00      	nop
 800b928:	50050000 	.word	0x50050000

0800b92c <DCMI_SetEmbeddedSynchroCodes>:
  * @param  DCMI_CodesInitTypeDef: pointer to a DCMI_CodesInitTypeDef structure that
  *         contains the embedded synchronization codes for the DCMI peripheral.
  * @retval None
  */
void DCMI_SetEmbeddedSynchroCodes(DCMI_CodesInitTypeDef* DCMI_CodesInitStruct)
{
 800b92c:	b480      	push	{r7}
 800b92e:	b083      	sub	sp, #12
 800b930:	af00      	add	r7, sp, #0
 800b932:	6078      	str	r0, [r7, #4]
  DCMI->ESCR = (uint32_t)(DCMI_CodesInitStruct->DCMI_FrameStartCode |
 800b934:	490b      	ldr	r1, [pc, #44]	; (800b964 <DCMI_SetEmbeddedSynchroCodes+0x38>)
 800b936:	687b      	ldr	r3, [r7, #4]
 800b938:	781b      	ldrb	r3, [r3, #0]
 800b93a:	461a      	mov	r2, r3
                          ((uint32_t)DCMI_CodesInitStruct->DCMI_LineStartCode << 8)|
 800b93c:	687b      	ldr	r3, [r7, #4]
 800b93e:	785b      	ldrb	r3, [r3, #1]
 800b940:	021b      	lsls	r3, r3, #8
  DCMI->ESCR = (uint32_t)(DCMI_CodesInitStruct->DCMI_FrameStartCode |
 800b942:	431a      	orrs	r2, r3
                          ((uint32_t)DCMI_CodesInitStruct->DCMI_LineEndCode << 16)|
 800b944:	687b      	ldr	r3, [r7, #4]
 800b946:	789b      	ldrb	r3, [r3, #2]
 800b948:	041b      	lsls	r3, r3, #16
                          ((uint32_t)DCMI_CodesInitStruct->DCMI_LineStartCode << 8)|
 800b94a:	431a      	orrs	r2, r3
                          ((uint32_t)DCMI_CodesInitStruct->DCMI_FrameEndCode << 24));
 800b94c:	687b      	ldr	r3, [r7, #4]
 800b94e:	78db      	ldrb	r3, [r3, #3]
 800b950:	061b      	lsls	r3, r3, #24
  DCMI->ESCR = (uint32_t)(DCMI_CodesInitStruct->DCMI_FrameStartCode |
 800b952:	4313      	orrs	r3, r2
 800b954:	618b      	str	r3, [r1, #24]
}
 800b956:	bf00      	nop
 800b958:	370c      	adds	r7, #12
 800b95a:	46bd      	mov	sp, r7
 800b95c:	f85d 7b04 	ldr.w	r7, [sp], #4
 800b960:	4770      	bx	lr
 800b962:	bf00      	nop
 800b964:	50050000 	.word	0x50050000

0800b968 <DCMI_JPEGCmd>:
  * @param  NewState: new state of the DCMI JPEG format. 
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void DCMI_JPEGCmd(FunctionalState NewState)
{
 800b968:	b480      	push	{r7}
 800b96a:	b083      	sub	sp, #12
 800b96c:	af00      	add	r7, sp, #0
 800b96e:	4603      	mov	r3, r0
 800b970:	71fb      	strb	r3, [r7, #7]
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
 
  if (NewState != DISABLE)
 800b972:	79fb      	ldrb	r3, [r7, #7]
 800b974:	2b00      	cmp	r3, #0
 800b976:	d006      	beq.n	800b986 <DCMI_JPEGCmd+0x1e>
  {
    /* Enable the DCMI JPEG format */
    DCMI->CR |= (uint32_t)DCMI_CR_JPEG;
 800b978:	4a09      	ldr	r2, [pc, #36]	; (800b9a0 <DCMI_JPEGCmd+0x38>)
 800b97a:	4b09      	ldr	r3, [pc, #36]	; (800b9a0 <DCMI_JPEGCmd+0x38>)
 800b97c:	681b      	ldr	r3, [r3, #0]
 800b97e:	f043 0308 	orr.w	r3, r3, #8
 800b982:	6013      	str	r3, [r2, #0]
  else
  {
    /* Disable the DCMI JPEG format */
    DCMI->CR &= ~(uint32_t)DCMI_CR_JPEG;
  }
}
 800b984:	e005      	b.n	800b992 <DCMI_JPEGCmd+0x2a>
    DCMI->CR &= ~(uint32_t)DCMI_CR_JPEG;
 800b986:	4a06      	ldr	r2, [pc, #24]	; (800b9a0 <DCMI_JPEGCmd+0x38>)
 800b988:	4b05      	ldr	r3, [pc, #20]	; (800b9a0 <DCMI_JPEGCmd+0x38>)
 800b98a:	681b      	ldr	r3, [r3, #0]
 800b98c:	f023 0308 	bic.w	r3, r3, #8
 800b990:	6013      	str	r3, [r2, #0]
}
 800b992:	bf00      	nop
 800b994:	370c      	adds	r7, #12
 800b996:	46bd      	mov	sp, r7
 800b998:	f85d 7b04 	ldr.w	r7, [sp], #4
 800b99c:	4770      	bx	lr
 800b99e:	bf00      	nop
 800b9a0:	50050000 	.word	0x50050000

0800b9a4 <DCMI_Cmd>:
  * @param  NewState: new state of the DCMI interface. 
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void DCMI_Cmd(FunctionalState NewState)
{
 800b9a4:	b480      	push	{r7}
 800b9a6:	b083      	sub	sp, #12
 800b9a8:	af00      	add	r7, sp, #0
 800b9aa:	4603      	mov	r3, r0
 800b9ac:	71fb      	strb	r3, [r7, #7]
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
 800b9ae:	79fb      	ldrb	r3, [r7, #7]
 800b9b0:	2b00      	cmp	r3, #0
 800b9b2:	d006      	beq.n	800b9c2 <DCMI_Cmd+0x1e>
  {
    /* Enable the DCMI by setting ENABLE bit */
    DCMI->CR |= (uint32_t)DCMI_CR_ENABLE;
 800b9b4:	4a09      	ldr	r2, [pc, #36]	; (800b9dc <DCMI_Cmd+0x38>)
 800b9b6:	4b09      	ldr	r3, [pc, #36]	; (800b9dc <DCMI_Cmd+0x38>)
 800b9b8:	681b      	ldr	r3, [r3, #0]
 800b9ba:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 800b9be:	6013      	str	r3, [r2, #0]
  else
  {
    /* Disable the DCMI by clearing ENABLE bit */
    DCMI->CR &= ~(uint32_t)DCMI_CR_ENABLE;
  }
}
 800b9c0:	e005      	b.n	800b9ce <DCMI_Cmd+0x2a>
    DCMI->CR &= ~(uint32_t)DCMI_CR_ENABLE;
 800b9c2:	4a06      	ldr	r2, [pc, #24]	; (800b9dc <DCMI_Cmd+0x38>)
 800b9c4:	4b05      	ldr	r3, [pc, #20]	; (800b9dc <DCMI_Cmd+0x38>)
 800b9c6:	681b      	ldr	r3, [r3, #0]
 800b9c8:	f423 4380 	bic.w	r3, r3, #16384	; 0x4000
 800b9cc:	6013      	str	r3, [r2, #0]
}
 800b9ce:	bf00      	nop
 800b9d0:	370c      	adds	r7, #12
 800b9d2:	46bd      	mov	sp, r7
 800b9d4:	f85d 7b04 	ldr.w	r7, [sp], #4
 800b9d8:	4770      	bx	lr
 800b9da:	bf00      	nop
 800b9dc:	50050000 	.word	0x50050000

0800b9e0 <DCMI_CaptureCmd>:
  * @param  NewState: new state of the DCMI capture. 
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void DCMI_CaptureCmd(FunctionalState NewState)
{
 800b9e0:	b480      	push	{r7}
 800b9e2:	b083      	sub	sp, #12
 800b9e4:	af00      	add	r7, sp, #0
 800b9e6:	4603      	mov	r3, r0
 800b9e8:	71fb      	strb	r3, [r7, #7]
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
    
  if (NewState != DISABLE)
 800b9ea:	79fb      	ldrb	r3, [r7, #7]
 800b9ec:	2b00      	cmp	r3, #0
 800b9ee:	d006      	beq.n	800b9fe <DCMI_CaptureCmd+0x1e>
  {
    /* Enable the DCMI Capture */
    DCMI->CR |= (uint32_t)DCMI_CR_CAPTURE;
 800b9f0:	4a09      	ldr	r2, [pc, #36]	; (800ba18 <DCMI_CaptureCmd+0x38>)
 800b9f2:	4b09      	ldr	r3, [pc, #36]	; (800ba18 <DCMI_CaptureCmd+0x38>)
 800b9f4:	681b      	ldr	r3, [r3, #0]
 800b9f6:	f043 0301 	orr.w	r3, r3, #1
 800b9fa:	6013      	str	r3, [r2, #0]
  else
  {
    /* Disable the DCMI Capture */
    DCMI->CR &= ~(uint32_t)DCMI_CR_CAPTURE;
  }
}
 800b9fc:	e005      	b.n	800ba0a <DCMI_CaptureCmd+0x2a>
    DCMI->CR &= ~(uint32_t)DCMI_CR_CAPTURE;
 800b9fe:	4a06      	ldr	r2, [pc, #24]	; (800ba18 <DCMI_CaptureCmd+0x38>)
 800ba00:	4b05      	ldr	r3, [pc, #20]	; (800ba18 <DCMI_CaptureCmd+0x38>)
 800ba02:	681b      	ldr	r3, [r3, #0]
 800ba04:	f023 0301 	bic.w	r3, r3, #1
 800ba08:	6013      	str	r3, [r2, #0]
}
 800ba0a:	bf00      	nop
 800ba0c:	370c      	adds	r7, #12
 800ba0e:	46bd      	mov	sp, r7
 800ba10:	f85d 7b04 	ldr.w	r7, [sp], #4
 800ba14:	4770      	bx	lr
 800ba16:	bf00      	nop
 800ba18:	50050000 	.word	0x50050000

0800ba1c <DCMI_ReadData>:
  * @brief  Reads the data stored in the DR register.
  * @param  None 
  * @retval Data register value
  */
uint32_t DCMI_ReadData(void)
{
 800ba1c:	b480      	push	{r7}
 800ba1e:	af00      	add	r7, sp, #0
  return DCMI->DR;
 800ba20:	4b03      	ldr	r3, [pc, #12]	; (800ba30 <DCMI_ReadData+0x14>)
 800ba22:	6a9b      	ldr	r3, [r3, #40]	; 0x28
}
 800ba24:	4618      	mov	r0, r3
 800ba26:	46bd      	mov	sp, r7
 800ba28:	f85d 7b04 	ldr.w	r7, [sp], #4
 800ba2c:	4770      	bx	lr
 800ba2e:	bf00      	nop
 800ba30:	50050000 	.word	0x50050000

0800ba34 <DCMI_ITConfig>:
  * @param  NewState: new state of the specified DCMI interrupts.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void DCMI_ITConfig(uint16_t DCMI_IT, FunctionalState NewState)
{
 800ba34:	b480      	push	{r7}
 800ba36:	b083      	sub	sp, #12
 800ba38:	af00      	add	r7, sp, #0
 800ba3a:	4603      	mov	r3, r0
 800ba3c:	460a      	mov	r2, r1
 800ba3e:	80fb      	strh	r3, [r7, #6]
 800ba40:	4613      	mov	r3, r2
 800ba42:	717b      	strb	r3, [r7, #5]
  /* Check the parameters */
  assert_param(IS_DCMI_CONFIG_IT(DCMI_IT));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
 800ba44:	797b      	ldrb	r3, [r7, #5]
 800ba46:	2b00      	cmp	r3, #0
 800ba48:	d006      	beq.n	800ba58 <DCMI_ITConfig+0x24>
  {
    /* Enable the Interrupt sources */
    DCMI->IER |= DCMI_IT;
 800ba4a:	490a      	ldr	r1, [pc, #40]	; (800ba74 <DCMI_ITConfig+0x40>)
 800ba4c:	4b09      	ldr	r3, [pc, #36]	; (800ba74 <DCMI_ITConfig+0x40>)
 800ba4e:	68da      	ldr	r2, [r3, #12]
 800ba50:	88fb      	ldrh	r3, [r7, #6]
 800ba52:	4313      	orrs	r3, r2
 800ba54:	60cb      	str	r3, [r1, #12]
  else
  {
    /* Disable the Interrupt sources */
    DCMI->IER &= (uint16_t)(~DCMI_IT);
  }  
}
 800ba56:	e007      	b.n	800ba68 <DCMI_ITConfig+0x34>
    DCMI->IER &= (uint16_t)(~DCMI_IT);
 800ba58:	4906      	ldr	r1, [pc, #24]	; (800ba74 <DCMI_ITConfig+0x40>)
 800ba5a:	4b06      	ldr	r3, [pc, #24]	; (800ba74 <DCMI_ITConfig+0x40>)
 800ba5c:	68db      	ldr	r3, [r3, #12]
 800ba5e:	88fa      	ldrh	r2, [r7, #6]
 800ba60:	43d2      	mvns	r2, r2
 800ba62:	b292      	uxth	r2, r2
 800ba64:	4013      	ands	r3, r2
 800ba66:	60cb      	str	r3, [r1, #12]
}
 800ba68:	bf00      	nop
 800ba6a:	370c      	adds	r7, #12
 800ba6c:	46bd      	mov	sp, r7
 800ba6e:	f85d 7b04 	ldr.w	r7, [sp], #4
 800ba72:	4770      	bx	lr
 800ba74:	50050000 	.word	0x50050000

0800ba78 <DCMI_GetFlagStatus>:
  *            @arg DCMI_FLAG_VSYNC: VSYNC flag mask
  *            @arg DCMI_FLAG_FNE: Fifo not empty flag mask
  * @retval The new state of DCMI_FLAG (SET or RESET).
  */
FlagStatus DCMI_GetFlagStatus(uint16_t DCMI_FLAG)
{
 800ba78:	b480      	push	{r7}
 800ba7a:	b087      	sub	sp, #28
 800ba7c:	af00      	add	r7, sp, #0
 800ba7e:	4603      	mov	r3, r0
 800ba80:	80fb      	strh	r3, [r7, #6]
  FlagStatus bitstatus = RESET;
 800ba82:	2300      	movs	r3, #0
 800ba84:	75fb      	strb	r3, [r7, #23]
  uint32_t dcmireg, tempreg = 0;
 800ba86:	2300      	movs	r3, #0
 800ba88:	613b      	str	r3, [r7, #16]

  /* Check the parameters */
  assert_param(IS_DCMI_GET_FLAG(DCMI_FLAG));
  
  /* Get the DCMI register index */
  dcmireg = (((uint16_t)DCMI_FLAG) >> 12);
 800ba8a:	88fb      	ldrh	r3, [r7, #6]
 800ba8c:	0b1b      	lsrs	r3, r3, #12
 800ba8e:	b29b      	uxth	r3, r3
 800ba90:	60fb      	str	r3, [r7, #12]
  
  if (dcmireg == 0x00) /* The FLAG is in RISR register */
 800ba92:	68fb      	ldr	r3, [r7, #12]
 800ba94:	2b00      	cmp	r3, #0
 800ba96:	d103      	bne.n	800baa0 <DCMI_GetFlagStatus+0x28>
  {
    tempreg= DCMI->RISR;
 800ba98:	4b0f      	ldr	r3, [pc, #60]	; (800bad8 <DCMI_GetFlagStatus+0x60>)
 800ba9a:	689b      	ldr	r3, [r3, #8]
 800ba9c:	613b      	str	r3, [r7, #16]
 800ba9e:	e009      	b.n	800bab4 <DCMI_GetFlagStatus+0x3c>
  }
  else if (dcmireg == 0x02) /* The FLAG is in SR register */
 800baa0:	68fb      	ldr	r3, [r7, #12]
 800baa2:	2b02      	cmp	r3, #2
 800baa4:	d103      	bne.n	800baae <DCMI_GetFlagStatus+0x36>
  {
    tempreg = DCMI->SR;
 800baa6:	4b0c      	ldr	r3, [pc, #48]	; (800bad8 <DCMI_GetFlagStatus+0x60>)
 800baa8:	685b      	ldr	r3, [r3, #4]
 800baaa:	613b      	str	r3, [r7, #16]
 800baac:	e002      	b.n	800bab4 <DCMI_GetFlagStatus+0x3c>
  }
  else /* The FLAG is in MISR register */
  {
    tempreg = DCMI->MISR;
 800baae:	4b0a      	ldr	r3, [pc, #40]	; (800bad8 <DCMI_GetFlagStatus+0x60>)
 800bab0:	691b      	ldr	r3, [r3, #16]
 800bab2:	613b      	str	r3, [r7, #16]
  }
  
  if ((tempreg & DCMI_FLAG) != (uint16_t)RESET )
 800bab4:	88fa      	ldrh	r2, [r7, #6]
 800bab6:	693b      	ldr	r3, [r7, #16]
 800bab8:	4013      	ands	r3, r2
 800baba:	2b00      	cmp	r3, #0
 800babc:	d002      	beq.n	800bac4 <DCMI_GetFlagStatus+0x4c>
  {
    bitstatus = SET;
 800babe:	2301      	movs	r3, #1
 800bac0:	75fb      	strb	r3, [r7, #23]
 800bac2:	e001      	b.n	800bac8 <DCMI_GetFlagStatus+0x50>
  }
  else
  {
    bitstatus = RESET;
 800bac4:	2300      	movs	r3, #0
 800bac6:	75fb      	strb	r3, [r7, #23]
  }
  /* Return the DCMI_FLAG status */
  return  bitstatus;
 800bac8:	7dfb      	ldrb	r3, [r7, #23]
}
 800baca:	4618      	mov	r0, r3
 800bacc:	371c      	adds	r7, #28
 800bace:	46bd      	mov	sp, r7
 800bad0:	f85d 7b04 	ldr.w	r7, [sp], #4
 800bad4:	4770      	bx	lr
 800bad6:	bf00      	nop
 800bad8:	50050000 	.word	0x50050000

0800badc <DCMI_ClearFlag>:
  *            @arg DCMI_FLAG_VSYNCRI: VSYNC Raw flag mask
  *            @arg DCMI_FLAG_LINERI: Line Raw flag mask
  * @retval None
  */
void DCMI_ClearFlag(uint16_t DCMI_FLAG)
{
 800badc:	b480      	push	{r7}
 800bade:	b083      	sub	sp, #12
 800bae0:	af00      	add	r7, sp, #0
 800bae2:	4603      	mov	r3, r0
 800bae4:	80fb      	strh	r3, [r7, #6]
  assert_param(IS_DCMI_CLEAR_FLAG(DCMI_FLAG));
  
  /* Clear the flag by writing in the ICR register 1 in the corresponding 
  Flag position*/
  
  DCMI->ICR = DCMI_FLAG;
 800bae6:	4a04      	ldr	r2, [pc, #16]	; (800baf8 <DCMI_ClearFlag+0x1c>)
 800bae8:	88fb      	ldrh	r3, [r7, #6]
 800baea:	6153      	str	r3, [r2, #20]
}
 800baec:	bf00      	nop
 800baee:	370c      	adds	r7, #12
 800baf0:	46bd      	mov	sp, r7
 800baf2:	f85d 7b04 	ldr.w	r7, [sp], #4
 800baf6:	4770      	bx	lr
 800baf8:	50050000 	.word	0x50050000

0800bafc <DCMI_GetITStatus>:
  *            @arg DCMI_IT_VSYNC: VSYNC interrupt mask
  *            @arg DCMI_IT_LINE: Line interrupt mask
  * @retval The new state of DCMI_IT (SET or RESET).
  */
ITStatus DCMI_GetITStatus(uint16_t DCMI_IT)
{
 800bafc:	b480      	push	{r7}
 800bafe:	b085      	sub	sp, #20
 800bb00:	af00      	add	r7, sp, #0
 800bb02:	4603      	mov	r3, r0
 800bb04:	80fb      	strh	r3, [r7, #6]
  ITStatus bitstatus = RESET;
 800bb06:	2300      	movs	r3, #0
 800bb08:	73fb      	strb	r3, [r7, #15]
  uint32_t itstatus = 0;
 800bb0a:	2300      	movs	r3, #0
 800bb0c:	60bb      	str	r3, [r7, #8]
  
  /* Check the parameters */
  assert_param(IS_DCMI_GET_IT(DCMI_IT));
  
  itstatus = DCMI->MISR & DCMI_IT; /* Only masked interrupts are checked */
 800bb0e:	4b0a      	ldr	r3, [pc, #40]	; (800bb38 <DCMI_GetITStatus+0x3c>)
 800bb10:	691a      	ldr	r2, [r3, #16]
 800bb12:	88fb      	ldrh	r3, [r7, #6]
 800bb14:	4013      	ands	r3, r2
 800bb16:	60bb      	str	r3, [r7, #8]
  
  if ((itstatus != (uint16_t)RESET))
 800bb18:	68bb      	ldr	r3, [r7, #8]
 800bb1a:	2b00      	cmp	r3, #0
 800bb1c:	d002      	beq.n	800bb24 <DCMI_GetITStatus+0x28>
  {
    bitstatus = SET;
 800bb1e:	2301      	movs	r3, #1
 800bb20:	73fb      	strb	r3, [r7, #15]
 800bb22:	e001      	b.n	800bb28 <DCMI_GetITStatus+0x2c>
  }
  else
  {
    bitstatus = RESET;
 800bb24:	2300      	movs	r3, #0
 800bb26:	73fb      	strb	r3, [r7, #15]
  }
  return bitstatus;
 800bb28:	7bfb      	ldrb	r3, [r7, #15]
}
 800bb2a:	4618      	mov	r0, r3
 800bb2c:	3714      	adds	r7, #20
 800bb2e:	46bd      	mov	sp, r7
 800bb30:	f85d 7b04 	ldr.w	r7, [sp], #4
 800bb34:	4770      	bx	lr
 800bb36:	bf00      	nop
 800bb38:	50050000 	.word	0x50050000

0800bb3c <DCMI_ClearITPendingBit>:
  *            @arg DCMI_IT_VSYNC: VSYNC interrupt mask
  *            @arg DCMI_IT_LINE: Line interrupt mask
  * @retval None
  */
void DCMI_ClearITPendingBit(uint16_t DCMI_IT)
{
 800bb3c:	b480      	push	{r7}
 800bb3e:	b083      	sub	sp, #12
 800bb40:	af00      	add	r7, sp, #0
 800bb42:	4603      	mov	r3, r0
 800bb44:	80fb      	strh	r3, [r7, #6]
  /* Clear the interrupt pending Bit by writing in the ICR register 1 in the 
  corresponding pending Bit position*/
  
  DCMI->ICR = DCMI_IT;
 800bb46:	4a04      	ldr	r2, [pc, #16]	; (800bb58 <DCMI_ClearITPendingBit+0x1c>)
 800bb48:	88fb      	ldrh	r3, [r7, #6]
 800bb4a:	6153      	str	r3, [r2, #20]
}
 800bb4c:	bf00      	nop
 800bb4e:	370c      	adds	r7, #12
 800bb50:	46bd      	mov	sp, r7
 800bb52:	f85d 7b04 	ldr.w	r7, [sp], #4
 800bb56:	4770      	bx	lr
 800bb58:	50050000 	.word	0x50050000

0800bb5c <DMA_DeInit>:
  * @param  DMAy_Streamx: where y can be 1 or 2 to select the DMA and x can be 0
  *         to 7 to select the DMA Stream.
  * @retval None
  */
void DMA_DeInit(DMA_Stream_TypeDef* DMAy_Streamx)
{
 800bb5c:	b480      	push	{r7}
 800bb5e:	b083      	sub	sp, #12
 800bb60:	af00      	add	r7, sp, #0
 800bb62:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_DMA_ALL_PERIPH(DMAy_Streamx));

  /* Disable the selected DMAy Streamx */
  DMAy_Streamx->CR &= ~((uint32_t)DMA_SxCR_EN);
 800bb64:	687b      	ldr	r3, [r7, #4]
 800bb66:	681b      	ldr	r3, [r3, #0]
 800bb68:	f023 0201 	bic.w	r2, r3, #1
 800bb6c:	687b      	ldr	r3, [r7, #4]
 800bb6e:	601a      	str	r2, [r3, #0]

  /* Reset DMAy Streamx control register */
  DMAy_Streamx->CR  = 0;
 800bb70:	687b      	ldr	r3, [r7, #4]
 800bb72:	2200      	movs	r2, #0
 800bb74:	601a      	str	r2, [r3, #0]
  
  /* Reset DMAy Streamx Number of Data to Transfer register */
  DMAy_Streamx->NDTR = 0;
 800bb76:	687b      	ldr	r3, [r7, #4]
 800bb78:	2200      	movs	r2, #0
 800bb7a:	605a      	str	r2, [r3, #4]
  
  /* Reset DMAy Streamx peripheral address register */
  DMAy_Streamx->PAR  = 0;
 800bb7c:	687b      	ldr	r3, [r7, #4]
 800bb7e:	2200      	movs	r2, #0
 800bb80:	609a      	str	r2, [r3, #8]
  
  /* Reset DMAy Streamx memory 0 address register */
  DMAy_Streamx->M0AR = 0;
 800bb82:	687b      	ldr	r3, [r7, #4]
 800bb84:	2200      	movs	r2, #0
 800bb86:	60da      	str	r2, [r3, #12]

  /* Reset DMAy Streamx memory 1 address register */
  DMAy_Streamx->M1AR = 0;
 800bb88:	687b      	ldr	r3, [r7, #4]
 800bb8a:	2200      	movs	r2, #0
 800bb8c:	611a      	str	r2, [r3, #16]

  /* Reset DMAy Streamx FIFO control register */
  DMAy_Streamx->FCR = (uint32_t)0x00000021; 
 800bb8e:	687b      	ldr	r3, [r7, #4]
 800bb90:	2221      	movs	r2, #33	; 0x21
 800bb92:	615a      	str	r2, [r3, #20]

  /* Reset interrupt pending bits for the selected stream */
  if (DMAy_Streamx == DMA1_Stream0)
 800bb94:	687b      	ldr	r3, [r7, #4]
 800bb96:	4a46      	ldr	r2, [pc, #280]	; (800bcb0 <DMA_DeInit+0x154>)
 800bb98:	4293      	cmp	r3, r2
 800bb9a:	d103      	bne.n	800bba4 <DMA_DeInit+0x48>
  {
    /* Reset interrupt pending bits for DMA1 Stream0 */
    DMA1->LIFCR = DMA_Stream0_IT_MASK;
 800bb9c:	4b45      	ldr	r3, [pc, #276]	; (800bcb4 <DMA_DeInit+0x158>)
 800bb9e:	223d      	movs	r2, #61	; 0x3d
 800bba0:	609a      	str	r2, [r3, #8]
    {
      /* Reset interrupt pending bits for DMA2 Stream7 */
      DMA2->HIFCR = DMA_Stream7_IT_MASK;
    }
  }
}
 800bba2:	e07e      	b.n	800bca2 <DMA_DeInit+0x146>
  else if (DMAy_Streamx == DMA1_Stream1)
 800bba4:	687b      	ldr	r3, [r7, #4]
 800bba6:	4a44      	ldr	r2, [pc, #272]	; (800bcb8 <DMA_DeInit+0x15c>)
 800bba8:	4293      	cmp	r3, r2
 800bbaa:	d104      	bne.n	800bbb6 <DMA_DeInit+0x5a>
    DMA1->LIFCR = DMA_Stream1_IT_MASK;
 800bbac:	4b41      	ldr	r3, [pc, #260]	; (800bcb4 <DMA_DeInit+0x158>)
 800bbae:	f44f 6274 	mov.w	r2, #3904	; 0xf40
 800bbb2:	609a      	str	r2, [r3, #8]
}
 800bbb4:	e075      	b.n	800bca2 <DMA_DeInit+0x146>
  else if (DMAy_Streamx == DMA1_Stream2)
 800bbb6:	687b      	ldr	r3, [r7, #4]
 800bbb8:	4a40      	ldr	r2, [pc, #256]	; (800bcbc <DMA_DeInit+0x160>)
 800bbba:	4293      	cmp	r3, r2
 800bbbc:	d104      	bne.n	800bbc8 <DMA_DeInit+0x6c>
    DMA1->LIFCR = DMA_Stream2_IT_MASK;
 800bbbe:	4b3d      	ldr	r3, [pc, #244]	; (800bcb4 <DMA_DeInit+0x158>)
 800bbc0:	f44f 1274 	mov.w	r2, #3997696	; 0x3d0000
 800bbc4:	609a      	str	r2, [r3, #8]
}
 800bbc6:	e06c      	b.n	800bca2 <DMA_DeInit+0x146>
  else if (DMAy_Streamx == DMA1_Stream3)
 800bbc8:	687b      	ldr	r3, [r7, #4]
 800bbca:	4a3d      	ldr	r2, [pc, #244]	; (800bcc0 <DMA_DeInit+0x164>)
 800bbcc:	4293      	cmp	r3, r2
 800bbce:	d104      	bne.n	800bbda <DMA_DeInit+0x7e>
    DMA1->LIFCR = DMA_Stream3_IT_MASK;
 800bbd0:	4b38      	ldr	r3, [pc, #224]	; (800bcb4 <DMA_DeInit+0x158>)
 800bbd2:	f04f 6274 	mov.w	r2, #255852544	; 0xf400000
 800bbd6:	609a      	str	r2, [r3, #8]
}
 800bbd8:	e063      	b.n	800bca2 <DMA_DeInit+0x146>
  else if (DMAy_Streamx == DMA1_Stream4)
 800bbda:	687b      	ldr	r3, [r7, #4]
 800bbdc:	4a39      	ldr	r2, [pc, #228]	; (800bcc4 <DMA_DeInit+0x168>)
 800bbde:	4293      	cmp	r3, r2
 800bbe0:	d103      	bne.n	800bbea <DMA_DeInit+0x8e>
    DMA1->HIFCR = DMA_Stream4_IT_MASK;
 800bbe2:	4b34      	ldr	r3, [pc, #208]	; (800bcb4 <DMA_DeInit+0x158>)
 800bbe4:	4a38      	ldr	r2, [pc, #224]	; (800bcc8 <DMA_DeInit+0x16c>)
 800bbe6:	60da      	str	r2, [r3, #12]
}
 800bbe8:	e05b      	b.n	800bca2 <DMA_DeInit+0x146>
  else if (DMAy_Streamx == DMA1_Stream5)
 800bbea:	687b      	ldr	r3, [r7, #4]
 800bbec:	4a37      	ldr	r2, [pc, #220]	; (800bccc <DMA_DeInit+0x170>)
 800bbee:	4293      	cmp	r3, r2
 800bbf0:	d103      	bne.n	800bbfa <DMA_DeInit+0x9e>
    DMA1->HIFCR = DMA_Stream5_IT_MASK;
 800bbf2:	4b30      	ldr	r3, [pc, #192]	; (800bcb4 <DMA_DeInit+0x158>)
 800bbf4:	4a36      	ldr	r2, [pc, #216]	; (800bcd0 <DMA_DeInit+0x174>)
 800bbf6:	60da      	str	r2, [r3, #12]
}
 800bbf8:	e053      	b.n	800bca2 <DMA_DeInit+0x146>
  else if (DMAy_Streamx == DMA1_Stream6)
 800bbfa:	687b      	ldr	r3, [r7, #4]
 800bbfc:	4a35      	ldr	r2, [pc, #212]	; (800bcd4 <DMA_DeInit+0x178>)
 800bbfe:	4293      	cmp	r3, r2
 800bc00:	d103      	bne.n	800bc0a <DMA_DeInit+0xae>
    DMA1->HIFCR = (uint32_t)DMA_Stream6_IT_MASK;
 800bc02:	4b2c      	ldr	r3, [pc, #176]	; (800bcb4 <DMA_DeInit+0x158>)
 800bc04:	4a34      	ldr	r2, [pc, #208]	; (800bcd8 <DMA_DeInit+0x17c>)
 800bc06:	60da      	str	r2, [r3, #12]
}
 800bc08:	e04b      	b.n	800bca2 <DMA_DeInit+0x146>
  else if (DMAy_Streamx == DMA1_Stream7)
 800bc0a:	687b      	ldr	r3, [r7, #4]
 800bc0c:	4a33      	ldr	r2, [pc, #204]	; (800bcdc <DMA_DeInit+0x180>)
 800bc0e:	4293      	cmp	r3, r2
 800bc10:	d104      	bne.n	800bc1c <DMA_DeInit+0xc0>
    DMA1->HIFCR = DMA_Stream7_IT_MASK;
 800bc12:	4b28      	ldr	r3, [pc, #160]	; (800bcb4 <DMA_DeInit+0x158>)
 800bc14:	f04f 523d 	mov.w	r2, #792723456	; 0x2f400000
 800bc18:	60da      	str	r2, [r3, #12]
}
 800bc1a:	e042      	b.n	800bca2 <DMA_DeInit+0x146>
  else if (DMAy_Streamx == DMA2_Stream0)
 800bc1c:	687b      	ldr	r3, [r7, #4]
 800bc1e:	4a30      	ldr	r2, [pc, #192]	; (800bce0 <DMA_DeInit+0x184>)
 800bc20:	4293      	cmp	r3, r2
 800bc22:	d103      	bne.n	800bc2c <DMA_DeInit+0xd0>
    DMA2->LIFCR = DMA_Stream0_IT_MASK;
 800bc24:	4b2f      	ldr	r3, [pc, #188]	; (800bce4 <DMA_DeInit+0x188>)
 800bc26:	223d      	movs	r2, #61	; 0x3d
 800bc28:	609a      	str	r2, [r3, #8]
}
 800bc2a:	e03a      	b.n	800bca2 <DMA_DeInit+0x146>
  else if (DMAy_Streamx == DMA2_Stream1)
 800bc2c:	687b      	ldr	r3, [r7, #4]
 800bc2e:	4a2e      	ldr	r2, [pc, #184]	; (800bce8 <DMA_DeInit+0x18c>)
 800bc30:	4293      	cmp	r3, r2
 800bc32:	d104      	bne.n	800bc3e <DMA_DeInit+0xe2>
    DMA2->LIFCR = DMA_Stream1_IT_MASK;
 800bc34:	4b2b      	ldr	r3, [pc, #172]	; (800bce4 <DMA_DeInit+0x188>)
 800bc36:	f44f 6274 	mov.w	r2, #3904	; 0xf40
 800bc3a:	609a      	str	r2, [r3, #8]
}
 800bc3c:	e031      	b.n	800bca2 <DMA_DeInit+0x146>
  else if (DMAy_Streamx == DMA2_Stream2)
 800bc3e:	687b      	ldr	r3, [r7, #4]
 800bc40:	4a2a      	ldr	r2, [pc, #168]	; (800bcec <DMA_DeInit+0x190>)
 800bc42:	4293      	cmp	r3, r2
 800bc44:	d104      	bne.n	800bc50 <DMA_DeInit+0xf4>
    DMA2->LIFCR = DMA_Stream2_IT_MASK;
 800bc46:	4b27      	ldr	r3, [pc, #156]	; (800bce4 <DMA_DeInit+0x188>)
 800bc48:	f44f 1274 	mov.w	r2, #3997696	; 0x3d0000
 800bc4c:	609a      	str	r2, [r3, #8]
}
 800bc4e:	e028      	b.n	800bca2 <DMA_DeInit+0x146>
  else if (DMAy_Streamx == DMA2_Stream3)
 800bc50:	687b      	ldr	r3, [r7, #4]
 800bc52:	4a27      	ldr	r2, [pc, #156]	; (800bcf0 <DMA_DeInit+0x194>)
 800bc54:	4293      	cmp	r3, r2
 800bc56:	d104      	bne.n	800bc62 <DMA_DeInit+0x106>
    DMA2->LIFCR = DMA_Stream3_IT_MASK;
 800bc58:	4b22      	ldr	r3, [pc, #136]	; (800bce4 <DMA_DeInit+0x188>)
 800bc5a:	f04f 6274 	mov.w	r2, #255852544	; 0xf400000
 800bc5e:	609a      	str	r2, [r3, #8]
}
 800bc60:	e01f      	b.n	800bca2 <DMA_DeInit+0x146>
  else if (DMAy_Streamx == DMA2_Stream4)
 800bc62:	687b      	ldr	r3, [r7, #4]
 800bc64:	4a23      	ldr	r2, [pc, #140]	; (800bcf4 <DMA_DeInit+0x198>)
 800bc66:	4293      	cmp	r3, r2
 800bc68:	d103      	bne.n	800bc72 <DMA_DeInit+0x116>
    DMA2->HIFCR = DMA_Stream4_IT_MASK;
 800bc6a:	4b1e      	ldr	r3, [pc, #120]	; (800bce4 <DMA_DeInit+0x188>)
 800bc6c:	4a16      	ldr	r2, [pc, #88]	; (800bcc8 <DMA_DeInit+0x16c>)
 800bc6e:	60da      	str	r2, [r3, #12]
}
 800bc70:	e017      	b.n	800bca2 <DMA_DeInit+0x146>
  else if (DMAy_Streamx == DMA2_Stream5)
 800bc72:	687b      	ldr	r3, [r7, #4]
 800bc74:	4a20      	ldr	r2, [pc, #128]	; (800bcf8 <DMA_DeInit+0x19c>)
 800bc76:	4293      	cmp	r3, r2
 800bc78:	d103      	bne.n	800bc82 <DMA_DeInit+0x126>
    DMA2->HIFCR = DMA_Stream5_IT_MASK;
 800bc7a:	4b1a      	ldr	r3, [pc, #104]	; (800bce4 <DMA_DeInit+0x188>)
 800bc7c:	4a14      	ldr	r2, [pc, #80]	; (800bcd0 <DMA_DeInit+0x174>)
 800bc7e:	60da      	str	r2, [r3, #12]
}
 800bc80:	e00f      	b.n	800bca2 <DMA_DeInit+0x146>
  else if (DMAy_Streamx == DMA2_Stream6)
 800bc82:	687b      	ldr	r3, [r7, #4]
 800bc84:	4a1d      	ldr	r2, [pc, #116]	; (800bcfc <DMA_DeInit+0x1a0>)
 800bc86:	4293      	cmp	r3, r2
 800bc88:	d103      	bne.n	800bc92 <DMA_DeInit+0x136>
    DMA2->HIFCR = DMA_Stream6_IT_MASK;
 800bc8a:	4b16      	ldr	r3, [pc, #88]	; (800bce4 <DMA_DeInit+0x188>)
 800bc8c:	4a12      	ldr	r2, [pc, #72]	; (800bcd8 <DMA_DeInit+0x17c>)
 800bc8e:	60da      	str	r2, [r3, #12]
}
 800bc90:	e007      	b.n	800bca2 <DMA_DeInit+0x146>
    if (DMAy_Streamx == DMA2_Stream7)
 800bc92:	687b      	ldr	r3, [r7, #4]
 800bc94:	4a1a      	ldr	r2, [pc, #104]	; (800bd00 <DMA_DeInit+0x1a4>)
 800bc96:	4293      	cmp	r3, r2
 800bc98:	d103      	bne.n	800bca2 <DMA_DeInit+0x146>
      DMA2->HIFCR = DMA_Stream7_IT_MASK;
 800bc9a:	4b12      	ldr	r3, [pc, #72]	; (800bce4 <DMA_DeInit+0x188>)
 800bc9c:	f04f 523d 	mov.w	r2, #792723456	; 0x2f400000
 800bca0:	60da      	str	r2, [r3, #12]
}
 800bca2:	bf00      	nop
 800bca4:	370c      	adds	r7, #12
 800bca6:	46bd      	mov	sp, r7
 800bca8:	f85d 7b04 	ldr.w	r7, [sp], #4
 800bcac:	4770      	bx	lr
 800bcae:	bf00      	nop
 800bcb0:	40026010 	.word	0x40026010
 800bcb4:	40026000 	.word	0x40026000
 800bcb8:	40026028 	.word	0x40026028
 800bcbc:	40026040 	.word	0x40026040
 800bcc0:	40026058 	.word	0x40026058
 800bcc4:	40026070 	.word	0x40026070
 800bcc8:	2000003d 	.word	0x2000003d
 800bccc:	40026088 	.word	0x40026088
 800bcd0:	20000f40 	.word	0x20000f40
 800bcd4:	400260a0 	.word	0x400260a0
 800bcd8:	203d0000 	.word	0x203d0000
 800bcdc:	400260b8 	.word	0x400260b8
 800bce0:	40026410 	.word	0x40026410
 800bce4:	40026400 	.word	0x40026400
 800bce8:	40026428 	.word	0x40026428
 800bcec:	40026440 	.word	0x40026440
 800bcf0:	40026458 	.word	0x40026458
 800bcf4:	40026470 	.word	0x40026470
 800bcf8:	40026488 	.word	0x40026488
 800bcfc:	400264a0 	.word	0x400264a0
 800bd00:	400264b8 	.word	0x400264b8

0800bd04 <DMA_Init>:
  * @param  DMA_InitStruct: pointer to a DMA_InitTypeDef structure that contains
  *         the configuration information for the specified DMA Stream.  
  * @retval None
  */
void DMA_Init(DMA_Stream_TypeDef* DMAy_Streamx, DMA_InitTypeDef* DMA_InitStruct)
{
 800bd04:	b480      	push	{r7}
 800bd06:	b085      	sub	sp, #20
 800bd08:	af00      	add	r7, sp, #0
 800bd0a:	6078      	str	r0, [r7, #4]
 800bd0c:	6039      	str	r1, [r7, #0]
  uint32_t tmpreg = 0;
 800bd0e:	2300      	movs	r3, #0
 800bd10:	60fb      	str	r3, [r7, #12]
  assert_param(IS_DMA_MEMORY_BURST(DMA_InitStruct->DMA_MemoryBurst));
  assert_param(IS_DMA_PERIPHERAL_BURST(DMA_InitStruct->DMA_PeripheralBurst));

  /*------------------------- DMAy Streamx CR Configuration ------------------*/
  /* Get the DMAy_Streamx CR value */
  tmpreg = DMAy_Streamx->CR;
 800bd12:	687b      	ldr	r3, [r7, #4]
 800bd14:	681b      	ldr	r3, [r3, #0]
 800bd16:	60fb      	str	r3, [r7, #12]

  /* Clear CHSEL, MBURST, PBURST, PL, MSIZE, PSIZE, MINC, PINC, CIRC and DIR bits */
  tmpreg &= ((uint32_t)~(DMA_SxCR_CHSEL | DMA_SxCR_MBURST | DMA_SxCR_PBURST | \
 800bd18:	68fa      	ldr	r2, [r7, #12]
 800bd1a:	4b25      	ldr	r3, [pc, #148]	; (800bdb0 <DMA_Init+0xac>)
 800bd1c:	4013      	ands	r3, r2
 800bd1e:	60fb      	str	r3, [r7, #12]
  /* Set MSIZE bits according to DMA_MemoryDataSize value */
  /* Set CIRC bit according to DMA_Mode value */
  /* Set PL bits according to DMA_Priority value */
  /* Set MBURST bits according to DMA_MemoryBurst value */
  /* Set PBURST bits according to DMA_PeripheralBurst value */
  tmpreg |= DMA_InitStruct->DMA_Channel | DMA_InitStruct->DMA_DIR |
 800bd20:	683b      	ldr	r3, [r7, #0]
 800bd22:	681a      	ldr	r2, [r3, #0]
 800bd24:	683b      	ldr	r3, [r7, #0]
 800bd26:	68db      	ldr	r3, [r3, #12]
 800bd28:	431a      	orrs	r2, r3
            DMA_InitStruct->DMA_PeripheralInc | DMA_InitStruct->DMA_MemoryInc |
 800bd2a:	683b      	ldr	r3, [r7, #0]
 800bd2c:	695b      	ldr	r3, [r3, #20]
  tmpreg |= DMA_InitStruct->DMA_Channel | DMA_InitStruct->DMA_DIR |
 800bd2e:	431a      	orrs	r2, r3
            DMA_InitStruct->DMA_PeripheralInc | DMA_InitStruct->DMA_MemoryInc |
 800bd30:	683b      	ldr	r3, [r7, #0]
 800bd32:	699b      	ldr	r3, [r3, #24]
 800bd34:	431a      	orrs	r2, r3
            DMA_InitStruct->DMA_PeripheralDataSize | DMA_InitStruct->DMA_MemoryDataSize |
 800bd36:	683b      	ldr	r3, [r7, #0]
 800bd38:	69db      	ldr	r3, [r3, #28]
            DMA_InitStruct->DMA_PeripheralInc | DMA_InitStruct->DMA_MemoryInc |
 800bd3a:	431a      	orrs	r2, r3
            DMA_InitStruct->DMA_PeripheralDataSize | DMA_InitStruct->DMA_MemoryDataSize |
 800bd3c:	683b      	ldr	r3, [r7, #0]
 800bd3e:	6a1b      	ldr	r3, [r3, #32]
 800bd40:	431a      	orrs	r2, r3
            DMA_InitStruct->DMA_Mode | DMA_InitStruct->DMA_Priority |
 800bd42:	683b      	ldr	r3, [r7, #0]
 800bd44:	6a5b      	ldr	r3, [r3, #36]	; 0x24
            DMA_InitStruct->DMA_PeripheralDataSize | DMA_InitStruct->DMA_MemoryDataSize |
 800bd46:	431a      	orrs	r2, r3
            DMA_InitStruct->DMA_Mode | DMA_InitStruct->DMA_Priority |
 800bd48:	683b      	ldr	r3, [r7, #0]
 800bd4a:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800bd4c:	431a      	orrs	r2, r3
            DMA_InitStruct->DMA_MemoryBurst | DMA_InitStruct->DMA_PeripheralBurst;
 800bd4e:	683b      	ldr	r3, [r7, #0]
 800bd50:	6b5b      	ldr	r3, [r3, #52]	; 0x34
            DMA_InitStruct->DMA_Mode | DMA_InitStruct->DMA_Priority |
 800bd52:	431a      	orrs	r2, r3
            DMA_InitStruct->DMA_MemoryBurst | DMA_InitStruct->DMA_PeripheralBurst;
 800bd54:	683b      	ldr	r3, [r7, #0]
 800bd56:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 800bd58:	4313      	orrs	r3, r2
  tmpreg |= DMA_InitStruct->DMA_Channel | DMA_InitStruct->DMA_DIR |
 800bd5a:	68fa      	ldr	r2, [r7, #12]
 800bd5c:	4313      	orrs	r3, r2
 800bd5e:	60fb      	str	r3, [r7, #12]

  /* Write to DMAy Streamx CR register */
  DMAy_Streamx->CR = tmpreg;
 800bd60:	687b      	ldr	r3, [r7, #4]
 800bd62:	68fa      	ldr	r2, [r7, #12]
 800bd64:	601a      	str	r2, [r3, #0]

  /*------------------------- DMAy Streamx FCR Configuration -----------------*/
  /* Get the DMAy_Streamx FCR value */
  tmpreg = DMAy_Streamx->FCR;
 800bd66:	687b      	ldr	r3, [r7, #4]
 800bd68:	695b      	ldr	r3, [r3, #20]
 800bd6a:	60fb      	str	r3, [r7, #12]

  /* Clear DMDIS and FTH bits */
  tmpreg &= (uint32_t)~(DMA_SxFCR_DMDIS | DMA_SxFCR_FTH);
 800bd6c:	68fb      	ldr	r3, [r7, #12]
 800bd6e:	f023 0307 	bic.w	r3, r3, #7
 800bd72:	60fb      	str	r3, [r7, #12]

  /* Configure DMAy Streamx FIFO: 
    Set DMDIS bits according to DMA_FIFOMode value 
    Set FTH bits according to DMA_FIFOThreshold value */
  tmpreg |= DMA_InitStruct->DMA_FIFOMode | DMA_InitStruct->DMA_FIFOThreshold;
 800bd74:	683b      	ldr	r3, [r7, #0]
 800bd76:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 800bd78:	683b      	ldr	r3, [r7, #0]
 800bd7a:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800bd7c:	4313      	orrs	r3, r2
 800bd7e:	68fa      	ldr	r2, [r7, #12]
 800bd80:	4313      	orrs	r3, r2
 800bd82:	60fb      	str	r3, [r7, #12]

  /* Write to DMAy Streamx CR */
  DMAy_Streamx->FCR = tmpreg;
 800bd84:	687b      	ldr	r3, [r7, #4]
 800bd86:	68fa      	ldr	r2, [r7, #12]
 800bd88:	615a      	str	r2, [r3, #20]

  /*------------------------- DMAy Streamx NDTR Configuration ----------------*/
  /* Write to DMAy Streamx NDTR register */
  DMAy_Streamx->NDTR = DMA_InitStruct->DMA_BufferSize;
 800bd8a:	683b      	ldr	r3, [r7, #0]
 800bd8c:	691a      	ldr	r2, [r3, #16]
 800bd8e:	687b      	ldr	r3, [r7, #4]
 800bd90:	605a      	str	r2, [r3, #4]

  /*------------------------- DMAy Streamx PAR Configuration -----------------*/
  /* Write to DMAy Streamx PAR */
  DMAy_Streamx->PAR = DMA_InitStruct->DMA_PeripheralBaseAddr;
 800bd92:	683b      	ldr	r3, [r7, #0]
 800bd94:	685a      	ldr	r2, [r3, #4]
 800bd96:	687b      	ldr	r3, [r7, #4]
 800bd98:	609a      	str	r2, [r3, #8]

  /*------------------------- DMAy Streamx M0AR Configuration ----------------*/
  /* Write to DMAy Streamx M0AR */
  DMAy_Streamx->M0AR = DMA_InitStruct->DMA_Memory0BaseAddr;
 800bd9a:	683b      	ldr	r3, [r7, #0]
 800bd9c:	689a      	ldr	r2, [r3, #8]
 800bd9e:	687b      	ldr	r3, [r7, #4]
 800bda0:	60da      	str	r2, [r3, #12]
}
 800bda2:	bf00      	nop
 800bda4:	3714      	adds	r7, #20
 800bda6:	46bd      	mov	sp, r7
 800bda8:	f85d 7b04 	ldr.w	r7, [sp], #4
 800bdac:	4770      	bx	lr
 800bdae:	bf00      	nop
 800bdb0:	f01c803f 	.word	0xf01c803f

0800bdb4 <DMA_StructInit>:
  * @param  DMA_InitStruct : pointer to a DMA_InitTypeDef structure which will 
  *         be initialized.
  * @retval None
  */
void DMA_StructInit(DMA_InitTypeDef* DMA_InitStruct)
{
 800bdb4:	b480      	push	{r7}
 800bdb6:	b083      	sub	sp, #12
 800bdb8:	af00      	add	r7, sp, #0
 800bdba:	6078      	str	r0, [r7, #4]
  /*-------------- Reset DMA init structure parameters values ----------------*/
  /* Initialize the DMA_Channel member */
  DMA_InitStruct->DMA_Channel = 0;
 800bdbc:	687b      	ldr	r3, [r7, #4]
 800bdbe:	2200      	movs	r2, #0
 800bdc0:	601a      	str	r2, [r3, #0]

  /* Initialize the DMA_PeripheralBaseAddr member */
  DMA_InitStruct->DMA_PeripheralBaseAddr = 0;
 800bdc2:	687b      	ldr	r3, [r7, #4]
 800bdc4:	2200      	movs	r2, #0
 800bdc6:	605a      	str	r2, [r3, #4]

  /* Initialize the DMA_Memory0BaseAddr member */
  DMA_InitStruct->DMA_Memory0BaseAddr = 0;
 800bdc8:	687b      	ldr	r3, [r7, #4]
 800bdca:	2200      	movs	r2, #0
 800bdcc:	609a      	str	r2, [r3, #8]

  /* Initialize the DMA_DIR member */
  DMA_InitStruct->DMA_DIR = DMA_DIR_PeripheralToMemory;
 800bdce:	687b      	ldr	r3, [r7, #4]
 800bdd0:	2200      	movs	r2, #0
 800bdd2:	60da      	str	r2, [r3, #12]

  /* Initialize the DMA_BufferSize member */
  DMA_InitStruct->DMA_BufferSize = 0;
 800bdd4:	687b      	ldr	r3, [r7, #4]
 800bdd6:	2200      	movs	r2, #0
 800bdd8:	611a      	str	r2, [r3, #16]

  /* Initialize the DMA_PeripheralInc member */
  DMA_InitStruct->DMA_PeripheralInc = DMA_PeripheralInc_Disable;
 800bdda:	687b      	ldr	r3, [r7, #4]
 800bddc:	2200      	movs	r2, #0
 800bdde:	615a      	str	r2, [r3, #20]

  /* Initialize the DMA_MemoryInc member */
  DMA_InitStruct->DMA_MemoryInc = DMA_MemoryInc_Disable;
 800bde0:	687b      	ldr	r3, [r7, #4]
 800bde2:	2200      	movs	r2, #0
 800bde4:	619a      	str	r2, [r3, #24]

  /* Initialize the DMA_PeripheralDataSize member */
  DMA_InitStruct->DMA_PeripheralDataSize = DMA_PeripheralDataSize_Byte;
 800bde6:	687b      	ldr	r3, [r7, #4]
 800bde8:	2200      	movs	r2, #0
 800bdea:	61da      	str	r2, [r3, #28]

  /* Initialize the DMA_MemoryDataSize member */
  DMA_InitStruct->DMA_MemoryDataSize = DMA_MemoryDataSize_Byte;
 800bdec:	687b      	ldr	r3, [r7, #4]
 800bdee:	2200      	movs	r2, #0
 800bdf0:	621a      	str	r2, [r3, #32]

  /* Initialize the DMA_Mode member */
  DMA_InitStruct->DMA_Mode = DMA_Mode_Normal;
 800bdf2:	687b      	ldr	r3, [r7, #4]
 800bdf4:	2200      	movs	r2, #0
 800bdf6:	625a      	str	r2, [r3, #36]	; 0x24

  /* Initialize the DMA_Priority member */
  DMA_InitStruct->DMA_Priority = DMA_Priority_Low;
 800bdf8:	687b      	ldr	r3, [r7, #4]
 800bdfa:	2200      	movs	r2, #0
 800bdfc:	629a      	str	r2, [r3, #40]	; 0x28

  /* Initialize the DMA_FIFOMode member */
  DMA_InitStruct->DMA_FIFOMode = DMA_FIFOMode_Disable;
 800bdfe:	687b      	ldr	r3, [r7, #4]
 800be00:	2200      	movs	r2, #0
 800be02:	62da      	str	r2, [r3, #44]	; 0x2c

  /* Initialize the DMA_FIFOThreshold member */
  DMA_InitStruct->DMA_FIFOThreshold = DMA_FIFOThreshold_1QuarterFull;
 800be04:	687b      	ldr	r3, [r7, #4]
 800be06:	2200      	movs	r2, #0
 800be08:	631a      	str	r2, [r3, #48]	; 0x30

  /* Initialize the DMA_MemoryBurst member */
  DMA_InitStruct->DMA_MemoryBurst = DMA_MemoryBurst_Single;
 800be0a:	687b      	ldr	r3, [r7, #4]
 800be0c:	2200      	movs	r2, #0
 800be0e:	635a      	str	r2, [r3, #52]	; 0x34

  /* Initialize the DMA_PeripheralBurst member */
  DMA_InitStruct->DMA_PeripheralBurst = DMA_PeripheralBurst_Single;
 800be10:	687b      	ldr	r3, [r7, #4]
 800be12:	2200      	movs	r2, #0
 800be14:	639a      	str	r2, [r3, #56]	; 0x38
}
 800be16:	bf00      	nop
 800be18:	370c      	adds	r7, #12
 800be1a:	46bd      	mov	sp, r7
 800be1c:	f85d 7b04 	ldr.w	r7, [sp], #4
 800be20:	4770      	bx	lr

0800be22 <DMA_Cmd>:
  *        this single data is finished.            
  *    
  * @retval None
  */
void DMA_Cmd(DMA_Stream_TypeDef* DMAy_Streamx, FunctionalState NewState)
{
 800be22:	b480      	push	{r7}
 800be24:	b083      	sub	sp, #12
 800be26:	af00      	add	r7, sp, #0
 800be28:	6078      	str	r0, [r7, #4]
 800be2a:	460b      	mov	r3, r1
 800be2c:	70fb      	strb	r3, [r7, #3]
  /* Check the parameters */
  assert_param(IS_DMA_ALL_PERIPH(DMAy_Streamx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 800be2e:	78fb      	ldrb	r3, [r7, #3]
 800be30:	2b00      	cmp	r3, #0
 800be32:	d006      	beq.n	800be42 <DMA_Cmd+0x20>
  {
    /* Enable the selected DMAy Streamx by setting EN bit */
    DMAy_Streamx->CR |= (uint32_t)DMA_SxCR_EN;
 800be34:	687b      	ldr	r3, [r7, #4]
 800be36:	681b      	ldr	r3, [r3, #0]
 800be38:	f043 0201 	orr.w	r2, r3, #1
 800be3c:	687b      	ldr	r3, [r7, #4]
 800be3e:	601a      	str	r2, [r3, #0]
  else
  {
    /* Disable the selected DMAy Streamx by clearing EN bit */
    DMAy_Streamx->CR &= ~(uint32_t)DMA_SxCR_EN;
  }
}
 800be40:	e005      	b.n	800be4e <DMA_Cmd+0x2c>
    DMAy_Streamx->CR &= ~(uint32_t)DMA_SxCR_EN;
 800be42:	687b      	ldr	r3, [r7, #4]
 800be44:	681b      	ldr	r3, [r3, #0]
 800be46:	f023 0201 	bic.w	r2, r3, #1
 800be4a:	687b      	ldr	r3, [r7, #4]
 800be4c:	601a      	str	r2, [r3, #0]
}
 800be4e:	bf00      	nop
 800be50:	370c      	adds	r7, #12
 800be52:	46bd      	mov	sp, r7
 800be54:	f85d 7b04 	ldr.w	r7, [sp], #4
 800be58:	4770      	bx	lr

0800be5a <DMA_PeriphIncOffsetSizeConfig>:
  *            @arg DMA_PINCOS_WordAligned: Peripheral address increment offset is 
  *                                         fixed to 4 (32-bit aligned addresses). 
  * @retval None
  */
void DMA_PeriphIncOffsetSizeConfig(DMA_Stream_TypeDef* DMAy_Streamx, uint32_t DMA_Pincos)
{
 800be5a:	b480      	push	{r7}
 800be5c:	b083      	sub	sp, #12
 800be5e:	af00      	add	r7, sp, #0
 800be60:	6078      	str	r0, [r7, #4]
 800be62:	6039      	str	r1, [r7, #0]
  /* Check the parameters */
  assert_param(IS_DMA_ALL_PERIPH(DMAy_Streamx));
  assert_param(IS_DMA_PINCOS_SIZE(DMA_Pincos));

  /* Check the needed Peripheral increment offset */
  if(DMA_Pincos != DMA_PINCOS_Psize)
 800be64:	683b      	ldr	r3, [r7, #0]
 800be66:	2b00      	cmp	r3, #0
 800be68:	d006      	beq.n	800be78 <DMA_PeriphIncOffsetSizeConfig+0x1e>
  {
    /* Configure DMA_SxCR_PINCOS bit with the input parameter */
    DMAy_Streamx->CR |= (uint32_t)DMA_SxCR_PINCOS;     
 800be6a:	687b      	ldr	r3, [r7, #4]
 800be6c:	681b      	ldr	r3, [r3, #0]
 800be6e:	f443 4200 	orr.w	r2, r3, #32768	; 0x8000
 800be72:	687b      	ldr	r3, [r7, #4]
 800be74:	601a      	str	r2, [r3, #0]
  else
  {
    /* Clear the PINCOS bit: Peripheral address incremented according to PSIZE */
    DMAy_Streamx->CR &= ~(uint32_t)DMA_SxCR_PINCOS;    
  }
}
 800be76:	e005      	b.n	800be84 <DMA_PeriphIncOffsetSizeConfig+0x2a>
    DMAy_Streamx->CR &= ~(uint32_t)DMA_SxCR_PINCOS;    
 800be78:	687b      	ldr	r3, [r7, #4]
 800be7a:	681b      	ldr	r3, [r3, #0]
 800be7c:	f423 4200 	bic.w	r2, r3, #32768	; 0x8000
 800be80:	687b      	ldr	r3, [r7, #4]
 800be82:	601a      	str	r2, [r3, #0]
}
 800be84:	bf00      	nop
 800be86:	370c      	adds	r7, #12
 800be88:	46bd      	mov	sp, r7
 800be8a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800be8e:	4770      	bx	lr

0800be90 <DMA_FlowControllerConfig>:
  *            @arg DMA_FlowCtrl_Peripheral: DMAy_Streamx transactions flow controller 
  *                                          is the peripheral.    
  * @retval None
  */
void DMA_FlowControllerConfig(DMA_Stream_TypeDef* DMAy_Streamx, uint32_t DMA_FlowCtrl)
{
 800be90:	b480      	push	{r7}
 800be92:	b083      	sub	sp, #12
 800be94:	af00      	add	r7, sp, #0
 800be96:	6078      	str	r0, [r7, #4]
 800be98:	6039      	str	r1, [r7, #0]
  /* Check the parameters */
  assert_param(IS_DMA_ALL_PERIPH(DMAy_Streamx));
  assert_param(IS_DMA_FLOW_CTRL(DMA_FlowCtrl));

  /* Check the needed flow controller  */
  if(DMA_FlowCtrl != DMA_FlowCtrl_Memory)
 800be9a:	683b      	ldr	r3, [r7, #0]
 800be9c:	2b00      	cmp	r3, #0
 800be9e:	d006      	beq.n	800beae <DMA_FlowControllerConfig+0x1e>
  {
    /* Configure DMA_SxCR_PFCTRL bit with the input parameter */
    DMAy_Streamx->CR |= (uint32_t)DMA_SxCR_PFCTRL;   
 800bea0:	687b      	ldr	r3, [r7, #4]
 800bea2:	681b      	ldr	r3, [r3, #0]
 800bea4:	f043 0220 	orr.w	r2, r3, #32
 800bea8:	687b      	ldr	r3, [r7, #4]
 800beaa:	601a      	str	r2, [r3, #0]
  else
  {
    /* Clear the PFCTRL bit: Memory is the flow controller */
    DMAy_Streamx->CR &= ~(uint32_t)DMA_SxCR_PFCTRL;    
  }
}
 800beac:	e005      	b.n	800beba <DMA_FlowControllerConfig+0x2a>
    DMAy_Streamx->CR &= ~(uint32_t)DMA_SxCR_PFCTRL;    
 800beae:	687b      	ldr	r3, [r7, #4]
 800beb0:	681b      	ldr	r3, [r3, #0]
 800beb2:	f023 0220 	bic.w	r2, r3, #32
 800beb6:	687b      	ldr	r3, [r7, #4]
 800beb8:	601a      	str	r2, [r3, #0]
}
 800beba:	bf00      	nop
 800bebc:	370c      	adds	r7, #12
 800bebe:	46bd      	mov	sp, r7
 800bec0:	f85d 7b04 	ldr.w	r7, [sp], #4
 800bec4:	4770      	bx	lr

0800bec6 <DMA_SetCurrDataCounter>:
  *         DMAy_SxPAR register is considered as Peripheral.
  *      
  * @retval The number of remaining data units in the current DMAy Streamx transfer.
  */
void DMA_SetCurrDataCounter(DMA_Stream_TypeDef* DMAy_Streamx, uint16_t Counter)
{
 800bec6:	b480      	push	{r7}
 800bec8:	b083      	sub	sp, #12
 800beca:	af00      	add	r7, sp, #0
 800becc:	6078      	str	r0, [r7, #4]
 800bece:	460b      	mov	r3, r1
 800bed0:	807b      	strh	r3, [r7, #2]
  /* Check the parameters */
  assert_param(IS_DMA_ALL_PERIPH(DMAy_Streamx));

  /* Write the number of data units to be transferred */
  DMAy_Streamx->NDTR = (uint16_t)Counter;
 800bed2:	887a      	ldrh	r2, [r7, #2]
 800bed4:	687b      	ldr	r3, [r7, #4]
 800bed6:	605a      	str	r2, [r3, #4]
}
 800bed8:	bf00      	nop
 800beda:	370c      	adds	r7, #12
 800bedc:	46bd      	mov	sp, r7
 800bede:	f85d 7b04 	ldr.w	r7, [sp], #4
 800bee2:	4770      	bx	lr

0800bee4 <DMA_GetCurrDataCounter>:
  * @param  DMAy_Streamx: where y can be 1 or 2 to select the DMA and x can be 0
  *          to 7 to select the DMA Stream.
  * @retval The number of remaining data units in the current DMAy Streamx transfer.
  */
uint16_t DMA_GetCurrDataCounter(DMA_Stream_TypeDef* DMAy_Streamx)
{
 800bee4:	b480      	push	{r7}
 800bee6:	b083      	sub	sp, #12
 800bee8:	af00      	add	r7, sp, #0
 800beea:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_DMA_ALL_PERIPH(DMAy_Streamx));

  /* Return the number of remaining data units for DMAy Streamx */
  return ((uint16_t)(DMAy_Streamx->NDTR));
 800beec:	687b      	ldr	r3, [r7, #4]
 800beee:	685b      	ldr	r3, [r3, #4]
 800bef0:	b29b      	uxth	r3, r3
}
 800bef2:	4618      	mov	r0, r3
 800bef4:	370c      	adds	r7, #12
 800bef6:	46bd      	mov	sp, r7
 800bef8:	f85d 7b04 	ldr.w	r7, [sp], #4
 800befc:	4770      	bx	lr

0800befe <DMA_DoubleBufferModeConfig>:
  *   
  * @retval None
  */
void DMA_DoubleBufferModeConfig(DMA_Stream_TypeDef* DMAy_Streamx, uint32_t Memory1BaseAddr,
                                uint32_t DMA_CurrentMemory)
{  
 800befe:	b480      	push	{r7}
 800bf00:	b085      	sub	sp, #20
 800bf02:	af00      	add	r7, sp, #0
 800bf04:	60f8      	str	r0, [r7, #12]
 800bf06:	60b9      	str	r1, [r7, #8]
 800bf08:	607a      	str	r2, [r7, #4]
  /* Check the parameters */
  assert_param(IS_DMA_ALL_PERIPH(DMAy_Streamx));
  assert_param(IS_DMA_CURRENT_MEM(DMA_CurrentMemory));

  if (DMA_CurrentMemory != DMA_Memory_0)
 800bf0a:	687b      	ldr	r3, [r7, #4]
 800bf0c:	2b00      	cmp	r3, #0
 800bf0e:	d006      	beq.n	800bf1e <DMA_DoubleBufferModeConfig+0x20>
  {
    /* Set Memory 1 as current memory address */
    DMAy_Streamx->CR |= (uint32_t)(DMA_SxCR_CT);    
 800bf10:	68fb      	ldr	r3, [r7, #12]
 800bf12:	681b      	ldr	r3, [r3, #0]
 800bf14:	f443 2200 	orr.w	r2, r3, #524288	; 0x80000
 800bf18:	68fb      	ldr	r3, [r7, #12]
 800bf1a:	601a      	str	r2, [r3, #0]
 800bf1c:	e005      	b.n	800bf2a <DMA_DoubleBufferModeConfig+0x2c>
  }
  else
  {
    /* Set Memory 0 as current memory address */
    DMAy_Streamx->CR &= ~(uint32_t)(DMA_SxCR_CT);    
 800bf1e:	68fb      	ldr	r3, [r7, #12]
 800bf20:	681b      	ldr	r3, [r3, #0]
 800bf22:	f423 2200 	bic.w	r2, r3, #524288	; 0x80000
 800bf26:	68fb      	ldr	r3, [r7, #12]
 800bf28:	601a      	str	r2, [r3, #0]
  }

  /* Write to DMAy Streamx M1AR */
  DMAy_Streamx->M1AR = Memory1BaseAddr;
 800bf2a:	68fb      	ldr	r3, [r7, #12]
 800bf2c:	68ba      	ldr	r2, [r7, #8]
 800bf2e:	611a      	str	r2, [r3, #16]
}
 800bf30:	bf00      	nop
 800bf32:	3714      	adds	r7, #20
 800bf34:	46bd      	mov	sp, r7
 800bf36:	f85d 7b04 	ldr.w	r7, [sp], #4
 800bf3a:	4770      	bx	lr

0800bf3c <DMA_DoubleBufferModeCmd>:
  * @param  NewState: new state of the DMAy Streamx double buffer mode. 
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void DMA_DoubleBufferModeCmd(DMA_Stream_TypeDef* DMAy_Streamx, FunctionalState NewState)
{  
 800bf3c:	b480      	push	{r7}
 800bf3e:	b083      	sub	sp, #12
 800bf40:	af00      	add	r7, sp, #0
 800bf42:	6078      	str	r0, [r7, #4]
 800bf44:	460b      	mov	r3, r1
 800bf46:	70fb      	strb	r3, [r7, #3]
  /* Check the parameters */
  assert_param(IS_DMA_ALL_PERIPH(DMAy_Streamx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  /* Configure the Double Buffer mode */
  if (NewState != DISABLE)
 800bf48:	78fb      	ldrb	r3, [r7, #3]
 800bf4a:	2b00      	cmp	r3, #0
 800bf4c:	d006      	beq.n	800bf5c <DMA_DoubleBufferModeCmd+0x20>
  {
    /* Enable the Double buffer mode */
    DMAy_Streamx->CR |= (uint32_t)DMA_SxCR_DBM;
 800bf4e:	687b      	ldr	r3, [r7, #4]
 800bf50:	681b      	ldr	r3, [r3, #0]
 800bf52:	f443 2280 	orr.w	r2, r3, #262144	; 0x40000
 800bf56:	687b      	ldr	r3, [r7, #4]
 800bf58:	601a      	str	r2, [r3, #0]
  else
  {
    /* Disable the Double buffer mode */
    DMAy_Streamx->CR &= ~(uint32_t)DMA_SxCR_DBM;
  }
}
 800bf5a:	e005      	b.n	800bf68 <DMA_DoubleBufferModeCmd+0x2c>
    DMAy_Streamx->CR &= ~(uint32_t)DMA_SxCR_DBM;
 800bf5c:	687b      	ldr	r3, [r7, #4]
 800bf5e:	681b      	ldr	r3, [r3, #0]
 800bf60:	f423 2280 	bic.w	r2, r3, #262144	; 0x40000
 800bf64:	687b      	ldr	r3, [r7, #4]
 800bf66:	601a      	str	r2, [r3, #0]
}
 800bf68:	bf00      	nop
 800bf6a:	370c      	adds	r7, #12
 800bf6c:	46bd      	mov	sp, r7
 800bf6e:	f85d 7b04 	ldr.w	r7, [sp], #4
 800bf72:	4770      	bx	lr

0800bf74 <DMA_MemoryTargetConfig>:
  *  
  * @retval None
  */
void DMA_MemoryTargetConfig(DMA_Stream_TypeDef* DMAy_Streamx, uint32_t MemoryBaseAddr,
                           uint32_t DMA_MemoryTarget)
{
 800bf74:	b480      	push	{r7}
 800bf76:	b085      	sub	sp, #20
 800bf78:	af00      	add	r7, sp, #0
 800bf7a:	60f8      	str	r0, [r7, #12]
 800bf7c:	60b9      	str	r1, [r7, #8]
 800bf7e:	607a      	str	r2, [r7, #4]
  /* Check the parameters */
  assert_param(IS_DMA_ALL_PERIPH(DMAy_Streamx));
  assert_param(IS_DMA_CURRENT_MEM(DMA_MemoryTarget));
    
  /* Check the Memory target to be configured */
  if (DMA_MemoryTarget != DMA_Memory_0)
 800bf80:	687b      	ldr	r3, [r7, #4]
 800bf82:	2b00      	cmp	r3, #0
 800bf84:	d003      	beq.n	800bf8e <DMA_MemoryTargetConfig+0x1a>
  {
    /* Write to DMAy Streamx M1AR */
    DMAy_Streamx->M1AR = MemoryBaseAddr;    
 800bf86:	68fb      	ldr	r3, [r7, #12]
 800bf88:	68ba      	ldr	r2, [r7, #8]
 800bf8a:	611a      	str	r2, [r3, #16]
  else
  {
    /* Write to DMAy Streamx M0AR */
    DMAy_Streamx->M0AR = MemoryBaseAddr;  
  }
}
 800bf8c:	e002      	b.n	800bf94 <DMA_MemoryTargetConfig+0x20>
    DMAy_Streamx->M0AR = MemoryBaseAddr;  
 800bf8e:	68fb      	ldr	r3, [r7, #12]
 800bf90:	68ba      	ldr	r2, [r7, #8]
 800bf92:	60da      	str	r2, [r3, #12]
}
 800bf94:	bf00      	nop
 800bf96:	3714      	adds	r7, #20
 800bf98:	46bd      	mov	sp, r7
 800bf9a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800bf9e:	4770      	bx	lr

0800bfa0 <DMA_GetCurrentMemoryTarget>:
  * @param  DMAy_Streamx: where y can be 1 or 2 to select the DMA and x can be 0
  *          to 7 to select the DMA Stream.
  * @retval The memory target number: 0 for Memory0 or 1 for Memory1. 
  */
uint32_t DMA_GetCurrentMemoryTarget(DMA_Stream_TypeDef* DMAy_Streamx)
{
 800bfa0:	b480      	push	{r7}
 800bfa2:	b085      	sub	sp, #20
 800bfa4:	af00      	add	r7, sp, #0
 800bfa6:	6078      	str	r0, [r7, #4]
  uint32_t tmp = 0;
 800bfa8:	2300      	movs	r3, #0
 800bfaa:	60fb      	str	r3, [r7, #12]
  
  /* Check the parameters */
  assert_param(IS_DMA_ALL_PERIPH(DMAy_Streamx));

  /* Get the current memory target */
  if ((DMAy_Streamx->CR & DMA_SxCR_CT) != 0)
 800bfac:	687b      	ldr	r3, [r7, #4]
 800bfae:	681b      	ldr	r3, [r3, #0]
 800bfb0:	f403 2300 	and.w	r3, r3, #524288	; 0x80000
 800bfb4:	2b00      	cmp	r3, #0
 800bfb6:	d002      	beq.n	800bfbe <DMA_GetCurrentMemoryTarget+0x1e>
  {
    /* Current memory buffer used is Memory 1 */
    tmp = 1;
 800bfb8:	2301      	movs	r3, #1
 800bfba:	60fb      	str	r3, [r7, #12]
 800bfbc:	e001      	b.n	800bfc2 <DMA_GetCurrentMemoryTarget+0x22>
  }  
  else
  {
    /* Current memory buffer used is Memory 0 */
    tmp = 0;    
 800bfbe:	2300      	movs	r3, #0
 800bfc0:	60fb      	str	r3, [r7, #12]
  }
  return tmp;
 800bfc2:	68fb      	ldr	r3, [r7, #12]
}
 800bfc4:	4618      	mov	r0, r3
 800bfc6:	3714      	adds	r7, #20
 800bfc8:	46bd      	mov	sp, r7
 800bfca:	f85d 7b04 	ldr.w	r7, [sp], #4
 800bfce:	4770      	bx	lr

0800bfd0 <DMA_GetCmdStatus>:
  *          of this single data is finished.  
  *      
  * @retval Current state of the DMAy Streamx (ENABLE or DISABLE).
  */
FunctionalState DMA_GetCmdStatus(DMA_Stream_TypeDef* DMAy_Streamx)
{
 800bfd0:	b480      	push	{r7}
 800bfd2:	b085      	sub	sp, #20
 800bfd4:	af00      	add	r7, sp, #0
 800bfd6:	6078      	str	r0, [r7, #4]
  FunctionalState state = DISABLE;
 800bfd8:	2300      	movs	r3, #0
 800bfda:	73fb      	strb	r3, [r7, #15]

  /* Check the parameters */
  assert_param(IS_DMA_ALL_PERIPH(DMAy_Streamx));

  if ((DMAy_Streamx->CR & (uint32_t)DMA_SxCR_EN) != 0)
 800bfdc:	687b      	ldr	r3, [r7, #4]
 800bfde:	681b      	ldr	r3, [r3, #0]
 800bfe0:	f003 0301 	and.w	r3, r3, #1
 800bfe4:	2b00      	cmp	r3, #0
 800bfe6:	d002      	beq.n	800bfee <DMA_GetCmdStatus+0x1e>
  {
    /* The selected DMAy Streamx EN bit is set (DMA is still transferring) */
    state = ENABLE;
 800bfe8:	2301      	movs	r3, #1
 800bfea:	73fb      	strb	r3, [r7, #15]
 800bfec:	e001      	b.n	800bff2 <DMA_GetCmdStatus+0x22>
  }
  else
  {
    /* The selected DMAy Streamx EN bit is cleared (DMA is disabled and 
        all transfers are complete) */
    state = DISABLE;
 800bfee:	2300      	movs	r3, #0
 800bff0:	73fb      	strb	r3, [r7, #15]
  }
  return state;
 800bff2:	7bfb      	ldrb	r3, [r7, #15]
}
 800bff4:	4618      	mov	r0, r3
 800bff6:	3714      	adds	r7, #20
 800bff8:	46bd      	mov	sp, r7
 800bffa:	f85d 7b04 	ldr.w	r7, [sp], #4
 800bffe:	4770      	bx	lr

0800c000 <DMA_GetFIFOStatus>:
  *           - DMA_FIFOStatus_3QuartersFull: if more than 3 quarters-full.
  *           - DMA_FIFOStatus_Empty: when FIFO is empty
  *           - DMA_FIFOStatus_Full: when FIFO is full
  */
uint32_t DMA_GetFIFOStatus(DMA_Stream_TypeDef* DMAy_Streamx)
{
 800c000:	b480      	push	{r7}
 800c002:	b085      	sub	sp, #20
 800c004:	af00      	add	r7, sp, #0
 800c006:	6078      	str	r0, [r7, #4]
  uint32_t tmpreg = 0;
 800c008:	2300      	movs	r3, #0
 800c00a:	60fb      	str	r3, [r7, #12]
 
  /* Check the parameters */
  assert_param(IS_DMA_ALL_PERIPH(DMAy_Streamx));
  
  /* Get the FIFO level bits */
  tmpreg = (uint32_t)((DMAy_Streamx->FCR & DMA_SxFCR_FS));
 800c00c:	687b      	ldr	r3, [r7, #4]
 800c00e:	695b      	ldr	r3, [r3, #20]
 800c010:	f003 0338 	and.w	r3, r3, #56	; 0x38
 800c014:	60fb      	str	r3, [r7, #12]
  
  return tmpreg;
 800c016:	68fb      	ldr	r3, [r7, #12]
}
 800c018:	4618      	mov	r0, r3
 800c01a:	3714      	adds	r7, #20
 800c01c:	46bd      	mov	sp, r7
 800c01e:	f85d 7b04 	ldr.w	r7, [sp], #4
 800c022:	4770      	bx	lr

0800c024 <DMA_GetFlagStatus>:
  *            @arg DMA_FLAG_FEIFx:  Streamx FIFO error flag
  *         Where x can be 0 to 7 to select the DMA Stream.
  * @retval The new state of DMA_FLAG (SET or RESET).
  */
FlagStatus DMA_GetFlagStatus(DMA_Stream_TypeDef* DMAy_Streamx, uint32_t DMA_FLAG)
{
 800c024:	b480      	push	{r7}
 800c026:	b087      	sub	sp, #28
 800c028:	af00      	add	r7, sp, #0
 800c02a:	6078      	str	r0, [r7, #4]
 800c02c:	6039      	str	r1, [r7, #0]
  FlagStatus bitstatus = RESET;
 800c02e:	2300      	movs	r3, #0
 800c030:	75fb      	strb	r3, [r7, #23]
  DMA_TypeDef* DMAy;
  uint32_t tmpreg = 0;
 800c032:	2300      	movs	r3, #0
 800c034:	60fb      	str	r3, [r7, #12]
  /* Check the parameters */
  assert_param(IS_DMA_ALL_PERIPH(DMAy_Streamx));
  assert_param(IS_DMA_GET_FLAG(DMA_FLAG));

  /* Determine the DMA to which belongs the stream */
  if (DMAy_Streamx < DMA2_Stream0)
 800c036:	687b      	ldr	r3, [r7, #4]
 800c038:	4a15      	ldr	r2, [pc, #84]	; (800c090 <DMA_GetFlagStatus+0x6c>)
 800c03a:	4293      	cmp	r3, r2
 800c03c:	d802      	bhi.n	800c044 <DMA_GetFlagStatus+0x20>
  {
    /* DMAy_Streamx belongs to DMA1 */
    DMAy = DMA1; 
 800c03e:	4b15      	ldr	r3, [pc, #84]	; (800c094 <DMA_GetFlagStatus+0x70>)
 800c040:	613b      	str	r3, [r7, #16]
 800c042:	e001      	b.n	800c048 <DMA_GetFlagStatus+0x24>
  } 
  else 
  {
    /* DMAy_Streamx belongs to DMA2 */
    DMAy = DMA2; 
 800c044:	4b14      	ldr	r3, [pc, #80]	; (800c098 <DMA_GetFlagStatus+0x74>)
 800c046:	613b      	str	r3, [r7, #16]
  }

  /* Check if the flag is in HISR or LISR */
  if ((DMA_FLAG & HIGH_ISR_MASK) != (uint32_t)RESET)
 800c048:	683b      	ldr	r3, [r7, #0]
 800c04a:	f003 5300 	and.w	r3, r3, #536870912	; 0x20000000
 800c04e:	2b00      	cmp	r3, #0
 800c050:	d003      	beq.n	800c05a <DMA_GetFlagStatus+0x36>
  {
    /* Get DMAy HISR register value */
    tmpreg = DMAy->HISR;
 800c052:	693b      	ldr	r3, [r7, #16]
 800c054:	685b      	ldr	r3, [r3, #4]
 800c056:	60fb      	str	r3, [r7, #12]
 800c058:	e002      	b.n	800c060 <DMA_GetFlagStatus+0x3c>
  }
  else
  {
    /* Get DMAy LISR register value */
    tmpreg = DMAy->LISR;
 800c05a:	693b      	ldr	r3, [r7, #16]
 800c05c:	681b      	ldr	r3, [r3, #0]
 800c05e:	60fb      	str	r3, [r7, #12]
  }   
 
  /* Mask the reserved bits */
  tmpreg &= (uint32_t)RESERVED_MASK;
 800c060:	68fb      	ldr	r3, [r7, #12]
 800c062:	f023 23f0 	bic.w	r3, r3, #4026593280	; 0xf000f000
 800c066:	f023 1382 	bic.w	r3, r3, #8519810	; 0x820082
 800c06a:	60fb      	str	r3, [r7, #12]

  /* Check the status of the specified DMA flag */
  if ((tmpreg & DMA_FLAG) != (uint32_t)RESET)
 800c06c:	68fa      	ldr	r2, [r7, #12]
 800c06e:	683b      	ldr	r3, [r7, #0]
 800c070:	4013      	ands	r3, r2
 800c072:	2b00      	cmp	r3, #0
 800c074:	d002      	beq.n	800c07c <DMA_GetFlagStatus+0x58>
  {
    /* DMA_FLAG is set */
    bitstatus = SET;
 800c076:	2301      	movs	r3, #1
 800c078:	75fb      	strb	r3, [r7, #23]
 800c07a:	e001      	b.n	800c080 <DMA_GetFlagStatus+0x5c>
  }
  else
  {
    /* DMA_FLAG is reset */
    bitstatus = RESET;
 800c07c:	2300      	movs	r3, #0
 800c07e:	75fb      	strb	r3, [r7, #23]
  }

  /* Return the DMA_FLAG status */
  return  bitstatus;
 800c080:	7dfb      	ldrb	r3, [r7, #23]
}
 800c082:	4618      	mov	r0, r3
 800c084:	371c      	adds	r7, #28
 800c086:	46bd      	mov	sp, r7
 800c088:	f85d 7b04 	ldr.w	r7, [sp], #4
 800c08c:	4770      	bx	lr
 800c08e:	bf00      	nop
 800c090:	4002640f 	.word	0x4002640f
 800c094:	40026000 	.word	0x40026000
 800c098:	40026400 	.word	0x40026400

0800c09c <DMA_ClearFlag>:
  *            @arg DMA_FLAG_FEIFx:  Streamx FIFO error flag
  *         Where x can be 0 to 7 to select the DMA Stream.   
  * @retval None
  */
void DMA_ClearFlag(DMA_Stream_TypeDef* DMAy_Streamx, uint32_t DMA_FLAG)
{
 800c09c:	b480      	push	{r7}
 800c09e:	b085      	sub	sp, #20
 800c0a0:	af00      	add	r7, sp, #0
 800c0a2:	6078      	str	r0, [r7, #4]
 800c0a4:	6039      	str	r1, [r7, #0]
  /* Check the parameters */
  assert_param(IS_DMA_ALL_PERIPH(DMAy_Streamx));
  assert_param(IS_DMA_CLEAR_FLAG(DMA_FLAG));

  /* Determine the DMA to which belongs the stream */
  if (DMAy_Streamx < DMA2_Stream0)
 800c0a6:	687b      	ldr	r3, [r7, #4]
 800c0a8:	4a10      	ldr	r2, [pc, #64]	; (800c0ec <DMA_ClearFlag+0x50>)
 800c0aa:	4293      	cmp	r3, r2
 800c0ac:	d802      	bhi.n	800c0b4 <DMA_ClearFlag+0x18>
  {
    /* DMAy_Streamx belongs to DMA1 */
    DMAy = DMA1; 
 800c0ae:	4b10      	ldr	r3, [pc, #64]	; (800c0f0 <DMA_ClearFlag+0x54>)
 800c0b0:	60fb      	str	r3, [r7, #12]
 800c0b2:	e001      	b.n	800c0b8 <DMA_ClearFlag+0x1c>
  } 
  else 
  {
    /* DMAy_Streamx belongs to DMA2 */
    DMAy = DMA2; 
 800c0b4:	4b0f      	ldr	r3, [pc, #60]	; (800c0f4 <DMA_ClearFlag+0x58>)
 800c0b6:	60fb      	str	r3, [r7, #12]
  }

  /* Check if LIFCR or HIFCR register is targeted */
  if ((DMA_FLAG & HIGH_ISR_MASK) != (uint32_t)RESET)
 800c0b8:	683b      	ldr	r3, [r7, #0]
 800c0ba:	f003 5300 	and.w	r3, r3, #536870912	; 0x20000000
 800c0be:	2b00      	cmp	r3, #0
 800c0c0:	d007      	beq.n	800c0d2 <DMA_ClearFlag+0x36>
  {
    /* Set DMAy HIFCR register clear flag bits */
    DMAy->HIFCR = (uint32_t)(DMA_FLAG & RESERVED_MASK);
 800c0c2:	683b      	ldr	r3, [r7, #0]
 800c0c4:	f023 23f0 	bic.w	r3, r3, #4026593280	; 0xf000f000
 800c0c8:	f023 1382 	bic.w	r3, r3, #8519810	; 0x820082
 800c0cc:	68fa      	ldr	r2, [r7, #12]
 800c0ce:	60d3      	str	r3, [r2, #12]
  else 
  {
    /* Set DMAy LIFCR register clear flag bits */
    DMAy->LIFCR = (uint32_t)(DMA_FLAG & RESERVED_MASK);
  }    
}
 800c0d0:	e006      	b.n	800c0e0 <DMA_ClearFlag+0x44>
    DMAy->LIFCR = (uint32_t)(DMA_FLAG & RESERVED_MASK);
 800c0d2:	683b      	ldr	r3, [r7, #0]
 800c0d4:	f023 23f0 	bic.w	r3, r3, #4026593280	; 0xf000f000
 800c0d8:	f023 1382 	bic.w	r3, r3, #8519810	; 0x820082
 800c0dc:	68fa      	ldr	r2, [r7, #12]
 800c0de:	6093      	str	r3, [r2, #8]
}
 800c0e0:	bf00      	nop
 800c0e2:	3714      	adds	r7, #20
 800c0e4:	46bd      	mov	sp, r7
 800c0e6:	f85d 7b04 	ldr.w	r7, [sp], #4
 800c0ea:	4770      	bx	lr
 800c0ec:	4002640f 	.word	0x4002640f
 800c0f0:	40026000 	.word	0x40026000
 800c0f4:	40026400 	.word	0x40026400

0800c0f8 <DMA_ITConfig>:
  * @param  NewState: new state of the specified DMA interrupts.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void DMA_ITConfig(DMA_Stream_TypeDef* DMAy_Streamx, uint32_t DMA_IT, FunctionalState NewState)
{
 800c0f8:	b480      	push	{r7}
 800c0fa:	b085      	sub	sp, #20
 800c0fc:	af00      	add	r7, sp, #0
 800c0fe:	60f8      	str	r0, [r7, #12]
 800c100:	60b9      	str	r1, [r7, #8]
 800c102:	4613      	mov	r3, r2
 800c104:	71fb      	strb	r3, [r7, #7]
  assert_param(IS_DMA_ALL_PERIPH(DMAy_Streamx));
  assert_param(IS_DMA_CONFIG_IT(DMA_IT));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  /* Check if the DMA_IT parameter contains a FIFO interrupt */
  if ((DMA_IT & DMA_IT_FE) != 0)
 800c106:	68bb      	ldr	r3, [r7, #8]
 800c108:	f003 0380 	and.w	r3, r3, #128	; 0x80
 800c10c:	2b00      	cmp	r3, #0
 800c10e:	d00f      	beq.n	800c130 <DMA_ITConfig+0x38>
  {
    if (NewState != DISABLE)
 800c110:	79fb      	ldrb	r3, [r7, #7]
 800c112:	2b00      	cmp	r3, #0
 800c114:	d006      	beq.n	800c124 <DMA_ITConfig+0x2c>
    {
      /* Enable the selected DMA FIFO interrupts */
      DMAy_Streamx->FCR |= (uint32_t)DMA_IT_FE;
 800c116:	68fb      	ldr	r3, [r7, #12]
 800c118:	695b      	ldr	r3, [r3, #20]
 800c11a:	f043 0280 	orr.w	r2, r3, #128	; 0x80
 800c11e:	68fb      	ldr	r3, [r7, #12]
 800c120:	615a      	str	r2, [r3, #20]
 800c122:	e005      	b.n	800c130 <DMA_ITConfig+0x38>
    }    
    else 
    {
      /* Disable the selected DMA FIFO interrupts */
      DMAy_Streamx->FCR &= ~(uint32_t)DMA_IT_FE;  
 800c124:	68fb      	ldr	r3, [r7, #12]
 800c126:	695b      	ldr	r3, [r3, #20]
 800c128:	f023 0280 	bic.w	r2, r3, #128	; 0x80
 800c12c:	68fb      	ldr	r3, [r7, #12]
 800c12e:	615a      	str	r2, [r3, #20]
    }
  }

  /* Check if the DMA_IT parameter contains a Transfer interrupt */
  if (DMA_IT != DMA_IT_FE)
 800c130:	68bb      	ldr	r3, [r7, #8]
 800c132:	2b80      	cmp	r3, #128	; 0x80
 800c134:	d014      	beq.n	800c160 <DMA_ITConfig+0x68>
  {
    if (NewState != DISABLE)
 800c136:	79fb      	ldrb	r3, [r7, #7]
 800c138:	2b00      	cmp	r3, #0
 800c13a:	d008      	beq.n	800c14e <DMA_ITConfig+0x56>
    {
      /* Enable the selected DMA transfer interrupts */
      DMAy_Streamx->CR |= (uint32_t)(DMA_IT  & TRANSFER_IT_ENABLE_MASK);
 800c13c:	68fb      	ldr	r3, [r7, #12]
 800c13e:	681a      	ldr	r2, [r3, #0]
 800c140:	68bb      	ldr	r3, [r7, #8]
 800c142:	f003 031e 	and.w	r3, r3, #30
 800c146:	431a      	orrs	r2, r3
 800c148:	68fb      	ldr	r3, [r7, #12]
 800c14a:	601a      	str	r2, [r3, #0]
    {
      /* Disable the selected DMA transfer interrupts */
      DMAy_Streamx->CR &= ~(uint32_t)(DMA_IT & TRANSFER_IT_ENABLE_MASK);
    }    
  }
}
 800c14c:	e008      	b.n	800c160 <DMA_ITConfig+0x68>
      DMAy_Streamx->CR &= ~(uint32_t)(DMA_IT & TRANSFER_IT_ENABLE_MASK);
 800c14e:	68fb      	ldr	r3, [r7, #12]
 800c150:	681a      	ldr	r2, [r3, #0]
 800c152:	68bb      	ldr	r3, [r7, #8]
 800c154:	f003 031e 	and.w	r3, r3, #30
 800c158:	43db      	mvns	r3, r3
 800c15a:	401a      	ands	r2, r3
 800c15c:	68fb      	ldr	r3, [r7, #12]
 800c15e:	601a      	str	r2, [r3, #0]
}
 800c160:	bf00      	nop
 800c162:	3714      	adds	r7, #20
 800c164:	46bd      	mov	sp, r7
 800c166:	f85d 7b04 	ldr.w	r7, [sp], #4
 800c16a:	4770      	bx	lr

0800c16c <DMA_GetITStatus>:
  *            @arg DMA_IT_FEIFx:  Streamx FIFO error interrupt
  *         Where x can be 0 to 7 to select the DMA Stream.
  * @retval The new state of DMA_IT (SET or RESET).
  */
ITStatus DMA_GetITStatus(DMA_Stream_TypeDef* DMAy_Streamx, uint32_t DMA_IT)
{
 800c16c:	b480      	push	{r7}
 800c16e:	b087      	sub	sp, #28
 800c170:	af00      	add	r7, sp, #0
 800c172:	6078      	str	r0, [r7, #4]
 800c174:	6039      	str	r1, [r7, #0]
  ITStatus bitstatus = RESET;
 800c176:	2300      	movs	r3, #0
 800c178:	75fb      	strb	r3, [r7, #23]
  DMA_TypeDef* DMAy;
  uint32_t tmpreg = 0, enablestatus = 0;
 800c17a:	2300      	movs	r3, #0
 800c17c:	60fb      	str	r3, [r7, #12]
 800c17e:	2300      	movs	r3, #0
 800c180:	60bb      	str	r3, [r7, #8]
  /* Check the parameters */
  assert_param(IS_DMA_ALL_PERIPH(DMAy_Streamx));
  assert_param(IS_DMA_GET_IT(DMA_IT));
 
  /* Determine the DMA to which belongs the stream */
  if (DMAy_Streamx < DMA2_Stream0)
 800c182:	687b      	ldr	r3, [r7, #4]
 800c184:	4a22      	ldr	r2, [pc, #136]	; (800c210 <DMA_GetITStatus+0xa4>)
 800c186:	4293      	cmp	r3, r2
 800c188:	d802      	bhi.n	800c190 <DMA_GetITStatus+0x24>
  {
    /* DMAy_Streamx belongs to DMA1 */
    DMAy = DMA1; 
 800c18a:	4b22      	ldr	r3, [pc, #136]	; (800c214 <DMA_GetITStatus+0xa8>)
 800c18c:	613b      	str	r3, [r7, #16]
 800c18e:	e001      	b.n	800c194 <DMA_GetITStatus+0x28>
  } 
  else 
  {
    /* DMAy_Streamx belongs to DMA2 */
    DMAy = DMA2; 
 800c190:	4b21      	ldr	r3, [pc, #132]	; (800c218 <DMA_GetITStatus+0xac>)
 800c192:	613b      	str	r3, [r7, #16]
  }

  /* Check if the interrupt enable bit is in the CR or FCR register */
  if ((DMA_IT & TRANSFER_IT_MASK) != (uint32_t)RESET)
 800c194:	683b      	ldr	r3, [r7, #0]
 800c196:	f023 23f0 	bic.w	r3, r3, #4026593280	; 0xf000f000
 800c19a:	f023 13c3 	bic.w	r3, r3, #12779715	; 0xc300c3
 800c19e:	2b00      	cmp	r3, #0
 800c1a0:	d00a      	beq.n	800c1b8 <DMA_GetITStatus+0x4c>
  {
    /* Get the interrupt enable position mask in CR register */
    tmpreg = (uint32_t)((DMA_IT >> 11) & TRANSFER_IT_ENABLE_MASK);   
 800c1a2:	683b      	ldr	r3, [r7, #0]
 800c1a4:	0adb      	lsrs	r3, r3, #11
 800c1a6:	f003 031e 	and.w	r3, r3, #30
 800c1aa:	60fb      	str	r3, [r7, #12]
    
    /* Check the enable bit in CR register */
    enablestatus = (uint32_t)(DMAy_Streamx->CR & tmpreg);
 800c1ac:	687b      	ldr	r3, [r7, #4]
 800c1ae:	681a      	ldr	r2, [r3, #0]
 800c1b0:	68fb      	ldr	r3, [r7, #12]
 800c1b2:	4013      	ands	r3, r2
 800c1b4:	60bb      	str	r3, [r7, #8]
 800c1b6:	e004      	b.n	800c1c2 <DMA_GetITStatus+0x56>
  }
  else 
  {
    /* Check the enable bit in FCR register */
    enablestatus = (uint32_t)(DMAy_Streamx->FCR & DMA_IT_FE); 
 800c1b8:	687b      	ldr	r3, [r7, #4]
 800c1ba:	695b      	ldr	r3, [r3, #20]
 800c1bc:	f003 0380 	and.w	r3, r3, #128	; 0x80
 800c1c0:	60bb      	str	r3, [r7, #8]
  }
 
  /* Check if the interrupt pending flag is in LISR or HISR */
  if ((DMA_IT & HIGH_ISR_MASK) != (uint32_t)RESET)
 800c1c2:	683b      	ldr	r3, [r7, #0]
 800c1c4:	f003 5300 	and.w	r3, r3, #536870912	; 0x20000000
 800c1c8:	2b00      	cmp	r3, #0
 800c1ca:	d003      	beq.n	800c1d4 <DMA_GetITStatus+0x68>
  {
    /* Get DMAy HISR register value */
    tmpreg = DMAy->HISR ;
 800c1cc:	693b      	ldr	r3, [r7, #16]
 800c1ce:	685b      	ldr	r3, [r3, #4]
 800c1d0:	60fb      	str	r3, [r7, #12]
 800c1d2:	e002      	b.n	800c1da <DMA_GetITStatus+0x6e>
  }
  else
  {
    /* Get DMAy LISR register value */
    tmpreg = DMAy->LISR ;
 800c1d4:	693b      	ldr	r3, [r7, #16]
 800c1d6:	681b      	ldr	r3, [r3, #0]
 800c1d8:	60fb      	str	r3, [r7, #12]
  } 

  /* mask all reserved bits */
  tmpreg &= (uint32_t)RESERVED_MASK;
 800c1da:	68fb      	ldr	r3, [r7, #12]
 800c1dc:	f023 23f0 	bic.w	r3, r3, #4026593280	; 0xf000f000
 800c1e0:	f023 1382 	bic.w	r3, r3, #8519810	; 0x820082
 800c1e4:	60fb      	str	r3, [r7, #12]

  /* Check the status of the specified DMA interrupt */
  if (((tmpreg & DMA_IT) != (uint32_t)RESET) && (enablestatus != (uint32_t)RESET))
 800c1e6:	68fa      	ldr	r2, [r7, #12]
 800c1e8:	683b      	ldr	r3, [r7, #0]
 800c1ea:	4013      	ands	r3, r2
 800c1ec:	2b00      	cmp	r3, #0
 800c1ee:	d005      	beq.n	800c1fc <DMA_GetITStatus+0x90>
 800c1f0:	68bb      	ldr	r3, [r7, #8]
 800c1f2:	2b00      	cmp	r3, #0
 800c1f4:	d002      	beq.n	800c1fc <DMA_GetITStatus+0x90>
  {
    /* DMA_IT is set */
    bitstatus = SET;
 800c1f6:	2301      	movs	r3, #1
 800c1f8:	75fb      	strb	r3, [r7, #23]
 800c1fa:	e001      	b.n	800c200 <DMA_GetITStatus+0x94>
  }
  else
  {
    /* DMA_IT is reset */
    bitstatus = RESET;
 800c1fc:	2300      	movs	r3, #0
 800c1fe:	75fb      	strb	r3, [r7, #23]
  }

  /* Return the DMA_IT status */
  return  bitstatus;
 800c200:	7dfb      	ldrb	r3, [r7, #23]
}
 800c202:	4618      	mov	r0, r3
 800c204:	371c      	adds	r7, #28
 800c206:	46bd      	mov	sp, r7
 800c208:	f85d 7b04 	ldr.w	r7, [sp], #4
 800c20c:	4770      	bx	lr
 800c20e:	bf00      	nop
 800c210:	4002640f 	.word	0x4002640f
 800c214:	40026000 	.word	0x40026000
 800c218:	40026400 	.word	0x40026400

0800c21c <DMA_ClearITPendingBit>:
  *            @arg DMA_IT_FEIFx:  Streamx FIFO error interrupt
  *         Where x can be 0 to 7 to select the DMA Stream.
  * @retval None
  */
void DMA_ClearITPendingBit(DMA_Stream_TypeDef* DMAy_Streamx, uint32_t DMA_IT)
{
 800c21c:	b480      	push	{r7}
 800c21e:	b085      	sub	sp, #20
 800c220:	af00      	add	r7, sp, #0
 800c222:	6078      	str	r0, [r7, #4]
 800c224:	6039      	str	r1, [r7, #0]
  /* Check the parameters */
  assert_param(IS_DMA_ALL_PERIPH(DMAy_Streamx));
  assert_param(IS_DMA_CLEAR_IT(DMA_IT));

  /* Determine the DMA to which belongs the stream */
  if (DMAy_Streamx < DMA2_Stream0)
 800c226:	687b      	ldr	r3, [r7, #4]
 800c228:	4a10      	ldr	r2, [pc, #64]	; (800c26c <DMA_ClearITPendingBit+0x50>)
 800c22a:	4293      	cmp	r3, r2
 800c22c:	d802      	bhi.n	800c234 <DMA_ClearITPendingBit+0x18>
  {
    /* DMAy_Streamx belongs to DMA1 */
    DMAy = DMA1; 
 800c22e:	4b10      	ldr	r3, [pc, #64]	; (800c270 <DMA_ClearITPendingBit+0x54>)
 800c230:	60fb      	str	r3, [r7, #12]
 800c232:	e001      	b.n	800c238 <DMA_ClearITPendingBit+0x1c>
  } 
  else 
  {
    /* DMAy_Streamx belongs to DMA2 */
    DMAy = DMA2; 
 800c234:	4b0f      	ldr	r3, [pc, #60]	; (800c274 <DMA_ClearITPendingBit+0x58>)
 800c236:	60fb      	str	r3, [r7, #12]
  }

  /* Check if LIFCR or HIFCR register is targeted */
  if ((DMA_IT & HIGH_ISR_MASK) != (uint32_t)RESET)
 800c238:	683b      	ldr	r3, [r7, #0]
 800c23a:	f003 5300 	and.w	r3, r3, #536870912	; 0x20000000
 800c23e:	2b00      	cmp	r3, #0
 800c240:	d007      	beq.n	800c252 <DMA_ClearITPendingBit+0x36>
  {
    /* Set DMAy HIFCR register clear interrupt bits */
    DMAy->HIFCR = (uint32_t)(DMA_IT & RESERVED_MASK);
 800c242:	683b      	ldr	r3, [r7, #0]
 800c244:	f023 23f0 	bic.w	r3, r3, #4026593280	; 0xf000f000
 800c248:	f023 1382 	bic.w	r3, r3, #8519810	; 0x820082
 800c24c:	68fa      	ldr	r2, [r7, #12]
 800c24e:	60d3      	str	r3, [r2, #12]
  else 
  {
    /* Set DMAy LIFCR register clear interrupt bits */
    DMAy->LIFCR = (uint32_t)(DMA_IT & RESERVED_MASK);
  }   
}
 800c250:	e006      	b.n	800c260 <DMA_ClearITPendingBit+0x44>
    DMAy->LIFCR = (uint32_t)(DMA_IT & RESERVED_MASK);
 800c252:	683b      	ldr	r3, [r7, #0]
 800c254:	f023 23f0 	bic.w	r3, r3, #4026593280	; 0xf000f000
 800c258:	f023 1382 	bic.w	r3, r3, #8519810	; 0x820082
 800c25c:	68fa      	ldr	r2, [r7, #12]
 800c25e:	6093      	str	r3, [r2, #8]
}
 800c260:	bf00      	nop
 800c262:	3714      	adds	r7, #20
 800c264:	46bd      	mov	sp, r7
 800c266:	f85d 7b04 	ldr.w	r7, [sp], #4
 800c26a:	4770      	bx	lr
 800c26c:	4002640f 	.word	0x4002640f
 800c270:	40026000 	.word	0x40026000
 800c274:	40026400 	.word	0x40026400

0800c278 <EXTI_DeInit>:
  * @brief  Deinitializes the EXTI peripheral registers to their default reset values.
  * @param  None
  * @retval None
  */
void EXTI_DeInit(void)
{
 800c278:	b480      	push	{r7}
 800c27a:	af00      	add	r7, sp, #0
  EXTI->IMR = 0x00000000;
 800c27c:	4b09      	ldr	r3, [pc, #36]	; (800c2a4 <EXTI_DeInit+0x2c>)
 800c27e:	2200      	movs	r2, #0
 800c280:	601a      	str	r2, [r3, #0]
  EXTI->EMR = 0x00000000;
 800c282:	4b08      	ldr	r3, [pc, #32]	; (800c2a4 <EXTI_DeInit+0x2c>)
 800c284:	2200      	movs	r2, #0
 800c286:	605a      	str	r2, [r3, #4]
  EXTI->RTSR = 0x00000000;
 800c288:	4b06      	ldr	r3, [pc, #24]	; (800c2a4 <EXTI_DeInit+0x2c>)
 800c28a:	2200      	movs	r2, #0
 800c28c:	609a      	str	r2, [r3, #8]
  EXTI->FTSR = 0x00000000;
 800c28e:	4b05      	ldr	r3, [pc, #20]	; (800c2a4 <EXTI_DeInit+0x2c>)
 800c290:	2200      	movs	r2, #0
 800c292:	60da      	str	r2, [r3, #12]
  EXTI->PR = 0x007FFFFF;
 800c294:	4b03      	ldr	r3, [pc, #12]	; (800c2a4 <EXTI_DeInit+0x2c>)
 800c296:	4a04      	ldr	r2, [pc, #16]	; (800c2a8 <EXTI_DeInit+0x30>)
 800c298:	615a      	str	r2, [r3, #20]
}
 800c29a:	bf00      	nop
 800c29c:	46bd      	mov	sp, r7
 800c29e:	f85d 7b04 	ldr.w	r7, [sp], #4
 800c2a2:	4770      	bx	lr
 800c2a4:	40013c00 	.word	0x40013c00
 800c2a8:	007fffff 	.word	0x007fffff

0800c2ac <EXTI_Init>:
  * @param  EXTI_InitStruct: pointer to a EXTI_InitTypeDef structure
  *         that contains the configuration information for the EXTI peripheral.
  * @retval None
  */
void EXTI_Init(EXTI_InitTypeDef* EXTI_InitStruct)
{
 800c2ac:	b480      	push	{r7}
 800c2ae:	b085      	sub	sp, #20
 800c2b0:	af00      	add	r7, sp, #0
 800c2b2:	6078      	str	r0, [r7, #4]
  uint32_t tmp = 0;
 800c2b4:	2300      	movs	r3, #0
 800c2b6:	60fb      	str	r3, [r7, #12]
  assert_param(IS_EXTI_MODE(EXTI_InitStruct->EXTI_Mode));
  assert_param(IS_EXTI_TRIGGER(EXTI_InitStruct->EXTI_Trigger));
  assert_param(IS_EXTI_LINE(EXTI_InitStruct->EXTI_Line));  
  assert_param(IS_FUNCTIONAL_STATE(EXTI_InitStruct->EXTI_LineCmd));

  tmp = (uint32_t)EXTI_BASE;
 800c2b8:	4b34      	ldr	r3, [pc, #208]	; (800c38c <EXTI_Init+0xe0>)
 800c2ba:	60fb      	str	r3, [r7, #12]
     
  if (EXTI_InitStruct->EXTI_LineCmd != DISABLE)
 800c2bc:	687b      	ldr	r3, [r7, #4]
 800c2be:	799b      	ldrb	r3, [r3, #6]
 800c2c0:	2b00      	cmp	r3, #0
 800c2c2:	d04f      	beq.n	800c364 <EXTI_Init+0xb8>
  {
    /* Clear EXTI line configuration */
    EXTI->IMR &= ~EXTI_InitStruct->EXTI_Line;
 800c2c4:	4931      	ldr	r1, [pc, #196]	; (800c38c <EXTI_Init+0xe0>)
 800c2c6:	4b31      	ldr	r3, [pc, #196]	; (800c38c <EXTI_Init+0xe0>)
 800c2c8:	681a      	ldr	r2, [r3, #0]
 800c2ca:	687b      	ldr	r3, [r7, #4]
 800c2cc:	681b      	ldr	r3, [r3, #0]
 800c2ce:	43db      	mvns	r3, r3
 800c2d0:	4013      	ands	r3, r2
 800c2d2:	600b      	str	r3, [r1, #0]
    EXTI->EMR &= ~EXTI_InitStruct->EXTI_Line;
 800c2d4:	492d      	ldr	r1, [pc, #180]	; (800c38c <EXTI_Init+0xe0>)
 800c2d6:	4b2d      	ldr	r3, [pc, #180]	; (800c38c <EXTI_Init+0xe0>)
 800c2d8:	685a      	ldr	r2, [r3, #4]
 800c2da:	687b      	ldr	r3, [r7, #4]
 800c2dc:	681b      	ldr	r3, [r3, #0]
 800c2de:	43db      	mvns	r3, r3
 800c2e0:	4013      	ands	r3, r2
 800c2e2:	604b      	str	r3, [r1, #4]
    
    tmp += EXTI_InitStruct->EXTI_Mode;
 800c2e4:	687b      	ldr	r3, [r7, #4]
 800c2e6:	791b      	ldrb	r3, [r3, #4]
 800c2e8:	461a      	mov	r2, r3
 800c2ea:	68fb      	ldr	r3, [r7, #12]
 800c2ec:	4413      	add	r3, r2
 800c2ee:	60fb      	str	r3, [r7, #12]

    *(__IO uint32_t *) tmp |= EXTI_InitStruct->EXTI_Line;
 800c2f0:	68fb      	ldr	r3, [r7, #12]
 800c2f2:	68fa      	ldr	r2, [r7, #12]
 800c2f4:	6811      	ldr	r1, [r2, #0]
 800c2f6:	687a      	ldr	r2, [r7, #4]
 800c2f8:	6812      	ldr	r2, [r2, #0]
 800c2fa:	430a      	orrs	r2, r1
 800c2fc:	601a      	str	r2, [r3, #0]

    /* Clear Rising Falling edge configuration */
    EXTI->RTSR &= ~EXTI_InitStruct->EXTI_Line;
 800c2fe:	4923      	ldr	r1, [pc, #140]	; (800c38c <EXTI_Init+0xe0>)
 800c300:	4b22      	ldr	r3, [pc, #136]	; (800c38c <EXTI_Init+0xe0>)
 800c302:	689a      	ldr	r2, [r3, #8]
 800c304:	687b      	ldr	r3, [r7, #4]
 800c306:	681b      	ldr	r3, [r3, #0]
 800c308:	43db      	mvns	r3, r3
 800c30a:	4013      	ands	r3, r2
 800c30c:	608b      	str	r3, [r1, #8]
    EXTI->FTSR &= ~EXTI_InitStruct->EXTI_Line;
 800c30e:	491f      	ldr	r1, [pc, #124]	; (800c38c <EXTI_Init+0xe0>)
 800c310:	4b1e      	ldr	r3, [pc, #120]	; (800c38c <EXTI_Init+0xe0>)
 800c312:	68da      	ldr	r2, [r3, #12]
 800c314:	687b      	ldr	r3, [r7, #4]
 800c316:	681b      	ldr	r3, [r3, #0]
 800c318:	43db      	mvns	r3, r3
 800c31a:	4013      	ands	r3, r2
 800c31c:	60cb      	str	r3, [r1, #12]
    
    /* Select the trigger for the selected external interrupts */
    if (EXTI_InitStruct->EXTI_Trigger == EXTI_Trigger_Rising_Falling)
 800c31e:	687b      	ldr	r3, [r7, #4]
 800c320:	795b      	ldrb	r3, [r3, #5]
 800c322:	2b10      	cmp	r3, #16
 800c324:	d10e      	bne.n	800c344 <EXTI_Init+0x98>
    {
      /* Rising Falling edge */
      EXTI->RTSR |= EXTI_InitStruct->EXTI_Line;
 800c326:	4919      	ldr	r1, [pc, #100]	; (800c38c <EXTI_Init+0xe0>)
 800c328:	4b18      	ldr	r3, [pc, #96]	; (800c38c <EXTI_Init+0xe0>)
 800c32a:	689a      	ldr	r2, [r3, #8]
 800c32c:	687b      	ldr	r3, [r7, #4]
 800c32e:	681b      	ldr	r3, [r3, #0]
 800c330:	4313      	orrs	r3, r2
 800c332:	608b      	str	r3, [r1, #8]
      EXTI->FTSR |= EXTI_InitStruct->EXTI_Line;
 800c334:	4915      	ldr	r1, [pc, #84]	; (800c38c <EXTI_Init+0xe0>)
 800c336:	4b15      	ldr	r3, [pc, #84]	; (800c38c <EXTI_Init+0xe0>)
 800c338:	68da      	ldr	r2, [r3, #12]
 800c33a:	687b      	ldr	r3, [r7, #4]
 800c33c:	681b      	ldr	r3, [r3, #0]
 800c33e:	4313      	orrs	r3, r2
 800c340:	60cb      	str	r3, [r1, #12]
    tmp += EXTI_InitStruct->EXTI_Mode;

    /* Disable the selected external lines */
    *(__IO uint32_t *) tmp &= ~EXTI_InitStruct->EXTI_Line;
  }
}
 800c342:	e01d      	b.n	800c380 <EXTI_Init+0xd4>
      tmp = (uint32_t)EXTI_BASE;
 800c344:	4b11      	ldr	r3, [pc, #68]	; (800c38c <EXTI_Init+0xe0>)
 800c346:	60fb      	str	r3, [r7, #12]
      tmp += EXTI_InitStruct->EXTI_Trigger;
 800c348:	687b      	ldr	r3, [r7, #4]
 800c34a:	795b      	ldrb	r3, [r3, #5]
 800c34c:	461a      	mov	r2, r3
 800c34e:	68fb      	ldr	r3, [r7, #12]
 800c350:	4413      	add	r3, r2
 800c352:	60fb      	str	r3, [r7, #12]
      *(__IO uint32_t *) tmp |= EXTI_InitStruct->EXTI_Line;
 800c354:	68fb      	ldr	r3, [r7, #12]
 800c356:	68fa      	ldr	r2, [r7, #12]
 800c358:	6811      	ldr	r1, [r2, #0]
 800c35a:	687a      	ldr	r2, [r7, #4]
 800c35c:	6812      	ldr	r2, [r2, #0]
 800c35e:	430a      	orrs	r2, r1
 800c360:	601a      	str	r2, [r3, #0]
}
 800c362:	e00d      	b.n	800c380 <EXTI_Init+0xd4>
    tmp += EXTI_InitStruct->EXTI_Mode;
 800c364:	687b      	ldr	r3, [r7, #4]
 800c366:	791b      	ldrb	r3, [r3, #4]
 800c368:	461a      	mov	r2, r3
 800c36a:	68fb      	ldr	r3, [r7, #12]
 800c36c:	4413      	add	r3, r2
 800c36e:	60fb      	str	r3, [r7, #12]
    *(__IO uint32_t *) tmp &= ~EXTI_InitStruct->EXTI_Line;
 800c370:	68fb      	ldr	r3, [r7, #12]
 800c372:	68fa      	ldr	r2, [r7, #12]
 800c374:	6811      	ldr	r1, [r2, #0]
 800c376:	687a      	ldr	r2, [r7, #4]
 800c378:	6812      	ldr	r2, [r2, #0]
 800c37a:	43d2      	mvns	r2, r2
 800c37c:	400a      	ands	r2, r1
 800c37e:	601a      	str	r2, [r3, #0]
}
 800c380:	bf00      	nop
 800c382:	3714      	adds	r7, #20
 800c384:	46bd      	mov	sp, r7
 800c386:	f85d 7b04 	ldr.w	r7, [sp], #4
 800c38a:	4770      	bx	lr
 800c38c:	40013c00 	.word	0x40013c00

0800c390 <EXTI_StructInit>:
  * @param  EXTI_InitStruct: pointer to a EXTI_InitTypeDef structure which will
  *         be initialized.
  * @retval None
  */
void EXTI_StructInit(EXTI_InitTypeDef* EXTI_InitStruct)
{
 800c390:	b480      	push	{r7}
 800c392:	b083      	sub	sp, #12
 800c394:	af00      	add	r7, sp, #0
 800c396:	6078      	str	r0, [r7, #4]
  EXTI_InitStruct->EXTI_Line = EXTI_LINENONE;
 800c398:	687b      	ldr	r3, [r7, #4]
 800c39a:	2200      	movs	r2, #0
 800c39c:	601a      	str	r2, [r3, #0]
  EXTI_InitStruct->EXTI_Mode = EXTI_Mode_Interrupt;
 800c39e:	687b      	ldr	r3, [r7, #4]
 800c3a0:	2200      	movs	r2, #0
 800c3a2:	711a      	strb	r2, [r3, #4]
  EXTI_InitStruct->EXTI_Trigger = EXTI_Trigger_Falling;
 800c3a4:	687b      	ldr	r3, [r7, #4]
 800c3a6:	220c      	movs	r2, #12
 800c3a8:	715a      	strb	r2, [r3, #5]
  EXTI_InitStruct->EXTI_LineCmd = DISABLE;
 800c3aa:	687b      	ldr	r3, [r7, #4]
 800c3ac:	2200      	movs	r2, #0
 800c3ae:	719a      	strb	r2, [r3, #6]
}
 800c3b0:	bf00      	nop
 800c3b2:	370c      	adds	r7, #12
 800c3b4:	46bd      	mov	sp, r7
 800c3b6:	f85d 7b04 	ldr.w	r7, [sp], #4
 800c3ba:	4770      	bx	lr

0800c3bc <EXTI_GenerateSWInterrupt>:
  *         will be generated.
  *         This parameter can be any combination of EXTI_Linex where x can be (0..22)
  * @retval None
  */
void EXTI_GenerateSWInterrupt(uint32_t EXTI_Line)
{
 800c3bc:	b480      	push	{r7}
 800c3be:	b083      	sub	sp, #12
 800c3c0:	af00      	add	r7, sp, #0
 800c3c2:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_EXTI_LINE(EXTI_Line));
  
  EXTI->SWIER |= EXTI_Line;
 800c3c4:	4905      	ldr	r1, [pc, #20]	; (800c3dc <EXTI_GenerateSWInterrupt+0x20>)
 800c3c6:	4b05      	ldr	r3, [pc, #20]	; (800c3dc <EXTI_GenerateSWInterrupt+0x20>)
 800c3c8:	691a      	ldr	r2, [r3, #16]
 800c3ca:	687b      	ldr	r3, [r7, #4]
 800c3cc:	4313      	orrs	r3, r2
 800c3ce:	610b      	str	r3, [r1, #16]
}
 800c3d0:	bf00      	nop
 800c3d2:	370c      	adds	r7, #12
 800c3d4:	46bd      	mov	sp, r7
 800c3d6:	f85d 7b04 	ldr.w	r7, [sp], #4
 800c3da:	4770      	bx	lr
 800c3dc:	40013c00 	.word	0x40013c00

0800c3e0 <EXTI_GetFlagStatus>:
  * @param  EXTI_Line: specifies the EXTI line flag to check.
  *          This parameter can be EXTI_Linex where x can be(0..22)
  * @retval The new state of EXTI_Line (SET or RESET).
  */
FlagStatus EXTI_GetFlagStatus(uint32_t EXTI_Line)
{
 800c3e0:	b480      	push	{r7}
 800c3e2:	b085      	sub	sp, #20
 800c3e4:	af00      	add	r7, sp, #0
 800c3e6:	6078      	str	r0, [r7, #4]
  FlagStatus bitstatus = RESET;
 800c3e8:	2300      	movs	r3, #0
 800c3ea:	73fb      	strb	r3, [r7, #15]
  /* Check the parameters */
  assert_param(IS_GET_EXTI_LINE(EXTI_Line));
  
  if ((EXTI->PR & EXTI_Line) != (uint32_t)RESET)
 800c3ec:	4b08      	ldr	r3, [pc, #32]	; (800c410 <EXTI_GetFlagStatus+0x30>)
 800c3ee:	695a      	ldr	r2, [r3, #20]
 800c3f0:	687b      	ldr	r3, [r7, #4]
 800c3f2:	4013      	ands	r3, r2
 800c3f4:	2b00      	cmp	r3, #0
 800c3f6:	d002      	beq.n	800c3fe <EXTI_GetFlagStatus+0x1e>
  {
    bitstatus = SET;
 800c3f8:	2301      	movs	r3, #1
 800c3fa:	73fb      	strb	r3, [r7, #15]
 800c3fc:	e001      	b.n	800c402 <EXTI_GetFlagStatus+0x22>
  }
  else
  {
    bitstatus = RESET;
 800c3fe:	2300      	movs	r3, #0
 800c400:	73fb      	strb	r3, [r7, #15]
  }
  return bitstatus;
 800c402:	7bfb      	ldrb	r3, [r7, #15]
}
 800c404:	4618      	mov	r0, r3
 800c406:	3714      	adds	r7, #20
 800c408:	46bd      	mov	sp, r7
 800c40a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800c40e:	4770      	bx	lr
 800c410:	40013c00 	.word	0x40013c00

0800c414 <EXTI_ClearFlag>:
  * @param  EXTI_Line: specifies the EXTI lines flags to clear.
  *          This parameter can be any combination of EXTI_Linex where x can be (0..22)
  * @retval None
  */
void EXTI_ClearFlag(uint32_t EXTI_Line)
{
 800c414:	b480      	push	{r7}
 800c416:	b083      	sub	sp, #12
 800c418:	af00      	add	r7, sp, #0
 800c41a:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_EXTI_LINE(EXTI_Line));
  
  EXTI->PR = EXTI_Line;
 800c41c:	4a04      	ldr	r2, [pc, #16]	; (800c430 <EXTI_ClearFlag+0x1c>)
 800c41e:	687b      	ldr	r3, [r7, #4]
 800c420:	6153      	str	r3, [r2, #20]
}
 800c422:	bf00      	nop
 800c424:	370c      	adds	r7, #12
 800c426:	46bd      	mov	sp, r7
 800c428:	f85d 7b04 	ldr.w	r7, [sp], #4
 800c42c:	4770      	bx	lr
 800c42e:	bf00      	nop
 800c430:	40013c00 	.word	0x40013c00

0800c434 <EXTI_GetITStatus>:
  * @param  EXTI_Line: specifies the EXTI line to check.
  *          This parameter can be EXTI_Linex where x can be(0..22)
  * @retval The new state of EXTI_Line (SET or RESET).
  */
ITStatus EXTI_GetITStatus(uint32_t EXTI_Line)
{
 800c434:	b480      	push	{r7}
 800c436:	b085      	sub	sp, #20
 800c438:	af00      	add	r7, sp, #0
 800c43a:	6078      	str	r0, [r7, #4]
  ITStatus bitstatus = RESET;
 800c43c:	2300      	movs	r3, #0
 800c43e:	73fb      	strb	r3, [r7, #15]
  uint32_t enablestatus = 0;
 800c440:	2300      	movs	r3, #0
 800c442:	60bb      	str	r3, [r7, #8]
  /* Check the parameters */
  assert_param(IS_GET_EXTI_LINE(EXTI_Line));
  
  enablestatus =  EXTI->IMR & EXTI_Line;
 800c444:	4b0c      	ldr	r3, [pc, #48]	; (800c478 <EXTI_GetITStatus+0x44>)
 800c446:	681a      	ldr	r2, [r3, #0]
 800c448:	687b      	ldr	r3, [r7, #4]
 800c44a:	4013      	ands	r3, r2
 800c44c:	60bb      	str	r3, [r7, #8]
  if (((EXTI->PR & EXTI_Line) != (uint32_t)RESET) && (enablestatus != (uint32_t)RESET))
 800c44e:	4b0a      	ldr	r3, [pc, #40]	; (800c478 <EXTI_GetITStatus+0x44>)
 800c450:	695a      	ldr	r2, [r3, #20]
 800c452:	687b      	ldr	r3, [r7, #4]
 800c454:	4013      	ands	r3, r2
 800c456:	2b00      	cmp	r3, #0
 800c458:	d005      	beq.n	800c466 <EXTI_GetITStatus+0x32>
 800c45a:	68bb      	ldr	r3, [r7, #8]
 800c45c:	2b00      	cmp	r3, #0
 800c45e:	d002      	beq.n	800c466 <EXTI_GetITStatus+0x32>
  {
    bitstatus = SET;
 800c460:	2301      	movs	r3, #1
 800c462:	73fb      	strb	r3, [r7, #15]
 800c464:	e001      	b.n	800c46a <EXTI_GetITStatus+0x36>
  }
  else
  {
    bitstatus = RESET;
 800c466:	2300      	movs	r3, #0
 800c468:	73fb      	strb	r3, [r7, #15]
  }
  return bitstatus;
 800c46a:	7bfb      	ldrb	r3, [r7, #15]
}
 800c46c:	4618      	mov	r0, r3
 800c46e:	3714      	adds	r7, #20
 800c470:	46bd      	mov	sp, r7
 800c472:	f85d 7b04 	ldr.w	r7, [sp], #4
 800c476:	4770      	bx	lr
 800c478:	40013c00 	.word	0x40013c00

0800c47c <EXTI_ClearITPendingBit>:
  * @param  EXTI_Line: specifies the EXTI lines to clear.
  *          This parameter can be any combination of EXTI_Linex where x can be (0..22)
  * @retval None
  */
void EXTI_ClearITPendingBit(uint32_t EXTI_Line)
{
 800c47c:	b480      	push	{r7}
 800c47e:	b083      	sub	sp, #12
 800c480:	af00      	add	r7, sp, #0
 800c482:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_EXTI_LINE(EXTI_Line));
  
  EXTI->PR = EXTI_Line;
 800c484:	4a04      	ldr	r2, [pc, #16]	; (800c498 <EXTI_ClearITPendingBit+0x1c>)
 800c486:	687b      	ldr	r3, [r7, #4]
 800c488:	6153      	str	r3, [r2, #20]
}
 800c48a:	bf00      	nop
 800c48c:	370c      	adds	r7, #12
 800c48e:	46bd      	mov	sp, r7
 800c490:	f85d 7b04 	ldr.w	r7, [sp], #4
 800c494:	4770      	bx	lr
 800c496:	bf00      	nop
 800c498:	40013c00 	.word	0x40013c00

0800c49c <FLASH_SetLatency>:
  *            @arg FLASH_Latency_6: FLASH Six Latency cycles
  *            @arg FLASH_Latency_7: FLASH Seven Latency cycles      
  * @retval None
  */
void FLASH_SetLatency(uint32_t FLASH_Latency)
{
 800c49c:	b480      	push	{r7}
 800c49e:	b083      	sub	sp, #12
 800c4a0:	af00      	add	r7, sp, #0
 800c4a2:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_FLASH_LATENCY(FLASH_Latency));
  
  /* Perform Byte access to FLASH_ACR[8:0] to set the Latency value */
  *(__IO uint8_t *)ACR_BYTE0_ADDRESS = (uint8_t)FLASH_Latency;
 800c4a4:	4b04      	ldr	r3, [pc, #16]	; (800c4b8 <FLASH_SetLatency+0x1c>)
 800c4a6:	687a      	ldr	r2, [r7, #4]
 800c4a8:	b2d2      	uxtb	r2, r2
 800c4aa:	701a      	strb	r2, [r3, #0]
}
 800c4ac:	bf00      	nop
 800c4ae:	370c      	adds	r7, #12
 800c4b0:	46bd      	mov	sp, r7
 800c4b2:	f85d 7b04 	ldr.w	r7, [sp], #4
 800c4b6:	4770      	bx	lr
 800c4b8:	40023c00 	.word	0x40023c00

0800c4bc <FLASH_PrefetchBufferCmd>:
  * @param  NewState: new state of the Prefetch Buffer.
  *          This parameter  can be: ENABLE or DISABLE.
  * @retval None
  */
void FLASH_PrefetchBufferCmd(FunctionalState NewState)
{
 800c4bc:	b480      	push	{r7}
 800c4be:	b083      	sub	sp, #12
 800c4c0:	af00      	add	r7, sp, #0
 800c4c2:	4603      	mov	r3, r0
 800c4c4:	71fb      	strb	r3, [r7, #7]
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  /* Enable or disable the Prefetch Buffer */
  if(NewState != DISABLE)
 800c4c6:	79fb      	ldrb	r3, [r7, #7]
 800c4c8:	2b00      	cmp	r3, #0
 800c4ca:	d006      	beq.n	800c4da <FLASH_PrefetchBufferCmd+0x1e>
  {
    FLASH->ACR |= FLASH_ACR_PRFTEN;
 800c4cc:	4a09      	ldr	r2, [pc, #36]	; (800c4f4 <FLASH_PrefetchBufferCmd+0x38>)
 800c4ce:	4b09      	ldr	r3, [pc, #36]	; (800c4f4 <FLASH_PrefetchBufferCmd+0x38>)
 800c4d0:	681b      	ldr	r3, [r3, #0]
 800c4d2:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 800c4d6:	6013      	str	r3, [r2, #0]
  }
  else
  {
    FLASH->ACR &= (~FLASH_ACR_PRFTEN);
  }
}
 800c4d8:	e005      	b.n	800c4e6 <FLASH_PrefetchBufferCmd+0x2a>
    FLASH->ACR &= (~FLASH_ACR_PRFTEN);
 800c4da:	4a06      	ldr	r2, [pc, #24]	; (800c4f4 <FLASH_PrefetchBufferCmd+0x38>)
 800c4dc:	4b05      	ldr	r3, [pc, #20]	; (800c4f4 <FLASH_PrefetchBufferCmd+0x38>)
 800c4de:	681b      	ldr	r3, [r3, #0]
 800c4e0:	f423 7380 	bic.w	r3, r3, #256	; 0x100
 800c4e4:	6013      	str	r3, [r2, #0]
}
 800c4e6:	bf00      	nop
 800c4e8:	370c      	adds	r7, #12
 800c4ea:	46bd      	mov	sp, r7
 800c4ec:	f85d 7b04 	ldr.w	r7, [sp], #4
 800c4f0:	4770      	bx	lr
 800c4f2:	bf00      	nop
 800c4f4:	40023c00 	.word	0x40023c00

0800c4f8 <FLASH_InstructionCacheCmd>:
  * @param  NewState: new state of the Instruction Cache.
  *          This parameter  can be: ENABLE or DISABLE.
  * @retval None
  */
void FLASH_InstructionCacheCmd(FunctionalState NewState)
{
 800c4f8:	b480      	push	{r7}
 800c4fa:	b083      	sub	sp, #12
 800c4fc:	af00      	add	r7, sp, #0
 800c4fe:	4603      	mov	r3, r0
 800c500:	71fb      	strb	r3, [r7, #7]
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if(NewState != DISABLE)
 800c502:	79fb      	ldrb	r3, [r7, #7]
 800c504:	2b00      	cmp	r3, #0
 800c506:	d006      	beq.n	800c516 <FLASH_InstructionCacheCmd+0x1e>
  {
    FLASH->ACR |= FLASH_ACR_ICEN;
 800c508:	4a09      	ldr	r2, [pc, #36]	; (800c530 <FLASH_InstructionCacheCmd+0x38>)
 800c50a:	4b09      	ldr	r3, [pc, #36]	; (800c530 <FLASH_InstructionCacheCmd+0x38>)
 800c50c:	681b      	ldr	r3, [r3, #0]
 800c50e:	f443 7300 	orr.w	r3, r3, #512	; 0x200
 800c512:	6013      	str	r3, [r2, #0]
  }
  else
  {
    FLASH->ACR &= (~FLASH_ACR_ICEN);
  }
}
 800c514:	e005      	b.n	800c522 <FLASH_InstructionCacheCmd+0x2a>
    FLASH->ACR &= (~FLASH_ACR_ICEN);
 800c516:	4a06      	ldr	r2, [pc, #24]	; (800c530 <FLASH_InstructionCacheCmd+0x38>)
 800c518:	4b05      	ldr	r3, [pc, #20]	; (800c530 <FLASH_InstructionCacheCmd+0x38>)
 800c51a:	681b      	ldr	r3, [r3, #0]
 800c51c:	f423 7300 	bic.w	r3, r3, #512	; 0x200
 800c520:	6013      	str	r3, [r2, #0]
}
 800c522:	bf00      	nop
 800c524:	370c      	adds	r7, #12
 800c526:	46bd      	mov	sp, r7
 800c528:	f85d 7b04 	ldr.w	r7, [sp], #4
 800c52c:	4770      	bx	lr
 800c52e:	bf00      	nop
 800c530:	40023c00 	.word	0x40023c00

0800c534 <FLASH_DataCacheCmd>:
  * @param  NewState: new state of the Data Cache.
  *          This parameter  can be: ENABLE or DISABLE.
  * @retval None
  */
void FLASH_DataCacheCmd(FunctionalState NewState)
{
 800c534:	b480      	push	{r7}
 800c536:	b083      	sub	sp, #12
 800c538:	af00      	add	r7, sp, #0
 800c53a:	4603      	mov	r3, r0
 800c53c:	71fb      	strb	r3, [r7, #7]
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if(NewState != DISABLE)
 800c53e:	79fb      	ldrb	r3, [r7, #7]
 800c540:	2b00      	cmp	r3, #0
 800c542:	d006      	beq.n	800c552 <FLASH_DataCacheCmd+0x1e>
  {
    FLASH->ACR |= FLASH_ACR_DCEN;
 800c544:	4a09      	ldr	r2, [pc, #36]	; (800c56c <FLASH_DataCacheCmd+0x38>)
 800c546:	4b09      	ldr	r3, [pc, #36]	; (800c56c <FLASH_DataCacheCmd+0x38>)
 800c548:	681b      	ldr	r3, [r3, #0]
 800c54a:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
 800c54e:	6013      	str	r3, [r2, #0]
  }
  else
  {
    FLASH->ACR &= (~FLASH_ACR_DCEN);
  }
}
 800c550:	e005      	b.n	800c55e <FLASH_DataCacheCmd+0x2a>
    FLASH->ACR &= (~FLASH_ACR_DCEN);
 800c552:	4a06      	ldr	r2, [pc, #24]	; (800c56c <FLASH_DataCacheCmd+0x38>)
 800c554:	4b05      	ldr	r3, [pc, #20]	; (800c56c <FLASH_DataCacheCmd+0x38>)
 800c556:	681b      	ldr	r3, [r3, #0]
 800c558:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 800c55c:	6013      	str	r3, [r2, #0]
}
 800c55e:	bf00      	nop
 800c560:	370c      	adds	r7, #12
 800c562:	46bd      	mov	sp, r7
 800c564:	f85d 7b04 	ldr.w	r7, [sp], #4
 800c568:	4770      	bx	lr
 800c56a:	bf00      	nop
 800c56c:	40023c00 	.word	0x40023c00

0800c570 <FLASH_InstructionCacheReset>:
  * @note   This function must be used only when the Instruction Cache is disabled.  
  * @param  None
  * @retval None
  */
void FLASH_InstructionCacheReset(void)
{
 800c570:	b480      	push	{r7}
 800c572:	af00      	add	r7, sp, #0
  FLASH->ACR |= FLASH_ACR_ICRST;
 800c574:	4a05      	ldr	r2, [pc, #20]	; (800c58c <FLASH_InstructionCacheReset+0x1c>)
 800c576:	4b05      	ldr	r3, [pc, #20]	; (800c58c <FLASH_InstructionCacheReset+0x1c>)
 800c578:	681b      	ldr	r3, [r3, #0]
 800c57a:	f443 6300 	orr.w	r3, r3, #2048	; 0x800
 800c57e:	6013      	str	r3, [r2, #0]
}
 800c580:	bf00      	nop
 800c582:	46bd      	mov	sp, r7
 800c584:	f85d 7b04 	ldr.w	r7, [sp], #4
 800c588:	4770      	bx	lr
 800c58a:	bf00      	nop
 800c58c:	40023c00 	.word	0x40023c00

0800c590 <FLASH_DataCacheReset>:
  * @note   This function must be used only when the Data Cache is disabled.  
  * @param  None
  * @retval None
  */
void FLASH_DataCacheReset(void)
{
 800c590:	b480      	push	{r7}
 800c592:	af00      	add	r7, sp, #0
  FLASH->ACR |= FLASH_ACR_DCRST;
 800c594:	4a05      	ldr	r2, [pc, #20]	; (800c5ac <FLASH_DataCacheReset+0x1c>)
 800c596:	4b05      	ldr	r3, [pc, #20]	; (800c5ac <FLASH_DataCacheReset+0x1c>)
 800c598:	681b      	ldr	r3, [r3, #0]
 800c59a:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
 800c59e:	6013      	str	r3, [r2, #0]
}
 800c5a0:	bf00      	nop
 800c5a2:	46bd      	mov	sp, r7
 800c5a4:	f85d 7b04 	ldr.w	r7, [sp], #4
 800c5a8:	4770      	bx	lr
 800c5aa:	bf00      	nop
 800c5ac:	40023c00 	.word	0x40023c00

0800c5b0 <FLASH_Unlock>:
  * @brief  Unlocks the FLASH control register access
  * @param  None
  * @retval None
  */
void FLASH_Unlock(void)
{
 800c5b0:	b480      	push	{r7}
 800c5b2:	af00      	add	r7, sp, #0
  if((FLASH->CR & FLASH_CR_LOCK) != RESET)
 800c5b4:	4b07      	ldr	r3, [pc, #28]	; (800c5d4 <FLASH_Unlock+0x24>)
 800c5b6:	691b      	ldr	r3, [r3, #16]
 800c5b8:	2b00      	cmp	r3, #0
 800c5ba:	da05      	bge.n	800c5c8 <FLASH_Unlock+0x18>
  {
    /* Authorize the FLASH Registers access */
    FLASH->KEYR = FLASH_KEY1;
 800c5bc:	4b05      	ldr	r3, [pc, #20]	; (800c5d4 <FLASH_Unlock+0x24>)
 800c5be:	4a06      	ldr	r2, [pc, #24]	; (800c5d8 <FLASH_Unlock+0x28>)
 800c5c0:	605a      	str	r2, [r3, #4]
    FLASH->KEYR = FLASH_KEY2;
 800c5c2:	4b04      	ldr	r3, [pc, #16]	; (800c5d4 <FLASH_Unlock+0x24>)
 800c5c4:	4a05      	ldr	r2, [pc, #20]	; (800c5dc <FLASH_Unlock+0x2c>)
 800c5c6:	605a      	str	r2, [r3, #4]
  }  
}
 800c5c8:	bf00      	nop
 800c5ca:	46bd      	mov	sp, r7
 800c5cc:	f85d 7b04 	ldr.w	r7, [sp], #4
 800c5d0:	4770      	bx	lr
 800c5d2:	bf00      	nop
 800c5d4:	40023c00 	.word	0x40023c00
 800c5d8:	45670123 	.word	0x45670123
 800c5dc:	cdef89ab 	.word	0xcdef89ab

0800c5e0 <FLASH_Lock>:
  * @brief  Locks the FLASH control register access
  * @param  None
  * @retval None
  */
void FLASH_Lock(void)
{
 800c5e0:	b480      	push	{r7}
 800c5e2:	af00      	add	r7, sp, #0
  /* Set the LOCK Bit to lock the FLASH Registers access */
  FLASH->CR |= FLASH_CR_LOCK;
 800c5e4:	4a05      	ldr	r2, [pc, #20]	; (800c5fc <FLASH_Lock+0x1c>)
 800c5e6:	4b05      	ldr	r3, [pc, #20]	; (800c5fc <FLASH_Lock+0x1c>)
 800c5e8:	691b      	ldr	r3, [r3, #16]
 800c5ea:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 800c5ee:	6113      	str	r3, [r2, #16]
}
 800c5f0:	bf00      	nop
 800c5f2:	46bd      	mov	sp, r7
 800c5f4:	f85d 7b04 	ldr.w	r7, [sp], #4
 800c5f8:	4770      	bx	lr
 800c5fa:	bf00      	nop
 800c5fc:	40023c00 	.word	0x40023c00

0800c600 <FLASH_EraseSector>:
  *       
  * @retval FLASH Status: The returned value can be: FLASH_BUSY, FLASH_ERROR_PROGRAM,
  *                       FLASH_ERROR_WRP, FLASH_ERROR_OPERATION or FLASH_COMPLETE.
  */
FLASH_Status FLASH_EraseSector(uint32_t FLASH_Sector, uint8_t VoltageRange)
{
 800c600:	b580      	push	{r7, lr}
 800c602:	b084      	sub	sp, #16
 800c604:	af00      	add	r7, sp, #0
 800c606:	6078      	str	r0, [r7, #4]
 800c608:	460b      	mov	r3, r1
 800c60a:	70fb      	strb	r3, [r7, #3]
  uint32_t tmp_psize = 0x0;
 800c60c:	2300      	movs	r3, #0
 800c60e:	60fb      	str	r3, [r7, #12]
  FLASH_Status status = FLASH_COMPLETE;
 800c610:	2308      	movs	r3, #8
 800c612:	72fb      	strb	r3, [r7, #11]

  /* Check the parameters */
  assert_param(IS_FLASH_SECTOR(FLASH_Sector));
  assert_param(IS_VOLTAGERANGE(VoltageRange));
  
  if(VoltageRange == VoltageRange_1)
 800c614:	78fb      	ldrb	r3, [r7, #3]
 800c616:	2b00      	cmp	r3, #0
 800c618:	d102      	bne.n	800c620 <FLASH_EraseSector+0x20>
  {
     tmp_psize = FLASH_PSIZE_BYTE;
 800c61a:	2300      	movs	r3, #0
 800c61c:	60fb      	str	r3, [r7, #12]
 800c61e:	e010      	b.n	800c642 <FLASH_EraseSector+0x42>
  }
  else if(VoltageRange == VoltageRange_2)
 800c620:	78fb      	ldrb	r3, [r7, #3]
 800c622:	2b01      	cmp	r3, #1
 800c624:	d103      	bne.n	800c62e <FLASH_EraseSector+0x2e>
  {
    tmp_psize = FLASH_PSIZE_HALF_WORD;
 800c626:	f44f 7380 	mov.w	r3, #256	; 0x100
 800c62a:	60fb      	str	r3, [r7, #12]
 800c62c:	e009      	b.n	800c642 <FLASH_EraseSector+0x42>
  }
  else if(VoltageRange == VoltageRange_3)
 800c62e:	78fb      	ldrb	r3, [r7, #3]
 800c630:	2b02      	cmp	r3, #2
 800c632:	d103      	bne.n	800c63c <FLASH_EraseSector+0x3c>
  {
    tmp_psize = FLASH_PSIZE_WORD;
 800c634:	f44f 7300 	mov.w	r3, #512	; 0x200
 800c638:	60fb      	str	r3, [r7, #12]
 800c63a:	e002      	b.n	800c642 <FLASH_EraseSector+0x42>
  }
  else
  {
    tmp_psize = FLASH_PSIZE_DOUBLE_WORD;
 800c63c:	f44f 7340 	mov.w	r3, #768	; 0x300
 800c640:	60fb      	str	r3, [r7, #12]
  }
  /* Wait for last operation to be completed */
  status = FLASH_WaitForLastOperation();
 800c642:	f000 faf7 	bl	800cc34 <FLASH_WaitForLastOperation>
 800c646:	4603      	mov	r3, r0
 800c648:	72fb      	strb	r3, [r7, #11]
  
  if(status == FLASH_COMPLETE)
 800c64a:	7afb      	ldrb	r3, [r7, #11]
 800c64c:	2b08      	cmp	r3, #8
 800c64e:	d12f      	bne.n	800c6b0 <FLASH_EraseSector+0xb0>
  { 
    /* if the previous operation is completed, proceed to erase the sector */
    FLASH->CR &= CR_PSIZE_MASK;
 800c650:	4a1a      	ldr	r2, [pc, #104]	; (800c6bc <FLASH_EraseSector+0xbc>)
 800c652:	4b1a      	ldr	r3, [pc, #104]	; (800c6bc <FLASH_EraseSector+0xbc>)
 800c654:	691b      	ldr	r3, [r3, #16]
 800c656:	f423 7340 	bic.w	r3, r3, #768	; 0x300
 800c65a:	6113      	str	r3, [r2, #16]
    FLASH->CR |= tmp_psize;
 800c65c:	4917      	ldr	r1, [pc, #92]	; (800c6bc <FLASH_EraseSector+0xbc>)
 800c65e:	4b17      	ldr	r3, [pc, #92]	; (800c6bc <FLASH_EraseSector+0xbc>)
 800c660:	691a      	ldr	r2, [r3, #16]
 800c662:	68fb      	ldr	r3, [r7, #12]
 800c664:	4313      	orrs	r3, r2
 800c666:	610b      	str	r3, [r1, #16]
    FLASH->CR &= SECTOR_MASK;
 800c668:	4a14      	ldr	r2, [pc, #80]	; (800c6bc <FLASH_EraseSector+0xbc>)
 800c66a:	4b14      	ldr	r3, [pc, #80]	; (800c6bc <FLASH_EraseSector+0xbc>)
 800c66c:	691b      	ldr	r3, [r3, #16]
 800c66e:	f023 03f8 	bic.w	r3, r3, #248	; 0xf8
 800c672:	6113      	str	r3, [r2, #16]
    FLASH->CR |= FLASH_CR_SER | FLASH_Sector;
 800c674:	4911      	ldr	r1, [pc, #68]	; (800c6bc <FLASH_EraseSector+0xbc>)
 800c676:	4b11      	ldr	r3, [pc, #68]	; (800c6bc <FLASH_EraseSector+0xbc>)
 800c678:	691a      	ldr	r2, [r3, #16]
 800c67a:	687b      	ldr	r3, [r7, #4]
 800c67c:	4313      	orrs	r3, r2
 800c67e:	f043 0302 	orr.w	r3, r3, #2
 800c682:	610b      	str	r3, [r1, #16]
    FLASH->CR |= FLASH_CR_STRT;
 800c684:	4a0d      	ldr	r2, [pc, #52]	; (800c6bc <FLASH_EraseSector+0xbc>)
 800c686:	4b0d      	ldr	r3, [pc, #52]	; (800c6bc <FLASH_EraseSector+0xbc>)
 800c688:	691b      	ldr	r3, [r3, #16]
 800c68a:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 800c68e:	6113      	str	r3, [r2, #16]
    
    /* Wait for last operation to be completed */
    status = FLASH_WaitForLastOperation();
 800c690:	f000 fad0 	bl	800cc34 <FLASH_WaitForLastOperation>
 800c694:	4603      	mov	r3, r0
 800c696:	72fb      	strb	r3, [r7, #11]
    
    /* if the erase operation is completed, disable the SER Bit */
    FLASH->CR &= (~FLASH_CR_SER);
 800c698:	4a08      	ldr	r2, [pc, #32]	; (800c6bc <FLASH_EraseSector+0xbc>)
 800c69a:	4b08      	ldr	r3, [pc, #32]	; (800c6bc <FLASH_EraseSector+0xbc>)
 800c69c:	691b      	ldr	r3, [r3, #16]
 800c69e:	f023 0302 	bic.w	r3, r3, #2
 800c6a2:	6113      	str	r3, [r2, #16]
    FLASH->CR &= SECTOR_MASK; 
 800c6a4:	4a05      	ldr	r2, [pc, #20]	; (800c6bc <FLASH_EraseSector+0xbc>)
 800c6a6:	4b05      	ldr	r3, [pc, #20]	; (800c6bc <FLASH_EraseSector+0xbc>)
 800c6a8:	691b      	ldr	r3, [r3, #16]
 800c6aa:	f023 03f8 	bic.w	r3, r3, #248	; 0xf8
 800c6ae:	6113      	str	r3, [r2, #16]
  }
  /* Return the Erase Status */
  return status;
 800c6b0:	7afb      	ldrb	r3, [r7, #11]
}
 800c6b2:	4618      	mov	r0, r3
 800c6b4:	3710      	adds	r7, #16
 800c6b6:	46bd      	mov	sp, r7
 800c6b8:	bd80      	pop	{r7, pc}
 800c6ba:	bf00      	nop
 800c6bc:	40023c00 	.word	0x40023c00

0800c6c0 <FLASH_EraseAllSectors>:
  *       
  * @retval FLASH Status: The returned value can be: FLASH_BUSY, FLASH_ERROR_PROGRAM,
  *                       FLASH_ERROR_WRP, FLASH_ERROR_OPERATION or FLASH_COMPLETE.
  */
FLASH_Status FLASH_EraseAllSectors(uint8_t VoltageRange)
{
 800c6c0:	b580      	push	{r7, lr}
 800c6c2:	b084      	sub	sp, #16
 800c6c4:	af00      	add	r7, sp, #0
 800c6c6:	4603      	mov	r3, r0
 800c6c8:	71fb      	strb	r3, [r7, #7]
  uint32_t tmp_psize = 0x0;
 800c6ca:	2300      	movs	r3, #0
 800c6cc:	60fb      	str	r3, [r7, #12]
  FLASH_Status status = FLASH_COMPLETE;
 800c6ce:	2308      	movs	r3, #8
 800c6d0:	72fb      	strb	r3, [r7, #11]
  
  /* Wait for last operation to be completed */
  status = FLASH_WaitForLastOperation();
 800c6d2:	f000 faaf 	bl	800cc34 <FLASH_WaitForLastOperation>
 800c6d6:	4603      	mov	r3, r0
 800c6d8:	72fb      	strb	r3, [r7, #11]
  assert_param(IS_VOLTAGERANGE(VoltageRange));
  
  if(VoltageRange == VoltageRange_1)
 800c6da:	79fb      	ldrb	r3, [r7, #7]
 800c6dc:	2b00      	cmp	r3, #0
 800c6de:	d102      	bne.n	800c6e6 <FLASH_EraseAllSectors+0x26>
  {
     tmp_psize = FLASH_PSIZE_BYTE;
 800c6e0:	2300      	movs	r3, #0
 800c6e2:	60fb      	str	r3, [r7, #12]
 800c6e4:	e010      	b.n	800c708 <FLASH_EraseAllSectors+0x48>
  }
  else if(VoltageRange == VoltageRange_2)
 800c6e6:	79fb      	ldrb	r3, [r7, #7]
 800c6e8:	2b01      	cmp	r3, #1
 800c6ea:	d103      	bne.n	800c6f4 <FLASH_EraseAllSectors+0x34>
  {
    tmp_psize = FLASH_PSIZE_HALF_WORD;
 800c6ec:	f44f 7380 	mov.w	r3, #256	; 0x100
 800c6f0:	60fb      	str	r3, [r7, #12]
 800c6f2:	e009      	b.n	800c708 <FLASH_EraseAllSectors+0x48>
  }
  else if(VoltageRange == VoltageRange_3)
 800c6f4:	79fb      	ldrb	r3, [r7, #7]
 800c6f6:	2b02      	cmp	r3, #2
 800c6f8:	d103      	bne.n	800c702 <FLASH_EraseAllSectors+0x42>
  {
    tmp_psize = FLASH_PSIZE_WORD;
 800c6fa:	f44f 7300 	mov.w	r3, #512	; 0x200
 800c6fe:	60fb      	str	r3, [r7, #12]
 800c700:	e002      	b.n	800c708 <FLASH_EraseAllSectors+0x48>
  }
  else
  {
    tmp_psize = FLASH_PSIZE_DOUBLE_WORD;
 800c702:	f44f 7340 	mov.w	r3, #768	; 0x300
 800c706:	60fb      	str	r3, [r7, #12]
  }  
  if(status == FLASH_COMPLETE)
 800c708:	7afb      	ldrb	r3, [r7, #11]
 800c70a:	2b08      	cmp	r3, #8
 800c70c:	d121      	bne.n	800c752 <FLASH_EraseAllSectors+0x92>
  {
    /* if the previous operation is completed, proceed to erase all sectors */
     FLASH->CR &= CR_PSIZE_MASK;
 800c70e:	4a13      	ldr	r2, [pc, #76]	; (800c75c <FLASH_EraseAllSectors+0x9c>)
 800c710:	4b12      	ldr	r3, [pc, #72]	; (800c75c <FLASH_EraseAllSectors+0x9c>)
 800c712:	691b      	ldr	r3, [r3, #16]
 800c714:	f423 7340 	bic.w	r3, r3, #768	; 0x300
 800c718:	6113      	str	r3, [r2, #16]
     FLASH->CR |= tmp_psize;
 800c71a:	4910      	ldr	r1, [pc, #64]	; (800c75c <FLASH_EraseAllSectors+0x9c>)
 800c71c:	4b0f      	ldr	r3, [pc, #60]	; (800c75c <FLASH_EraseAllSectors+0x9c>)
 800c71e:	691a      	ldr	r2, [r3, #16]
 800c720:	68fb      	ldr	r3, [r7, #12]
 800c722:	4313      	orrs	r3, r2
 800c724:	610b      	str	r3, [r1, #16]
     FLASH->CR |= FLASH_CR_MER;
 800c726:	4a0d      	ldr	r2, [pc, #52]	; (800c75c <FLASH_EraseAllSectors+0x9c>)
 800c728:	4b0c      	ldr	r3, [pc, #48]	; (800c75c <FLASH_EraseAllSectors+0x9c>)
 800c72a:	691b      	ldr	r3, [r3, #16]
 800c72c:	f043 0304 	orr.w	r3, r3, #4
 800c730:	6113      	str	r3, [r2, #16]
     FLASH->CR |= FLASH_CR_STRT;
 800c732:	4a0a      	ldr	r2, [pc, #40]	; (800c75c <FLASH_EraseAllSectors+0x9c>)
 800c734:	4b09      	ldr	r3, [pc, #36]	; (800c75c <FLASH_EraseAllSectors+0x9c>)
 800c736:	691b      	ldr	r3, [r3, #16]
 800c738:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 800c73c:	6113      	str	r3, [r2, #16]
    
    /* Wait for last operation to be completed */
    status = FLASH_WaitForLastOperation();
 800c73e:	f000 fa79 	bl	800cc34 <FLASH_WaitForLastOperation>
 800c742:	4603      	mov	r3, r0
 800c744:	72fb      	strb	r3, [r7, #11]

    /* if the erase operation is completed, disable the MER Bit */
    FLASH->CR &= (~FLASH_CR_MER);
 800c746:	4a05      	ldr	r2, [pc, #20]	; (800c75c <FLASH_EraseAllSectors+0x9c>)
 800c748:	4b04      	ldr	r3, [pc, #16]	; (800c75c <FLASH_EraseAllSectors+0x9c>)
 800c74a:	691b      	ldr	r3, [r3, #16]
 800c74c:	f023 0304 	bic.w	r3, r3, #4
 800c750:	6113      	str	r3, [r2, #16]

  }   
  /* Return the Erase Status */
  return status;
 800c752:	7afb      	ldrb	r3, [r7, #11]
}
 800c754:	4618      	mov	r0, r3
 800c756:	3710      	adds	r7, #16
 800c758:	46bd      	mov	sp, r7
 800c75a:	bd80      	pop	{r7, pc}
 800c75c:	40023c00 	.word	0x40023c00

0800c760 <FLASH_ProgramDoubleWord>:
  * @param  Data: specifies the data to be programmed.
  * @retval FLASH Status: The returned value can be: FLASH_BUSY, FLASH_ERROR_PROGRAM,
  *                       FLASH_ERROR_WRP, FLASH_ERROR_OPERATION or FLASH_COMPLETE.
  */
FLASH_Status FLASH_ProgramDoubleWord(uint32_t Address, uint64_t Data)
{
 800c760:	b590      	push	{r4, r7, lr}
 800c762:	b087      	sub	sp, #28
 800c764:	af00      	add	r7, sp, #0
 800c766:	60f8      	str	r0, [r7, #12]
 800c768:	e9c7 2300 	strd	r2, r3, [r7]
  FLASH_Status status = FLASH_COMPLETE;
 800c76c:	2308      	movs	r3, #8
 800c76e:	75fb      	strb	r3, [r7, #23]

  /* Check the parameters */
  assert_param(IS_FLASH_ADDRESS(Address));

  /* Wait for last operation to be completed */
  status = FLASH_WaitForLastOperation();
 800c770:	f000 fa60 	bl	800cc34 <FLASH_WaitForLastOperation>
 800c774:	4603      	mov	r3, r0
 800c776:	75fb      	strb	r3, [r7, #23]
  
  if(status == FLASH_COMPLETE)
 800c778:	7dfb      	ldrb	r3, [r7, #23]
 800c77a:	2b08      	cmp	r3, #8
 800c77c:	d120      	bne.n	800c7c0 <FLASH_ProgramDoubleWord+0x60>
  {
    /* if the previous operation is completed, proceed to program the new data */
    FLASH->CR &= CR_PSIZE_MASK;
 800c77e:	4a13      	ldr	r2, [pc, #76]	; (800c7cc <FLASH_ProgramDoubleWord+0x6c>)
 800c780:	4b12      	ldr	r3, [pc, #72]	; (800c7cc <FLASH_ProgramDoubleWord+0x6c>)
 800c782:	691b      	ldr	r3, [r3, #16]
 800c784:	f423 7340 	bic.w	r3, r3, #768	; 0x300
 800c788:	6113      	str	r3, [r2, #16]
    FLASH->CR |= FLASH_PSIZE_DOUBLE_WORD;
 800c78a:	4a10      	ldr	r2, [pc, #64]	; (800c7cc <FLASH_ProgramDoubleWord+0x6c>)
 800c78c:	4b0f      	ldr	r3, [pc, #60]	; (800c7cc <FLASH_ProgramDoubleWord+0x6c>)
 800c78e:	691b      	ldr	r3, [r3, #16]
 800c790:	f443 7340 	orr.w	r3, r3, #768	; 0x300
 800c794:	6113      	str	r3, [r2, #16]
    FLASH->CR |= FLASH_CR_PG;
 800c796:	4a0d      	ldr	r2, [pc, #52]	; (800c7cc <FLASH_ProgramDoubleWord+0x6c>)
 800c798:	4b0c      	ldr	r3, [pc, #48]	; (800c7cc <FLASH_ProgramDoubleWord+0x6c>)
 800c79a:	691b      	ldr	r3, [r3, #16]
 800c79c:	f043 0301 	orr.w	r3, r3, #1
 800c7a0:	6113      	str	r3, [r2, #16]
  
    *(__IO uint64_t*)Address = Data;
 800c7a2:	68fa      	ldr	r2, [r7, #12]
 800c7a4:	e897 0018 	ldmia.w	r7, {r3, r4}
 800c7a8:	e882 0018 	stmia.w	r2, {r3, r4}
        
    /* Wait for last operation to be completed */
    status = FLASH_WaitForLastOperation();
 800c7ac:	f000 fa42 	bl	800cc34 <FLASH_WaitForLastOperation>
 800c7b0:	4603      	mov	r3, r0
 800c7b2:	75fb      	strb	r3, [r7, #23]

    /* if the program operation is completed, disable the PG Bit */
    FLASH->CR &= (~FLASH_CR_PG);
 800c7b4:	4a05      	ldr	r2, [pc, #20]	; (800c7cc <FLASH_ProgramDoubleWord+0x6c>)
 800c7b6:	4b05      	ldr	r3, [pc, #20]	; (800c7cc <FLASH_ProgramDoubleWord+0x6c>)
 800c7b8:	691b      	ldr	r3, [r3, #16]
 800c7ba:	f023 0301 	bic.w	r3, r3, #1
 800c7be:	6113      	str	r3, [r2, #16]
  } 
  /* Return the Program Status */
  return status;
 800c7c0:	7dfb      	ldrb	r3, [r7, #23]
}
 800c7c2:	4618      	mov	r0, r3
 800c7c4:	371c      	adds	r7, #28
 800c7c6:	46bd      	mov	sp, r7
 800c7c8:	bd90      	pop	{r4, r7, pc}
 800c7ca:	bf00      	nop
 800c7cc:	40023c00 	.word	0x40023c00

0800c7d0 <FLASH_ProgramWord>:
  * @param  Data: specifies the data to be programmed.
  * @retval FLASH Status: The returned value can be: FLASH_BUSY, FLASH_ERROR_PROGRAM,
  *                       FLASH_ERROR_WRP, FLASH_ERROR_OPERATION or FLASH_COMPLETE.
  */
FLASH_Status FLASH_ProgramWord(uint32_t Address, uint32_t Data)
{
 800c7d0:	b580      	push	{r7, lr}
 800c7d2:	b084      	sub	sp, #16
 800c7d4:	af00      	add	r7, sp, #0
 800c7d6:	6078      	str	r0, [r7, #4]
 800c7d8:	6039      	str	r1, [r7, #0]
  FLASH_Status status = FLASH_COMPLETE;
 800c7da:	2308      	movs	r3, #8
 800c7dc:	73fb      	strb	r3, [r7, #15]

  /* Check the parameters */
  assert_param(IS_FLASH_ADDRESS(Address));

  /* Wait for last operation to be completed */
  status = FLASH_WaitForLastOperation();
 800c7de:	f000 fa29 	bl	800cc34 <FLASH_WaitForLastOperation>
 800c7e2:	4603      	mov	r3, r0
 800c7e4:	73fb      	strb	r3, [r7, #15]
  
  if(status == FLASH_COMPLETE)
 800c7e6:	7bfb      	ldrb	r3, [r7, #15]
 800c7e8:	2b08      	cmp	r3, #8
 800c7ea:	d11e      	bne.n	800c82a <FLASH_ProgramWord+0x5a>
  {
    /* if the previous operation is completed, proceed to program the new data */
    FLASH->CR &= CR_PSIZE_MASK;
 800c7ec:	4a11      	ldr	r2, [pc, #68]	; (800c834 <FLASH_ProgramWord+0x64>)
 800c7ee:	4b11      	ldr	r3, [pc, #68]	; (800c834 <FLASH_ProgramWord+0x64>)
 800c7f0:	691b      	ldr	r3, [r3, #16]
 800c7f2:	f423 7340 	bic.w	r3, r3, #768	; 0x300
 800c7f6:	6113      	str	r3, [r2, #16]
    FLASH->CR |= FLASH_PSIZE_WORD;
 800c7f8:	4a0e      	ldr	r2, [pc, #56]	; (800c834 <FLASH_ProgramWord+0x64>)
 800c7fa:	4b0e      	ldr	r3, [pc, #56]	; (800c834 <FLASH_ProgramWord+0x64>)
 800c7fc:	691b      	ldr	r3, [r3, #16]
 800c7fe:	f443 7300 	orr.w	r3, r3, #512	; 0x200
 800c802:	6113      	str	r3, [r2, #16]
    FLASH->CR |= FLASH_CR_PG;
 800c804:	4a0b      	ldr	r2, [pc, #44]	; (800c834 <FLASH_ProgramWord+0x64>)
 800c806:	4b0b      	ldr	r3, [pc, #44]	; (800c834 <FLASH_ProgramWord+0x64>)
 800c808:	691b      	ldr	r3, [r3, #16]
 800c80a:	f043 0301 	orr.w	r3, r3, #1
 800c80e:	6113      	str	r3, [r2, #16]
  
    *(__IO uint32_t*)Address = Data;
 800c810:	687b      	ldr	r3, [r7, #4]
 800c812:	683a      	ldr	r2, [r7, #0]
 800c814:	601a      	str	r2, [r3, #0]
        
    /* Wait for last operation to be completed */
    status = FLASH_WaitForLastOperation();
 800c816:	f000 fa0d 	bl	800cc34 <FLASH_WaitForLastOperation>
 800c81a:	4603      	mov	r3, r0
 800c81c:	73fb      	strb	r3, [r7, #15]

    /* if the program operation is completed, disable the PG Bit */
    FLASH->CR &= (~FLASH_CR_PG);
 800c81e:	4a05      	ldr	r2, [pc, #20]	; (800c834 <FLASH_ProgramWord+0x64>)
 800c820:	4b04      	ldr	r3, [pc, #16]	; (800c834 <FLASH_ProgramWord+0x64>)
 800c822:	691b      	ldr	r3, [r3, #16]
 800c824:	f023 0301 	bic.w	r3, r3, #1
 800c828:	6113      	str	r3, [r2, #16]
  } 
  /* Return the Program Status */
  return status;
 800c82a:	7bfb      	ldrb	r3, [r7, #15]
}
 800c82c:	4618      	mov	r0, r3
 800c82e:	3710      	adds	r7, #16
 800c830:	46bd      	mov	sp, r7
 800c832:	bd80      	pop	{r7, pc}
 800c834:	40023c00 	.word	0x40023c00

0800c838 <FLASH_ProgramHalfWord>:
  * @param  Data: specifies the data to be programmed.
  * @retval FLASH Status: The returned value can be: FLASH_BUSY, FLASH_ERROR_PROGRAM,
  *                       FLASH_ERROR_WRP, FLASH_ERROR_OPERATION or FLASH_COMPLETE.
  */
FLASH_Status FLASH_ProgramHalfWord(uint32_t Address, uint16_t Data)
{
 800c838:	b580      	push	{r7, lr}
 800c83a:	b084      	sub	sp, #16
 800c83c:	af00      	add	r7, sp, #0
 800c83e:	6078      	str	r0, [r7, #4]
 800c840:	460b      	mov	r3, r1
 800c842:	807b      	strh	r3, [r7, #2]
  FLASH_Status status = FLASH_COMPLETE;
 800c844:	2308      	movs	r3, #8
 800c846:	73fb      	strb	r3, [r7, #15]

  /* Check the parameters */
  assert_param(IS_FLASH_ADDRESS(Address));

  /* Wait for last operation to be completed */
  status = FLASH_WaitForLastOperation();
 800c848:	f000 f9f4 	bl	800cc34 <FLASH_WaitForLastOperation>
 800c84c:	4603      	mov	r3, r0
 800c84e:	73fb      	strb	r3, [r7, #15]
  
  if(status == FLASH_COMPLETE)
 800c850:	7bfb      	ldrb	r3, [r7, #15]
 800c852:	2b08      	cmp	r3, #8
 800c854:	d11e      	bne.n	800c894 <FLASH_ProgramHalfWord+0x5c>
  {
    /* if the previous operation is completed, proceed to program the new data */
    FLASH->CR &= CR_PSIZE_MASK;
 800c856:	4a12      	ldr	r2, [pc, #72]	; (800c8a0 <FLASH_ProgramHalfWord+0x68>)
 800c858:	4b11      	ldr	r3, [pc, #68]	; (800c8a0 <FLASH_ProgramHalfWord+0x68>)
 800c85a:	691b      	ldr	r3, [r3, #16]
 800c85c:	f423 7340 	bic.w	r3, r3, #768	; 0x300
 800c860:	6113      	str	r3, [r2, #16]
    FLASH->CR |= FLASH_PSIZE_HALF_WORD;
 800c862:	4a0f      	ldr	r2, [pc, #60]	; (800c8a0 <FLASH_ProgramHalfWord+0x68>)
 800c864:	4b0e      	ldr	r3, [pc, #56]	; (800c8a0 <FLASH_ProgramHalfWord+0x68>)
 800c866:	691b      	ldr	r3, [r3, #16]
 800c868:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 800c86c:	6113      	str	r3, [r2, #16]
    FLASH->CR |= FLASH_CR_PG;
 800c86e:	4a0c      	ldr	r2, [pc, #48]	; (800c8a0 <FLASH_ProgramHalfWord+0x68>)
 800c870:	4b0b      	ldr	r3, [pc, #44]	; (800c8a0 <FLASH_ProgramHalfWord+0x68>)
 800c872:	691b      	ldr	r3, [r3, #16]
 800c874:	f043 0301 	orr.w	r3, r3, #1
 800c878:	6113      	str	r3, [r2, #16]
  
    *(__IO uint16_t*)Address = Data;
 800c87a:	687b      	ldr	r3, [r7, #4]
 800c87c:	887a      	ldrh	r2, [r7, #2]
 800c87e:	801a      	strh	r2, [r3, #0]
        
    /* Wait for last operation to be completed */
    status = FLASH_WaitForLastOperation();
 800c880:	f000 f9d8 	bl	800cc34 <FLASH_WaitForLastOperation>
 800c884:	4603      	mov	r3, r0
 800c886:	73fb      	strb	r3, [r7, #15]

    /* if the program operation is completed, disable the PG Bit */
    FLASH->CR &= (~FLASH_CR_PG);
 800c888:	4a05      	ldr	r2, [pc, #20]	; (800c8a0 <FLASH_ProgramHalfWord+0x68>)
 800c88a:	4b05      	ldr	r3, [pc, #20]	; (800c8a0 <FLASH_ProgramHalfWord+0x68>)
 800c88c:	691b      	ldr	r3, [r3, #16]
 800c88e:	f023 0301 	bic.w	r3, r3, #1
 800c892:	6113      	str	r3, [r2, #16]
  } 
  /* Return the Program Status */
  return status;
 800c894:	7bfb      	ldrb	r3, [r7, #15]
}
 800c896:	4618      	mov	r0, r3
 800c898:	3710      	adds	r7, #16
 800c89a:	46bd      	mov	sp, r7
 800c89c:	bd80      	pop	{r7, pc}
 800c89e:	bf00      	nop
 800c8a0:	40023c00 	.word	0x40023c00

0800c8a4 <FLASH_ProgramByte>:
  * @param  Data: specifies the data to be programmed.
  * @retval FLASH Status: The returned value can be: FLASH_BUSY, FLASH_ERROR_PROGRAM,
  *                       FLASH_ERROR_WRP, FLASH_ERROR_OPERATION or FLASH_COMPLETE.
  */
FLASH_Status FLASH_ProgramByte(uint32_t Address, uint8_t Data)
{
 800c8a4:	b580      	push	{r7, lr}
 800c8a6:	b084      	sub	sp, #16
 800c8a8:	af00      	add	r7, sp, #0
 800c8aa:	6078      	str	r0, [r7, #4]
 800c8ac:	460b      	mov	r3, r1
 800c8ae:	70fb      	strb	r3, [r7, #3]
  FLASH_Status status = FLASH_COMPLETE;
 800c8b0:	2308      	movs	r3, #8
 800c8b2:	73fb      	strb	r3, [r7, #15]

  /* Check the parameters */
  assert_param(IS_FLASH_ADDRESS(Address));

  /* Wait for last operation to be completed */
  status = FLASH_WaitForLastOperation();
 800c8b4:	f000 f9be 	bl	800cc34 <FLASH_WaitForLastOperation>
 800c8b8:	4603      	mov	r3, r0
 800c8ba:	73fb      	strb	r3, [r7, #15]
  
  if(status == FLASH_COMPLETE)
 800c8bc:	7bfb      	ldrb	r3, [r7, #15]
 800c8be:	2b08      	cmp	r3, #8
 800c8c0:	d11c      	bne.n	800c8fc <FLASH_ProgramByte+0x58>
  {
    /* if the previous operation is completed, proceed to program the new data */
    FLASH->CR &= CR_PSIZE_MASK;
 800c8c2:	4a11      	ldr	r2, [pc, #68]	; (800c908 <FLASH_ProgramByte+0x64>)
 800c8c4:	4b10      	ldr	r3, [pc, #64]	; (800c908 <FLASH_ProgramByte+0x64>)
 800c8c6:	691b      	ldr	r3, [r3, #16]
 800c8c8:	f423 7340 	bic.w	r3, r3, #768	; 0x300
 800c8cc:	6113      	str	r3, [r2, #16]
    FLASH->CR |= FLASH_PSIZE_BYTE;
 800c8ce:	4a0e      	ldr	r2, [pc, #56]	; (800c908 <FLASH_ProgramByte+0x64>)
 800c8d0:	4b0d      	ldr	r3, [pc, #52]	; (800c908 <FLASH_ProgramByte+0x64>)
 800c8d2:	691b      	ldr	r3, [r3, #16]
 800c8d4:	6113      	str	r3, [r2, #16]
    FLASH->CR |= FLASH_CR_PG;
 800c8d6:	4a0c      	ldr	r2, [pc, #48]	; (800c908 <FLASH_ProgramByte+0x64>)
 800c8d8:	4b0b      	ldr	r3, [pc, #44]	; (800c908 <FLASH_ProgramByte+0x64>)
 800c8da:	691b      	ldr	r3, [r3, #16]
 800c8dc:	f043 0301 	orr.w	r3, r3, #1
 800c8e0:	6113      	str	r3, [r2, #16]
  
    *(__IO uint8_t*)Address = Data;
 800c8e2:	687b      	ldr	r3, [r7, #4]
 800c8e4:	78fa      	ldrb	r2, [r7, #3]
 800c8e6:	701a      	strb	r2, [r3, #0]
        
    /* Wait for last operation to be completed */
    status = FLASH_WaitForLastOperation();
 800c8e8:	f000 f9a4 	bl	800cc34 <FLASH_WaitForLastOperation>
 800c8ec:	4603      	mov	r3, r0
 800c8ee:	73fb      	strb	r3, [r7, #15]

    /* if the program operation is completed, disable the PG Bit */
    FLASH->CR &= (~FLASH_CR_PG);
 800c8f0:	4a05      	ldr	r2, [pc, #20]	; (800c908 <FLASH_ProgramByte+0x64>)
 800c8f2:	4b05      	ldr	r3, [pc, #20]	; (800c908 <FLASH_ProgramByte+0x64>)
 800c8f4:	691b      	ldr	r3, [r3, #16]
 800c8f6:	f023 0301 	bic.w	r3, r3, #1
 800c8fa:	6113      	str	r3, [r2, #16]
  } 

  /* Return the Program Status */
  return status;
 800c8fc:	7bfb      	ldrb	r3, [r7, #15]
}
 800c8fe:	4618      	mov	r0, r3
 800c900:	3710      	adds	r7, #16
 800c902:	46bd      	mov	sp, r7
 800c904:	bd80      	pop	{r7, pc}
 800c906:	bf00      	nop
 800c908:	40023c00 	.word	0x40023c00

0800c90c <FLASH_OB_Unlock>:
  * @brief  Unlocks the FLASH Option Control Registers access.
  * @param  None
  * @retval None
  */
void FLASH_OB_Unlock(void)
{
 800c90c:	b480      	push	{r7}
 800c90e:	af00      	add	r7, sp, #0
  if((FLASH->OPTCR & FLASH_OPTCR_OPTLOCK) != RESET)
 800c910:	4b08      	ldr	r3, [pc, #32]	; (800c934 <FLASH_OB_Unlock+0x28>)
 800c912:	695b      	ldr	r3, [r3, #20]
 800c914:	f003 0301 	and.w	r3, r3, #1
 800c918:	2b00      	cmp	r3, #0
 800c91a:	d005      	beq.n	800c928 <FLASH_OB_Unlock+0x1c>
  {
    /* Authorizes the Option Byte register programming */
    FLASH->OPTKEYR = FLASH_OPT_KEY1;
 800c91c:	4b05      	ldr	r3, [pc, #20]	; (800c934 <FLASH_OB_Unlock+0x28>)
 800c91e:	4a06      	ldr	r2, [pc, #24]	; (800c938 <FLASH_OB_Unlock+0x2c>)
 800c920:	609a      	str	r2, [r3, #8]
    FLASH->OPTKEYR = FLASH_OPT_KEY2;
 800c922:	4b04      	ldr	r3, [pc, #16]	; (800c934 <FLASH_OB_Unlock+0x28>)
 800c924:	4a05      	ldr	r2, [pc, #20]	; (800c93c <FLASH_OB_Unlock+0x30>)
 800c926:	609a      	str	r2, [r3, #8]
  }  
}
 800c928:	bf00      	nop
 800c92a:	46bd      	mov	sp, r7
 800c92c:	f85d 7b04 	ldr.w	r7, [sp], #4
 800c930:	4770      	bx	lr
 800c932:	bf00      	nop
 800c934:	40023c00 	.word	0x40023c00
 800c938:	08192a3b 	.word	0x08192a3b
 800c93c:	4c5d6e7f 	.word	0x4c5d6e7f

0800c940 <FLASH_OB_Lock>:
  * @brief  Locks the FLASH Option Control Registers access.
  * @param  None
  * @retval None
  */
void FLASH_OB_Lock(void)
{
 800c940:	b480      	push	{r7}
 800c942:	af00      	add	r7, sp, #0
  /* Set the OPTLOCK Bit to lock the FLASH Option Byte Registers access */
  FLASH->OPTCR |= FLASH_OPTCR_OPTLOCK;
 800c944:	4a05      	ldr	r2, [pc, #20]	; (800c95c <FLASH_OB_Lock+0x1c>)
 800c946:	4b05      	ldr	r3, [pc, #20]	; (800c95c <FLASH_OB_Lock+0x1c>)
 800c948:	695b      	ldr	r3, [r3, #20]
 800c94a:	f043 0301 	orr.w	r3, r3, #1
 800c94e:	6153      	str	r3, [r2, #20]
}
 800c950:	bf00      	nop
 800c952:	46bd      	mov	sp, r7
 800c954:	f85d 7b04 	ldr.w	r7, [sp], #4
 800c958:	4770      	bx	lr
 800c95a:	bf00      	nop
 800c95c:	40023c00 	.word	0x40023c00

0800c960 <FLASH_OB_WRPConfig>:
  * @param  Newstate: new state of the Write Protection.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None  
  */
void FLASH_OB_WRPConfig(uint32_t OB_WRP, FunctionalState NewState)
{ 
 800c960:	b580      	push	{r7, lr}
 800c962:	b084      	sub	sp, #16
 800c964:	af00      	add	r7, sp, #0
 800c966:	6078      	str	r0, [r7, #4]
 800c968:	460b      	mov	r3, r1
 800c96a:	70fb      	strb	r3, [r7, #3]
  FLASH_Status status = FLASH_COMPLETE;
 800c96c:	2308      	movs	r3, #8
 800c96e:	73fb      	strb	r3, [r7, #15]
  
  /* Check the parameters */
  assert_param(IS_OB_WRP(OB_WRP));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
    
  status = FLASH_WaitForLastOperation();
 800c970:	f000 f960 	bl	800cc34 <FLASH_WaitForLastOperation>
 800c974:	4603      	mov	r3, r0
 800c976:	73fb      	strb	r3, [r7, #15]

  if(status == FLASH_COMPLETE)
 800c978:	7bfb      	ldrb	r3, [r7, #15]
 800c97a:	2b08      	cmp	r3, #8
 800c97c:	d117      	bne.n	800c9ae <FLASH_OB_WRPConfig+0x4e>
  { 
    if(NewState != DISABLE)
 800c97e:	78fb      	ldrb	r3, [r7, #3]
 800c980:	2b00      	cmp	r3, #0
 800c982:	d00b      	beq.n	800c99c <FLASH_OB_WRPConfig+0x3c>
    {
      *(__IO uint16_t*)OPTCR_BYTE2_ADDRESS &= (~OB_WRP);
 800c984:	490c      	ldr	r1, [pc, #48]	; (800c9b8 <FLASH_OB_WRPConfig+0x58>)
 800c986:	4b0c      	ldr	r3, [pc, #48]	; (800c9b8 <FLASH_OB_WRPConfig+0x58>)
 800c988:	881b      	ldrh	r3, [r3, #0]
 800c98a:	b29a      	uxth	r2, r3
 800c98c:	687b      	ldr	r3, [r7, #4]
 800c98e:	b29b      	uxth	r3, r3
 800c990:	43db      	mvns	r3, r3
 800c992:	b29b      	uxth	r3, r3
 800c994:	4013      	ands	r3, r2
 800c996:	b29b      	uxth	r3, r3
 800c998:	800b      	strh	r3, [r1, #0]
    else
    {
      *(__IO uint16_t*)OPTCR_BYTE2_ADDRESS |= (uint16_t)OB_WRP;
    }
  }
}
 800c99a:	e008      	b.n	800c9ae <FLASH_OB_WRPConfig+0x4e>
      *(__IO uint16_t*)OPTCR_BYTE2_ADDRESS |= (uint16_t)OB_WRP;
 800c99c:	4906      	ldr	r1, [pc, #24]	; (800c9b8 <FLASH_OB_WRPConfig+0x58>)
 800c99e:	4b06      	ldr	r3, [pc, #24]	; (800c9b8 <FLASH_OB_WRPConfig+0x58>)
 800c9a0:	881b      	ldrh	r3, [r3, #0]
 800c9a2:	b29a      	uxth	r2, r3
 800c9a4:	687b      	ldr	r3, [r7, #4]
 800c9a6:	b29b      	uxth	r3, r3
 800c9a8:	4313      	orrs	r3, r2
 800c9aa:	b29b      	uxth	r3, r3
 800c9ac:	800b      	strh	r3, [r1, #0]
}
 800c9ae:	bf00      	nop
 800c9b0:	3710      	adds	r7, #16
 800c9b2:	46bd      	mov	sp, r7
 800c9b4:	bd80      	pop	{r7, pc}
 800c9b6:	bf00      	nop
 800c9b8:	40023c16 	.word	0x40023c16

0800c9bc <FLASH_OB_RDPConfig>:
  * !!!Warning!!! When enabling OB_RDP level 2 it's no more possible to go back to level 1 or 0
  *    
  * @retval None
  */
void FLASH_OB_RDPConfig(uint8_t OB_RDP)
{
 800c9bc:	b580      	push	{r7, lr}
 800c9be:	b084      	sub	sp, #16
 800c9c0:	af00      	add	r7, sp, #0
 800c9c2:	4603      	mov	r3, r0
 800c9c4:	71fb      	strb	r3, [r7, #7]
  FLASH_Status status = FLASH_COMPLETE;
 800c9c6:	2308      	movs	r3, #8
 800c9c8:	73fb      	strb	r3, [r7, #15]

  /* Check the parameters */
  assert_param(IS_OB_RDP(OB_RDP));

  status = FLASH_WaitForLastOperation();
 800c9ca:	f000 f933 	bl	800cc34 <FLASH_WaitForLastOperation>
 800c9ce:	4603      	mov	r3, r0
 800c9d0:	73fb      	strb	r3, [r7, #15]

  if(status == FLASH_COMPLETE)
 800c9d2:	7bfb      	ldrb	r3, [r7, #15]
 800c9d4:	2b08      	cmp	r3, #8
 800c9d6:	d102      	bne.n	800c9de <FLASH_OB_RDPConfig+0x22>
  {
    *(__IO uint8_t*)OPTCR_BYTE1_ADDRESS = OB_RDP;
 800c9d8:	4a03      	ldr	r2, [pc, #12]	; (800c9e8 <FLASH_OB_RDPConfig+0x2c>)
 800c9da:	79fb      	ldrb	r3, [r7, #7]
 800c9dc:	7013      	strb	r3, [r2, #0]

  }
}
 800c9de:	bf00      	nop
 800c9e0:	3710      	adds	r7, #16
 800c9e2:	46bd      	mov	sp, r7
 800c9e4:	bd80      	pop	{r7, pc}
 800c9e6:	bf00      	nop
 800c9e8:	40023c15 	.word	0x40023c15

0800c9ec <FLASH_OB_UserConfig>:
  *            @arg OB_STDBY_NoRST: No reset generated when entering in STANDBY
  *            @arg OB_STDBY_RST: Reset generated when entering in STANDBY
  * @retval None
  */
void FLASH_OB_UserConfig(uint8_t OB_IWDG, uint8_t OB_STOP, uint8_t OB_STDBY)
{
 800c9ec:	b580      	push	{r7, lr}
 800c9ee:	b084      	sub	sp, #16
 800c9f0:	af00      	add	r7, sp, #0
 800c9f2:	4603      	mov	r3, r0
 800c9f4:	71fb      	strb	r3, [r7, #7]
 800c9f6:	460b      	mov	r3, r1
 800c9f8:	71bb      	strb	r3, [r7, #6]
 800c9fa:	4613      	mov	r3, r2
 800c9fc:	717b      	strb	r3, [r7, #5]
  uint8_t optiontmp = 0xFF;
 800c9fe:	23ff      	movs	r3, #255	; 0xff
 800ca00:	73fb      	strb	r3, [r7, #15]
  FLASH_Status status = FLASH_COMPLETE; 
 800ca02:	2308      	movs	r3, #8
 800ca04:	73bb      	strb	r3, [r7, #14]
  assert_param(IS_OB_IWDG_SOURCE(OB_IWDG));
  assert_param(IS_OB_STOP_SOURCE(OB_STOP));
  assert_param(IS_OB_STDBY_SOURCE(OB_STDBY));

  /* Wait for last operation to be completed */
  status = FLASH_WaitForLastOperation();
 800ca06:	f000 f915 	bl	800cc34 <FLASH_WaitForLastOperation>
 800ca0a:	4603      	mov	r3, r0
 800ca0c:	73bb      	strb	r3, [r7, #14]
  
  if(status == FLASH_COMPLETE)
 800ca0e:	7bbb      	ldrb	r3, [r7, #14]
 800ca10:	2b08      	cmp	r3, #8
 800ca12:	d111      	bne.n	800ca38 <FLASH_OB_UserConfig+0x4c>
  { 
    /* Mask OPTLOCK, OPTSTRT and BOR_LEV bits */
    optiontmp =  (uint8_t)((*(__IO uint8_t *)OPTCR_BYTE0_ADDRESS) & (uint8_t)0x0F); 
 800ca14:	4b0a      	ldr	r3, [pc, #40]	; (800ca40 <FLASH_OB_UserConfig+0x54>)
 800ca16:	781b      	ldrb	r3, [r3, #0]
 800ca18:	b2db      	uxtb	r3, r3
 800ca1a:	f003 030f 	and.w	r3, r3, #15
 800ca1e:	73fb      	strb	r3, [r7, #15]

    /* Update User Option Byte */
    *(__IO uint8_t *)OPTCR_BYTE0_ADDRESS = OB_IWDG | (uint8_t)(OB_STDBY | (uint8_t)(OB_STOP | ((uint8_t)optiontmp))); 
 800ca20:	4907      	ldr	r1, [pc, #28]	; (800ca40 <FLASH_OB_UserConfig+0x54>)
 800ca22:	79ba      	ldrb	r2, [r7, #6]
 800ca24:	7bfb      	ldrb	r3, [r7, #15]
 800ca26:	4313      	orrs	r3, r2
 800ca28:	b2da      	uxtb	r2, r3
 800ca2a:	797b      	ldrb	r3, [r7, #5]
 800ca2c:	4313      	orrs	r3, r2
 800ca2e:	b2da      	uxtb	r2, r3
 800ca30:	79fb      	ldrb	r3, [r7, #7]
 800ca32:	4313      	orrs	r3, r2
 800ca34:	b2db      	uxtb	r3, r3
 800ca36:	700b      	strb	r3, [r1, #0]
  }  
}
 800ca38:	bf00      	nop
 800ca3a:	3710      	adds	r7, #16
 800ca3c:	46bd      	mov	sp, r7
 800ca3e:	bd80      	pop	{r7, pc}
 800ca40:	40023c14 	.word	0x40023c14

0800ca44 <FLASH_OB_BORConfig>:
  *            @arg OB_BOR_LEVEL1: Supply voltage ranges from 2.1 to 2.4 V
  *            @arg OB_BOR_OFF: Supply voltage ranges from 1.62 to 2.1 V
  * @retval None
  */
void FLASH_OB_BORConfig(uint8_t OB_BOR)
{
 800ca44:	b480      	push	{r7}
 800ca46:	b083      	sub	sp, #12
 800ca48:	af00      	add	r7, sp, #0
 800ca4a:	4603      	mov	r3, r0
 800ca4c:	71fb      	strb	r3, [r7, #7]
  /* Check the parameters */
  assert_param(IS_OB_BOR(OB_BOR));

  /* Set the BOR Level */
  *(__IO uint8_t *)OPTCR_BYTE0_ADDRESS &= (~FLASH_OPTCR_BOR_LEV);
 800ca4e:	4a0b      	ldr	r2, [pc, #44]	; (800ca7c <FLASH_OB_BORConfig+0x38>)
 800ca50:	4b0a      	ldr	r3, [pc, #40]	; (800ca7c <FLASH_OB_BORConfig+0x38>)
 800ca52:	781b      	ldrb	r3, [r3, #0]
 800ca54:	b2db      	uxtb	r3, r3
 800ca56:	f023 030c 	bic.w	r3, r3, #12
 800ca5a:	b2db      	uxtb	r3, r3
 800ca5c:	7013      	strb	r3, [r2, #0]
  *(__IO uint8_t *)OPTCR_BYTE0_ADDRESS |= OB_BOR;
 800ca5e:	4907      	ldr	r1, [pc, #28]	; (800ca7c <FLASH_OB_BORConfig+0x38>)
 800ca60:	4b06      	ldr	r3, [pc, #24]	; (800ca7c <FLASH_OB_BORConfig+0x38>)
 800ca62:	781b      	ldrb	r3, [r3, #0]
 800ca64:	b2da      	uxtb	r2, r3
 800ca66:	79fb      	ldrb	r3, [r7, #7]
 800ca68:	4313      	orrs	r3, r2
 800ca6a:	b2db      	uxtb	r3, r3
 800ca6c:	700b      	strb	r3, [r1, #0]

}
 800ca6e:	bf00      	nop
 800ca70:	370c      	adds	r7, #12
 800ca72:	46bd      	mov	sp, r7
 800ca74:	f85d 7b04 	ldr.w	r7, [sp], #4
 800ca78:	4770      	bx	lr
 800ca7a:	bf00      	nop
 800ca7c:	40023c14 	.word	0x40023c14

0800ca80 <FLASH_OB_Launch>:
  * @param  None
  * @retval FLASH Status: The returned value can be: FLASH_BUSY, FLASH_ERROR_PROGRAM,
  *                       FLASH_ERROR_WRP, FLASH_ERROR_OPERATION or FLASH_COMPLETE.
  */
FLASH_Status FLASH_OB_Launch(void)
{
 800ca80:	b580      	push	{r7, lr}
 800ca82:	b082      	sub	sp, #8
 800ca84:	af00      	add	r7, sp, #0
  FLASH_Status status = FLASH_COMPLETE;
 800ca86:	2308      	movs	r3, #8
 800ca88:	71fb      	strb	r3, [r7, #7]

  /* Set the OPTSTRT bit in OPTCR register */
  *(__IO uint8_t *)OPTCR_BYTE0_ADDRESS |= FLASH_OPTCR_OPTSTRT;
 800ca8a:	4a08      	ldr	r2, [pc, #32]	; (800caac <FLASH_OB_Launch+0x2c>)
 800ca8c:	4b07      	ldr	r3, [pc, #28]	; (800caac <FLASH_OB_Launch+0x2c>)
 800ca8e:	781b      	ldrb	r3, [r3, #0]
 800ca90:	b2db      	uxtb	r3, r3
 800ca92:	f043 0302 	orr.w	r3, r3, #2
 800ca96:	b2db      	uxtb	r3, r3
 800ca98:	7013      	strb	r3, [r2, #0]

  /* Wait for last operation to be completed */
  status = FLASH_WaitForLastOperation();
 800ca9a:	f000 f8cb 	bl	800cc34 <FLASH_WaitForLastOperation>
 800ca9e:	4603      	mov	r3, r0
 800caa0:	71fb      	strb	r3, [r7, #7]

  return status;
 800caa2:	79fb      	ldrb	r3, [r7, #7]
}
 800caa4:	4618      	mov	r0, r3
 800caa6:	3708      	adds	r7, #8
 800caa8:	46bd      	mov	sp, r7
 800caaa:	bd80      	pop	{r7, pc}
 800caac:	40023c14 	.word	0x40023c14

0800cab0 <FLASH_OB_GetUser>:
  * @param  None
  * @retval The FLASH User Option Bytes values: IWDG_SW(Bit0), RST_STOP(Bit1)
  *         and RST_STDBY(Bit2).
  */
uint8_t FLASH_OB_GetUser(void)
{
 800cab0:	b480      	push	{r7}
 800cab2:	af00      	add	r7, sp, #0
  /* Return the User Option Byte */
  return (uint8_t)(FLASH->OPTCR >> 5);
 800cab4:	4b04      	ldr	r3, [pc, #16]	; (800cac8 <FLASH_OB_GetUser+0x18>)
 800cab6:	695b      	ldr	r3, [r3, #20]
 800cab8:	095b      	lsrs	r3, r3, #5
 800caba:	b2db      	uxtb	r3, r3
}
 800cabc:	4618      	mov	r0, r3
 800cabe:	46bd      	mov	sp, r7
 800cac0:	f85d 7b04 	ldr.w	r7, [sp], #4
 800cac4:	4770      	bx	lr
 800cac6:	bf00      	nop
 800cac8:	40023c00 	.word	0x40023c00

0800cacc <FLASH_OB_GetWRP>:
  * @brief  Returns the FLASH Write Protection Option Bytes value.
  * @param  None
  * @retval The FLASH Write Protection  Option Bytes value
  */
uint16_t FLASH_OB_GetWRP(void)
{
 800cacc:	b480      	push	{r7}
 800cace:	af00      	add	r7, sp, #0
  /* Return the FLASH write protection Register value */
  return (*(__IO uint16_t *)(OPTCR_BYTE2_ADDRESS));
 800cad0:	4b03      	ldr	r3, [pc, #12]	; (800cae0 <FLASH_OB_GetWRP+0x14>)
 800cad2:	881b      	ldrh	r3, [r3, #0]
 800cad4:	b29b      	uxth	r3, r3
}
 800cad6:	4618      	mov	r0, r3
 800cad8:	46bd      	mov	sp, r7
 800cada:	f85d 7b04 	ldr.w	r7, [sp], #4
 800cade:	4770      	bx	lr
 800cae0:	40023c16 	.word	0x40023c16

0800cae4 <FLASH_OB_GetRDP>:
  * @retval FLASH ReadOut Protection Status:
  *           - SET, when OB_RDP_Level_1 or OB_RDP_Level_2 is set
  *           - RESET, when OB_RDP_Level_0 is set
  */
FlagStatus FLASH_OB_GetRDP(void)
{
 800cae4:	b480      	push	{r7}
 800cae6:	b083      	sub	sp, #12
 800cae8:	af00      	add	r7, sp, #0
  FlagStatus readstatus = RESET;
 800caea:	2300      	movs	r3, #0
 800caec:	71fb      	strb	r3, [r7, #7]

  if ((*(__IO uint8_t*)(OPTCR_BYTE1_ADDRESS) != (uint8_t)OB_RDP_Level_0))
 800caee:	4b08      	ldr	r3, [pc, #32]	; (800cb10 <FLASH_OB_GetRDP+0x2c>)
 800caf0:	781b      	ldrb	r3, [r3, #0]
 800caf2:	b2db      	uxtb	r3, r3
 800caf4:	2baa      	cmp	r3, #170	; 0xaa
 800caf6:	d002      	beq.n	800cafe <FLASH_OB_GetRDP+0x1a>
  {
    readstatus = SET;
 800caf8:	2301      	movs	r3, #1
 800cafa:	71fb      	strb	r3, [r7, #7]
 800cafc:	e001      	b.n	800cb02 <FLASH_OB_GetRDP+0x1e>
  }
  else
  {
    readstatus = RESET;
 800cafe:	2300      	movs	r3, #0
 800cb00:	71fb      	strb	r3, [r7, #7]
  }
  return readstatus;
 800cb02:	79fb      	ldrb	r3, [r7, #7]
}
 800cb04:	4618      	mov	r0, r3
 800cb06:	370c      	adds	r7, #12
 800cb08:	46bd      	mov	sp, r7
 800cb0a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800cb0e:	4770      	bx	lr
 800cb10:	40023c15 	.word	0x40023c15

0800cb14 <FLASH_OB_GetBOR>:
  *           - OB_BOR_LEVEL2: Supply voltage ranges from 2.4 to 2.7 V
  *           - OB_BOR_LEVEL1: Supply voltage ranges from 2.1 to 2.4 V
  *           - OB_BOR_OFF   : Supply voltage ranges from 1.62 to 2.1 V  
  */
uint8_t FLASH_OB_GetBOR(void)
{
 800cb14:	b480      	push	{r7}
 800cb16:	af00      	add	r7, sp, #0
  /* Return the FLASH BOR level */
  return (uint8_t)(*(__IO uint8_t *)(OPTCR_BYTE0_ADDRESS) & (uint8_t)0x0C);
 800cb18:	4b05      	ldr	r3, [pc, #20]	; (800cb30 <FLASH_OB_GetBOR+0x1c>)
 800cb1a:	781b      	ldrb	r3, [r3, #0]
 800cb1c:	b2db      	uxtb	r3, r3
 800cb1e:	f003 030c 	and.w	r3, r3, #12
 800cb22:	b2db      	uxtb	r3, r3
}
 800cb24:	4618      	mov	r0, r3
 800cb26:	46bd      	mov	sp, r7
 800cb28:	f85d 7b04 	ldr.w	r7, [sp], #4
 800cb2c:	4770      	bx	lr
 800cb2e:	bf00      	nop
 800cb30:	40023c14 	.word	0x40023c14

0800cb34 <FLASH_ITConfig>:
  *            @arg FLASH_IT_ERR: FLASH Error Interrupt
  *            @arg FLASH_IT_EOP: FLASH end of operation Interrupt
  * @retval None 
  */
void FLASH_ITConfig(uint32_t FLASH_IT, FunctionalState NewState)
{
 800cb34:	b480      	push	{r7}
 800cb36:	b083      	sub	sp, #12
 800cb38:	af00      	add	r7, sp, #0
 800cb3a:	6078      	str	r0, [r7, #4]
 800cb3c:	460b      	mov	r3, r1
 800cb3e:	70fb      	strb	r3, [r7, #3]
  /* Check the parameters */
  assert_param(IS_FLASH_IT(FLASH_IT)); 
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if(NewState != DISABLE)
 800cb40:	78fb      	ldrb	r3, [r7, #3]
 800cb42:	2b00      	cmp	r3, #0
 800cb44:	d006      	beq.n	800cb54 <FLASH_ITConfig+0x20>
  {
    /* Enable the interrupt sources */
    FLASH->CR |= FLASH_IT;
 800cb46:	490a      	ldr	r1, [pc, #40]	; (800cb70 <FLASH_ITConfig+0x3c>)
 800cb48:	4b09      	ldr	r3, [pc, #36]	; (800cb70 <FLASH_ITConfig+0x3c>)
 800cb4a:	691a      	ldr	r2, [r3, #16]
 800cb4c:	687b      	ldr	r3, [r7, #4]
 800cb4e:	4313      	orrs	r3, r2
 800cb50:	610b      	str	r3, [r1, #16]
  else
  {
    /* Disable the interrupt sources */
    FLASH->CR &= ~(uint32_t)FLASH_IT;
  }
}
 800cb52:	e006      	b.n	800cb62 <FLASH_ITConfig+0x2e>
    FLASH->CR &= ~(uint32_t)FLASH_IT;
 800cb54:	4906      	ldr	r1, [pc, #24]	; (800cb70 <FLASH_ITConfig+0x3c>)
 800cb56:	4b06      	ldr	r3, [pc, #24]	; (800cb70 <FLASH_ITConfig+0x3c>)
 800cb58:	691a      	ldr	r2, [r3, #16]
 800cb5a:	687b      	ldr	r3, [r7, #4]
 800cb5c:	43db      	mvns	r3, r3
 800cb5e:	4013      	ands	r3, r2
 800cb60:	610b      	str	r3, [r1, #16]
}
 800cb62:	bf00      	nop
 800cb64:	370c      	adds	r7, #12
 800cb66:	46bd      	mov	sp, r7
 800cb68:	f85d 7b04 	ldr.w	r7, [sp], #4
 800cb6c:	4770      	bx	lr
 800cb6e:	bf00      	nop
 800cb70:	40023c00 	.word	0x40023c00

0800cb74 <FLASH_GetFlagStatus>:
  *            @arg FLASH_FLAG_PGSERR: FLASH Programming Sequence error flag
  *            @arg FLASH_FLAG_BSY: FLASH Busy flag
  * @retval The new state of FLASH_FLAG (SET or RESET).
  */
FlagStatus FLASH_GetFlagStatus(uint32_t FLASH_FLAG)
{
 800cb74:	b480      	push	{r7}
 800cb76:	b085      	sub	sp, #20
 800cb78:	af00      	add	r7, sp, #0
 800cb7a:	6078      	str	r0, [r7, #4]
  FlagStatus bitstatus = RESET;
 800cb7c:	2300      	movs	r3, #0
 800cb7e:	73fb      	strb	r3, [r7, #15]
  /* Check the parameters */
  assert_param(IS_FLASH_GET_FLAG(FLASH_FLAG));

  if((FLASH->SR & FLASH_FLAG) != (uint32_t)RESET)
 800cb80:	4b08      	ldr	r3, [pc, #32]	; (800cba4 <FLASH_GetFlagStatus+0x30>)
 800cb82:	68da      	ldr	r2, [r3, #12]
 800cb84:	687b      	ldr	r3, [r7, #4]
 800cb86:	4013      	ands	r3, r2
 800cb88:	2b00      	cmp	r3, #0
 800cb8a:	d002      	beq.n	800cb92 <FLASH_GetFlagStatus+0x1e>
  {
    bitstatus = SET;
 800cb8c:	2301      	movs	r3, #1
 800cb8e:	73fb      	strb	r3, [r7, #15]
 800cb90:	e001      	b.n	800cb96 <FLASH_GetFlagStatus+0x22>
  }
  else
  {
    bitstatus = RESET;
 800cb92:	2300      	movs	r3, #0
 800cb94:	73fb      	strb	r3, [r7, #15]
  }
  /* Return the new state of FLASH_FLAG (SET or RESET) */
  return bitstatus; 
 800cb96:	7bfb      	ldrb	r3, [r7, #15]
}
 800cb98:	4618      	mov	r0, r3
 800cb9a:	3714      	adds	r7, #20
 800cb9c:	46bd      	mov	sp, r7
 800cb9e:	f85d 7b04 	ldr.w	r7, [sp], #4
 800cba2:	4770      	bx	lr
 800cba4:	40023c00 	.word	0x40023c00

0800cba8 <FLASH_ClearFlag>:
  *            @arg FLASH_FLAG_PGPERR: FLASH Programming Parallelism error flag
  *            @arg FLASH_FLAG_PGSERR: FLASH Programming Sequence error flag
  * @retval None
  */
void FLASH_ClearFlag(uint32_t FLASH_FLAG)
{
 800cba8:	b480      	push	{r7}
 800cbaa:	b083      	sub	sp, #12
 800cbac:	af00      	add	r7, sp, #0
 800cbae:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_FLASH_CLEAR_FLAG(FLASH_FLAG));
  
  /* Clear the flags */
  FLASH->SR = FLASH_FLAG;
 800cbb0:	4a04      	ldr	r2, [pc, #16]	; (800cbc4 <FLASH_ClearFlag+0x1c>)
 800cbb2:	687b      	ldr	r3, [r7, #4]
 800cbb4:	60d3      	str	r3, [r2, #12]
}
 800cbb6:	bf00      	nop
 800cbb8:	370c      	adds	r7, #12
 800cbba:	46bd      	mov	sp, r7
 800cbbc:	f85d 7b04 	ldr.w	r7, [sp], #4
 800cbc0:	4770      	bx	lr
 800cbc2:	bf00      	nop
 800cbc4:	40023c00 	.word	0x40023c00

0800cbc8 <FLASH_GetStatus>:
  * @param  None
  * @retval FLASH Status: The returned value can be: FLASH_BUSY, FLASH_ERROR_PROGRAM,
  *                       FLASH_ERROR_WRP, FLASH_ERROR_OPERATION or FLASH_COMPLETE.
  */
FLASH_Status FLASH_GetStatus(void)
{
 800cbc8:	b480      	push	{r7}
 800cbca:	b083      	sub	sp, #12
 800cbcc:	af00      	add	r7, sp, #0
  FLASH_Status flashstatus = FLASH_COMPLETE;
 800cbce:	2308      	movs	r3, #8
 800cbd0:	71fb      	strb	r3, [r7, #7]
  
  if((FLASH->SR & FLASH_FLAG_BSY) == FLASH_FLAG_BSY) 
 800cbd2:	4b17      	ldr	r3, [pc, #92]	; (800cc30 <FLASH_GetStatus+0x68>)
 800cbd4:	68db      	ldr	r3, [r3, #12]
 800cbd6:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
 800cbda:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 800cbde:	d102      	bne.n	800cbe6 <FLASH_GetStatus+0x1e>
  {
    flashstatus = FLASH_BUSY;
 800cbe0:	2301      	movs	r3, #1
 800cbe2:	71fb      	strb	r3, [r7, #7]
 800cbe4:	e01c      	b.n	800cc20 <FLASH_GetStatus+0x58>
  }
  else 
  {  
    if((FLASH->SR & FLASH_FLAG_WRPERR) != (uint32_t)0x00)
 800cbe6:	4b12      	ldr	r3, [pc, #72]	; (800cc30 <FLASH_GetStatus+0x68>)
 800cbe8:	68db      	ldr	r3, [r3, #12]
 800cbea:	f003 0310 	and.w	r3, r3, #16
 800cbee:	2b00      	cmp	r3, #0
 800cbf0:	d002      	beq.n	800cbf8 <FLASH_GetStatus+0x30>
    { 
      flashstatus = FLASH_ERROR_WRP;
 800cbf2:	2305      	movs	r3, #5
 800cbf4:	71fb      	strb	r3, [r7, #7]
 800cbf6:	e013      	b.n	800cc20 <FLASH_GetStatus+0x58>
    }
    else 
    {
      if((FLASH->SR & (uint32_t)0xEF) != (uint32_t)0x00)
 800cbf8:	4b0d      	ldr	r3, [pc, #52]	; (800cc30 <FLASH_GetStatus+0x68>)
 800cbfa:	68db      	ldr	r3, [r3, #12]
 800cbfc:	f003 03ef 	and.w	r3, r3, #239	; 0xef
 800cc00:	2b00      	cmp	r3, #0
 800cc02:	d002      	beq.n	800cc0a <FLASH_GetStatus+0x42>
      {
        flashstatus = FLASH_ERROR_PROGRAM; 
 800cc04:	2306      	movs	r3, #6
 800cc06:	71fb      	strb	r3, [r7, #7]
 800cc08:	e00a      	b.n	800cc20 <FLASH_GetStatus+0x58>
      }
      else
      {
        if((FLASH->SR & FLASH_FLAG_OPERR) != (uint32_t)0x00)
 800cc0a:	4b09      	ldr	r3, [pc, #36]	; (800cc30 <FLASH_GetStatus+0x68>)
 800cc0c:	68db      	ldr	r3, [r3, #12]
 800cc0e:	f003 0302 	and.w	r3, r3, #2
 800cc12:	2b00      	cmp	r3, #0
 800cc14:	d002      	beq.n	800cc1c <FLASH_GetStatus+0x54>
        {
          flashstatus = FLASH_ERROR_OPERATION;
 800cc16:	2307      	movs	r3, #7
 800cc18:	71fb      	strb	r3, [r7, #7]
 800cc1a:	e001      	b.n	800cc20 <FLASH_GetStatus+0x58>
        }
        else
        {
          flashstatus = FLASH_COMPLETE;
 800cc1c:	2308      	movs	r3, #8
 800cc1e:	71fb      	strb	r3, [r7, #7]
        }
      }
    }
  }
  /* Return the FLASH Status */
  return flashstatus;
 800cc20:	79fb      	ldrb	r3, [r7, #7]
}
 800cc22:	4618      	mov	r0, r3
 800cc24:	370c      	adds	r7, #12
 800cc26:	46bd      	mov	sp, r7
 800cc28:	f85d 7b04 	ldr.w	r7, [sp], #4
 800cc2c:	4770      	bx	lr
 800cc2e:	bf00      	nop
 800cc30:	40023c00 	.word	0x40023c00

0800cc34 <FLASH_WaitForLastOperation>:
  * @param  None
  * @retval FLASH Status: The returned value can be: FLASH_BUSY, FLASH_ERROR_PROGRAM,
  *                       FLASH_ERROR_WRP, FLASH_ERROR_OPERATION or FLASH_COMPLETE.
  */
FLASH_Status FLASH_WaitForLastOperation(void)
{ 
 800cc34:	b580      	push	{r7, lr}
 800cc36:	b082      	sub	sp, #8
 800cc38:	af00      	add	r7, sp, #0
  __IO FLASH_Status status = FLASH_COMPLETE;
 800cc3a:	2308      	movs	r3, #8
 800cc3c:	71fb      	strb	r3, [r7, #7]
   
  /* Check for the FLASH Status */
  status = FLASH_GetStatus();
 800cc3e:	f7ff ffc3 	bl	800cbc8 <FLASH_GetStatus>
 800cc42:	4603      	mov	r3, r0
 800cc44:	71fb      	strb	r3, [r7, #7]

  /* Wait for the FLASH operation to complete by polling on BUSY flag to be reset.
     Even if the FLASH operation fails, the BUSY flag will be reset and an error
     flag will be set */
  while(status == FLASH_BUSY)
 800cc46:	e003      	b.n	800cc50 <FLASH_WaitForLastOperation+0x1c>
  {
    status = FLASH_GetStatus();
 800cc48:	f7ff ffbe 	bl	800cbc8 <FLASH_GetStatus>
 800cc4c:	4603      	mov	r3, r0
 800cc4e:	71fb      	strb	r3, [r7, #7]
  while(status == FLASH_BUSY)
 800cc50:	79fb      	ldrb	r3, [r7, #7]
 800cc52:	b2db      	uxtb	r3, r3
 800cc54:	2b01      	cmp	r3, #1
 800cc56:	d0f7      	beq.n	800cc48 <FLASH_WaitForLastOperation+0x14>
  }
  /* Return the operation status */
  return status;
 800cc58:	79fb      	ldrb	r3, [r7, #7]
 800cc5a:	b2db      	uxtb	r3, r3
}
 800cc5c:	4618      	mov	r0, r3
 800cc5e:	3708      	adds	r7, #8
 800cc60:	46bd      	mov	sp, r7
 800cc62:	bd80      	pop	{r7, pc}

0800cc64 <FSMC_NORSRAMDeInit>:
  *            @arg FSMC_Bank1_NORSRAM3: FSMC Bank1 NOR/SRAM3 
  *            @arg FSMC_Bank1_NORSRAM4: FSMC Bank1 NOR/SRAM4 
  * @retval None
  */
void FSMC_NORSRAMDeInit(uint32_t FSMC_Bank)
{
 800cc64:	b480      	push	{r7}
 800cc66:	b083      	sub	sp, #12
 800cc68:	af00      	add	r7, sp, #0
 800cc6a:	6078      	str	r0, [r7, #4]
  /* Check the parameter */
  assert_param(IS_FSMC_NORSRAM_BANK(FSMC_Bank));
  
  /* FSMC_Bank1_NORSRAM1 */
  if(FSMC_Bank == FSMC_Bank1_NORSRAM1)
 800cc6c:	687b      	ldr	r3, [r7, #4]
 800cc6e:	2b00      	cmp	r3, #0
 800cc70:	d107      	bne.n	800cc82 <FSMC_NORSRAMDeInit+0x1e>
  {
    FSMC_Bank1->BTCR[FSMC_Bank] = 0x000030DB;    
 800cc72:	f04f 4220 	mov.w	r2, #2684354560	; 0xa0000000
 800cc76:	687b      	ldr	r3, [r7, #4]
 800cc78:	f243 01db 	movw	r1, #12507	; 0x30db
 800cc7c:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
 800cc80:	e006      	b.n	800cc90 <FSMC_NORSRAMDeInit+0x2c>
  }
  /* FSMC_Bank1_NORSRAM2,  FSMC_Bank1_NORSRAM3 or FSMC_Bank1_NORSRAM4 */
  else
  {   
    FSMC_Bank1->BTCR[FSMC_Bank] = 0x000030D2; 
 800cc82:	f04f 4220 	mov.w	r2, #2684354560	; 0xa0000000
 800cc86:	687b      	ldr	r3, [r7, #4]
 800cc88:	f243 01d2 	movw	r1, #12498	; 0x30d2
 800cc8c:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
  }
  FSMC_Bank1->BTCR[FSMC_Bank + 1] = 0x0FFFFFFF;
 800cc90:	f04f 4220 	mov.w	r2, #2684354560	; 0xa0000000
 800cc94:	687b      	ldr	r3, [r7, #4]
 800cc96:	3301      	adds	r3, #1
 800cc98:	f06f 4170 	mvn.w	r1, #4026531840	; 0xf0000000
 800cc9c:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
  FSMC_Bank1E->BWTR[FSMC_Bank] = 0x0FFFFFFF;  
 800cca0:	4a05      	ldr	r2, [pc, #20]	; (800ccb8 <FSMC_NORSRAMDeInit+0x54>)
 800cca2:	687b      	ldr	r3, [r7, #4]
 800cca4:	f06f 4170 	mvn.w	r1, #4026531840	; 0xf0000000
 800cca8:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
}
 800ccac:	bf00      	nop
 800ccae:	370c      	adds	r7, #12
 800ccb0:	46bd      	mov	sp, r7
 800ccb2:	f85d 7b04 	ldr.w	r7, [sp], #4
 800ccb6:	4770      	bx	lr
 800ccb8:	a0000104 	.word	0xa0000104

0800ccbc <FSMC_NORSRAMInit>:
  *         that contains the configuration information for the FSMC NOR/SRAM 
  *         specified Banks.                       
  * @retval None
  */
void FSMC_NORSRAMInit(FSMC_NORSRAMInitTypeDef* FSMC_NORSRAMInitStruct)
{ 
 800ccbc:	b480      	push	{r7}
 800ccbe:	b083      	sub	sp, #12
 800ccc0:	af00      	add	r7, sp, #0
 800ccc2:	6078      	str	r0, [r7, #4]
  assert_param(IS_FSMC_CLK_DIV(FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_CLKDivision));
  assert_param(IS_FSMC_DATA_LATENCY(FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_DataLatency));
  assert_param(IS_FSMC_ACCESS_MODE(FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_AccessMode)); 
  
  /* Bank1 NOR/SRAM control register configuration */ 
  FSMC_Bank1->BTCR[FSMC_NORSRAMInitStruct->FSMC_Bank] = 
 800ccc4:	f04f 4020 	mov.w	r0, #2684354560	; 0xa0000000
 800ccc8:	687b      	ldr	r3, [r7, #4]
 800ccca:	681b      	ldr	r3, [r3, #0]
            (uint32_t)FSMC_NORSRAMInitStruct->FSMC_DataAddressMux |
 800cccc:	687a      	ldr	r2, [r7, #4]
 800ccce:	6851      	ldr	r1, [r2, #4]
            FSMC_NORSRAMInitStruct->FSMC_MemoryType |
 800ccd0:	687a      	ldr	r2, [r7, #4]
 800ccd2:	6892      	ldr	r2, [r2, #8]
            (uint32_t)FSMC_NORSRAMInitStruct->FSMC_DataAddressMux |
 800ccd4:	4311      	orrs	r1, r2
            FSMC_NORSRAMInitStruct->FSMC_MemoryDataWidth |
 800ccd6:	687a      	ldr	r2, [r7, #4]
 800ccd8:	68d2      	ldr	r2, [r2, #12]
            FSMC_NORSRAMInitStruct->FSMC_MemoryType |
 800ccda:	4311      	orrs	r1, r2
            FSMC_NORSRAMInitStruct->FSMC_BurstAccessMode |
 800ccdc:	687a      	ldr	r2, [r7, #4]
 800ccde:	6912      	ldr	r2, [r2, #16]
            FSMC_NORSRAMInitStruct->FSMC_MemoryDataWidth |
 800cce0:	4311      	orrs	r1, r2
            FSMC_NORSRAMInitStruct->FSMC_AsynchronousWait |
 800cce2:	687a      	ldr	r2, [r7, #4]
 800cce4:	6952      	ldr	r2, [r2, #20]
            FSMC_NORSRAMInitStruct->FSMC_BurstAccessMode |
 800cce6:	4311      	orrs	r1, r2
            FSMC_NORSRAMInitStruct->FSMC_WaitSignalPolarity |
 800cce8:	687a      	ldr	r2, [r7, #4]
 800ccea:	6992      	ldr	r2, [r2, #24]
            FSMC_NORSRAMInitStruct->FSMC_AsynchronousWait |
 800ccec:	4311      	orrs	r1, r2
            FSMC_NORSRAMInitStruct->FSMC_WrapMode |
 800ccee:	687a      	ldr	r2, [r7, #4]
 800ccf0:	69d2      	ldr	r2, [r2, #28]
            FSMC_NORSRAMInitStruct->FSMC_WaitSignalPolarity |
 800ccf2:	4311      	orrs	r1, r2
            FSMC_NORSRAMInitStruct->FSMC_WaitSignalActive |
 800ccf4:	687a      	ldr	r2, [r7, #4]
 800ccf6:	6a12      	ldr	r2, [r2, #32]
            FSMC_NORSRAMInitStruct->FSMC_WrapMode |
 800ccf8:	4311      	orrs	r1, r2
            FSMC_NORSRAMInitStruct->FSMC_WriteOperation |
 800ccfa:	687a      	ldr	r2, [r7, #4]
 800ccfc:	6a52      	ldr	r2, [r2, #36]	; 0x24
            FSMC_NORSRAMInitStruct->FSMC_WaitSignalActive |
 800ccfe:	4311      	orrs	r1, r2
            FSMC_NORSRAMInitStruct->FSMC_WaitSignal |
 800cd00:	687a      	ldr	r2, [r7, #4]
 800cd02:	6a92      	ldr	r2, [r2, #40]	; 0x28
            FSMC_NORSRAMInitStruct->FSMC_WriteOperation |
 800cd04:	4311      	orrs	r1, r2
            FSMC_NORSRAMInitStruct->FSMC_ExtendedMode |
 800cd06:	687a      	ldr	r2, [r7, #4]
 800cd08:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
            FSMC_NORSRAMInitStruct->FSMC_WaitSignal |
 800cd0a:	4311      	orrs	r1, r2
            FSMC_NORSRAMInitStruct->FSMC_WriteBurst;
 800cd0c:	687a      	ldr	r2, [r7, #4]
 800cd0e:	6b12      	ldr	r2, [r2, #48]	; 0x30
            FSMC_NORSRAMInitStruct->FSMC_ExtendedMode |
 800cd10:	430a      	orrs	r2, r1
  FSMC_Bank1->BTCR[FSMC_NORSRAMInitStruct->FSMC_Bank] = 
 800cd12:	f840 2023 	str.w	r2, [r0, r3, lsl #2]
  if(FSMC_NORSRAMInitStruct->FSMC_MemoryType == FSMC_MemoryType_NOR)
 800cd16:	687b      	ldr	r3, [r7, #4]
 800cd18:	689b      	ldr	r3, [r3, #8]
 800cd1a:	2b08      	cmp	r3, #8
 800cd1c:	d10d      	bne.n	800cd3a <FSMC_NORSRAMInit+0x7e>
  {
    FSMC_Bank1->BTCR[FSMC_NORSRAMInitStruct->FSMC_Bank] |= (uint32_t)BCR_FACCEN_SET;
 800cd1e:	f04f 4120 	mov.w	r1, #2684354560	; 0xa0000000
 800cd22:	687b      	ldr	r3, [r7, #4]
 800cd24:	681b      	ldr	r3, [r3, #0]
 800cd26:	f04f 4020 	mov.w	r0, #2684354560	; 0xa0000000
 800cd2a:	687a      	ldr	r2, [r7, #4]
 800cd2c:	6812      	ldr	r2, [r2, #0]
 800cd2e:	f850 2022 	ldr.w	r2, [r0, r2, lsl #2]
 800cd32:	f042 0240 	orr.w	r2, r2, #64	; 0x40
 800cd36:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
  }
  /* Bank1 NOR/SRAM timing register configuration */
  FSMC_Bank1->BTCR[FSMC_NORSRAMInitStruct->FSMC_Bank+1] = 
 800cd3a:	f04f 4020 	mov.w	r0, #2684354560	; 0xa0000000
 800cd3e:	687b      	ldr	r3, [r7, #4]
 800cd40:	681b      	ldr	r3, [r3, #0]
 800cd42:	3301      	adds	r3, #1
            (uint32_t)FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_AddressSetupTime |
 800cd44:	687a      	ldr	r2, [r7, #4]
 800cd46:	6b52      	ldr	r2, [r2, #52]	; 0x34
 800cd48:	6811      	ldr	r1, [r2, #0]
            (FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_AddressHoldTime << 4) |
 800cd4a:	687a      	ldr	r2, [r7, #4]
 800cd4c:	6b52      	ldr	r2, [r2, #52]	; 0x34
 800cd4e:	6852      	ldr	r2, [r2, #4]
 800cd50:	0112      	lsls	r2, r2, #4
            (uint32_t)FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_AddressSetupTime |
 800cd52:	4311      	orrs	r1, r2
            (FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_DataSetupTime << 8) |
 800cd54:	687a      	ldr	r2, [r7, #4]
 800cd56:	6b52      	ldr	r2, [r2, #52]	; 0x34
 800cd58:	6892      	ldr	r2, [r2, #8]
 800cd5a:	0212      	lsls	r2, r2, #8
            (FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_AddressHoldTime << 4) |
 800cd5c:	4311      	orrs	r1, r2
            (FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_BusTurnAroundDuration << 16) |
 800cd5e:	687a      	ldr	r2, [r7, #4]
 800cd60:	6b52      	ldr	r2, [r2, #52]	; 0x34
 800cd62:	68d2      	ldr	r2, [r2, #12]
 800cd64:	0412      	lsls	r2, r2, #16
            (FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_DataSetupTime << 8) |
 800cd66:	4311      	orrs	r1, r2
            (FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_CLKDivision << 20) |
 800cd68:	687a      	ldr	r2, [r7, #4]
 800cd6a:	6b52      	ldr	r2, [r2, #52]	; 0x34
 800cd6c:	6912      	ldr	r2, [r2, #16]
 800cd6e:	0512      	lsls	r2, r2, #20
            (FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_BusTurnAroundDuration << 16) |
 800cd70:	4311      	orrs	r1, r2
            (FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_DataLatency << 24) |
 800cd72:	687a      	ldr	r2, [r7, #4]
 800cd74:	6b52      	ldr	r2, [r2, #52]	; 0x34
 800cd76:	6952      	ldr	r2, [r2, #20]
 800cd78:	0612      	lsls	r2, r2, #24
            (FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_CLKDivision << 20) |
 800cd7a:	4311      	orrs	r1, r2
             FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_AccessMode;
 800cd7c:	687a      	ldr	r2, [r7, #4]
 800cd7e:	6b52      	ldr	r2, [r2, #52]	; 0x34
 800cd80:	6992      	ldr	r2, [r2, #24]
            (FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_DataLatency << 24) |
 800cd82:	430a      	orrs	r2, r1
  FSMC_Bank1->BTCR[FSMC_NORSRAMInitStruct->FSMC_Bank+1] = 
 800cd84:	f840 2023 	str.w	r2, [r0, r3, lsl #2]
            
    
  /* Bank1 NOR/SRAM timing register for write configuration, if extended mode is used */
  if(FSMC_NORSRAMInitStruct->FSMC_ExtendedMode == FSMC_ExtendedMode_Enable)
 800cd88:	687b      	ldr	r3, [r7, #4]
 800cd8a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800cd8c:	f5b3 4f80 	cmp.w	r3, #16384	; 0x4000
 800cd90:	d120      	bne.n	800cdd4 <FSMC_NORSRAMInit+0x118>
    assert_param(IS_FSMC_ADDRESS_HOLD_TIME(FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_AddressHoldTime));
    assert_param(IS_FSMC_DATASETUP_TIME(FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_DataSetupTime));
    assert_param(IS_FSMC_CLK_DIV(FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_CLKDivision));
    assert_param(IS_FSMC_DATA_LATENCY(FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_DataLatency));
    assert_param(IS_FSMC_ACCESS_MODE(FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_AccessMode));
    FSMC_Bank1E->BWTR[FSMC_NORSRAMInitStruct->FSMC_Bank] = 
 800cd92:	4817      	ldr	r0, [pc, #92]	; (800cdf0 <FSMC_NORSRAMInit+0x134>)
 800cd94:	687b      	ldr	r3, [r7, #4]
 800cd96:	681b      	ldr	r3, [r3, #0]
              (uint32_t)FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_AddressSetupTime |
 800cd98:	687a      	ldr	r2, [r7, #4]
 800cd9a:	6b92      	ldr	r2, [r2, #56]	; 0x38
 800cd9c:	6811      	ldr	r1, [r2, #0]
              (FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_AddressHoldTime << 4 )|
 800cd9e:	687a      	ldr	r2, [r7, #4]
 800cda0:	6b92      	ldr	r2, [r2, #56]	; 0x38
 800cda2:	6852      	ldr	r2, [r2, #4]
 800cda4:	0112      	lsls	r2, r2, #4
              (uint32_t)FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_AddressSetupTime |
 800cda6:	4311      	orrs	r1, r2
              (FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_DataSetupTime << 8) |
 800cda8:	687a      	ldr	r2, [r7, #4]
 800cdaa:	6b92      	ldr	r2, [r2, #56]	; 0x38
 800cdac:	6892      	ldr	r2, [r2, #8]
 800cdae:	0212      	lsls	r2, r2, #8
              (FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_AddressHoldTime << 4 )|
 800cdb0:	4311      	orrs	r1, r2
              (FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_CLKDivision << 20) |
 800cdb2:	687a      	ldr	r2, [r7, #4]
 800cdb4:	6b92      	ldr	r2, [r2, #56]	; 0x38
 800cdb6:	6912      	ldr	r2, [r2, #16]
 800cdb8:	0512      	lsls	r2, r2, #20
              (FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_DataSetupTime << 8) |
 800cdba:	4311      	orrs	r1, r2
              (FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_DataLatency << 24) |
 800cdbc:	687a      	ldr	r2, [r7, #4]
 800cdbe:	6b92      	ldr	r2, [r2, #56]	; 0x38
 800cdc0:	6952      	ldr	r2, [r2, #20]
 800cdc2:	0612      	lsls	r2, r2, #24
              (FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_CLKDivision << 20) |
 800cdc4:	4311      	orrs	r1, r2
               FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_AccessMode;
 800cdc6:	687a      	ldr	r2, [r7, #4]
 800cdc8:	6b92      	ldr	r2, [r2, #56]	; 0x38
 800cdca:	6992      	ldr	r2, [r2, #24]
              (FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_DataLatency << 24) |
 800cdcc:	430a      	orrs	r2, r1
    FSMC_Bank1E->BWTR[FSMC_NORSRAMInitStruct->FSMC_Bank] = 
 800cdce:	f840 2023 	str.w	r2, [r0, r3, lsl #2]
  }
  else
  {
    FSMC_Bank1E->BWTR[FSMC_NORSRAMInitStruct->FSMC_Bank] = 0x0FFFFFFF;
  }
}
 800cdd2:	e006      	b.n	800cde2 <FSMC_NORSRAMInit+0x126>
    FSMC_Bank1E->BWTR[FSMC_NORSRAMInitStruct->FSMC_Bank] = 0x0FFFFFFF;
 800cdd4:	4a06      	ldr	r2, [pc, #24]	; (800cdf0 <FSMC_NORSRAMInit+0x134>)
 800cdd6:	687b      	ldr	r3, [r7, #4]
 800cdd8:	681b      	ldr	r3, [r3, #0]
 800cdda:	f06f 4170 	mvn.w	r1, #4026531840	; 0xf0000000
 800cdde:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
}
 800cde2:	bf00      	nop
 800cde4:	370c      	adds	r7, #12
 800cde6:	46bd      	mov	sp, r7
 800cde8:	f85d 7b04 	ldr.w	r7, [sp], #4
 800cdec:	4770      	bx	lr
 800cdee:	bf00      	nop
 800cdf0:	a0000104 	.word	0xa0000104

0800cdf4 <FSMC_NORSRAMStructInit>:
  * @param  FSMC_NORSRAMInitStruct: pointer to a FSMC_NORSRAMInitTypeDef structure 
  *         which will be initialized.
  * @retval None
  */
void FSMC_NORSRAMStructInit(FSMC_NORSRAMInitTypeDef* FSMC_NORSRAMInitStruct)
{  
 800cdf4:	b480      	push	{r7}
 800cdf6:	b083      	sub	sp, #12
 800cdf8:	af00      	add	r7, sp, #0
 800cdfa:	6078      	str	r0, [r7, #4]
  /* Reset NOR/SRAM Init structure parameters values */
  FSMC_NORSRAMInitStruct->FSMC_Bank = FSMC_Bank1_NORSRAM1;
 800cdfc:	687b      	ldr	r3, [r7, #4]
 800cdfe:	2200      	movs	r2, #0
 800ce00:	601a      	str	r2, [r3, #0]
  FSMC_NORSRAMInitStruct->FSMC_DataAddressMux = FSMC_DataAddressMux_Enable;
 800ce02:	687b      	ldr	r3, [r7, #4]
 800ce04:	2202      	movs	r2, #2
 800ce06:	605a      	str	r2, [r3, #4]
  FSMC_NORSRAMInitStruct->FSMC_MemoryType = FSMC_MemoryType_SRAM;
 800ce08:	687b      	ldr	r3, [r7, #4]
 800ce0a:	2200      	movs	r2, #0
 800ce0c:	609a      	str	r2, [r3, #8]
  FSMC_NORSRAMInitStruct->FSMC_MemoryDataWidth = FSMC_MemoryDataWidth_8b;
 800ce0e:	687b      	ldr	r3, [r7, #4]
 800ce10:	2200      	movs	r2, #0
 800ce12:	60da      	str	r2, [r3, #12]
  FSMC_NORSRAMInitStruct->FSMC_BurstAccessMode = FSMC_BurstAccessMode_Disable;
 800ce14:	687b      	ldr	r3, [r7, #4]
 800ce16:	2200      	movs	r2, #0
 800ce18:	611a      	str	r2, [r3, #16]
  FSMC_NORSRAMInitStruct->FSMC_AsynchronousWait = FSMC_AsynchronousWait_Disable;
 800ce1a:	687b      	ldr	r3, [r7, #4]
 800ce1c:	2200      	movs	r2, #0
 800ce1e:	615a      	str	r2, [r3, #20]
  FSMC_NORSRAMInitStruct->FSMC_WaitSignalPolarity = FSMC_WaitSignalPolarity_Low;
 800ce20:	687b      	ldr	r3, [r7, #4]
 800ce22:	2200      	movs	r2, #0
 800ce24:	619a      	str	r2, [r3, #24]
  FSMC_NORSRAMInitStruct->FSMC_WrapMode = FSMC_WrapMode_Disable;
 800ce26:	687b      	ldr	r3, [r7, #4]
 800ce28:	2200      	movs	r2, #0
 800ce2a:	61da      	str	r2, [r3, #28]
  FSMC_NORSRAMInitStruct->FSMC_WaitSignalActive = FSMC_WaitSignalActive_BeforeWaitState;
 800ce2c:	687b      	ldr	r3, [r7, #4]
 800ce2e:	2200      	movs	r2, #0
 800ce30:	621a      	str	r2, [r3, #32]
  FSMC_NORSRAMInitStruct->FSMC_WriteOperation = FSMC_WriteOperation_Enable;
 800ce32:	687b      	ldr	r3, [r7, #4]
 800ce34:	f44f 5280 	mov.w	r2, #4096	; 0x1000
 800ce38:	625a      	str	r2, [r3, #36]	; 0x24
  FSMC_NORSRAMInitStruct->FSMC_WaitSignal = FSMC_WaitSignal_Enable;
 800ce3a:	687b      	ldr	r3, [r7, #4]
 800ce3c:	f44f 5200 	mov.w	r2, #8192	; 0x2000
 800ce40:	629a      	str	r2, [r3, #40]	; 0x28
  FSMC_NORSRAMInitStruct->FSMC_ExtendedMode = FSMC_ExtendedMode_Disable;
 800ce42:	687b      	ldr	r3, [r7, #4]
 800ce44:	2200      	movs	r2, #0
 800ce46:	62da      	str	r2, [r3, #44]	; 0x2c
  FSMC_NORSRAMInitStruct->FSMC_WriteBurst = FSMC_WriteBurst_Disable;
 800ce48:	687b      	ldr	r3, [r7, #4]
 800ce4a:	2200      	movs	r2, #0
 800ce4c:	631a      	str	r2, [r3, #48]	; 0x30
  FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_AddressSetupTime = 0xF;
 800ce4e:	687b      	ldr	r3, [r7, #4]
 800ce50:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 800ce52:	220f      	movs	r2, #15
 800ce54:	601a      	str	r2, [r3, #0]
  FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_AddressHoldTime = 0xF;
 800ce56:	687b      	ldr	r3, [r7, #4]
 800ce58:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 800ce5a:	220f      	movs	r2, #15
 800ce5c:	605a      	str	r2, [r3, #4]
  FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_DataSetupTime = 0xFF;
 800ce5e:	687b      	ldr	r3, [r7, #4]
 800ce60:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 800ce62:	22ff      	movs	r2, #255	; 0xff
 800ce64:	609a      	str	r2, [r3, #8]
  FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_BusTurnAroundDuration = 0xF;
 800ce66:	687b      	ldr	r3, [r7, #4]
 800ce68:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 800ce6a:	220f      	movs	r2, #15
 800ce6c:	60da      	str	r2, [r3, #12]
  FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_CLKDivision = 0xF;
 800ce6e:	687b      	ldr	r3, [r7, #4]
 800ce70:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 800ce72:	220f      	movs	r2, #15
 800ce74:	611a      	str	r2, [r3, #16]
  FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_DataLatency = 0xF;
 800ce76:	687b      	ldr	r3, [r7, #4]
 800ce78:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 800ce7a:	220f      	movs	r2, #15
 800ce7c:	615a      	str	r2, [r3, #20]
  FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_AccessMode = FSMC_AccessMode_A; 
 800ce7e:	687b      	ldr	r3, [r7, #4]
 800ce80:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 800ce82:	2200      	movs	r2, #0
 800ce84:	619a      	str	r2, [r3, #24]
  FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_AddressSetupTime = 0xF;
 800ce86:	687b      	ldr	r3, [r7, #4]
 800ce88:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 800ce8a:	220f      	movs	r2, #15
 800ce8c:	601a      	str	r2, [r3, #0]
  FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_AddressHoldTime = 0xF;
 800ce8e:	687b      	ldr	r3, [r7, #4]
 800ce90:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 800ce92:	220f      	movs	r2, #15
 800ce94:	605a      	str	r2, [r3, #4]
  FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_DataSetupTime = 0xFF;
 800ce96:	687b      	ldr	r3, [r7, #4]
 800ce98:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 800ce9a:	22ff      	movs	r2, #255	; 0xff
 800ce9c:	609a      	str	r2, [r3, #8]
  FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_BusTurnAroundDuration = 0xF;
 800ce9e:	687b      	ldr	r3, [r7, #4]
 800cea0:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 800cea2:	220f      	movs	r2, #15
 800cea4:	60da      	str	r2, [r3, #12]
  FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_CLKDivision = 0xF;
 800cea6:	687b      	ldr	r3, [r7, #4]
 800cea8:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 800ceaa:	220f      	movs	r2, #15
 800ceac:	611a      	str	r2, [r3, #16]
  FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_DataLatency = 0xF;
 800ceae:	687b      	ldr	r3, [r7, #4]
 800ceb0:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 800ceb2:	220f      	movs	r2, #15
 800ceb4:	615a      	str	r2, [r3, #20]
  FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_AccessMode = FSMC_AccessMode_A;
 800ceb6:	687b      	ldr	r3, [r7, #4]
 800ceb8:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 800ceba:	2200      	movs	r2, #0
 800cebc:	619a      	str	r2, [r3, #24]
}
 800cebe:	bf00      	nop
 800cec0:	370c      	adds	r7, #12
 800cec2:	46bd      	mov	sp, r7
 800cec4:	f85d 7b04 	ldr.w	r7, [sp], #4
 800cec8:	4770      	bx	lr

0800ceca <FSMC_NORSRAMCmd>:
  *            @arg FSMC_Bank1_NORSRAM4: FSMC Bank1 NOR/SRAM4 
  * @param  NewState: new state of the FSMC_Bank. This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void FSMC_NORSRAMCmd(uint32_t FSMC_Bank, FunctionalState NewState)
{
 800ceca:	b480      	push	{r7}
 800cecc:	b083      	sub	sp, #12
 800cece:	af00      	add	r7, sp, #0
 800ced0:	6078      	str	r0, [r7, #4]
 800ced2:	460b      	mov	r3, r1
 800ced4:	70fb      	strb	r3, [r7, #3]
  assert_param(IS_FSMC_NORSRAM_BANK(FSMC_Bank));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
 800ced6:	78fb      	ldrb	r3, [r7, #3]
 800ced8:	2b00      	cmp	r3, #0
 800ceda:	d00c      	beq.n	800cef6 <FSMC_NORSRAMCmd+0x2c>
  {
    /* Enable the selected NOR/SRAM Bank by setting the PBKEN bit in the BCRx register */
    FSMC_Bank1->BTCR[FSMC_Bank] |= BCR_MBKEN_SET;
 800cedc:	f04f 4120 	mov.w	r1, #2684354560	; 0xa0000000
 800cee0:	f04f 4220 	mov.w	r2, #2684354560	; 0xa0000000
 800cee4:	687b      	ldr	r3, [r7, #4]
 800cee6:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 800ceea:	f043 0201 	orr.w	r2, r3, #1
 800ceee:	687b      	ldr	r3, [r7, #4]
 800cef0:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
  else
  {
    /* Disable the selected NOR/SRAM Bank by clearing the PBKEN bit in the BCRx register */
    FSMC_Bank1->BTCR[FSMC_Bank] &= BCR_MBKEN_RESET;
  }
}
 800cef4:	e00b      	b.n	800cf0e <FSMC_NORSRAMCmd+0x44>
    FSMC_Bank1->BTCR[FSMC_Bank] &= BCR_MBKEN_RESET;
 800cef6:	f04f 4120 	mov.w	r1, #2684354560	; 0xa0000000
 800cefa:	f04f 4220 	mov.w	r2, #2684354560	; 0xa0000000
 800cefe:	687b      	ldr	r3, [r7, #4]
 800cf00:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
 800cf04:	4b05      	ldr	r3, [pc, #20]	; (800cf1c <FSMC_NORSRAMCmd+0x52>)
 800cf06:	4013      	ands	r3, r2
 800cf08:	687a      	ldr	r2, [r7, #4]
 800cf0a:	f841 3022 	str.w	r3, [r1, r2, lsl #2]
}
 800cf0e:	bf00      	nop
 800cf10:	370c      	adds	r7, #12
 800cf12:	46bd      	mov	sp, r7
 800cf14:	f85d 7b04 	ldr.w	r7, [sp], #4
 800cf18:	4770      	bx	lr
 800cf1a:	bf00      	nop
 800cf1c:	000ffffe 	.word	0x000ffffe

0800cf20 <FSMC_NANDDeInit>:
  *            @arg FSMC_Bank2_NAND: FSMC Bank2 NAND 
  *            @arg FSMC_Bank3_NAND: FSMC Bank3 NAND 
  * @retval None
  */
void FSMC_NANDDeInit(uint32_t FSMC_Bank)
{
 800cf20:	b480      	push	{r7}
 800cf22:	b083      	sub	sp, #12
 800cf24:	af00      	add	r7, sp, #0
 800cf26:	6078      	str	r0, [r7, #4]
  /* Check the parameter */
  assert_param(IS_FSMC_NAND_BANK(FSMC_Bank));
  
  if(FSMC_Bank == FSMC_Bank2_NAND)
 800cf28:	687b      	ldr	r3, [r7, #4]
 800cf2a:	2b10      	cmp	r3, #16
 800cf2c:	d10e      	bne.n	800cf4c <FSMC_NANDDeInit+0x2c>
  {
    /* Set the FSMC_Bank2 registers to their reset values */
    FSMC_Bank2->PCR2 = 0x00000018;
 800cf2e:	4b11      	ldr	r3, [pc, #68]	; (800cf74 <FSMC_NANDDeInit+0x54>)
 800cf30:	2218      	movs	r2, #24
 800cf32:	601a      	str	r2, [r3, #0]
    FSMC_Bank2->SR2 = 0x00000040;
 800cf34:	4b0f      	ldr	r3, [pc, #60]	; (800cf74 <FSMC_NANDDeInit+0x54>)
 800cf36:	2240      	movs	r2, #64	; 0x40
 800cf38:	605a      	str	r2, [r3, #4]
    FSMC_Bank2->PMEM2 = 0xFCFCFCFC;
 800cf3a:	4b0e      	ldr	r3, [pc, #56]	; (800cf74 <FSMC_NANDDeInit+0x54>)
 800cf3c:	f04f 32fc 	mov.w	r2, #4244438268	; 0xfcfcfcfc
 800cf40:	609a      	str	r2, [r3, #8]
    FSMC_Bank2->PATT2 = 0xFCFCFCFC;  
 800cf42:	4b0c      	ldr	r3, [pc, #48]	; (800cf74 <FSMC_NANDDeInit+0x54>)
 800cf44:	f04f 32fc 	mov.w	r2, #4244438268	; 0xfcfcfcfc
 800cf48:	60da      	str	r2, [r3, #12]
    FSMC_Bank3->PCR3 = 0x00000018;
    FSMC_Bank3->SR3 = 0x00000040;
    FSMC_Bank3->PMEM3 = 0xFCFCFCFC;
    FSMC_Bank3->PATT3 = 0xFCFCFCFC; 
  }  
}
 800cf4a:	e00d      	b.n	800cf68 <FSMC_NANDDeInit+0x48>
    FSMC_Bank3->PCR3 = 0x00000018;
 800cf4c:	4b0a      	ldr	r3, [pc, #40]	; (800cf78 <FSMC_NANDDeInit+0x58>)
 800cf4e:	2218      	movs	r2, #24
 800cf50:	601a      	str	r2, [r3, #0]
    FSMC_Bank3->SR3 = 0x00000040;
 800cf52:	4b09      	ldr	r3, [pc, #36]	; (800cf78 <FSMC_NANDDeInit+0x58>)
 800cf54:	2240      	movs	r2, #64	; 0x40
 800cf56:	605a      	str	r2, [r3, #4]
    FSMC_Bank3->PMEM3 = 0xFCFCFCFC;
 800cf58:	4b07      	ldr	r3, [pc, #28]	; (800cf78 <FSMC_NANDDeInit+0x58>)
 800cf5a:	f04f 32fc 	mov.w	r2, #4244438268	; 0xfcfcfcfc
 800cf5e:	609a      	str	r2, [r3, #8]
    FSMC_Bank3->PATT3 = 0xFCFCFCFC; 
 800cf60:	4b05      	ldr	r3, [pc, #20]	; (800cf78 <FSMC_NANDDeInit+0x58>)
 800cf62:	f04f 32fc 	mov.w	r2, #4244438268	; 0xfcfcfcfc
 800cf66:	60da      	str	r2, [r3, #12]
}
 800cf68:	bf00      	nop
 800cf6a:	370c      	adds	r7, #12
 800cf6c:	46bd      	mov	sp, r7
 800cf6e:	f85d 7b04 	ldr.w	r7, [sp], #4
 800cf72:	4770      	bx	lr
 800cf74:	a0000060 	.word	0xa0000060
 800cf78:	a0000080 	.word	0xa0000080

0800cf7c <FSMC_NANDInit>:
  * @param  FSMC_NANDInitStruct : pointer to a FSMC_NANDInitTypeDef structure that
  *         contains the configuration information for the FSMC NAND specified Banks.                       
  * @retval None
  */
void FSMC_NANDInit(FSMC_NANDInitTypeDef* FSMC_NANDInitStruct)
{
 800cf7c:	b480      	push	{r7}
 800cf7e:	b087      	sub	sp, #28
 800cf80:	af00      	add	r7, sp, #0
 800cf82:	6078      	str	r0, [r7, #4]
  uint32_t tmppcr = 0x00000000, tmppmem = 0x00000000, tmppatt = 0x00000000; 
 800cf84:	2300      	movs	r3, #0
 800cf86:	617b      	str	r3, [r7, #20]
 800cf88:	2300      	movs	r3, #0
 800cf8a:	613b      	str	r3, [r7, #16]
 800cf8c:	2300      	movs	r3, #0
 800cf8e:	60fb      	str	r3, [r7, #12]
  assert_param(IS_FSMC_WAIT_TIME(FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_WaitSetupTime));
  assert_param(IS_FSMC_HOLD_TIME(FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HoldSetupTime));
  assert_param(IS_FSMC_HIZ_TIME(FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HiZSetupTime));
  
  /* Set the tmppcr value according to FSMC_NANDInitStruct parameters */
  tmppcr = (uint32_t)FSMC_NANDInitStruct->FSMC_Waitfeature |
 800cf90:	687b      	ldr	r3, [r7, #4]
 800cf92:	685a      	ldr	r2, [r3, #4]
            PCR_MEMORYTYPE_NAND |
            FSMC_NANDInitStruct->FSMC_MemoryDataWidth |
 800cf94:	687b      	ldr	r3, [r7, #4]
 800cf96:	689b      	ldr	r3, [r3, #8]
            PCR_MEMORYTYPE_NAND |
 800cf98:	431a      	orrs	r2, r3
            FSMC_NANDInitStruct->FSMC_ECC |
 800cf9a:	687b      	ldr	r3, [r7, #4]
 800cf9c:	68db      	ldr	r3, [r3, #12]
            FSMC_NANDInitStruct->FSMC_MemoryDataWidth |
 800cf9e:	431a      	orrs	r2, r3
            FSMC_NANDInitStruct->FSMC_ECCPageSize |
 800cfa0:	687b      	ldr	r3, [r7, #4]
 800cfa2:	691b      	ldr	r3, [r3, #16]
            FSMC_NANDInitStruct->FSMC_ECC |
 800cfa4:	431a      	orrs	r2, r3
            (FSMC_NANDInitStruct->FSMC_TCLRSetupTime << 9 )|
 800cfa6:	687b      	ldr	r3, [r7, #4]
 800cfa8:	695b      	ldr	r3, [r3, #20]
 800cfaa:	025b      	lsls	r3, r3, #9
            FSMC_NANDInitStruct->FSMC_ECCPageSize |
 800cfac:	431a      	orrs	r2, r3
            (FSMC_NANDInitStruct->FSMC_TARSetupTime << 13);
 800cfae:	687b      	ldr	r3, [r7, #4]
 800cfb0:	699b      	ldr	r3, [r3, #24]
 800cfb2:	035b      	lsls	r3, r3, #13
            (FSMC_NANDInitStruct->FSMC_TCLRSetupTime << 9 )|
 800cfb4:	4313      	orrs	r3, r2
  tmppcr = (uint32_t)FSMC_NANDInitStruct->FSMC_Waitfeature |
 800cfb6:	f043 0308 	orr.w	r3, r3, #8
 800cfba:	617b      	str	r3, [r7, #20]
            
  /* Set tmppmem value according to FSMC_CommonSpaceTimingStructure parameters */
  tmppmem = (uint32_t)FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_SetupTime |
 800cfbc:	687b      	ldr	r3, [r7, #4]
 800cfbe:	69db      	ldr	r3, [r3, #28]
 800cfc0:	681a      	ldr	r2, [r3, #0]
            (FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_WaitSetupTime << 8) |
 800cfc2:	687b      	ldr	r3, [r7, #4]
 800cfc4:	69db      	ldr	r3, [r3, #28]
 800cfc6:	685b      	ldr	r3, [r3, #4]
 800cfc8:	021b      	lsls	r3, r3, #8
  tmppmem = (uint32_t)FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_SetupTime |
 800cfca:	431a      	orrs	r2, r3
            (FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HoldSetupTime << 16)|
 800cfcc:	687b      	ldr	r3, [r7, #4]
 800cfce:	69db      	ldr	r3, [r3, #28]
 800cfd0:	689b      	ldr	r3, [r3, #8]
 800cfd2:	041b      	lsls	r3, r3, #16
            (FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_WaitSetupTime << 8) |
 800cfd4:	431a      	orrs	r2, r3
            (FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HiZSetupTime << 24); 
 800cfd6:	687b      	ldr	r3, [r7, #4]
 800cfd8:	69db      	ldr	r3, [r3, #28]
 800cfda:	68db      	ldr	r3, [r3, #12]
 800cfdc:	061b      	lsls	r3, r3, #24
  tmppmem = (uint32_t)FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_SetupTime |
 800cfde:	4313      	orrs	r3, r2
 800cfe0:	613b      	str	r3, [r7, #16]
            
  /* Set tmppatt value according to FSMC_AttributeSpaceTimingStructure parameters */
  tmppatt = (uint32_t)FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_SetupTime |
 800cfe2:	687b      	ldr	r3, [r7, #4]
 800cfe4:	6a1b      	ldr	r3, [r3, #32]
 800cfe6:	681a      	ldr	r2, [r3, #0]
            (FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_WaitSetupTime << 8) |
 800cfe8:	687b      	ldr	r3, [r7, #4]
 800cfea:	6a1b      	ldr	r3, [r3, #32]
 800cfec:	685b      	ldr	r3, [r3, #4]
 800cfee:	021b      	lsls	r3, r3, #8
  tmppatt = (uint32_t)FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_SetupTime |
 800cff0:	431a      	orrs	r2, r3
            (FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HoldSetupTime << 16)|
 800cff2:	687b      	ldr	r3, [r7, #4]
 800cff4:	6a1b      	ldr	r3, [r3, #32]
 800cff6:	689b      	ldr	r3, [r3, #8]
 800cff8:	041b      	lsls	r3, r3, #16
            (FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_WaitSetupTime << 8) |
 800cffa:	431a      	orrs	r2, r3
            (FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HiZSetupTime << 24);
 800cffc:	687b      	ldr	r3, [r7, #4]
 800cffe:	6a1b      	ldr	r3, [r3, #32]
 800d000:	68db      	ldr	r3, [r3, #12]
 800d002:	061b      	lsls	r3, r3, #24
  tmppatt = (uint32_t)FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_SetupTime |
 800d004:	4313      	orrs	r3, r2
 800d006:	60fb      	str	r3, [r7, #12]
  
  if(FSMC_NANDInitStruct->FSMC_Bank == FSMC_Bank2_NAND)
 800d008:	687b      	ldr	r3, [r7, #4]
 800d00a:	681b      	ldr	r3, [r3, #0]
 800d00c:	2b10      	cmp	r3, #16
 800d00e:	d109      	bne.n	800d024 <FSMC_NANDInit+0xa8>
  {
    /* FSMC_Bank2_NAND registers configuration */
    FSMC_Bank2->PCR2 = tmppcr;
 800d010:	4a0c      	ldr	r2, [pc, #48]	; (800d044 <FSMC_NANDInit+0xc8>)
 800d012:	697b      	ldr	r3, [r7, #20]
 800d014:	6013      	str	r3, [r2, #0]
    FSMC_Bank2->PMEM2 = tmppmem;
 800d016:	4a0b      	ldr	r2, [pc, #44]	; (800d044 <FSMC_NANDInit+0xc8>)
 800d018:	693b      	ldr	r3, [r7, #16]
 800d01a:	6093      	str	r3, [r2, #8]
    FSMC_Bank2->PATT2 = tmppatt;
 800d01c:	4a09      	ldr	r2, [pc, #36]	; (800d044 <FSMC_NANDInit+0xc8>)
 800d01e:	68fb      	ldr	r3, [r7, #12]
 800d020:	60d3      	str	r3, [r2, #12]
    /* FSMC_Bank3_NAND registers configuration */
    FSMC_Bank3->PCR3 = tmppcr;
    FSMC_Bank3->PMEM3 = tmppmem;
    FSMC_Bank3->PATT3 = tmppatt;
  }
}
 800d022:	e008      	b.n	800d036 <FSMC_NANDInit+0xba>
    FSMC_Bank3->PCR3 = tmppcr;
 800d024:	4a08      	ldr	r2, [pc, #32]	; (800d048 <FSMC_NANDInit+0xcc>)
 800d026:	697b      	ldr	r3, [r7, #20]
 800d028:	6013      	str	r3, [r2, #0]
    FSMC_Bank3->PMEM3 = tmppmem;
 800d02a:	4a07      	ldr	r2, [pc, #28]	; (800d048 <FSMC_NANDInit+0xcc>)
 800d02c:	693b      	ldr	r3, [r7, #16]
 800d02e:	6093      	str	r3, [r2, #8]
    FSMC_Bank3->PATT3 = tmppatt;
 800d030:	4a05      	ldr	r2, [pc, #20]	; (800d048 <FSMC_NANDInit+0xcc>)
 800d032:	68fb      	ldr	r3, [r7, #12]
 800d034:	60d3      	str	r3, [r2, #12]
}
 800d036:	bf00      	nop
 800d038:	371c      	adds	r7, #28
 800d03a:	46bd      	mov	sp, r7
 800d03c:	f85d 7b04 	ldr.w	r7, [sp], #4
 800d040:	4770      	bx	lr
 800d042:	bf00      	nop
 800d044:	a0000060 	.word	0xa0000060
 800d048:	a0000080 	.word	0xa0000080

0800d04c <FSMC_NANDStructInit>:
  * @param  FSMC_NANDInitStruct: pointer to a FSMC_NANDInitTypeDef structure which
  *         will be initialized.
  * @retval None
  */
void FSMC_NANDStructInit(FSMC_NANDInitTypeDef* FSMC_NANDInitStruct)
{ 
 800d04c:	b480      	push	{r7}
 800d04e:	b083      	sub	sp, #12
 800d050:	af00      	add	r7, sp, #0
 800d052:	6078      	str	r0, [r7, #4]
  /* Reset NAND Init structure parameters values */
  FSMC_NANDInitStruct->FSMC_Bank = FSMC_Bank2_NAND;
 800d054:	687b      	ldr	r3, [r7, #4]
 800d056:	2210      	movs	r2, #16
 800d058:	601a      	str	r2, [r3, #0]
  FSMC_NANDInitStruct->FSMC_Waitfeature = FSMC_Waitfeature_Disable;
 800d05a:	687b      	ldr	r3, [r7, #4]
 800d05c:	2200      	movs	r2, #0
 800d05e:	605a      	str	r2, [r3, #4]
  FSMC_NANDInitStruct->FSMC_MemoryDataWidth = FSMC_MemoryDataWidth_8b;
 800d060:	687b      	ldr	r3, [r7, #4]
 800d062:	2200      	movs	r2, #0
 800d064:	609a      	str	r2, [r3, #8]
  FSMC_NANDInitStruct->FSMC_ECC = FSMC_ECC_Disable;
 800d066:	687b      	ldr	r3, [r7, #4]
 800d068:	2200      	movs	r2, #0
 800d06a:	60da      	str	r2, [r3, #12]
  FSMC_NANDInitStruct->FSMC_ECCPageSize = FSMC_ECCPageSize_256Bytes;
 800d06c:	687b      	ldr	r3, [r7, #4]
 800d06e:	2200      	movs	r2, #0
 800d070:	611a      	str	r2, [r3, #16]
  FSMC_NANDInitStruct->FSMC_TCLRSetupTime = 0x0;
 800d072:	687b      	ldr	r3, [r7, #4]
 800d074:	2200      	movs	r2, #0
 800d076:	615a      	str	r2, [r3, #20]
  FSMC_NANDInitStruct->FSMC_TARSetupTime = 0x0;
 800d078:	687b      	ldr	r3, [r7, #4]
 800d07a:	2200      	movs	r2, #0
 800d07c:	619a      	str	r2, [r3, #24]
  FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_SetupTime = 0xFC;
 800d07e:	687b      	ldr	r3, [r7, #4]
 800d080:	69db      	ldr	r3, [r3, #28]
 800d082:	22fc      	movs	r2, #252	; 0xfc
 800d084:	601a      	str	r2, [r3, #0]
  FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_WaitSetupTime = 0xFC;
 800d086:	687b      	ldr	r3, [r7, #4]
 800d088:	69db      	ldr	r3, [r3, #28]
 800d08a:	22fc      	movs	r2, #252	; 0xfc
 800d08c:	605a      	str	r2, [r3, #4]
  FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HoldSetupTime = 0xFC;
 800d08e:	687b      	ldr	r3, [r7, #4]
 800d090:	69db      	ldr	r3, [r3, #28]
 800d092:	22fc      	movs	r2, #252	; 0xfc
 800d094:	609a      	str	r2, [r3, #8]
  FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HiZSetupTime = 0xFC;
 800d096:	687b      	ldr	r3, [r7, #4]
 800d098:	69db      	ldr	r3, [r3, #28]
 800d09a:	22fc      	movs	r2, #252	; 0xfc
 800d09c:	60da      	str	r2, [r3, #12]
  FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_SetupTime = 0xFC;
 800d09e:	687b      	ldr	r3, [r7, #4]
 800d0a0:	6a1b      	ldr	r3, [r3, #32]
 800d0a2:	22fc      	movs	r2, #252	; 0xfc
 800d0a4:	601a      	str	r2, [r3, #0]
  FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_WaitSetupTime = 0xFC;
 800d0a6:	687b      	ldr	r3, [r7, #4]
 800d0a8:	6a1b      	ldr	r3, [r3, #32]
 800d0aa:	22fc      	movs	r2, #252	; 0xfc
 800d0ac:	605a      	str	r2, [r3, #4]
  FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HoldSetupTime = 0xFC;
 800d0ae:	687b      	ldr	r3, [r7, #4]
 800d0b0:	6a1b      	ldr	r3, [r3, #32]
 800d0b2:	22fc      	movs	r2, #252	; 0xfc
 800d0b4:	609a      	str	r2, [r3, #8]
  FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HiZSetupTime = 0xFC;	  
 800d0b6:	687b      	ldr	r3, [r7, #4]
 800d0b8:	6a1b      	ldr	r3, [r3, #32]
 800d0ba:	22fc      	movs	r2, #252	; 0xfc
 800d0bc:	60da      	str	r2, [r3, #12]
}
 800d0be:	bf00      	nop
 800d0c0:	370c      	adds	r7, #12
 800d0c2:	46bd      	mov	sp, r7
 800d0c4:	f85d 7b04 	ldr.w	r7, [sp], #4
 800d0c8:	4770      	bx	lr

0800d0ca <FSMC_NANDCmd>:
  *            @arg FSMC_Bank3_NAND: FSMC Bank3 NAND
  * @param  NewState: new state of the FSMC_Bank. This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void FSMC_NANDCmd(uint32_t FSMC_Bank, FunctionalState NewState)
{
 800d0ca:	b480      	push	{r7}
 800d0cc:	b083      	sub	sp, #12
 800d0ce:	af00      	add	r7, sp, #0
 800d0d0:	6078      	str	r0, [r7, #4]
 800d0d2:	460b      	mov	r3, r1
 800d0d4:	70fb      	strb	r3, [r7, #3]
  assert_param(IS_FSMC_NAND_BANK(FSMC_Bank));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
 800d0d6:	78fb      	ldrb	r3, [r7, #3]
 800d0d8:	2b00      	cmp	r3, #0
 800d0da:	d010      	beq.n	800d0fe <FSMC_NANDCmd+0x34>
  {
    /* Enable the selected NAND Bank by setting the PBKEN bit in the PCRx register */
    if(FSMC_Bank == FSMC_Bank2_NAND)
 800d0dc:	687b      	ldr	r3, [r7, #4]
 800d0de:	2b10      	cmp	r3, #16
 800d0e0:	d106      	bne.n	800d0f0 <FSMC_NANDCmd+0x26>
    {
      FSMC_Bank2->PCR2 |= PCR_PBKEN_SET;
 800d0e2:	4a12      	ldr	r2, [pc, #72]	; (800d12c <FSMC_NANDCmd+0x62>)
 800d0e4:	4b11      	ldr	r3, [pc, #68]	; (800d12c <FSMC_NANDCmd+0x62>)
 800d0e6:	681b      	ldr	r3, [r3, #0]
 800d0e8:	f043 0304 	orr.w	r3, r3, #4
 800d0ec:	6013      	str	r3, [r2, #0]
    else
    {
      FSMC_Bank3->PCR3 &= PCR_PBKEN_RESET;
    }
  }
}
 800d0ee:	e016      	b.n	800d11e <FSMC_NANDCmd+0x54>
      FSMC_Bank3->PCR3 |= PCR_PBKEN_SET;
 800d0f0:	4a0f      	ldr	r2, [pc, #60]	; (800d130 <FSMC_NANDCmd+0x66>)
 800d0f2:	4b0f      	ldr	r3, [pc, #60]	; (800d130 <FSMC_NANDCmd+0x66>)
 800d0f4:	681b      	ldr	r3, [r3, #0]
 800d0f6:	f043 0304 	orr.w	r3, r3, #4
 800d0fa:	6013      	str	r3, [r2, #0]
}
 800d0fc:	e00f      	b.n	800d11e <FSMC_NANDCmd+0x54>
    if(FSMC_Bank == FSMC_Bank2_NAND)
 800d0fe:	687b      	ldr	r3, [r7, #4]
 800d100:	2b10      	cmp	r3, #16
 800d102:	d106      	bne.n	800d112 <FSMC_NANDCmd+0x48>
      FSMC_Bank2->PCR2 &= PCR_PBKEN_RESET;
 800d104:	4909      	ldr	r1, [pc, #36]	; (800d12c <FSMC_NANDCmd+0x62>)
 800d106:	4b09      	ldr	r3, [pc, #36]	; (800d12c <FSMC_NANDCmd+0x62>)
 800d108:	681a      	ldr	r2, [r3, #0]
 800d10a:	4b0a      	ldr	r3, [pc, #40]	; (800d134 <FSMC_NANDCmd+0x6a>)
 800d10c:	4013      	ands	r3, r2
 800d10e:	600b      	str	r3, [r1, #0]
}
 800d110:	e005      	b.n	800d11e <FSMC_NANDCmd+0x54>
      FSMC_Bank3->PCR3 &= PCR_PBKEN_RESET;
 800d112:	4907      	ldr	r1, [pc, #28]	; (800d130 <FSMC_NANDCmd+0x66>)
 800d114:	4b06      	ldr	r3, [pc, #24]	; (800d130 <FSMC_NANDCmd+0x66>)
 800d116:	681a      	ldr	r2, [r3, #0]
 800d118:	4b06      	ldr	r3, [pc, #24]	; (800d134 <FSMC_NANDCmd+0x6a>)
 800d11a:	4013      	ands	r3, r2
 800d11c:	600b      	str	r3, [r1, #0]
}
 800d11e:	bf00      	nop
 800d120:	370c      	adds	r7, #12
 800d122:	46bd      	mov	sp, r7
 800d124:	f85d 7b04 	ldr.w	r7, [sp], #4
 800d128:	4770      	bx	lr
 800d12a:	bf00      	nop
 800d12c:	a0000060 	.word	0xa0000060
 800d130:	a0000080 	.word	0xa0000080
 800d134:	000ffffb 	.word	0x000ffffb

0800d138 <FSMC_NANDECCCmd>:
  * @param  NewState: new state of the FSMC NAND ECC feature.  
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void FSMC_NANDECCCmd(uint32_t FSMC_Bank, FunctionalState NewState)
{
 800d138:	b480      	push	{r7}
 800d13a:	b083      	sub	sp, #12
 800d13c:	af00      	add	r7, sp, #0
 800d13e:	6078      	str	r0, [r7, #4]
 800d140:	460b      	mov	r3, r1
 800d142:	70fb      	strb	r3, [r7, #3]
  assert_param(IS_FSMC_NAND_BANK(FSMC_Bank));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
 800d144:	78fb      	ldrb	r3, [r7, #3]
 800d146:	2b00      	cmp	r3, #0
 800d148:	d010      	beq.n	800d16c <FSMC_NANDECCCmd+0x34>
  {
    /* Enable the selected NAND Bank ECC function by setting the ECCEN bit in the PCRx register */
    if(FSMC_Bank == FSMC_Bank2_NAND)
 800d14a:	687b      	ldr	r3, [r7, #4]
 800d14c:	2b10      	cmp	r3, #16
 800d14e:	d106      	bne.n	800d15e <FSMC_NANDECCCmd+0x26>
    {
      FSMC_Bank2->PCR2 |= PCR_ECCEN_SET;
 800d150:	4a11      	ldr	r2, [pc, #68]	; (800d198 <FSMC_NANDECCCmd+0x60>)
 800d152:	4b11      	ldr	r3, [pc, #68]	; (800d198 <FSMC_NANDECCCmd+0x60>)
 800d154:	681b      	ldr	r3, [r3, #0]
 800d156:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 800d15a:	6013      	str	r3, [r2, #0]
    else
    {
      FSMC_Bank3->PCR3 &= PCR_ECCEN_RESET;
    }
  }
}
 800d15c:	e016      	b.n	800d18c <FSMC_NANDECCCmd+0x54>
      FSMC_Bank3->PCR3 |= PCR_ECCEN_SET;
 800d15e:	4a0f      	ldr	r2, [pc, #60]	; (800d19c <FSMC_NANDECCCmd+0x64>)
 800d160:	4b0e      	ldr	r3, [pc, #56]	; (800d19c <FSMC_NANDECCCmd+0x64>)
 800d162:	681b      	ldr	r3, [r3, #0]
 800d164:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 800d168:	6013      	str	r3, [r2, #0]
}
 800d16a:	e00f      	b.n	800d18c <FSMC_NANDECCCmd+0x54>
    if(FSMC_Bank == FSMC_Bank2_NAND)
 800d16c:	687b      	ldr	r3, [r7, #4]
 800d16e:	2b10      	cmp	r3, #16
 800d170:	d106      	bne.n	800d180 <FSMC_NANDECCCmd+0x48>
      FSMC_Bank2->PCR2 &= PCR_ECCEN_RESET;
 800d172:	4909      	ldr	r1, [pc, #36]	; (800d198 <FSMC_NANDECCCmd+0x60>)
 800d174:	4b08      	ldr	r3, [pc, #32]	; (800d198 <FSMC_NANDECCCmd+0x60>)
 800d176:	681a      	ldr	r2, [r3, #0]
 800d178:	4b09      	ldr	r3, [pc, #36]	; (800d1a0 <FSMC_NANDECCCmd+0x68>)
 800d17a:	4013      	ands	r3, r2
 800d17c:	600b      	str	r3, [r1, #0]
}
 800d17e:	e005      	b.n	800d18c <FSMC_NANDECCCmd+0x54>
      FSMC_Bank3->PCR3 &= PCR_ECCEN_RESET;
 800d180:	4906      	ldr	r1, [pc, #24]	; (800d19c <FSMC_NANDECCCmd+0x64>)
 800d182:	4b06      	ldr	r3, [pc, #24]	; (800d19c <FSMC_NANDECCCmd+0x64>)
 800d184:	681a      	ldr	r2, [r3, #0]
 800d186:	4b06      	ldr	r3, [pc, #24]	; (800d1a0 <FSMC_NANDECCCmd+0x68>)
 800d188:	4013      	ands	r3, r2
 800d18a:	600b      	str	r3, [r1, #0]
}
 800d18c:	bf00      	nop
 800d18e:	370c      	adds	r7, #12
 800d190:	46bd      	mov	sp, r7
 800d192:	f85d 7b04 	ldr.w	r7, [sp], #4
 800d196:	4770      	bx	lr
 800d198:	a0000060 	.word	0xa0000060
 800d19c:	a0000080 	.word	0xa0000080
 800d1a0:	000fffbf 	.word	0x000fffbf

0800d1a4 <FSMC_GetECC>:
  *            @arg FSMC_Bank2_NAND: FSMC Bank2 NAND 
  *            @arg FSMC_Bank3_NAND: FSMC Bank3 NAND
  * @retval The Error Correction Code (ECC) value.
  */
uint32_t FSMC_GetECC(uint32_t FSMC_Bank)
{
 800d1a4:	b480      	push	{r7}
 800d1a6:	b085      	sub	sp, #20
 800d1a8:	af00      	add	r7, sp, #0
 800d1aa:	6078      	str	r0, [r7, #4]
  uint32_t eccval = 0x00000000;
 800d1ac:	2300      	movs	r3, #0
 800d1ae:	60fb      	str	r3, [r7, #12]
  
  if(FSMC_Bank == FSMC_Bank2_NAND)
 800d1b0:	687b      	ldr	r3, [r7, #4]
 800d1b2:	2b10      	cmp	r3, #16
 800d1b4:	d103      	bne.n	800d1be <FSMC_GetECC+0x1a>
  {
    /* Get the ECCR2 register value */
    eccval = FSMC_Bank2->ECCR2;
 800d1b6:	4b07      	ldr	r3, [pc, #28]	; (800d1d4 <FSMC_GetECC+0x30>)
 800d1b8:	695b      	ldr	r3, [r3, #20]
 800d1ba:	60fb      	str	r3, [r7, #12]
 800d1bc:	e002      	b.n	800d1c4 <FSMC_GetECC+0x20>
  }
  else
  {
    /* Get the ECCR3 register value */
    eccval = FSMC_Bank3->ECCR3;
 800d1be:	4b06      	ldr	r3, [pc, #24]	; (800d1d8 <FSMC_GetECC+0x34>)
 800d1c0:	695b      	ldr	r3, [r3, #20]
 800d1c2:	60fb      	str	r3, [r7, #12]
  }
  /* Return the error correction code value */
  return(eccval);
 800d1c4:	68fb      	ldr	r3, [r7, #12]
}
 800d1c6:	4618      	mov	r0, r3
 800d1c8:	3714      	adds	r7, #20
 800d1ca:	46bd      	mov	sp, r7
 800d1cc:	f85d 7b04 	ldr.w	r7, [sp], #4
 800d1d0:	4770      	bx	lr
 800d1d2:	bf00      	nop
 800d1d4:	a0000060 	.word	0xa0000060
 800d1d8:	a0000080 	.word	0xa0000080

0800d1dc <FSMC_PCCARDDeInit>:
  * @brief  Deinitializes the FSMC PCCARD Bank registers to their default reset values.
  * @param  None                       
  * @retval None
  */
void FSMC_PCCARDDeInit(void)
{
 800d1dc:	b480      	push	{r7}
 800d1de:	af00      	add	r7, sp, #0
  /* Set the FSMC_Bank4 registers to their reset values */
  FSMC_Bank4->PCR4 = 0x00000018; 
 800d1e0:	4b0b      	ldr	r3, [pc, #44]	; (800d210 <FSMC_PCCARDDeInit+0x34>)
 800d1e2:	2218      	movs	r2, #24
 800d1e4:	601a      	str	r2, [r3, #0]
  FSMC_Bank4->SR4 = 0x00000000;	
 800d1e6:	4b0a      	ldr	r3, [pc, #40]	; (800d210 <FSMC_PCCARDDeInit+0x34>)
 800d1e8:	2200      	movs	r2, #0
 800d1ea:	605a      	str	r2, [r3, #4]
  FSMC_Bank4->PMEM4 = 0xFCFCFCFC;
 800d1ec:	4b08      	ldr	r3, [pc, #32]	; (800d210 <FSMC_PCCARDDeInit+0x34>)
 800d1ee:	f04f 32fc 	mov.w	r2, #4244438268	; 0xfcfcfcfc
 800d1f2:	609a      	str	r2, [r3, #8]
  FSMC_Bank4->PATT4 = 0xFCFCFCFC;
 800d1f4:	4b06      	ldr	r3, [pc, #24]	; (800d210 <FSMC_PCCARDDeInit+0x34>)
 800d1f6:	f04f 32fc 	mov.w	r2, #4244438268	; 0xfcfcfcfc
 800d1fa:	60da      	str	r2, [r3, #12]
  FSMC_Bank4->PIO4 = 0xFCFCFCFC;
 800d1fc:	4b04      	ldr	r3, [pc, #16]	; (800d210 <FSMC_PCCARDDeInit+0x34>)
 800d1fe:	f04f 32fc 	mov.w	r2, #4244438268	; 0xfcfcfcfc
 800d202:	611a      	str	r2, [r3, #16]
}
 800d204:	bf00      	nop
 800d206:	46bd      	mov	sp, r7
 800d208:	f85d 7b04 	ldr.w	r7, [sp], #4
 800d20c:	4770      	bx	lr
 800d20e:	bf00      	nop
 800d210:	a00000a0 	.word	0xa00000a0

0800d214 <FSMC_PCCARDInit>:
  * @param  FSMC_PCCARDInitStruct : pointer to a FSMC_PCCARDInitTypeDef structure
  *         that contains the configuration information for the FSMC PCCARD Bank.                       
  * @retval None
  */
void FSMC_PCCARDInit(FSMC_PCCARDInitTypeDef* FSMC_PCCARDInitStruct)
{
 800d214:	b480      	push	{r7}
 800d216:	b083      	sub	sp, #12
 800d218:	af00      	add	r7, sp, #0
 800d21a:	6078      	str	r0, [r7, #4]
  assert_param(IS_FSMC_WAIT_TIME(FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_WaitSetupTime));
  assert_param(IS_FSMC_HOLD_TIME(FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_HoldSetupTime));
  assert_param(IS_FSMC_HIZ_TIME(FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_HiZSetupTime));
  
  /* Set the PCR4 register value according to FSMC_PCCARDInitStruct parameters */
  FSMC_Bank4->PCR4 = (uint32_t)FSMC_PCCARDInitStruct->FSMC_Waitfeature |
 800d21c:	4927      	ldr	r1, [pc, #156]	; (800d2bc <FSMC_PCCARDInit+0xa8>)
 800d21e:	687b      	ldr	r3, [r7, #4]
 800d220:	681a      	ldr	r2, [r3, #0]
                     FSMC_MemoryDataWidth_16b |  
                     (FSMC_PCCARDInitStruct->FSMC_TCLRSetupTime << 9) |
 800d222:	687b      	ldr	r3, [r7, #4]
 800d224:	685b      	ldr	r3, [r3, #4]
 800d226:	025b      	lsls	r3, r3, #9
                     FSMC_MemoryDataWidth_16b |  
 800d228:	431a      	orrs	r2, r3
                     (FSMC_PCCARDInitStruct->FSMC_TARSetupTime << 13);
 800d22a:	687b      	ldr	r3, [r7, #4]
 800d22c:	689b      	ldr	r3, [r3, #8]
 800d22e:	035b      	lsls	r3, r3, #13
                     (FSMC_PCCARDInitStruct->FSMC_TCLRSetupTime << 9) |
 800d230:	4313      	orrs	r3, r2
 800d232:	f043 0310 	orr.w	r3, r3, #16
  FSMC_Bank4->PCR4 = (uint32_t)FSMC_PCCARDInitStruct->FSMC_Waitfeature |
 800d236:	600b      	str	r3, [r1, #0]
            
  /* Set PMEM4 register value according to FSMC_CommonSpaceTimingStructure parameters */
  FSMC_Bank4->PMEM4 = (uint32_t)FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_SetupTime |
 800d238:	4920      	ldr	r1, [pc, #128]	; (800d2bc <FSMC_PCCARDInit+0xa8>)
 800d23a:	687b      	ldr	r3, [r7, #4]
 800d23c:	68db      	ldr	r3, [r3, #12]
 800d23e:	681a      	ldr	r2, [r3, #0]
                      (FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_WaitSetupTime << 8) |
 800d240:	687b      	ldr	r3, [r7, #4]
 800d242:	68db      	ldr	r3, [r3, #12]
 800d244:	685b      	ldr	r3, [r3, #4]
 800d246:	021b      	lsls	r3, r3, #8
  FSMC_Bank4->PMEM4 = (uint32_t)FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_SetupTime |
 800d248:	431a      	orrs	r2, r3
                      (FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HoldSetupTime << 16)|
 800d24a:	687b      	ldr	r3, [r7, #4]
 800d24c:	68db      	ldr	r3, [r3, #12]
 800d24e:	689b      	ldr	r3, [r3, #8]
 800d250:	041b      	lsls	r3, r3, #16
                      (FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_WaitSetupTime << 8) |
 800d252:	431a      	orrs	r2, r3
                      (FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HiZSetupTime << 24); 
 800d254:	687b      	ldr	r3, [r7, #4]
 800d256:	68db      	ldr	r3, [r3, #12]
 800d258:	68db      	ldr	r3, [r3, #12]
 800d25a:	061b      	lsls	r3, r3, #24
                      (FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HoldSetupTime << 16)|
 800d25c:	4313      	orrs	r3, r2
  FSMC_Bank4->PMEM4 = (uint32_t)FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_SetupTime |
 800d25e:	608b      	str	r3, [r1, #8]
            
  /* Set PATT4 register value according to FSMC_AttributeSpaceTimingStructure parameters */
  FSMC_Bank4->PATT4 = (uint32_t)FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_SetupTime |
 800d260:	4916      	ldr	r1, [pc, #88]	; (800d2bc <FSMC_PCCARDInit+0xa8>)
 800d262:	687b      	ldr	r3, [r7, #4]
 800d264:	691b      	ldr	r3, [r3, #16]
 800d266:	681a      	ldr	r2, [r3, #0]
                      (FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_WaitSetupTime << 8) |
 800d268:	687b      	ldr	r3, [r7, #4]
 800d26a:	691b      	ldr	r3, [r3, #16]
 800d26c:	685b      	ldr	r3, [r3, #4]
 800d26e:	021b      	lsls	r3, r3, #8
  FSMC_Bank4->PATT4 = (uint32_t)FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_SetupTime |
 800d270:	431a      	orrs	r2, r3
                      (FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HoldSetupTime << 16)|
 800d272:	687b      	ldr	r3, [r7, #4]
 800d274:	691b      	ldr	r3, [r3, #16]
 800d276:	689b      	ldr	r3, [r3, #8]
 800d278:	041b      	lsls	r3, r3, #16
                      (FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_WaitSetupTime << 8) |
 800d27a:	431a      	orrs	r2, r3
                      (FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HiZSetupTime << 24);	
 800d27c:	687b      	ldr	r3, [r7, #4]
 800d27e:	691b      	ldr	r3, [r3, #16]
 800d280:	68db      	ldr	r3, [r3, #12]
 800d282:	061b      	lsls	r3, r3, #24
                      (FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HoldSetupTime << 16)|
 800d284:	4313      	orrs	r3, r2
  FSMC_Bank4->PATT4 = (uint32_t)FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_SetupTime |
 800d286:	60cb      	str	r3, [r1, #12]
            
  /* Set PIO4 register value according to FSMC_IOSpaceTimingStructure parameters */
  FSMC_Bank4->PIO4 = (uint32_t)FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_SetupTime |
 800d288:	490c      	ldr	r1, [pc, #48]	; (800d2bc <FSMC_PCCARDInit+0xa8>)
 800d28a:	687b      	ldr	r3, [r7, #4]
 800d28c:	695b      	ldr	r3, [r3, #20]
 800d28e:	681a      	ldr	r2, [r3, #0]
                     (FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_WaitSetupTime << 8) |
 800d290:	687b      	ldr	r3, [r7, #4]
 800d292:	695b      	ldr	r3, [r3, #20]
 800d294:	685b      	ldr	r3, [r3, #4]
 800d296:	021b      	lsls	r3, r3, #8
  FSMC_Bank4->PIO4 = (uint32_t)FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_SetupTime |
 800d298:	431a      	orrs	r2, r3
                     (FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_HoldSetupTime << 16)|
 800d29a:	687b      	ldr	r3, [r7, #4]
 800d29c:	695b      	ldr	r3, [r3, #20]
 800d29e:	689b      	ldr	r3, [r3, #8]
 800d2a0:	041b      	lsls	r3, r3, #16
                     (FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_WaitSetupTime << 8) |
 800d2a2:	431a      	orrs	r2, r3
                     (FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_HiZSetupTime << 24);             
 800d2a4:	687b      	ldr	r3, [r7, #4]
 800d2a6:	695b      	ldr	r3, [r3, #20]
 800d2a8:	68db      	ldr	r3, [r3, #12]
 800d2aa:	061b      	lsls	r3, r3, #24
                     (FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_HoldSetupTime << 16)|
 800d2ac:	4313      	orrs	r3, r2
  FSMC_Bank4->PIO4 = (uint32_t)FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_SetupTime |
 800d2ae:	610b      	str	r3, [r1, #16]
}
 800d2b0:	bf00      	nop
 800d2b2:	370c      	adds	r7, #12
 800d2b4:	46bd      	mov	sp, r7
 800d2b6:	f85d 7b04 	ldr.w	r7, [sp], #4
 800d2ba:	4770      	bx	lr
 800d2bc:	a00000a0 	.word	0xa00000a0

0800d2c0 <FSMC_PCCARDStructInit>:
  * @param  FSMC_PCCARDInitStruct: pointer to a FSMC_PCCARDInitTypeDef structure
  *         which will be initialized.
  * @retval None
  */
void FSMC_PCCARDStructInit(FSMC_PCCARDInitTypeDef* FSMC_PCCARDInitStruct)
{
 800d2c0:	b480      	push	{r7}
 800d2c2:	b083      	sub	sp, #12
 800d2c4:	af00      	add	r7, sp, #0
 800d2c6:	6078      	str	r0, [r7, #4]
  /* Reset PCCARD Init structure parameters values */
  FSMC_PCCARDInitStruct->FSMC_Waitfeature = FSMC_Waitfeature_Disable;
 800d2c8:	687b      	ldr	r3, [r7, #4]
 800d2ca:	2200      	movs	r2, #0
 800d2cc:	601a      	str	r2, [r3, #0]
  FSMC_PCCARDInitStruct->FSMC_TCLRSetupTime = 0x0;
 800d2ce:	687b      	ldr	r3, [r7, #4]
 800d2d0:	2200      	movs	r2, #0
 800d2d2:	605a      	str	r2, [r3, #4]
  FSMC_PCCARDInitStruct->FSMC_TARSetupTime = 0x0;
 800d2d4:	687b      	ldr	r3, [r7, #4]
 800d2d6:	2200      	movs	r2, #0
 800d2d8:	609a      	str	r2, [r3, #8]
  FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_SetupTime = 0xFC;
 800d2da:	687b      	ldr	r3, [r7, #4]
 800d2dc:	68db      	ldr	r3, [r3, #12]
 800d2de:	22fc      	movs	r2, #252	; 0xfc
 800d2e0:	601a      	str	r2, [r3, #0]
  FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_WaitSetupTime = 0xFC;
 800d2e2:	687b      	ldr	r3, [r7, #4]
 800d2e4:	68db      	ldr	r3, [r3, #12]
 800d2e6:	22fc      	movs	r2, #252	; 0xfc
 800d2e8:	605a      	str	r2, [r3, #4]
  FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HoldSetupTime = 0xFC;
 800d2ea:	687b      	ldr	r3, [r7, #4]
 800d2ec:	68db      	ldr	r3, [r3, #12]
 800d2ee:	22fc      	movs	r2, #252	; 0xfc
 800d2f0:	609a      	str	r2, [r3, #8]
  FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HiZSetupTime = 0xFC;
 800d2f2:	687b      	ldr	r3, [r7, #4]
 800d2f4:	68db      	ldr	r3, [r3, #12]
 800d2f6:	22fc      	movs	r2, #252	; 0xfc
 800d2f8:	60da      	str	r2, [r3, #12]
  FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_SetupTime = 0xFC;
 800d2fa:	687b      	ldr	r3, [r7, #4]
 800d2fc:	691b      	ldr	r3, [r3, #16]
 800d2fe:	22fc      	movs	r2, #252	; 0xfc
 800d300:	601a      	str	r2, [r3, #0]
  FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_WaitSetupTime = 0xFC;
 800d302:	687b      	ldr	r3, [r7, #4]
 800d304:	691b      	ldr	r3, [r3, #16]
 800d306:	22fc      	movs	r2, #252	; 0xfc
 800d308:	605a      	str	r2, [r3, #4]
  FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HoldSetupTime = 0xFC;
 800d30a:	687b      	ldr	r3, [r7, #4]
 800d30c:	691b      	ldr	r3, [r3, #16]
 800d30e:	22fc      	movs	r2, #252	; 0xfc
 800d310:	609a      	str	r2, [r3, #8]
  FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HiZSetupTime = 0xFC;	
 800d312:	687b      	ldr	r3, [r7, #4]
 800d314:	691b      	ldr	r3, [r3, #16]
 800d316:	22fc      	movs	r2, #252	; 0xfc
 800d318:	60da      	str	r2, [r3, #12]
  FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_SetupTime = 0xFC;
 800d31a:	687b      	ldr	r3, [r7, #4]
 800d31c:	695b      	ldr	r3, [r3, #20]
 800d31e:	22fc      	movs	r2, #252	; 0xfc
 800d320:	601a      	str	r2, [r3, #0]
  FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_WaitSetupTime = 0xFC;
 800d322:	687b      	ldr	r3, [r7, #4]
 800d324:	695b      	ldr	r3, [r3, #20]
 800d326:	22fc      	movs	r2, #252	; 0xfc
 800d328:	605a      	str	r2, [r3, #4]
  FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_HoldSetupTime = 0xFC;
 800d32a:	687b      	ldr	r3, [r7, #4]
 800d32c:	695b      	ldr	r3, [r3, #20]
 800d32e:	22fc      	movs	r2, #252	; 0xfc
 800d330:	609a      	str	r2, [r3, #8]
  FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_HiZSetupTime = 0xFC;
 800d332:	687b      	ldr	r3, [r7, #4]
 800d334:	695b      	ldr	r3, [r3, #20]
 800d336:	22fc      	movs	r2, #252	; 0xfc
 800d338:	60da      	str	r2, [r3, #12]
}
 800d33a:	bf00      	nop
 800d33c:	370c      	adds	r7, #12
 800d33e:	46bd      	mov	sp, r7
 800d340:	f85d 7b04 	ldr.w	r7, [sp], #4
 800d344:	4770      	bx	lr

0800d346 <FSMC_PCCARDCmd>:
  * @param  NewState: new state of the PCCARD Memory Bank.  
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void FSMC_PCCARDCmd(FunctionalState NewState)
{
 800d346:	b480      	push	{r7}
 800d348:	b083      	sub	sp, #12
 800d34a:	af00      	add	r7, sp, #0
 800d34c:	4603      	mov	r3, r0
 800d34e:	71fb      	strb	r3, [r7, #7]
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
 800d350:	79fb      	ldrb	r3, [r7, #7]
 800d352:	2b00      	cmp	r3, #0
 800d354:	d006      	beq.n	800d364 <FSMC_PCCARDCmd+0x1e>
  {
    /* Enable the PCCARD Bank by setting the PBKEN bit in the PCR4 register */
    FSMC_Bank4->PCR4 |= PCR_PBKEN_SET;
 800d356:	4a09      	ldr	r2, [pc, #36]	; (800d37c <FSMC_PCCARDCmd+0x36>)
 800d358:	4b08      	ldr	r3, [pc, #32]	; (800d37c <FSMC_PCCARDCmd+0x36>)
 800d35a:	681b      	ldr	r3, [r3, #0]
 800d35c:	f043 0304 	orr.w	r3, r3, #4
 800d360:	6013      	str	r3, [r2, #0]
  else
  {
    /* Disable the PCCARD Bank by clearing the PBKEN bit in the PCR4 register */
    FSMC_Bank4->PCR4 &= PCR_PBKEN_RESET;
  }
}
 800d362:	e005      	b.n	800d370 <FSMC_PCCARDCmd+0x2a>
    FSMC_Bank4->PCR4 &= PCR_PBKEN_RESET;
 800d364:	4905      	ldr	r1, [pc, #20]	; (800d37c <FSMC_PCCARDCmd+0x36>)
 800d366:	4b05      	ldr	r3, [pc, #20]	; (800d37c <FSMC_PCCARDCmd+0x36>)
 800d368:	681a      	ldr	r2, [r3, #0]
 800d36a:	4b05      	ldr	r3, [pc, #20]	; (800d380 <FSMC_PCCARDCmd+0x3a>)
 800d36c:	4013      	ands	r3, r2
 800d36e:	600b      	str	r3, [r1, #0]
}
 800d370:	bf00      	nop
 800d372:	370c      	adds	r7, #12
 800d374:	46bd      	mov	sp, r7
 800d376:	f85d 7b04 	ldr.w	r7, [sp], #4
 800d37a:	4770      	bx	lr
 800d37c:	a00000a0 	.word	0xa00000a0
 800d380:	000ffffb 	.word	0x000ffffb

0800d384 <FSMC_ITConfig>:
  * @param  NewState: new state of the specified FSMC interrupts.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void FSMC_ITConfig(uint32_t FSMC_Bank, uint32_t FSMC_IT, FunctionalState NewState)
{
 800d384:	b480      	push	{r7}
 800d386:	b085      	sub	sp, #20
 800d388:	af00      	add	r7, sp, #0
 800d38a:	60f8      	str	r0, [r7, #12]
 800d38c:	60b9      	str	r1, [r7, #8]
 800d38e:	4613      	mov	r3, r2
 800d390:	71fb      	strb	r3, [r7, #7]
  assert_param(IS_FSMC_IT_BANK(FSMC_Bank));
  assert_param(IS_FSMC_IT(FSMC_IT));	
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
 800d392:	79fb      	ldrb	r3, [r7, #7]
 800d394:	2b00      	cmp	r3, #0
 800d396:	d01b      	beq.n	800d3d0 <FSMC_ITConfig+0x4c>
  {
    /* Enable the selected FSMC_Bank2 interrupts */
    if(FSMC_Bank == FSMC_Bank2_NAND)
 800d398:	68fb      	ldr	r3, [r7, #12]
 800d39a:	2b10      	cmp	r3, #16
 800d39c:	d106      	bne.n	800d3ac <FSMC_ITConfig+0x28>
    {
      FSMC_Bank2->SR2 |= FSMC_IT;
 800d39e:	491e      	ldr	r1, [pc, #120]	; (800d418 <FSMC_ITConfig+0x94>)
 800d3a0:	4b1d      	ldr	r3, [pc, #116]	; (800d418 <FSMC_ITConfig+0x94>)
 800d3a2:	685a      	ldr	r2, [r3, #4]
 800d3a4:	68bb      	ldr	r3, [r7, #8]
 800d3a6:	4313      	orrs	r3, r2
 800d3a8:	604b      	str	r3, [r1, #4]
    else
    {
      FSMC_Bank4->SR4 &= (uint32_t)~FSMC_IT;    
    }
  }
}
 800d3aa:	e02f      	b.n	800d40c <FSMC_ITConfig+0x88>
    else if (FSMC_Bank == FSMC_Bank3_NAND)
 800d3ac:	68fb      	ldr	r3, [r7, #12]
 800d3ae:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 800d3b2:	d106      	bne.n	800d3c2 <FSMC_ITConfig+0x3e>
      FSMC_Bank3->SR3 |= FSMC_IT;
 800d3b4:	4919      	ldr	r1, [pc, #100]	; (800d41c <FSMC_ITConfig+0x98>)
 800d3b6:	4b19      	ldr	r3, [pc, #100]	; (800d41c <FSMC_ITConfig+0x98>)
 800d3b8:	685a      	ldr	r2, [r3, #4]
 800d3ba:	68bb      	ldr	r3, [r7, #8]
 800d3bc:	4313      	orrs	r3, r2
 800d3be:	604b      	str	r3, [r1, #4]
}
 800d3c0:	e024      	b.n	800d40c <FSMC_ITConfig+0x88>
      FSMC_Bank4->SR4 |= FSMC_IT;    
 800d3c2:	4917      	ldr	r1, [pc, #92]	; (800d420 <FSMC_ITConfig+0x9c>)
 800d3c4:	4b16      	ldr	r3, [pc, #88]	; (800d420 <FSMC_ITConfig+0x9c>)
 800d3c6:	685a      	ldr	r2, [r3, #4]
 800d3c8:	68bb      	ldr	r3, [r7, #8]
 800d3ca:	4313      	orrs	r3, r2
 800d3cc:	604b      	str	r3, [r1, #4]
}
 800d3ce:	e01d      	b.n	800d40c <FSMC_ITConfig+0x88>
    if(FSMC_Bank == FSMC_Bank2_NAND)
 800d3d0:	68fb      	ldr	r3, [r7, #12]
 800d3d2:	2b10      	cmp	r3, #16
 800d3d4:	d107      	bne.n	800d3e6 <FSMC_ITConfig+0x62>
      FSMC_Bank2->SR2 &= (uint32_t)~FSMC_IT;
 800d3d6:	4910      	ldr	r1, [pc, #64]	; (800d418 <FSMC_ITConfig+0x94>)
 800d3d8:	4b0f      	ldr	r3, [pc, #60]	; (800d418 <FSMC_ITConfig+0x94>)
 800d3da:	685a      	ldr	r2, [r3, #4]
 800d3dc:	68bb      	ldr	r3, [r7, #8]
 800d3de:	43db      	mvns	r3, r3
 800d3e0:	4013      	ands	r3, r2
 800d3e2:	604b      	str	r3, [r1, #4]
}
 800d3e4:	e012      	b.n	800d40c <FSMC_ITConfig+0x88>
    else if (FSMC_Bank == FSMC_Bank3_NAND)
 800d3e6:	68fb      	ldr	r3, [r7, #12]
 800d3e8:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 800d3ec:	d107      	bne.n	800d3fe <FSMC_ITConfig+0x7a>
      FSMC_Bank3->SR3 &= (uint32_t)~FSMC_IT;
 800d3ee:	490b      	ldr	r1, [pc, #44]	; (800d41c <FSMC_ITConfig+0x98>)
 800d3f0:	4b0a      	ldr	r3, [pc, #40]	; (800d41c <FSMC_ITConfig+0x98>)
 800d3f2:	685a      	ldr	r2, [r3, #4]
 800d3f4:	68bb      	ldr	r3, [r7, #8]
 800d3f6:	43db      	mvns	r3, r3
 800d3f8:	4013      	ands	r3, r2
 800d3fa:	604b      	str	r3, [r1, #4]
}
 800d3fc:	e006      	b.n	800d40c <FSMC_ITConfig+0x88>
      FSMC_Bank4->SR4 &= (uint32_t)~FSMC_IT;    
 800d3fe:	4908      	ldr	r1, [pc, #32]	; (800d420 <FSMC_ITConfig+0x9c>)
 800d400:	4b07      	ldr	r3, [pc, #28]	; (800d420 <FSMC_ITConfig+0x9c>)
 800d402:	685a      	ldr	r2, [r3, #4]
 800d404:	68bb      	ldr	r3, [r7, #8]
 800d406:	43db      	mvns	r3, r3
 800d408:	4013      	ands	r3, r2
 800d40a:	604b      	str	r3, [r1, #4]
}
 800d40c:	bf00      	nop
 800d40e:	3714      	adds	r7, #20
 800d410:	46bd      	mov	sp, r7
 800d412:	f85d 7b04 	ldr.w	r7, [sp], #4
 800d416:	4770      	bx	lr
 800d418:	a0000060 	.word	0xa0000060
 800d41c:	a0000080 	.word	0xa0000080
 800d420:	a00000a0 	.word	0xa00000a0

0800d424 <FSMC_GetFlagStatus>:
  *            @arg FSMC_FLAG_FallingEdge: Falling edge detection Flag.
  *            @arg FSMC_FLAG_FEMPT: Fifo empty Flag. 
  * @retval The new state of FSMC_FLAG (SET or RESET).
  */
FlagStatus FSMC_GetFlagStatus(uint32_t FSMC_Bank, uint32_t FSMC_FLAG)
{
 800d424:	b480      	push	{r7}
 800d426:	b085      	sub	sp, #20
 800d428:	af00      	add	r7, sp, #0
 800d42a:	6078      	str	r0, [r7, #4]
 800d42c:	6039      	str	r1, [r7, #0]
  FlagStatus bitstatus = RESET;
 800d42e:	2300      	movs	r3, #0
 800d430:	73fb      	strb	r3, [r7, #15]
  uint32_t tmpsr = 0x00000000;
 800d432:	2300      	movs	r3, #0
 800d434:	60bb      	str	r3, [r7, #8]
  
  /* Check the parameters */
  assert_param(IS_FSMC_GETFLAG_BANK(FSMC_Bank));
  assert_param(IS_FSMC_GET_FLAG(FSMC_FLAG));
  
  if(FSMC_Bank == FSMC_Bank2_NAND)
 800d436:	687b      	ldr	r3, [r7, #4]
 800d438:	2b10      	cmp	r3, #16
 800d43a:	d103      	bne.n	800d444 <FSMC_GetFlagStatus+0x20>
  {
    tmpsr = FSMC_Bank2->SR2;
 800d43c:	4b0f      	ldr	r3, [pc, #60]	; (800d47c <FSMC_GetFlagStatus+0x58>)
 800d43e:	685b      	ldr	r3, [r3, #4]
 800d440:	60bb      	str	r3, [r7, #8]
 800d442:	e00a      	b.n	800d45a <FSMC_GetFlagStatus+0x36>
  }  
  else if(FSMC_Bank == FSMC_Bank3_NAND)
 800d444:	687b      	ldr	r3, [r7, #4]
 800d446:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 800d44a:	d103      	bne.n	800d454 <FSMC_GetFlagStatus+0x30>
  {
    tmpsr = FSMC_Bank3->SR3;
 800d44c:	4b0c      	ldr	r3, [pc, #48]	; (800d480 <FSMC_GetFlagStatus+0x5c>)
 800d44e:	685b      	ldr	r3, [r3, #4]
 800d450:	60bb      	str	r3, [r7, #8]
 800d452:	e002      	b.n	800d45a <FSMC_GetFlagStatus+0x36>
  }
  /* FSMC_Bank4_PCCARD*/
  else
  {
    tmpsr = FSMC_Bank4->SR4;
 800d454:	4b0b      	ldr	r3, [pc, #44]	; (800d484 <FSMC_GetFlagStatus+0x60>)
 800d456:	685b      	ldr	r3, [r3, #4]
 800d458:	60bb      	str	r3, [r7, #8]
  } 
  
  /* Get the flag status */
  if ((tmpsr & FSMC_FLAG) != (uint16_t)RESET )
 800d45a:	68ba      	ldr	r2, [r7, #8]
 800d45c:	683b      	ldr	r3, [r7, #0]
 800d45e:	4013      	ands	r3, r2
 800d460:	2b00      	cmp	r3, #0
 800d462:	d002      	beq.n	800d46a <FSMC_GetFlagStatus+0x46>
  {
    bitstatus = SET;
 800d464:	2301      	movs	r3, #1
 800d466:	73fb      	strb	r3, [r7, #15]
 800d468:	e001      	b.n	800d46e <FSMC_GetFlagStatus+0x4a>
  }
  else
  {
    bitstatus = RESET;
 800d46a:	2300      	movs	r3, #0
 800d46c:	73fb      	strb	r3, [r7, #15]
  }
  /* Return the flag status */
  return bitstatus;
 800d46e:	7bfb      	ldrb	r3, [r7, #15]
}
 800d470:	4618      	mov	r0, r3
 800d472:	3714      	adds	r7, #20
 800d474:	46bd      	mov	sp, r7
 800d476:	f85d 7b04 	ldr.w	r7, [sp], #4
 800d47a:	4770      	bx	lr
 800d47c:	a0000060 	.word	0xa0000060
 800d480:	a0000080 	.word	0xa0000080
 800d484:	a00000a0 	.word	0xa00000a0

0800d488 <FSMC_ClearFlag>:
  *            @arg FSMC_FLAG_Level: Level detection Flag.
  *            @arg FSMC_FLAG_FallingEdge: Falling edge detection Flag.
  * @retval None
  */
void FSMC_ClearFlag(uint32_t FSMC_Bank, uint32_t FSMC_FLAG)
{
 800d488:	b480      	push	{r7}
 800d48a:	b083      	sub	sp, #12
 800d48c:	af00      	add	r7, sp, #0
 800d48e:	6078      	str	r0, [r7, #4]
 800d490:	6039      	str	r1, [r7, #0]
 /* Check the parameters */
  assert_param(IS_FSMC_GETFLAG_BANK(FSMC_Bank));
  assert_param(IS_FSMC_CLEAR_FLAG(FSMC_FLAG)) ;
    
  if(FSMC_Bank == FSMC_Bank2_NAND)
 800d492:	687b      	ldr	r3, [r7, #4]
 800d494:	2b10      	cmp	r3, #16
 800d496:	d107      	bne.n	800d4a8 <FSMC_ClearFlag+0x20>
  {
    FSMC_Bank2->SR2 &= ~FSMC_FLAG; 
 800d498:	4910      	ldr	r1, [pc, #64]	; (800d4dc <FSMC_ClearFlag+0x54>)
 800d49a:	4b10      	ldr	r3, [pc, #64]	; (800d4dc <FSMC_ClearFlag+0x54>)
 800d49c:	685a      	ldr	r2, [r3, #4]
 800d49e:	683b      	ldr	r3, [r7, #0]
 800d4a0:	43db      	mvns	r3, r3
 800d4a2:	4013      	ands	r3, r2
 800d4a4:	604b      	str	r3, [r1, #4]
  /* FSMC_Bank4_PCCARD*/
  else
  {
    FSMC_Bank4->SR4 &= ~FSMC_FLAG;
  }
}
 800d4a6:	e012      	b.n	800d4ce <FSMC_ClearFlag+0x46>
  else if(FSMC_Bank == FSMC_Bank3_NAND)
 800d4a8:	687b      	ldr	r3, [r7, #4]
 800d4aa:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 800d4ae:	d107      	bne.n	800d4c0 <FSMC_ClearFlag+0x38>
    FSMC_Bank3->SR3 &= ~FSMC_FLAG;
 800d4b0:	490b      	ldr	r1, [pc, #44]	; (800d4e0 <FSMC_ClearFlag+0x58>)
 800d4b2:	4b0b      	ldr	r3, [pc, #44]	; (800d4e0 <FSMC_ClearFlag+0x58>)
 800d4b4:	685a      	ldr	r2, [r3, #4]
 800d4b6:	683b      	ldr	r3, [r7, #0]
 800d4b8:	43db      	mvns	r3, r3
 800d4ba:	4013      	ands	r3, r2
 800d4bc:	604b      	str	r3, [r1, #4]
}
 800d4be:	e006      	b.n	800d4ce <FSMC_ClearFlag+0x46>
    FSMC_Bank4->SR4 &= ~FSMC_FLAG;
 800d4c0:	4908      	ldr	r1, [pc, #32]	; (800d4e4 <FSMC_ClearFlag+0x5c>)
 800d4c2:	4b08      	ldr	r3, [pc, #32]	; (800d4e4 <FSMC_ClearFlag+0x5c>)
 800d4c4:	685a      	ldr	r2, [r3, #4]
 800d4c6:	683b      	ldr	r3, [r7, #0]
 800d4c8:	43db      	mvns	r3, r3
 800d4ca:	4013      	ands	r3, r2
 800d4cc:	604b      	str	r3, [r1, #4]
}
 800d4ce:	bf00      	nop
 800d4d0:	370c      	adds	r7, #12
 800d4d2:	46bd      	mov	sp, r7
 800d4d4:	f85d 7b04 	ldr.w	r7, [sp], #4
 800d4d8:	4770      	bx	lr
 800d4da:	bf00      	nop
 800d4dc:	a0000060 	.word	0xa0000060
 800d4e0:	a0000080 	.word	0xa0000080
 800d4e4:	a00000a0 	.word	0xa00000a0

0800d4e8 <FSMC_GetITStatus>:
  *            @arg FSMC_IT_Level: Level edge detection interrupt.
  *            @arg FSMC_IT_FallingEdge: Falling edge detection interrupt. 
  * @retval The new state of FSMC_IT (SET or RESET).
  */
ITStatus FSMC_GetITStatus(uint32_t FSMC_Bank, uint32_t FSMC_IT)
{
 800d4e8:	b480      	push	{r7}
 800d4ea:	b087      	sub	sp, #28
 800d4ec:	af00      	add	r7, sp, #0
 800d4ee:	6078      	str	r0, [r7, #4]
 800d4f0:	6039      	str	r1, [r7, #0]
  ITStatus bitstatus = RESET;
 800d4f2:	2300      	movs	r3, #0
 800d4f4:	75fb      	strb	r3, [r7, #23]
  uint32_t tmpsr = 0x0, itstatus = 0x0, itenable = 0x0; 
 800d4f6:	2300      	movs	r3, #0
 800d4f8:	613b      	str	r3, [r7, #16]
 800d4fa:	2300      	movs	r3, #0
 800d4fc:	60fb      	str	r3, [r7, #12]
 800d4fe:	2300      	movs	r3, #0
 800d500:	60bb      	str	r3, [r7, #8]
  
  /* Check the parameters */
  assert_param(IS_FSMC_IT_BANK(FSMC_Bank));
  assert_param(IS_FSMC_GET_IT(FSMC_IT));
  
  if(FSMC_Bank == FSMC_Bank2_NAND)
 800d502:	687b      	ldr	r3, [r7, #4]
 800d504:	2b10      	cmp	r3, #16
 800d506:	d103      	bne.n	800d510 <FSMC_GetITStatus+0x28>
  {
    tmpsr = FSMC_Bank2->SR2;
 800d508:	4b14      	ldr	r3, [pc, #80]	; (800d55c <FSMC_GetITStatus+0x74>)
 800d50a:	685b      	ldr	r3, [r3, #4]
 800d50c:	613b      	str	r3, [r7, #16]
 800d50e:	e00a      	b.n	800d526 <FSMC_GetITStatus+0x3e>
  }  
  else if(FSMC_Bank == FSMC_Bank3_NAND)
 800d510:	687b      	ldr	r3, [r7, #4]
 800d512:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 800d516:	d103      	bne.n	800d520 <FSMC_GetITStatus+0x38>
  {
    tmpsr = FSMC_Bank3->SR3;
 800d518:	4b11      	ldr	r3, [pc, #68]	; (800d560 <FSMC_GetITStatus+0x78>)
 800d51a:	685b      	ldr	r3, [r3, #4]
 800d51c:	613b      	str	r3, [r7, #16]
 800d51e:	e002      	b.n	800d526 <FSMC_GetITStatus+0x3e>
  }
  /* FSMC_Bank4_PCCARD*/
  else
  {
    tmpsr = FSMC_Bank4->SR4;
 800d520:	4b10      	ldr	r3, [pc, #64]	; (800d564 <FSMC_GetITStatus+0x7c>)
 800d522:	685b      	ldr	r3, [r3, #4]
 800d524:	613b      	str	r3, [r7, #16]
  } 
  
  itstatus = tmpsr & FSMC_IT;
 800d526:	693a      	ldr	r2, [r7, #16]
 800d528:	683b      	ldr	r3, [r7, #0]
 800d52a:	4013      	ands	r3, r2
 800d52c:	60fb      	str	r3, [r7, #12]
  
  itenable = tmpsr & (FSMC_IT >> 3);
 800d52e:	683b      	ldr	r3, [r7, #0]
 800d530:	08da      	lsrs	r2, r3, #3
 800d532:	693b      	ldr	r3, [r7, #16]
 800d534:	4013      	ands	r3, r2
 800d536:	60bb      	str	r3, [r7, #8]
  if ((itstatus != (uint32_t)RESET)  && (itenable != (uint32_t)RESET))
 800d538:	68fb      	ldr	r3, [r7, #12]
 800d53a:	2b00      	cmp	r3, #0
 800d53c:	d005      	beq.n	800d54a <FSMC_GetITStatus+0x62>
 800d53e:	68bb      	ldr	r3, [r7, #8]
 800d540:	2b00      	cmp	r3, #0
 800d542:	d002      	beq.n	800d54a <FSMC_GetITStatus+0x62>
  {
    bitstatus = SET;
 800d544:	2301      	movs	r3, #1
 800d546:	75fb      	strb	r3, [r7, #23]
 800d548:	e001      	b.n	800d54e <FSMC_GetITStatus+0x66>
  }
  else
  {
    bitstatus = RESET;
 800d54a:	2300      	movs	r3, #0
 800d54c:	75fb      	strb	r3, [r7, #23]
  }
  return bitstatus; 
 800d54e:	7dfb      	ldrb	r3, [r7, #23]
}
 800d550:	4618      	mov	r0, r3
 800d552:	371c      	adds	r7, #28
 800d554:	46bd      	mov	sp, r7
 800d556:	f85d 7b04 	ldr.w	r7, [sp], #4
 800d55a:	4770      	bx	lr
 800d55c:	a0000060 	.word	0xa0000060
 800d560:	a0000080 	.word	0xa0000080
 800d564:	a00000a0 	.word	0xa00000a0

0800d568 <FSMC_ClearITPendingBit>:
  *            @arg FSMC_IT_Level: Level edge detection interrupt.
  *            @arg FSMC_IT_FallingEdge: Falling edge detection interrupt.
  * @retval None
  */
void FSMC_ClearITPendingBit(uint32_t FSMC_Bank, uint32_t FSMC_IT)
{
 800d568:	b480      	push	{r7}
 800d56a:	b083      	sub	sp, #12
 800d56c:	af00      	add	r7, sp, #0
 800d56e:	6078      	str	r0, [r7, #4]
 800d570:	6039      	str	r1, [r7, #0]
  /* Check the parameters */
  assert_param(IS_FSMC_IT_BANK(FSMC_Bank));
  assert_param(IS_FSMC_IT(FSMC_IT));
    
  if(FSMC_Bank == FSMC_Bank2_NAND)
 800d572:	687b      	ldr	r3, [r7, #4]
 800d574:	2b10      	cmp	r3, #16
 800d576:	d108      	bne.n	800d58a <FSMC_ClearITPendingBit+0x22>
  {
    FSMC_Bank2->SR2 &= ~(FSMC_IT >> 3); 
 800d578:	4911      	ldr	r1, [pc, #68]	; (800d5c0 <FSMC_ClearITPendingBit+0x58>)
 800d57a:	4b11      	ldr	r3, [pc, #68]	; (800d5c0 <FSMC_ClearITPendingBit+0x58>)
 800d57c:	685a      	ldr	r2, [r3, #4]
 800d57e:	683b      	ldr	r3, [r7, #0]
 800d580:	08db      	lsrs	r3, r3, #3
 800d582:	43db      	mvns	r3, r3
 800d584:	4013      	ands	r3, r2
 800d586:	604b      	str	r3, [r1, #4]
  /* FSMC_Bank4_PCCARD*/
  else
  {
    FSMC_Bank4->SR4 &= ~(FSMC_IT >> 3);
  }
}
 800d588:	e014      	b.n	800d5b4 <FSMC_ClearITPendingBit+0x4c>
  else if(FSMC_Bank == FSMC_Bank3_NAND)
 800d58a:	687b      	ldr	r3, [r7, #4]
 800d58c:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 800d590:	d108      	bne.n	800d5a4 <FSMC_ClearITPendingBit+0x3c>
    FSMC_Bank3->SR3 &= ~(FSMC_IT >> 3);
 800d592:	490c      	ldr	r1, [pc, #48]	; (800d5c4 <FSMC_ClearITPendingBit+0x5c>)
 800d594:	4b0b      	ldr	r3, [pc, #44]	; (800d5c4 <FSMC_ClearITPendingBit+0x5c>)
 800d596:	685a      	ldr	r2, [r3, #4]
 800d598:	683b      	ldr	r3, [r7, #0]
 800d59a:	08db      	lsrs	r3, r3, #3
 800d59c:	43db      	mvns	r3, r3
 800d59e:	4013      	ands	r3, r2
 800d5a0:	604b      	str	r3, [r1, #4]
}
 800d5a2:	e007      	b.n	800d5b4 <FSMC_ClearITPendingBit+0x4c>
    FSMC_Bank4->SR4 &= ~(FSMC_IT >> 3);
 800d5a4:	4908      	ldr	r1, [pc, #32]	; (800d5c8 <FSMC_ClearITPendingBit+0x60>)
 800d5a6:	4b08      	ldr	r3, [pc, #32]	; (800d5c8 <FSMC_ClearITPendingBit+0x60>)
 800d5a8:	685a      	ldr	r2, [r3, #4]
 800d5aa:	683b      	ldr	r3, [r7, #0]
 800d5ac:	08db      	lsrs	r3, r3, #3
 800d5ae:	43db      	mvns	r3, r3
 800d5b0:	4013      	ands	r3, r2
 800d5b2:	604b      	str	r3, [r1, #4]
}
 800d5b4:	bf00      	nop
 800d5b6:	370c      	adds	r7, #12
 800d5b8:	46bd      	mov	sp, r7
 800d5ba:	f85d 7b04 	ldr.w	r7, [sp], #4
 800d5be:	4770      	bx	lr
 800d5c0:	a0000060 	.word	0xa0000060
 800d5c4:	a0000080 	.word	0xa0000080
 800d5c8:	a00000a0 	.word	0xa00000a0

0800d5cc <GPIO_DeInit>:
  * @note   By default, The GPIO pins are configured in input floating mode (except JTAG pins).
  * @param  GPIOx: where x can be (A..I) to select the GPIO peripheral.
  * @retval None
  */
void GPIO_DeInit(GPIO_TypeDef* GPIOx)
{
 800d5cc:	b580      	push	{r7, lr}
 800d5ce:	b082      	sub	sp, #8
 800d5d0:	af00      	add	r7, sp, #0
 800d5d2:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));

  if (GPIOx == GPIOA)
 800d5d4:	687b      	ldr	r3, [r7, #4]
 800d5d6:	4a3c      	ldr	r2, [pc, #240]	; (800d6c8 <GPIO_DeInit+0xfc>)
 800d5d8:	4293      	cmp	r3, r2
 800d5da:	d108      	bne.n	800d5ee <GPIO_DeInit+0x22>
  {
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOA, ENABLE);
 800d5dc:	2101      	movs	r1, #1
 800d5de:	2001      	movs	r0, #1
 800d5e0:	f002 f938 	bl	800f854 <RCC_AHB1PeriphResetCmd>
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOA, DISABLE);
 800d5e4:	2100      	movs	r1, #0
 800d5e6:	2001      	movs	r0, #1
 800d5e8:	f002 f934 	bl	800f854 <RCC_AHB1PeriphResetCmd>
    {
      RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOI, ENABLE);
      RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOI, DISABLE);
    }
  }
}
 800d5ec:	e068      	b.n	800d6c0 <GPIO_DeInit+0xf4>
  else if (GPIOx == GPIOB)
 800d5ee:	687b      	ldr	r3, [r7, #4]
 800d5f0:	4a36      	ldr	r2, [pc, #216]	; (800d6cc <GPIO_DeInit+0x100>)
 800d5f2:	4293      	cmp	r3, r2
 800d5f4:	d108      	bne.n	800d608 <GPIO_DeInit+0x3c>
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOB, ENABLE);
 800d5f6:	2101      	movs	r1, #1
 800d5f8:	2002      	movs	r0, #2
 800d5fa:	f002 f92b 	bl	800f854 <RCC_AHB1PeriphResetCmd>
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOB, DISABLE);
 800d5fe:	2100      	movs	r1, #0
 800d600:	2002      	movs	r0, #2
 800d602:	f002 f927 	bl	800f854 <RCC_AHB1PeriphResetCmd>
}
 800d606:	e05b      	b.n	800d6c0 <GPIO_DeInit+0xf4>
  else if (GPIOx == GPIOC)
 800d608:	687b      	ldr	r3, [r7, #4]
 800d60a:	4a31      	ldr	r2, [pc, #196]	; (800d6d0 <GPIO_DeInit+0x104>)
 800d60c:	4293      	cmp	r3, r2
 800d60e:	d108      	bne.n	800d622 <GPIO_DeInit+0x56>
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOC, ENABLE);
 800d610:	2101      	movs	r1, #1
 800d612:	2004      	movs	r0, #4
 800d614:	f002 f91e 	bl	800f854 <RCC_AHB1PeriphResetCmd>
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOC, DISABLE);
 800d618:	2100      	movs	r1, #0
 800d61a:	2004      	movs	r0, #4
 800d61c:	f002 f91a 	bl	800f854 <RCC_AHB1PeriphResetCmd>
}
 800d620:	e04e      	b.n	800d6c0 <GPIO_DeInit+0xf4>
  else if (GPIOx == GPIOD)
 800d622:	687b      	ldr	r3, [r7, #4]
 800d624:	4a2b      	ldr	r2, [pc, #172]	; (800d6d4 <GPIO_DeInit+0x108>)
 800d626:	4293      	cmp	r3, r2
 800d628:	d108      	bne.n	800d63c <GPIO_DeInit+0x70>
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOD, ENABLE);
 800d62a:	2101      	movs	r1, #1
 800d62c:	2008      	movs	r0, #8
 800d62e:	f002 f911 	bl	800f854 <RCC_AHB1PeriphResetCmd>
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOD, DISABLE);
 800d632:	2100      	movs	r1, #0
 800d634:	2008      	movs	r0, #8
 800d636:	f002 f90d 	bl	800f854 <RCC_AHB1PeriphResetCmd>
}
 800d63a:	e041      	b.n	800d6c0 <GPIO_DeInit+0xf4>
  else if (GPIOx == GPIOE)
 800d63c:	687b      	ldr	r3, [r7, #4]
 800d63e:	4a26      	ldr	r2, [pc, #152]	; (800d6d8 <GPIO_DeInit+0x10c>)
 800d640:	4293      	cmp	r3, r2
 800d642:	d108      	bne.n	800d656 <GPIO_DeInit+0x8a>
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOE, ENABLE);
 800d644:	2101      	movs	r1, #1
 800d646:	2010      	movs	r0, #16
 800d648:	f002 f904 	bl	800f854 <RCC_AHB1PeriphResetCmd>
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOE, DISABLE);
 800d64c:	2100      	movs	r1, #0
 800d64e:	2010      	movs	r0, #16
 800d650:	f002 f900 	bl	800f854 <RCC_AHB1PeriphResetCmd>
}
 800d654:	e034      	b.n	800d6c0 <GPIO_DeInit+0xf4>
  else if (GPIOx == GPIOF)
 800d656:	687b      	ldr	r3, [r7, #4]
 800d658:	4a20      	ldr	r2, [pc, #128]	; (800d6dc <GPIO_DeInit+0x110>)
 800d65a:	4293      	cmp	r3, r2
 800d65c:	d108      	bne.n	800d670 <GPIO_DeInit+0xa4>
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOF, ENABLE);
 800d65e:	2101      	movs	r1, #1
 800d660:	2020      	movs	r0, #32
 800d662:	f002 f8f7 	bl	800f854 <RCC_AHB1PeriphResetCmd>
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOF, DISABLE);
 800d666:	2100      	movs	r1, #0
 800d668:	2020      	movs	r0, #32
 800d66a:	f002 f8f3 	bl	800f854 <RCC_AHB1PeriphResetCmd>
}
 800d66e:	e027      	b.n	800d6c0 <GPIO_DeInit+0xf4>
  else if (GPIOx == GPIOG)
 800d670:	687b      	ldr	r3, [r7, #4]
 800d672:	4a1b      	ldr	r2, [pc, #108]	; (800d6e0 <GPIO_DeInit+0x114>)
 800d674:	4293      	cmp	r3, r2
 800d676:	d108      	bne.n	800d68a <GPIO_DeInit+0xbe>
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOG, ENABLE);
 800d678:	2101      	movs	r1, #1
 800d67a:	2040      	movs	r0, #64	; 0x40
 800d67c:	f002 f8ea 	bl	800f854 <RCC_AHB1PeriphResetCmd>
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOG, DISABLE);
 800d680:	2100      	movs	r1, #0
 800d682:	2040      	movs	r0, #64	; 0x40
 800d684:	f002 f8e6 	bl	800f854 <RCC_AHB1PeriphResetCmd>
}
 800d688:	e01a      	b.n	800d6c0 <GPIO_DeInit+0xf4>
  else if (GPIOx == GPIOH)
 800d68a:	687b      	ldr	r3, [r7, #4]
 800d68c:	4a15      	ldr	r2, [pc, #84]	; (800d6e4 <GPIO_DeInit+0x118>)
 800d68e:	4293      	cmp	r3, r2
 800d690:	d108      	bne.n	800d6a4 <GPIO_DeInit+0xd8>
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOH, ENABLE);
 800d692:	2101      	movs	r1, #1
 800d694:	2080      	movs	r0, #128	; 0x80
 800d696:	f002 f8dd 	bl	800f854 <RCC_AHB1PeriphResetCmd>
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOH, DISABLE);
 800d69a:	2100      	movs	r1, #0
 800d69c:	2080      	movs	r0, #128	; 0x80
 800d69e:	f002 f8d9 	bl	800f854 <RCC_AHB1PeriphResetCmd>
}
 800d6a2:	e00d      	b.n	800d6c0 <GPIO_DeInit+0xf4>
    if (GPIOx == GPIOI)
 800d6a4:	687b      	ldr	r3, [r7, #4]
 800d6a6:	4a10      	ldr	r2, [pc, #64]	; (800d6e8 <GPIO_DeInit+0x11c>)
 800d6a8:	4293      	cmp	r3, r2
 800d6aa:	d109      	bne.n	800d6c0 <GPIO_DeInit+0xf4>
      RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOI, ENABLE);
 800d6ac:	2101      	movs	r1, #1
 800d6ae:	f44f 7080 	mov.w	r0, #256	; 0x100
 800d6b2:	f002 f8cf 	bl	800f854 <RCC_AHB1PeriphResetCmd>
      RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOI, DISABLE);
 800d6b6:	2100      	movs	r1, #0
 800d6b8:	f44f 7080 	mov.w	r0, #256	; 0x100
 800d6bc:	f002 f8ca 	bl	800f854 <RCC_AHB1PeriphResetCmd>
}
 800d6c0:	bf00      	nop
 800d6c2:	3708      	adds	r7, #8
 800d6c4:	46bd      	mov	sp, r7
 800d6c6:	bd80      	pop	{r7, pc}
 800d6c8:	40020000 	.word	0x40020000
 800d6cc:	40020400 	.word	0x40020400
 800d6d0:	40020800 	.word	0x40020800
 800d6d4:	40020c00 	.word	0x40020c00
 800d6d8:	40021000 	.word	0x40021000
 800d6dc:	40021400 	.word	0x40021400
 800d6e0:	40021800 	.word	0x40021800
 800d6e4:	40021c00 	.word	0x40021c00
 800d6e8:	40022000 	.word	0x40022000

0800d6ec <GPIO_Init>:
  * @param  GPIO_InitStruct: pointer to a GPIO_InitTypeDef structure that contains
  *         the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void GPIO_Init(GPIO_TypeDef* GPIOx, GPIO_InitTypeDef* GPIO_InitStruct)
{
 800d6ec:	b480      	push	{r7}
 800d6ee:	b087      	sub	sp, #28
 800d6f0:	af00      	add	r7, sp, #0
 800d6f2:	6078      	str	r0, [r7, #4]
 800d6f4:	6039      	str	r1, [r7, #0]
  uint32_t pinpos = 0x00, pos = 0x00 , currentpin = 0x00;
 800d6f6:	2300      	movs	r3, #0
 800d6f8:	617b      	str	r3, [r7, #20]
 800d6fa:	2300      	movs	r3, #0
 800d6fc:	613b      	str	r3, [r7, #16]
 800d6fe:	2300      	movs	r3, #0
 800d700:	60fb      	str	r3, [r7, #12]
  assert_param(IS_GPIO_MODE(GPIO_InitStruct->GPIO_Mode));
  assert_param(IS_GPIO_PUPD(GPIO_InitStruct->GPIO_PuPd));

  /* -------------------------Configure the port pins---------------- */
  /*-- GPIO Mode Configuration --*/
  for (pinpos = 0x00; pinpos < 0x10; pinpos++)
 800d702:	2300      	movs	r3, #0
 800d704:	617b      	str	r3, [r7, #20]
 800d706:	e076      	b.n	800d7f6 <GPIO_Init+0x10a>
  {
    pos = ((uint32_t)0x01) << pinpos;
 800d708:	2201      	movs	r2, #1
 800d70a:	697b      	ldr	r3, [r7, #20]
 800d70c:	fa02 f303 	lsl.w	r3, r2, r3
 800d710:	613b      	str	r3, [r7, #16]
    /* Get the port pins position */
    currentpin = (GPIO_InitStruct->GPIO_Pin) & pos;
 800d712:	683b      	ldr	r3, [r7, #0]
 800d714:	681a      	ldr	r2, [r3, #0]
 800d716:	693b      	ldr	r3, [r7, #16]
 800d718:	4013      	ands	r3, r2
 800d71a:	60fb      	str	r3, [r7, #12]

    if (currentpin == pos)
 800d71c:	68fa      	ldr	r2, [r7, #12]
 800d71e:	693b      	ldr	r3, [r7, #16]
 800d720:	429a      	cmp	r2, r3
 800d722:	d165      	bne.n	800d7f0 <GPIO_Init+0x104>
    {
      GPIOx->MODER  &= ~(GPIO_MODER_MODER0 << (pinpos * 2));
 800d724:	687b      	ldr	r3, [r7, #4]
 800d726:	681a      	ldr	r2, [r3, #0]
 800d728:	697b      	ldr	r3, [r7, #20]
 800d72a:	005b      	lsls	r3, r3, #1
 800d72c:	2103      	movs	r1, #3
 800d72e:	fa01 f303 	lsl.w	r3, r1, r3
 800d732:	43db      	mvns	r3, r3
 800d734:	401a      	ands	r2, r3
 800d736:	687b      	ldr	r3, [r7, #4]
 800d738:	601a      	str	r2, [r3, #0]
      GPIOx->MODER |= (((uint32_t)GPIO_InitStruct->GPIO_Mode) << (pinpos * 2));
 800d73a:	687b      	ldr	r3, [r7, #4]
 800d73c:	681a      	ldr	r2, [r3, #0]
 800d73e:	683b      	ldr	r3, [r7, #0]
 800d740:	791b      	ldrb	r3, [r3, #4]
 800d742:	4619      	mov	r1, r3
 800d744:	697b      	ldr	r3, [r7, #20]
 800d746:	005b      	lsls	r3, r3, #1
 800d748:	fa01 f303 	lsl.w	r3, r1, r3
 800d74c:	431a      	orrs	r2, r3
 800d74e:	687b      	ldr	r3, [r7, #4]
 800d750:	601a      	str	r2, [r3, #0]

      if ((GPIO_InitStruct->GPIO_Mode == GPIO_Mode_OUT) || (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_AF))
 800d752:	683b      	ldr	r3, [r7, #0]
 800d754:	791b      	ldrb	r3, [r3, #4]
 800d756:	2b01      	cmp	r3, #1
 800d758:	d003      	beq.n	800d762 <GPIO_Init+0x76>
 800d75a:	683b      	ldr	r3, [r7, #0]
 800d75c:	791b      	ldrb	r3, [r3, #4]
 800d75e:	2b02      	cmp	r3, #2
 800d760:	d12e      	bne.n	800d7c0 <GPIO_Init+0xd4>
      {
        /* Check Speed mode parameters */
        assert_param(IS_GPIO_SPEED(GPIO_InitStruct->GPIO_Speed));

        /* Speed mode configuration */
        GPIOx->OSPEEDR &= ~(GPIO_OSPEEDER_OSPEEDR0 << (pinpos * 2));
 800d762:	687b      	ldr	r3, [r7, #4]
 800d764:	689a      	ldr	r2, [r3, #8]
 800d766:	697b      	ldr	r3, [r7, #20]
 800d768:	005b      	lsls	r3, r3, #1
 800d76a:	2103      	movs	r1, #3
 800d76c:	fa01 f303 	lsl.w	r3, r1, r3
 800d770:	43db      	mvns	r3, r3
 800d772:	401a      	ands	r2, r3
 800d774:	687b      	ldr	r3, [r7, #4]
 800d776:	609a      	str	r2, [r3, #8]
        GPIOx->OSPEEDR |= ((uint32_t)(GPIO_InitStruct->GPIO_Speed) << (pinpos * 2));
 800d778:	687b      	ldr	r3, [r7, #4]
 800d77a:	689a      	ldr	r2, [r3, #8]
 800d77c:	683b      	ldr	r3, [r7, #0]
 800d77e:	795b      	ldrb	r3, [r3, #5]
 800d780:	4619      	mov	r1, r3
 800d782:	697b      	ldr	r3, [r7, #20]
 800d784:	005b      	lsls	r3, r3, #1
 800d786:	fa01 f303 	lsl.w	r3, r1, r3
 800d78a:	431a      	orrs	r2, r3
 800d78c:	687b      	ldr	r3, [r7, #4]
 800d78e:	609a      	str	r2, [r3, #8]

        /* Check Output mode parameters */
        assert_param(IS_GPIO_OTYPE(GPIO_InitStruct->GPIO_OType));

        /* Output mode configuration*/
        GPIOx->OTYPER  &= ~((GPIO_OTYPER_OT_0) << ((uint16_t)pinpos)) ;
 800d790:	687b      	ldr	r3, [r7, #4]
 800d792:	685a      	ldr	r2, [r3, #4]
 800d794:	697b      	ldr	r3, [r7, #20]
 800d796:	b29b      	uxth	r3, r3
 800d798:	4619      	mov	r1, r3
 800d79a:	2301      	movs	r3, #1
 800d79c:	408b      	lsls	r3, r1
 800d79e:	43db      	mvns	r3, r3
 800d7a0:	401a      	ands	r2, r3
 800d7a2:	687b      	ldr	r3, [r7, #4]
 800d7a4:	605a      	str	r2, [r3, #4]
        GPIOx->OTYPER |= (uint16_t)(((uint16_t)GPIO_InitStruct->GPIO_OType) << ((uint16_t)pinpos));
 800d7a6:	687b      	ldr	r3, [r7, #4]
 800d7a8:	685b      	ldr	r3, [r3, #4]
 800d7aa:	683a      	ldr	r2, [r7, #0]
 800d7ac:	7992      	ldrb	r2, [r2, #6]
 800d7ae:	4611      	mov	r1, r2
 800d7b0:	697a      	ldr	r2, [r7, #20]
 800d7b2:	b292      	uxth	r2, r2
 800d7b4:	fa01 f202 	lsl.w	r2, r1, r2
 800d7b8:	b292      	uxth	r2, r2
 800d7ba:	431a      	orrs	r2, r3
 800d7bc:	687b      	ldr	r3, [r7, #4]
 800d7be:	605a      	str	r2, [r3, #4]
      }

      /* Pull-up Pull down resistor configuration*/
      GPIOx->PUPDR &= ~(GPIO_PUPDR_PUPDR0 << ((uint16_t)pinpos * 2));
 800d7c0:	687b      	ldr	r3, [r7, #4]
 800d7c2:	68da      	ldr	r2, [r3, #12]
 800d7c4:	697b      	ldr	r3, [r7, #20]
 800d7c6:	b29b      	uxth	r3, r3
 800d7c8:	005b      	lsls	r3, r3, #1
 800d7ca:	2103      	movs	r1, #3
 800d7cc:	fa01 f303 	lsl.w	r3, r1, r3
 800d7d0:	43db      	mvns	r3, r3
 800d7d2:	401a      	ands	r2, r3
 800d7d4:	687b      	ldr	r3, [r7, #4]
 800d7d6:	60da      	str	r2, [r3, #12]
      GPIOx->PUPDR |= (((uint32_t)GPIO_InitStruct->GPIO_PuPd) << (pinpos * 2));
 800d7d8:	687b      	ldr	r3, [r7, #4]
 800d7da:	68da      	ldr	r2, [r3, #12]
 800d7dc:	683b      	ldr	r3, [r7, #0]
 800d7de:	79db      	ldrb	r3, [r3, #7]
 800d7e0:	4619      	mov	r1, r3
 800d7e2:	697b      	ldr	r3, [r7, #20]
 800d7e4:	005b      	lsls	r3, r3, #1
 800d7e6:	fa01 f303 	lsl.w	r3, r1, r3
 800d7ea:	431a      	orrs	r2, r3
 800d7ec:	687b      	ldr	r3, [r7, #4]
 800d7ee:	60da      	str	r2, [r3, #12]
  for (pinpos = 0x00; pinpos < 0x10; pinpos++)
 800d7f0:	697b      	ldr	r3, [r7, #20]
 800d7f2:	3301      	adds	r3, #1
 800d7f4:	617b      	str	r3, [r7, #20]
 800d7f6:	697b      	ldr	r3, [r7, #20]
 800d7f8:	2b0f      	cmp	r3, #15
 800d7fa:	d985      	bls.n	800d708 <GPIO_Init+0x1c>
    }
  }
}
 800d7fc:	bf00      	nop
 800d7fe:	371c      	adds	r7, #28
 800d800:	46bd      	mov	sp, r7
 800d802:	f85d 7b04 	ldr.w	r7, [sp], #4
 800d806:	4770      	bx	lr

0800d808 <GPIO_StructInit>:
  * @brief  Fills each GPIO_InitStruct member with its default value.
  * @param  GPIO_InitStruct : pointer to a GPIO_InitTypeDef structure which will be initialized.
  * @retval None
  */
void GPIO_StructInit(GPIO_InitTypeDef* GPIO_InitStruct)
{
 800d808:	b480      	push	{r7}
 800d80a:	b083      	sub	sp, #12
 800d80c:	af00      	add	r7, sp, #0
 800d80e:	6078      	str	r0, [r7, #4]
  /* Reset GPIO init structure parameters values */
  GPIO_InitStruct->GPIO_Pin  = GPIO_Pin_All;
 800d810:	687b      	ldr	r3, [r7, #4]
 800d812:	f64f 72ff 	movw	r2, #65535	; 0xffff
 800d816:	601a      	str	r2, [r3, #0]
  GPIO_InitStruct->GPIO_Mode = GPIO_Mode_IN;
 800d818:	687b      	ldr	r3, [r7, #4]
 800d81a:	2200      	movs	r2, #0
 800d81c:	711a      	strb	r2, [r3, #4]
  GPIO_InitStruct->GPIO_Speed = GPIO_Speed_2MHz;
 800d81e:	687b      	ldr	r3, [r7, #4]
 800d820:	2200      	movs	r2, #0
 800d822:	715a      	strb	r2, [r3, #5]
  GPIO_InitStruct->GPIO_OType = GPIO_OType_PP;
 800d824:	687b      	ldr	r3, [r7, #4]
 800d826:	2200      	movs	r2, #0
 800d828:	719a      	strb	r2, [r3, #6]
  GPIO_InitStruct->GPIO_PuPd = GPIO_PuPd_NOPULL;
 800d82a:	687b      	ldr	r3, [r7, #4]
 800d82c:	2200      	movs	r2, #0
 800d82e:	71da      	strb	r2, [r3, #7]
}
 800d830:	bf00      	nop
 800d832:	370c      	adds	r7, #12
 800d834:	46bd      	mov	sp, r7
 800d836:	f85d 7b04 	ldr.w	r7, [sp], #4
 800d83a:	4770      	bx	lr

0800d83c <GPIO_PinLockConfig>:
  * @param  GPIO_Pin: specifies the port bit to be locked.
  *          This parameter can be any combination of GPIO_Pin_x where x can be (0..15).
  * @retval None
  */
void GPIO_PinLockConfig(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)
{
 800d83c:	b480      	push	{r7}
 800d83e:	b085      	sub	sp, #20
 800d840:	af00      	add	r7, sp, #0
 800d842:	6078      	str	r0, [r7, #4]
 800d844:	460b      	mov	r3, r1
 800d846:	807b      	strh	r3, [r7, #2]
  __IO uint32_t tmp = 0x00010000;
 800d848:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 800d84c:	60fb      	str	r3, [r7, #12]

  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  assert_param(IS_GPIO_PIN(GPIO_Pin));

  tmp |= GPIO_Pin;
 800d84e:	887a      	ldrh	r2, [r7, #2]
 800d850:	68fb      	ldr	r3, [r7, #12]
 800d852:	4313      	orrs	r3, r2
 800d854:	60fb      	str	r3, [r7, #12]
  /* Set LCKK bit */
  GPIOx->LCKR = tmp;
 800d856:	68fa      	ldr	r2, [r7, #12]
 800d858:	687b      	ldr	r3, [r7, #4]
 800d85a:	61da      	str	r2, [r3, #28]
  /* Reset LCKK bit */
  GPIOx->LCKR =  GPIO_Pin;
 800d85c:	887a      	ldrh	r2, [r7, #2]
 800d85e:	687b      	ldr	r3, [r7, #4]
 800d860:	61da      	str	r2, [r3, #28]
  /* Set LCKK bit */
  GPIOx->LCKR = tmp;
 800d862:	68fa      	ldr	r2, [r7, #12]
 800d864:	687b      	ldr	r3, [r7, #4]
 800d866:	61da      	str	r2, [r3, #28]
  /* Read LCKK bit*/
  tmp = GPIOx->LCKR;
 800d868:	687b      	ldr	r3, [r7, #4]
 800d86a:	69db      	ldr	r3, [r3, #28]
 800d86c:	60fb      	str	r3, [r7, #12]
  /* Read LCKK bit*/
  tmp = GPIOx->LCKR;
 800d86e:	687b      	ldr	r3, [r7, #4]
 800d870:	69db      	ldr	r3, [r3, #28]
 800d872:	60fb      	str	r3, [r7, #12]
}
 800d874:	bf00      	nop
 800d876:	3714      	adds	r7, #20
 800d878:	46bd      	mov	sp, r7
 800d87a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800d87e:	4770      	bx	lr

0800d880 <GPIO_ReadInputDataBit>:
  * @param  GPIO_Pin: specifies the port bit to read.
  *         This parameter can be GPIO_Pin_x where x can be (0..15).
  * @retval The input port pin value.
  */
uint8_t GPIO_ReadInputDataBit(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)
{
 800d880:	b480      	push	{r7}
 800d882:	b085      	sub	sp, #20
 800d884:	af00      	add	r7, sp, #0
 800d886:	6078      	str	r0, [r7, #4]
 800d888:	460b      	mov	r3, r1
 800d88a:	807b      	strh	r3, [r7, #2]
  uint8_t bitstatus = 0x00;
 800d88c:	2300      	movs	r3, #0
 800d88e:	73fb      	strb	r3, [r7, #15]

  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  assert_param(IS_GET_GPIO_PIN(GPIO_Pin));

  if ((GPIOx->IDR & GPIO_Pin) != (uint32_t)Bit_RESET)
 800d890:	687b      	ldr	r3, [r7, #4]
 800d892:	691a      	ldr	r2, [r3, #16]
 800d894:	887b      	ldrh	r3, [r7, #2]
 800d896:	4013      	ands	r3, r2
 800d898:	2b00      	cmp	r3, #0
 800d89a:	d002      	beq.n	800d8a2 <GPIO_ReadInputDataBit+0x22>
  {
    bitstatus = (uint8_t)Bit_SET;
 800d89c:	2301      	movs	r3, #1
 800d89e:	73fb      	strb	r3, [r7, #15]
 800d8a0:	e001      	b.n	800d8a6 <GPIO_ReadInputDataBit+0x26>
  }
  else
  {
    bitstatus = (uint8_t)Bit_RESET;
 800d8a2:	2300      	movs	r3, #0
 800d8a4:	73fb      	strb	r3, [r7, #15]
  }
  return bitstatus;
 800d8a6:	7bfb      	ldrb	r3, [r7, #15]
}
 800d8a8:	4618      	mov	r0, r3
 800d8aa:	3714      	adds	r7, #20
 800d8ac:	46bd      	mov	sp, r7
 800d8ae:	f85d 7b04 	ldr.w	r7, [sp], #4
 800d8b2:	4770      	bx	lr

0800d8b4 <GPIO_ReadInputData>:
  * @brief  Reads the specified GPIO input data port.
  * @param  GPIOx: where x can be (A..I) to select the GPIO peripheral.
  * @retval GPIO input data port value.
  */
uint16_t GPIO_ReadInputData(GPIO_TypeDef* GPIOx)
{
 800d8b4:	b480      	push	{r7}
 800d8b6:	b083      	sub	sp, #12
 800d8b8:	af00      	add	r7, sp, #0
 800d8ba:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));

  return ((uint16_t)GPIOx->IDR);
 800d8bc:	687b      	ldr	r3, [r7, #4]
 800d8be:	691b      	ldr	r3, [r3, #16]
 800d8c0:	b29b      	uxth	r3, r3
}
 800d8c2:	4618      	mov	r0, r3
 800d8c4:	370c      	adds	r7, #12
 800d8c6:	46bd      	mov	sp, r7
 800d8c8:	f85d 7b04 	ldr.w	r7, [sp], #4
 800d8cc:	4770      	bx	lr

0800d8ce <GPIO_ReadOutputDataBit>:
  * @param  GPIO_Pin: specifies the port bit to read.
  *          This parameter can be GPIO_Pin_x where x can be (0..15).
  * @retval The output port pin value.
  */
uint8_t GPIO_ReadOutputDataBit(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)
{
 800d8ce:	b480      	push	{r7}
 800d8d0:	b085      	sub	sp, #20
 800d8d2:	af00      	add	r7, sp, #0
 800d8d4:	6078      	str	r0, [r7, #4]
 800d8d6:	460b      	mov	r3, r1
 800d8d8:	807b      	strh	r3, [r7, #2]
  uint8_t bitstatus = 0x00;
 800d8da:	2300      	movs	r3, #0
 800d8dc:	73fb      	strb	r3, [r7, #15]

  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  assert_param(IS_GET_GPIO_PIN(GPIO_Pin));

  if ((GPIOx->ODR & GPIO_Pin) != (uint32_t)Bit_RESET)
 800d8de:	687b      	ldr	r3, [r7, #4]
 800d8e0:	695a      	ldr	r2, [r3, #20]
 800d8e2:	887b      	ldrh	r3, [r7, #2]
 800d8e4:	4013      	ands	r3, r2
 800d8e6:	2b00      	cmp	r3, #0
 800d8e8:	d002      	beq.n	800d8f0 <GPIO_ReadOutputDataBit+0x22>
  {
    bitstatus = (uint8_t)Bit_SET;
 800d8ea:	2301      	movs	r3, #1
 800d8ec:	73fb      	strb	r3, [r7, #15]
 800d8ee:	e001      	b.n	800d8f4 <GPIO_ReadOutputDataBit+0x26>
  }
  else
  {
    bitstatus = (uint8_t)Bit_RESET;
 800d8f0:	2300      	movs	r3, #0
 800d8f2:	73fb      	strb	r3, [r7, #15]
  }
  return bitstatus;
 800d8f4:	7bfb      	ldrb	r3, [r7, #15]
}
 800d8f6:	4618      	mov	r0, r3
 800d8f8:	3714      	adds	r7, #20
 800d8fa:	46bd      	mov	sp, r7
 800d8fc:	f85d 7b04 	ldr.w	r7, [sp], #4
 800d900:	4770      	bx	lr

0800d902 <GPIO_ReadOutputData>:
  * @brief  Reads the specified GPIO output data port.
  * @param  GPIOx: where x can be (A..I) to select the GPIO peripheral.
  * @retval GPIO output data port value.
  */
uint16_t GPIO_ReadOutputData(GPIO_TypeDef* GPIOx)
{
 800d902:	b480      	push	{r7}
 800d904:	b083      	sub	sp, #12
 800d906:	af00      	add	r7, sp, #0
 800d908:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));

  return ((uint16_t)GPIOx->ODR);
 800d90a:	687b      	ldr	r3, [r7, #4]
 800d90c:	695b      	ldr	r3, [r3, #20]
 800d90e:	b29b      	uxth	r3, r3
}
 800d910:	4618      	mov	r0, r3
 800d912:	370c      	adds	r7, #12
 800d914:	46bd      	mov	sp, r7
 800d916:	f85d 7b04 	ldr.w	r7, [sp], #4
 800d91a:	4770      	bx	lr

0800d91c <GPIO_SetBits>:
  * @param  GPIO_Pin: specifies the port bits to be written.
  *          This parameter can be any combination of GPIO_Pin_x where x can be (0..15).
  * @retval None
  */
void GPIO_SetBits(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)
{
 800d91c:	b480      	push	{r7}
 800d91e:	b083      	sub	sp, #12
 800d920:	af00      	add	r7, sp, #0
 800d922:	6078      	str	r0, [r7, #4]
 800d924:	460b      	mov	r3, r1
 800d926:	807b      	strh	r3, [r7, #2]
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  assert_param(IS_GPIO_PIN(GPIO_Pin));

  GPIOx->BSRRL = GPIO_Pin;
 800d928:	687b      	ldr	r3, [r7, #4]
 800d92a:	887a      	ldrh	r2, [r7, #2]
 800d92c:	831a      	strh	r2, [r3, #24]
}
 800d92e:	bf00      	nop
 800d930:	370c      	adds	r7, #12
 800d932:	46bd      	mov	sp, r7
 800d934:	f85d 7b04 	ldr.w	r7, [sp], #4
 800d938:	4770      	bx	lr

0800d93a <GPIO_ResetBits>:
  * @param  GPIO_Pin: specifies the port bits to be written.
  *          This parameter can be any combination of GPIO_Pin_x where x can be (0..15).
  * @retval None
  */
void GPIO_ResetBits(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)
{
 800d93a:	b480      	push	{r7}
 800d93c:	b083      	sub	sp, #12
 800d93e:	af00      	add	r7, sp, #0
 800d940:	6078      	str	r0, [r7, #4]
 800d942:	460b      	mov	r3, r1
 800d944:	807b      	strh	r3, [r7, #2]
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  assert_param(IS_GPIO_PIN(GPIO_Pin));

  GPIOx->BSRRH = GPIO_Pin;
 800d946:	687b      	ldr	r3, [r7, #4]
 800d948:	887a      	ldrh	r2, [r7, #2]
 800d94a:	835a      	strh	r2, [r3, #26]
}
 800d94c:	bf00      	nop
 800d94e:	370c      	adds	r7, #12
 800d950:	46bd      	mov	sp, r7
 800d952:	f85d 7b04 	ldr.w	r7, [sp], #4
 800d956:	4770      	bx	lr

0800d958 <GPIO_WriteBit>:
  *            @arg Bit_RESET: to clear the port pin
  *            @arg Bit_SET: to set the port pin
  * @retval None
  */
void GPIO_WriteBit(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin, BitAction BitVal)
{
 800d958:	b480      	push	{r7}
 800d95a:	b083      	sub	sp, #12
 800d95c:	af00      	add	r7, sp, #0
 800d95e:	6078      	str	r0, [r7, #4]
 800d960:	460b      	mov	r3, r1
 800d962:	807b      	strh	r3, [r7, #2]
 800d964:	4613      	mov	r3, r2
 800d966:	707b      	strb	r3, [r7, #1]
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  assert_param(IS_GET_GPIO_PIN(GPIO_Pin));
  assert_param(IS_GPIO_BIT_ACTION(BitVal));

  if (BitVal != Bit_RESET)
 800d968:	787b      	ldrb	r3, [r7, #1]
 800d96a:	2b00      	cmp	r3, #0
 800d96c:	d003      	beq.n	800d976 <GPIO_WriteBit+0x1e>
  {
    GPIOx->BSRRL = GPIO_Pin;
 800d96e:	687b      	ldr	r3, [r7, #4]
 800d970:	887a      	ldrh	r2, [r7, #2]
 800d972:	831a      	strh	r2, [r3, #24]
  }
  else
  {
    GPIOx->BSRRH = GPIO_Pin ;
  }
}
 800d974:	e002      	b.n	800d97c <GPIO_WriteBit+0x24>
    GPIOx->BSRRH = GPIO_Pin ;
 800d976:	687b      	ldr	r3, [r7, #4]
 800d978:	887a      	ldrh	r2, [r7, #2]
 800d97a:	835a      	strh	r2, [r3, #26]
}
 800d97c:	bf00      	nop
 800d97e:	370c      	adds	r7, #12
 800d980:	46bd      	mov	sp, r7
 800d982:	f85d 7b04 	ldr.w	r7, [sp], #4
 800d986:	4770      	bx	lr

0800d988 <GPIO_Write>:
  * @param  GPIOx: where x can be (A..I) to select the GPIO peripheral.
  * @param  PortVal: specifies the value to be written to the port output data register.
  * @retval None
  */
void GPIO_Write(GPIO_TypeDef* GPIOx, uint16_t PortVal)
{
 800d988:	b480      	push	{r7}
 800d98a:	b083      	sub	sp, #12
 800d98c:	af00      	add	r7, sp, #0
 800d98e:	6078      	str	r0, [r7, #4]
 800d990:	460b      	mov	r3, r1
 800d992:	807b      	strh	r3, [r7, #2]
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));

  GPIOx->ODR = PortVal;
 800d994:	887a      	ldrh	r2, [r7, #2]
 800d996:	687b      	ldr	r3, [r7, #4]
 800d998:	615a      	str	r2, [r3, #20]
}
 800d99a:	bf00      	nop
 800d99c:	370c      	adds	r7, #12
 800d99e:	46bd      	mov	sp, r7
 800d9a0:	f85d 7b04 	ldr.w	r7, [sp], #4
 800d9a4:	4770      	bx	lr

0800d9a6 <GPIO_ToggleBits>:
  * @param  GPIOx: where x can be (A..I) to select the GPIO peripheral.
  * @param  GPIO_Pin: Specifies the pins to be toggled.
  * @retval None
  */
void GPIO_ToggleBits(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)
{
 800d9a6:	b480      	push	{r7}
 800d9a8:	b083      	sub	sp, #12
 800d9aa:	af00      	add	r7, sp, #0
 800d9ac:	6078      	str	r0, [r7, #4]
 800d9ae:	460b      	mov	r3, r1
 800d9b0:	807b      	strh	r3, [r7, #2]
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));

  GPIOx->ODR ^= GPIO_Pin;
 800d9b2:	687b      	ldr	r3, [r7, #4]
 800d9b4:	695a      	ldr	r2, [r3, #20]
 800d9b6:	887b      	ldrh	r3, [r7, #2]
 800d9b8:	405a      	eors	r2, r3
 800d9ba:	687b      	ldr	r3, [r7, #4]
 800d9bc:	615a      	str	r2, [r3, #20]
}
 800d9be:	bf00      	nop
 800d9c0:	370c      	adds	r7, #12
 800d9c2:	46bd      	mov	sp, r7
 800d9c4:	f85d 7b04 	ldr.w	r7, [sp], #4
 800d9c8:	4770      	bx	lr

0800d9ca <GPIO_PinAFConfig>:
  *            @arg GPIO_AF_DCMI: Connect DCMI pins to AF13
  *            @arg GPIO_AF_EVENTOUT: Connect EVENTOUT pins to AF15
  * @retval None
  */
void GPIO_PinAFConfig(GPIO_TypeDef* GPIOx, uint16_t GPIO_PinSource, uint8_t GPIO_AF)
{
 800d9ca:	b480      	push	{r7}
 800d9cc:	b085      	sub	sp, #20
 800d9ce:	af00      	add	r7, sp, #0
 800d9d0:	6078      	str	r0, [r7, #4]
 800d9d2:	460b      	mov	r3, r1
 800d9d4:	807b      	strh	r3, [r7, #2]
 800d9d6:	4613      	mov	r3, r2
 800d9d8:	707b      	strb	r3, [r7, #1]
  uint32_t temp = 0x00;
 800d9da:	2300      	movs	r3, #0
 800d9dc:	60fb      	str	r3, [r7, #12]
  uint32_t temp_2 = 0x00;
 800d9de:	2300      	movs	r3, #0
 800d9e0:	60bb      	str	r3, [r7, #8]
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  assert_param(IS_GPIO_PIN_SOURCE(GPIO_PinSource));
  assert_param(IS_GPIO_AF(GPIO_AF));
  
  temp = ((uint32_t)(GPIO_AF) << ((uint32_t)((uint32_t)GPIO_PinSource & (uint32_t)0x07) * 4)) ;
 800d9e2:	787a      	ldrb	r2, [r7, #1]
 800d9e4:	887b      	ldrh	r3, [r7, #2]
 800d9e6:	f003 0307 	and.w	r3, r3, #7
 800d9ea:	009b      	lsls	r3, r3, #2
 800d9ec:	fa02 f303 	lsl.w	r3, r2, r3
 800d9f0:	60fb      	str	r3, [r7, #12]
  GPIOx->AFR[GPIO_PinSource >> 0x03] &= ~((uint32_t)0xF << ((uint32_t)((uint32_t)GPIO_PinSource & (uint32_t)0x07) * 4)) ;
 800d9f2:	887b      	ldrh	r3, [r7, #2]
 800d9f4:	08db      	lsrs	r3, r3, #3
 800d9f6:	b29b      	uxth	r3, r3
 800d9f8:	4618      	mov	r0, r3
 800d9fa:	887b      	ldrh	r3, [r7, #2]
 800d9fc:	08db      	lsrs	r3, r3, #3
 800d9fe:	b29b      	uxth	r3, r3
 800da00:	461a      	mov	r2, r3
 800da02:	687b      	ldr	r3, [r7, #4]
 800da04:	3208      	adds	r2, #8
 800da06:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 800da0a:	887b      	ldrh	r3, [r7, #2]
 800da0c:	f003 0307 	and.w	r3, r3, #7
 800da10:	009b      	lsls	r3, r3, #2
 800da12:	210f      	movs	r1, #15
 800da14:	fa01 f303 	lsl.w	r3, r1, r3
 800da18:	43db      	mvns	r3, r3
 800da1a:	ea02 0103 	and.w	r1, r2, r3
 800da1e:	687b      	ldr	r3, [r7, #4]
 800da20:	f100 0208 	add.w	r2, r0, #8
 800da24:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
  temp_2 = GPIOx->AFR[GPIO_PinSource >> 0x03] | temp;
 800da28:	887b      	ldrh	r3, [r7, #2]
 800da2a:	08db      	lsrs	r3, r3, #3
 800da2c:	b29b      	uxth	r3, r3
 800da2e:	461a      	mov	r2, r3
 800da30:	687b      	ldr	r3, [r7, #4]
 800da32:	3208      	adds	r2, #8
 800da34:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 800da38:	68fb      	ldr	r3, [r7, #12]
 800da3a:	4313      	orrs	r3, r2
 800da3c:	60bb      	str	r3, [r7, #8]
  GPIOx->AFR[GPIO_PinSource >> 0x03] = temp_2;
 800da3e:	887b      	ldrh	r3, [r7, #2]
 800da40:	08db      	lsrs	r3, r3, #3
 800da42:	b29b      	uxth	r3, r3
 800da44:	461a      	mov	r2, r3
 800da46:	687b      	ldr	r3, [r7, #4]
 800da48:	3208      	adds	r2, #8
 800da4a:	68b9      	ldr	r1, [r7, #8]
 800da4c:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
}
 800da50:	bf00      	nop
 800da52:	3714      	adds	r7, #20
 800da54:	46bd      	mov	sp, r7
 800da56:	f85d 7b04 	ldr.w	r7, [sp], #4
 800da5a:	4770      	bx	lr

0800da5c <HASH_DeInit>:
  * @brief  Deinitializes the HASH peripheral registers to their default reset values
  * @param  None
  * @retval None
  */
void HASH_DeInit(void)
{
 800da5c:	b580      	push	{r7, lr}
 800da5e:	af00      	add	r7, sp, #0
  /* Enable HASH reset state */
  RCC_AHB2PeriphResetCmd(RCC_AHB2Periph_HASH, ENABLE);
 800da60:	2101      	movs	r1, #1
 800da62:	2020      	movs	r0, #32
 800da64:	f001 ff16 	bl	800f894 <RCC_AHB2PeriphResetCmd>
  /* Release HASH from reset state */
  RCC_AHB2PeriphResetCmd(RCC_AHB2Periph_HASH, DISABLE);
 800da68:	2100      	movs	r1, #0
 800da6a:	2020      	movs	r0, #32
 800da6c:	f001 ff12 	bl	800f894 <RCC_AHB2PeriphResetCmd>
}
 800da70:	bf00      	nop
 800da72:	bd80      	pop	{r7, pc}

0800da74 <HASH_Init>:
  * @note   The field HASH_HMACKeyType in HASH_InitTypeDef must be filled only 
  *          if the algorithm mode is HMAC.       
  * @retval None
  */
void HASH_Init(HASH_InitTypeDef* HASH_InitStruct)
{
 800da74:	b480      	push	{r7}
 800da76:	b083      	sub	sp, #12
 800da78:	af00      	add	r7, sp, #0
 800da7a:	6078      	str	r0, [r7, #4]
  assert_param(IS_HASH_ALGOSELECTION(HASH_InitStruct->HASH_AlgoSelection));
  assert_param(IS_HASH_DATATYPE(HASH_InitStruct->HASH_DataType));
  assert_param(IS_HASH_ALGOMODE(HASH_InitStruct->HASH_AlgoMode));
  
  /* Configure the Algorithm used, algorithm mode and the datatype */
  HASH->CR &= ~ (HASH_CR_ALGO | HASH_CR_DATATYPE | HASH_CR_MODE);
 800da7c:	4a17      	ldr	r2, [pc, #92]	; (800dadc <HASH_Init+0x68>)
 800da7e:	4b17      	ldr	r3, [pc, #92]	; (800dadc <HASH_Init+0x68>)
 800da80:	681b      	ldr	r3, [r3, #0]
 800da82:	f023 03f0 	bic.w	r3, r3, #240	; 0xf0
 800da86:	6013      	str	r3, [r2, #0]
  HASH->CR |= (HASH_InitStruct->HASH_AlgoSelection | \
 800da88:	4814      	ldr	r0, [pc, #80]	; (800dadc <HASH_Init+0x68>)
 800da8a:	4b14      	ldr	r3, [pc, #80]	; (800dadc <HASH_Init+0x68>)
 800da8c:	681a      	ldr	r2, [r3, #0]
 800da8e:	687b      	ldr	r3, [r7, #4]
 800da90:	6819      	ldr	r1, [r3, #0]
               HASH_InitStruct->HASH_DataType | \
 800da92:	687b      	ldr	r3, [r7, #4]
 800da94:	689b      	ldr	r3, [r3, #8]
  HASH->CR |= (HASH_InitStruct->HASH_AlgoSelection | \
 800da96:	4319      	orrs	r1, r3
               HASH_InitStruct->HASH_AlgoMode);
 800da98:	687b      	ldr	r3, [r7, #4]
 800da9a:	685b      	ldr	r3, [r3, #4]
               HASH_InitStruct->HASH_DataType | \
 800da9c:	430b      	orrs	r3, r1
  HASH->CR |= (HASH_InitStruct->HASH_AlgoSelection | \
 800da9e:	4313      	orrs	r3, r2
 800daa0:	6003      	str	r3, [r0, #0]
  
  /* if algorithm mode is HMAC, set the Key */  
  if(HASH_InitStruct->HASH_AlgoMode == HASH_AlgoMode_HMAC) 
 800daa2:	687b      	ldr	r3, [r7, #4]
 800daa4:	685b      	ldr	r3, [r3, #4]
 800daa6:	2b40      	cmp	r3, #64	; 0x40
 800daa8:	d10c      	bne.n	800dac4 <HASH_Init+0x50>
  {
    assert_param(IS_HASH_HMAC_KEYTYPE(HASH_InitStruct->HASH_HMACKeyType));
    HASH->CR &= ~HASH_CR_LKEY;
 800daaa:	4a0c      	ldr	r2, [pc, #48]	; (800dadc <HASH_Init+0x68>)
 800daac:	4b0b      	ldr	r3, [pc, #44]	; (800dadc <HASH_Init+0x68>)
 800daae:	681b      	ldr	r3, [r3, #0]
 800dab0:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 800dab4:	6013      	str	r3, [r2, #0]
    HASH->CR |= HASH_InitStruct->HASH_HMACKeyType;
 800dab6:	4909      	ldr	r1, [pc, #36]	; (800dadc <HASH_Init+0x68>)
 800dab8:	4b08      	ldr	r3, [pc, #32]	; (800dadc <HASH_Init+0x68>)
 800daba:	681a      	ldr	r2, [r3, #0]
 800dabc:	687b      	ldr	r3, [r7, #4]
 800dabe:	68db      	ldr	r3, [r3, #12]
 800dac0:	4313      	orrs	r3, r2
 800dac2:	600b      	str	r3, [r1, #0]
  }

  /* Reset the HASH processor core, so that the HASH will be ready to compute 
     the message digest of a new message */
  HASH->CR |= HASH_CR_INIT;  
 800dac4:	4a05      	ldr	r2, [pc, #20]	; (800dadc <HASH_Init+0x68>)
 800dac6:	4b05      	ldr	r3, [pc, #20]	; (800dadc <HASH_Init+0x68>)
 800dac8:	681b      	ldr	r3, [r3, #0]
 800daca:	f043 0304 	orr.w	r3, r3, #4
 800dace:	6013      	str	r3, [r2, #0]
}
 800dad0:	bf00      	nop
 800dad2:	370c      	adds	r7, #12
 800dad4:	46bd      	mov	sp, r7
 800dad6:	f85d 7b04 	ldr.w	r7, [sp], #4
 800dada:	4770      	bx	lr
 800dadc:	50060400 	.word	0x50060400

0800dae0 <HASH_StructInit>:
  *  @note  The default values set are : Processor mode is HASH, Algorithm selected is SHA1,
  *          Data type selected is 32b and HMAC Key Type is short key.  
  * @retval None
  */
void HASH_StructInit(HASH_InitTypeDef* HASH_InitStruct)
{
 800dae0:	b480      	push	{r7}
 800dae2:	b083      	sub	sp, #12
 800dae4:	af00      	add	r7, sp, #0
 800dae6:	6078      	str	r0, [r7, #4]
  /* Initialize the HASH_AlgoSelection member */
  HASH_InitStruct->HASH_AlgoSelection = HASH_AlgoSelection_SHA1;
 800dae8:	687b      	ldr	r3, [r7, #4]
 800daea:	2200      	movs	r2, #0
 800daec:	601a      	str	r2, [r3, #0]

  /* Initialize the HASH_AlgoMode member */
  HASH_InitStruct->HASH_AlgoMode = HASH_AlgoMode_HASH;
 800daee:	687b      	ldr	r3, [r7, #4]
 800daf0:	2200      	movs	r2, #0
 800daf2:	605a      	str	r2, [r3, #4]

  /* Initialize the HASH_DataType member */
  HASH_InitStruct->HASH_DataType = HASH_DataType_32b;
 800daf4:	687b      	ldr	r3, [r7, #4]
 800daf6:	2200      	movs	r2, #0
 800daf8:	609a      	str	r2, [r3, #8]

  /* Initialize the HASH_HMACKeyType member */
  HASH_InitStruct->HASH_HMACKeyType = HASH_HMACKeyType_ShortKey;
 800dafa:	687b      	ldr	r3, [r7, #4]
 800dafc:	2200      	movs	r2, #0
 800dafe:	60da      	str	r2, [r3, #12]
}
 800db00:	bf00      	nop
 800db02:	370c      	adds	r7, #12
 800db04:	46bd      	mov	sp, r7
 800db06:	f85d 7b04 	ldr.w	r7, [sp], #4
 800db0a:	4770      	bx	lr

0800db0c <HASH_Reset>:
  *         interrupt and HASH_FLAG_DCIS flag. 
  * @param  None
  * @retval None
  */
void HASH_Reset(void)
{
 800db0c:	b480      	push	{r7}
 800db0e:	af00      	add	r7, sp, #0
  /* Reset the HASH processor core */
  HASH->CR |= HASH_CR_INIT;
 800db10:	4a05      	ldr	r2, [pc, #20]	; (800db28 <HASH_Reset+0x1c>)
 800db12:	4b05      	ldr	r3, [pc, #20]	; (800db28 <HASH_Reset+0x1c>)
 800db14:	681b      	ldr	r3, [r3, #0]
 800db16:	f043 0304 	orr.w	r3, r3, #4
 800db1a:	6013      	str	r3, [r2, #0]
}
 800db1c:	bf00      	nop
 800db1e:	46bd      	mov	sp, r7
 800db20:	f85d 7b04 	ldr.w	r7, [sp], #4
 800db24:	4770      	bx	lr
 800db26:	bf00      	nop
 800db28:	50060400 	.word	0x50060400

0800db2c <HASH_SetLastWordValidBitsNbr>:
  * @note   The Number of valid bits must be set before to start the message 
  *         digest competition (in Hash and HMAC) and key treatment(in HMAC).    
  * @retval None
  */
void HASH_SetLastWordValidBitsNbr(uint16_t ValidNumber)
{
 800db2c:	b480      	push	{r7}
 800db2e:	b083      	sub	sp, #12
 800db30:	af00      	add	r7, sp, #0
 800db32:	4603      	mov	r3, r0
 800db34:	80fb      	strh	r3, [r7, #6]
  /* Check the parameters */
  assert_param(IS_HASH_VALIDBITSNUMBER(ValidNumber));
  
  /* Configure the Number of valid bits in last word of the message */
  HASH->STR &= ~(HASH_STR_NBW);
 800db36:	4a09      	ldr	r2, [pc, #36]	; (800db5c <HASH_SetLastWordValidBitsNbr+0x30>)
 800db38:	4b08      	ldr	r3, [pc, #32]	; (800db5c <HASH_SetLastWordValidBitsNbr+0x30>)
 800db3a:	689b      	ldr	r3, [r3, #8]
 800db3c:	f023 031f 	bic.w	r3, r3, #31
 800db40:	6093      	str	r3, [r2, #8]
  HASH->STR |= ValidNumber;
 800db42:	4906      	ldr	r1, [pc, #24]	; (800db5c <HASH_SetLastWordValidBitsNbr+0x30>)
 800db44:	4b05      	ldr	r3, [pc, #20]	; (800db5c <HASH_SetLastWordValidBitsNbr+0x30>)
 800db46:	689a      	ldr	r2, [r3, #8]
 800db48:	88fb      	ldrh	r3, [r7, #6]
 800db4a:	4313      	orrs	r3, r2
 800db4c:	608b      	str	r3, [r1, #8]
}
 800db4e:	bf00      	nop
 800db50:	370c      	adds	r7, #12
 800db52:	46bd      	mov	sp, r7
 800db54:	f85d 7b04 	ldr.w	r7, [sp], #4
 800db58:	4770      	bx	lr
 800db5a:	bf00      	nop
 800db5c:	50060400 	.word	0x50060400

0800db60 <HASH_DataIn>:
  * @brief  Writes data in the Data Input FIFO
  * @param  Data: new data of the message to be processed.
  * @retval None
  */
void HASH_DataIn(uint32_t Data)
{
 800db60:	b480      	push	{r7}
 800db62:	b083      	sub	sp, #12
 800db64:	af00      	add	r7, sp, #0
 800db66:	6078      	str	r0, [r7, #4]
  /* Write in the DIN register a new data */
  HASH->DIN = Data;
 800db68:	4a04      	ldr	r2, [pc, #16]	; (800db7c <HASH_DataIn+0x1c>)
 800db6a:	687b      	ldr	r3, [r7, #4]
 800db6c:	6053      	str	r3, [r2, #4]
}
 800db6e:	bf00      	nop
 800db70:	370c      	adds	r7, #12
 800db72:	46bd      	mov	sp, r7
 800db74:	f85d 7b04 	ldr.w	r7, [sp], #4
 800db78:	4770      	bx	lr
 800db7a:	bf00      	nop
 800db7c:	50060400 	.word	0x50060400

0800db80 <HASH_GetInFIFOWordsNbr>:
  * @brief  Returns the number of words already pushed into the IN FIFO.
  * @param  None
  * @retval The value of words already pushed into the IN FIFO.
  */
uint8_t HASH_GetInFIFOWordsNbr(void)
{
 800db80:	b480      	push	{r7}
 800db82:	af00      	add	r7, sp, #0
  /* Return the value of NBW bits */
  return ((HASH->CR & HASH_CR_NBW) >> 8);
 800db84:	4b05      	ldr	r3, [pc, #20]	; (800db9c <HASH_GetInFIFOWordsNbr+0x1c>)
 800db86:	681b      	ldr	r3, [r3, #0]
 800db88:	0a1b      	lsrs	r3, r3, #8
 800db8a:	b2db      	uxtb	r3, r3
 800db8c:	f003 030f 	and.w	r3, r3, #15
 800db90:	b2db      	uxtb	r3, r3
}
 800db92:	4618      	mov	r0, r3
 800db94:	46bd      	mov	sp, r7
 800db96:	f85d 7b04 	ldr.w	r7, [sp], #4
 800db9a:	4770      	bx	lr
 800db9c:	50060400 	.word	0x50060400

0800dba0 <HASH_GetDigest>:
  * @param  HASH_MessageDigest: pointer to a HASH_MsgDigest structure which will 
  *         hold the message digest result 
  * @retval None
  */
void HASH_GetDigest(HASH_MsgDigest* HASH_MessageDigest)
{
 800dba0:	b480      	push	{r7}
 800dba2:	b083      	sub	sp, #12
 800dba4:	af00      	add	r7, sp, #0
 800dba6:	6078      	str	r0, [r7, #4]
  /* Get the data field */
  HASH_MessageDigest->Data[0] = HASH->HR[0];
 800dba8:	4b0c      	ldr	r3, [pc, #48]	; (800dbdc <HASH_GetDigest+0x3c>)
 800dbaa:	68da      	ldr	r2, [r3, #12]
 800dbac:	687b      	ldr	r3, [r7, #4]
 800dbae:	601a      	str	r2, [r3, #0]
  HASH_MessageDigest->Data[1] = HASH->HR[1];
 800dbb0:	4b0a      	ldr	r3, [pc, #40]	; (800dbdc <HASH_GetDigest+0x3c>)
 800dbb2:	691a      	ldr	r2, [r3, #16]
 800dbb4:	687b      	ldr	r3, [r7, #4]
 800dbb6:	605a      	str	r2, [r3, #4]
  HASH_MessageDigest->Data[2] = HASH->HR[2];
 800dbb8:	4b08      	ldr	r3, [pc, #32]	; (800dbdc <HASH_GetDigest+0x3c>)
 800dbba:	695a      	ldr	r2, [r3, #20]
 800dbbc:	687b      	ldr	r3, [r7, #4]
 800dbbe:	609a      	str	r2, [r3, #8]
  HASH_MessageDigest->Data[3] = HASH->HR[3];
 800dbc0:	4b06      	ldr	r3, [pc, #24]	; (800dbdc <HASH_GetDigest+0x3c>)
 800dbc2:	699a      	ldr	r2, [r3, #24]
 800dbc4:	687b      	ldr	r3, [r7, #4]
 800dbc6:	60da      	str	r2, [r3, #12]
  HASH_MessageDigest->Data[4] = HASH->HR[4];
 800dbc8:	4b04      	ldr	r3, [pc, #16]	; (800dbdc <HASH_GetDigest+0x3c>)
 800dbca:	69da      	ldr	r2, [r3, #28]
 800dbcc:	687b      	ldr	r3, [r7, #4]
 800dbce:	611a      	str	r2, [r3, #16]
}
 800dbd0:	bf00      	nop
 800dbd2:	370c      	adds	r7, #12
 800dbd4:	46bd      	mov	sp, r7
 800dbd6:	f85d 7b04 	ldr.w	r7, [sp], #4
 800dbda:	4770      	bx	lr
 800dbdc:	50060400 	.word	0x50060400

0800dbe0 <HASH_StartDigest>:
  * @brief  Starts the message padding and calculation of the final message     
  * @param  None
  * @retval None
  */
void HASH_StartDigest(void)
{
 800dbe0:	b480      	push	{r7}
 800dbe2:	af00      	add	r7, sp, #0
  /* Start the Digest calculation */
  HASH->STR |= HASH_STR_DCAL;
 800dbe4:	4a05      	ldr	r2, [pc, #20]	; (800dbfc <HASH_StartDigest+0x1c>)
 800dbe6:	4b05      	ldr	r3, [pc, #20]	; (800dbfc <HASH_StartDigest+0x1c>)
 800dbe8:	689b      	ldr	r3, [r3, #8]
 800dbea:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 800dbee:	6093      	str	r3, [r2, #8]
}
 800dbf0:	bf00      	nop
 800dbf2:	46bd      	mov	sp, r7
 800dbf4:	f85d 7b04 	ldr.w	r7, [sp], #4
 800dbf8:	4770      	bx	lr
 800dbfa:	bf00      	nop
 800dbfc:	50060400 	.word	0x50060400

0800dc00 <HASH_SaveContext>:
  * @param  HASH_ContextSave: pointer to a HASH_Context structure that contains
  *         the repository for current context.
  * @retval None
  */
void HASH_SaveContext(HASH_Context* HASH_ContextSave)
{
 800dc00:	b480      	push	{r7}
 800dc02:	b085      	sub	sp, #20
 800dc04:	af00      	add	r7, sp, #0
 800dc06:	6078      	str	r0, [r7, #4]
  uint8_t i = 0;
 800dc08:	2300      	movs	r3, #0
 800dc0a:	73fb      	strb	r3, [r7, #15]
  
  /* save context registers */
  HASH_ContextSave->HASH_IMR = HASH->IMR;  
 800dc0c:	4b12      	ldr	r3, [pc, #72]	; (800dc58 <HASH_SaveContext+0x58>)
 800dc0e:	6a1a      	ldr	r2, [r3, #32]
 800dc10:	687b      	ldr	r3, [r7, #4]
 800dc12:	601a      	str	r2, [r3, #0]
  HASH_ContextSave->HASH_STR = HASH->STR;      
 800dc14:	4b10      	ldr	r3, [pc, #64]	; (800dc58 <HASH_SaveContext+0x58>)
 800dc16:	689a      	ldr	r2, [r3, #8]
 800dc18:	687b      	ldr	r3, [r7, #4]
 800dc1a:	605a      	str	r2, [r3, #4]
  HASH_ContextSave->HASH_CR  = HASH->CR;     
 800dc1c:	4b0e      	ldr	r3, [pc, #56]	; (800dc58 <HASH_SaveContext+0x58>)
 800dc1e:	681a      	ldr	r2, [r3, #0]
 800dc20:	687b      	ldr	r3, [r7, #4]
 800dc22:	609a      	str	r2, [r3, #8]
  for(i=0; i<=50;i++)
 800dc24:	2300      	movs	r3, #0
 800dc26:	73fb      	strb	r3, [r7, #15]
 800dc28:	e00d      	b.n	800dc46 <HASH_SaveContext+0x46>
  {
     HASH_ContextSave->HASH_CSR[i] = HASH->CSR[i];
 800dc2a:	7bfb      	ldrb	r3, [r7, #15]
 800dc2c:	490a      	ldr	r1, [pc, #40]	; (800dc58 <HASH_SaveContext+0x58>)
 800dc2e:	7bfa      	ldrb	r2, [r7, #15]
 800dc30:	323e      	adds	r2, #62	; 0x3e
 800dc32:	f851 2022 	ldr.w	r2, [r1, r2, lsl #2]
 800dc36:	6879      	ldr	r1, [r7, #4]
 800dc38:	3302      	adds	r3, #2
 800dc3a:	009b      	lsls	r3, r3, #2
 800dc3c:	440b      	add	r3, r1
 800dc3e:	605a      	str	r2, [r3, #4]
  for(i=0; i<=50;i++)
 800dc40:	7bfb      	ldrb	r3, [r7, #15]
 800dc42:	3301      	adds	r3, #1
 800dc44:	73fb      	strb	r3, [r7, #15]
 800dc46:	7bfb      	ldrb	r3, [r7, #15]
 800dc48:	2b32      	cmp	r3, #50	; 0x32
 800dc4a:	d9ee      	bls.n	800dc2a <HASH_SaveContext+0x2a>
  }   
}
 800dc4c:	bf00      	nop
 800dc4e:	3714      	adds	r7, #20
 800dc50:	46bd      	mov	sp, r7
 800dc52:	f85d 7b04 	ldr.w	r7, [sp], #4
 800dc56:	4770      	bx	lr
 800dc58:	50060400 	.word	0x50060400

0800dc5c <HASH_RestoreContext>:
  * @param  HASH_ContextRestore: pointer to a HASH_Context structure that contains
  *         the repository for saved context.
  * @retval None
  */
void HASH_RestoreContext(HASH_Context* HASH_ContextRestore)  
{
 800dc5c:	b480      	push	{r7}
 800dc5e:	b085      	sub	sp, #20
 800dc60:	af00      	add	r7, sp, #0
 800dc62:	6078      	str	r0, [r7, #4]
  uint8_t i = 0;
 800dc64:	2300      	movs	r3, #0
 800dc66:	73fb      	strb	r3, [r7, #15]
  
  /* restore context registers */
  HASH->IMR = HASH_ContextRestore->HASH_IMR;   
 800dc68:	4a16      	ldr	r2, [pc, #88]	; (800dcc4 <HASH_RestoreContext+0x68>)
 800dc6a:	687b      	ldr	r3, [r7, #4]
 800dc6c:	681b      	ldr	r3, [r3, #0]
 800dc6e:	6213      	str	r3, [r2, #32]
  HASH->STR = HASH_ContextRestore->HASH_STR;     
 800dc70:	4a14      	ldr	r2, [pc, #80]	; (800dcc4 <HASH_RestoreContext+0x68>)
 800dc72:	687b      	ldr	r3, [r7, #4]
 800dc74:	685b      	ldr	r3, [r3, #4]
 800dc76:	6093      	str	r3, [r2, #8]
  HASH->CR = HASH_ContextRestore->HASH_CR;
 800dc78:	4a12      	ldr	r2, [pc, #72]	; (800dcc4 <HASH_RestoreContext+0x68>)
 800dc7a:	687b      	ldr	r3, [r7, #4]
 800dc7c:	689b      	ldr	r3, [r3, #8]
 800dc7e:	6013      	str	r3, [r2, #0]
  
  /* Initialize the hash processor */
  HASH->CR |= HASH_CR_INIT; 
 800dc80:	4a10      	ldr	r2, [pc, #64]	; (800dcc4 <HASH_RestoreContext+0x68>)
 800dc82:	4b10      	ldr	r3, [pc, #64]	; (800dcc4 <HASH_RestoreContext+0x68>)
 800dc84:	681b      	ldr	r3, [r3, #0]
 800dc86:	f043 0304 	orr.w	r3, r3, #4
 800dc8a:	6013      	str	r3, [r2, #0]
  
   /* continue restoring context registers */     
  for(i=0; i<=50;i++)
 800dc8c:	2300      	movs	r3, #0
 800dc8e:	73fb      	strb	r3, [r7, #15]
 800dc90:	e00e      	b.n	800dcb0 <HASH_RestoreContext+0x54>
  {
     HASH->CSR[i] = HASH_ContextRestore->HASH_CSR[i];
 800dc92:	480c      	ldr	r0, [pc, #48]	; (800dcc4 <HASH_RestoreContext+0x68>)
 800dc94:	7bf9      	ldrb	r1, [r7, #15]
 800dc96:	7bfb      	ldrb	r3, [r7, #15]
 800dc98:	687a      	ldr	r2, [r7, #4]
 800dc9a:	3302      	adds	r3, #2
 800dc9c:	009b      	lsls	r3, r3, #2
 800dc9e:	4413      	add	r3, r2
 800dca0:	685a      	ldr	r2, [r3, #4]
 800dca2:	f101 033e 	add.w	r3, r1, #62	; 0x3e
 800dca6:	f840 2023 	str.w	r2, [r0, r3, lsl #2]
  for(i=0; i<=50;i++)
 800dcaa:	7bfb      	ldrb	r3, [r7, #15]
 800dcac:	3301      	adds	r3, #1
 800dcae:	73fb      	strb	r3, [r7, #15]
 800dcb0:	7bfb      	ldrb	r3, [r7, #15]
 800dcb2:	2b32      	cmp	r3, #50	; 0x32
 800dcb4:	d9ed      	bls.n	800dc92 <HASH_RestoreContext+0x36>
  }   
}
 800dcb6:	bf00      	nop
 800dcb8:	3714      	adds	r7, #20
 800dcba:	46bd      	mov	sp, r7
 800dcbc:	f85d 7b04 	ldr.w	r7, [sp], #4
 800dcc0:	4770      	bx	lr
 800dcc2:	bf00      	nop
 800dcc4:	50060400 	.word	0x50060400

0800dcc8 <HASH_DMACmd>:
  * @param  NewState: new state of the selected HASH DMA transfer request.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void HASH_DMACmd(FunctionalState NewState)
{
 800dcc8:	b480      	push	{r7}
 800dcca:	b083      	sub	sp, #12
 800dccc:	af00      	add	r7, sp, #0
 800dcce:	4603      	mov	r3, r0
 800dcd0:	71fb      	strb	r3, [r7, #7]
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 800dcd2:	79fb      	ldrb	r3, [r7, #7]
 800dcd4:	2b00      	cmp	r3, #0
 800dcd6:	d006      	beq.n	800dce6 <HASH_DMACmd+0x1e>
  {
    /* Enable the HASH DMA request */
    HASH->CR |= HASH_CR_DMAE;
 800dcd8:	4a09      	ldr	r2, [pc, #36]	; (800dd00 <HASH_DMACmd+0x38>)
 800dcda:	4b09      	ldr	r3, [pc, #36]	; (800dd00 <HASH_DMACmd+0x38>)
 800dcdc:	681b      	ldr	r3, [r3, #0]
 800dcde:	f043 0308 	orr.w	r3, r3, #8
 800dce2:	6013      	str	r3, [r2, #0]
  else
  {
    /* Disable the HASH DMA request */
    HASH->CR &= ~HASH_CR_DMAE;
  }
}
 800dce4:	e005      	b.n	800dcf2 <HASH_DMACmd+0x2a>
    HASH->CR &= ~HASH_CR_DMAE;
 800dce6:	4a06      	ldr	r2, [pc, #24]	; (800dd00 <HASH_DMACmd+0x38>)
 800dce8:	4b05      	ldr	r3, [pc, #20]	; (800dd00 <HASH_DMACmd+0x38>)
 800dcea:	681b      	ldr	r3, [r3, #0]
 800dcec:	f023 0308 	bic.w	r3, r3, #8
 800dcf0:	6013      	str	r3, [r2, #0]
}
 800dcf2:	bf00      	nop
 800dcf4:	370c      	adds	r7, #12
 800dcf6:	46bd      	mov	sp, r7
 800dcf8:	f85d 7b04 	ldr.w	r7, [sp], #4
 800dcfc:	4770      	bx	lr
 800dcfe:	bf00      	nop
 800dd00:	50060400 	.word	0x50060400

0800dd04 <HASH_ITConfig>:
  * @param  NewState: new state of the specified HASH interrupt.
  *           This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void HASH_ITConfig(uint8_t HASH_IT, FunctionalState NewState)
{
 800dd04:	b480      	push	{r7}
 800dd06:	b083      	sub	sp, #12
 800dd08:	af00      	add	r7, sp, #0
 800dd0a:	4603      	mov	r3, r0
 800dd0c:	460a      	mov	r2, r1
 800dd0e:	71fb      	strb	r3, [r7, #7]
 800dd10:	4613      	mov	r3, r2
 800dd12:	71bb      	strb	r3, [r7, #6]
  /* Check the parameters */
  assert_param(IS_HASH_IT(HASH_IT));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 800dd14:	79bb      	ldrb	r3, [r7, #6]
 800dd16:	2b00      	cmp	r3, #0
 800dd18:	d006      	beq.n	800dd28 <HASH_ITConfig+0x24>
  {
    /* Enable the selected HASH interrupt */
    HASH->IMR |= HASH_IT;
 800dd1a:	490a      	ldr	r1, [pc, #40]	; (800dd44 <HASH_ITConfig+0x40>)
 800dd1c:	4b09      	ldr	r3, [pc, #36]	; (800dd44 <HASH_ITConfig+0x40>)
 800dd1e:	6a1a      	ldr	r2, [r3, #32]
 800dd20:	79fb      	ldrb	r3, [r7, #7]
 800dd22:	4313      	orrs	r3, r2
 800dd24:	620b      	str	r3, [r1, #32]
  else
  {
    /* Disable the selected HASH interrupt */
    HASH->IMR &= (uint8_t) ~HASH_IT;
  }
}
 800dd26:	e007      	b.n	800dd38 <HASH_ITConfig+0x34>
    HASH->IMR &= (uint8_t) ~HASH_IT;
 800dd28:	4906      	ldr	r1, [pc, #24]	; (800dd44 <HASH_ITConfig+0x40>)
 800dd2a:	4b06      	ldr	r3, [pc, #24]	; (800dd44 <HASH_ITConfig+0x40>)
 800dd2c:	6a1b      	ldr	r3, [r3, #32]
 800dd2e:	79fa      	ldrb	r2, [r7, #7]
 800dd30:	43d2      	mvns	r2, r2
 800dd32:	b2d2      	uxtb	r2, r2
 800dd34:	4013      	ands	r3, r2
 800dd36:	620b      	str	r3, [r1, #32]
}
 800dd38:	bf00      	nop
 800dd3a:	370c      	adds	r7, #12
 800dd3c:	46bd      	mov	sp, r7
 800dd3e:	f85d 7b04 	ldr.w	r7, [sp], #4
 800dd42:	4770      	bx	lr
 800dd44:	50060400 	.word	0x50060400

0800dd48 <HASH_GetFlagStatus>:
  *            @arg HASH_FLAG_DMAS: DMAS Status flag
  *            @arg HASH_FLAG_DINNE: Data Input register (DIN) not empty status flag
  * @retval The new state of HASH_FLAG (SET or RESET)
  */
FlagStatus HASH_GetFlagStatus(uint16_t HASH_FLAG)
{
 800dd48:	b480      	push	{r7}
 800dd4a:	b085      	sub	sp, #20
 800dd4c:	af00      	add	r7, sp, #0
 800dd4e:	4603      	mov	r3, r0
 800dd50:	80fb      	strh	r3, [r7, #6]
  FlagStatus bitstatus = RESET;
 800dd52:	2300      	movs	r3, #0
 800dd54:	73fb      	strb	r3, [r7, #15]
  uint32_t tempreg = 0;
 800dd56:	2300      	movs	r3, #0
 800dd58:	60bb      	str	r3, [r7, #8]

  /* Check the parameters */
  assert_param(IS_HASH_GET_FLAG(HASH_FLAG));

  /* check if the FLAG is in CR register */
  if ((HASH_FLAG & HASH_FLAG_DINNE) != (uint16_t)RESET ) 
 800dd5a:	88fb      	ldrh	r3, [r7, #6]
 800dd5c:	f403 5380 	and.w	r3, r3, #4096	; 0x1000
 800dd60:	2b00      	cmp	r3, #0
 800dd62:	d003      	beq.n	800dd6c <HASH_GetFlagStatus+0x24>
  {
    tempreg = HASH->CR;
 800dd64:	4b0b      	ldr	r3, [pc, #44]	; (800dd94 <HASH_GetFlagStatus+0x4c>)
 800dd66:	681b      	ldr	r3, [r3, #0]
 800dd68:	60bb      	str	r3, [r7, #8]
 800dd6a:	e002      	b.n	800dd72 <HASH_GetFlagStatus+0x2a>
  }
  else /* The FLAG is in SR register */
  {
    tempreg = HASH->SR;
 800dd6c:	4b09      	ldr	r3, [pc, #36]	; (800dd94 <HASH_GetFlagStatus+0x4c>)
 800dd6e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800dd70:	60bb      	str	r3, [r7, #8]
  }

  /* Check the status of the specified HASH flag */
  if ((tempreg & HASH_FLAG) != (uint16_t)RESET)
 800dd72:	88fa      	ldrh	r2, [r7, #6]
 800dd74:	68bb      	ldr	r3, [r7, #8]
 800dd76:	4013      	ands	r3, r2
 800dd78:	2b00      	cmp	r3, #0
 800dd7a:	d002      	beq.n	800dd82 <HASH_GetFlagStatus+0x3a>
  {
    /* HASH is set */
    bitstatus = SET;
 800dd7c:	2301      	movs	r3, #1
 800dd7e:	73fb      	strb	r3, [r7, #15]
 800dd80:	e001      	b.n	800dd86 <HASH_GetFlagStatus+0x3e>
  }
  else
  {
    /* HASH_FLAG is reset */
    bitstatus = RESET;
 800dd82:	2300      	movs	r3, #0
 800dd84:	73fb      	strb	r3, [r7, #15]
  }

  /* Return the HASH_FLAG status */
  return  bitstatus;
 800dd86:	7bfb      	ldrb	r3, [r7, #15]
}
 800dd88:	4618      	mov	r0, r3
 800dd8a:	3714      	adds	r7, #20
 800dd8c:	46bd      	mov	sp, r7
 800dd8e:	f85d 7b04 	ldr.w	r7, [sp], #4
 800dd92:	4770      	bx	lr
 800dd94:	50060400 	.word	0x50060400

0800dd98 <HASH_ClearFlag>:
  *            @arg HASH_FLAG_DINIS: Data Input Flag
  *            @arg HASH_FLAG_DCIS: Digest Calculation Completion Flag                       
  * @retval None
  */
void HASH_ClearFlag(uint16_t HASH_FLAG)
{
 800dd98:	b480      	push	{r7}
 800dd9a:	b083      	sub	sp, #12
 800dd9c:	af00      	add	r7, sp, #0
 800dd9e:	4603      	mov	r3, r0
 800dda0:	80fb      	strh	r3, [r7, #6]
  /* Check the parameters */
  assert_param(IS_HASH_CLEAR_FLAG(HASH_FLAG));
  
  /* Clear the selected HASH flags */
  HASH->SR = ~(uint32_t)HASH_FLAG;
 800dda2:	4a05      	ldr	r2, [pc, #20]	; (800ddb8 <HASH_ClearFlag+0x20>)
 800dda4:	88fb      	ldrh	r3, [r7, #6]
 800dda6:	43db      	mvns	r3, r3
 800dda8:	6253      	str	r3, [r2, #36]	; 0x24
}
 800ddaa:	bf00      	nop
 800ddac:	370c      	adds	r7, #12
 800ddae:	46bd      	mov	sp, r7
 800ddb0:	f85d 7b04 	ldr.w	r7, [sp], #4
 800ddb4:	4770      	bx	lr
 800ddb6:	bf00      	nop
 800ddb8:	50060400 	.word	0x50060400

0800ddbc <HASH_GetITStatus>:
  *            @arg HASH_IT_DINI: Data Input interrupt
  *            @arg HASH_IT_DCI: Digest Calculation Completion Interrupt
  * @retval The new state of HASH_IT (SET or RESET).
  */
ITStatus HASH_GetITStatus(uint8_t HASH_IT)
{
 800ddbc:	b480      	push	{r7}
 800ddbe:	b085      	sub	sp, #20
 800ddc0:	af00      	add	r7, sp, #0
 800ddc2:	4603      	mov	r3, r0
 800ddc4:	71fb      	strb	r3, [r7, #7]
  ITStatus bitstatus = RESET;
 800ddc6:	2300      	movs	r3, #0
 800ddc8:	73fb      	strb	r3, [r7, #15]
  uint32_t tmpreg = 0;
 800ddca:	2300      	movs	r3, #0
 800ddcc:	60bb      	str	r3, [r7, #8]
  /* Check the parameters */
  assert_param(IS_HASH_GET_IT(HASH_IT));  


  /* Check the status of the specified HASH interrupt */
  tmpreg =  HASH->SR;
 800ddce:	4b0b      	ldr	r3, [pc, #44]	; (800ddfc <HASH_GetITStatus+0x40>)
 800ddd0:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800ddd2:	60bb      	str	r3, [r7, #8]

  if (((HASH->IMR & tmpreg) & HASH_IT) != RESET)
 800ddd4:	4b09      	ldr	r3, [pc, #36]	; (800ddfc <HASH_GetITStatus+0x40>)
 800ddd6:	6a1a      	ldr	r2, [r3, #32]
 800ddd8:	68bb      	ldr	r3, [r7, #8]
 800ddda:	401a      	ands	r2, r3
 800dddc:	79fb      	ldrb	r3, [r7, #7]
 800ddde:	4013      	ands	r3, r2
 800dde0:	2b00      	cmp	r3, #0
 800dde2:	d002      	beq.n	800ddea <HASH_GetITStatus+0x2e>
  {
    /* HASH_IT is set */
    bitstatus = SET;
 800dde4:	2301      	movs	r3, #1
 800dde6:	73fb      	strb	r3, [r7, #15]
 800dde8:	e001      	b.n	800ddee <HASH_GetITStatus+0x32>
  }
  else
  {
    /* HASH_IT is reset */
    bitstatus = RESET;
 800ddea:	2300      	movs	r3, #0
 800ddec:	73fb      	strb	r3, [r7, #15]
  }
  /* Return the HASH_IT status */
  return bitstatus;
 800ddee:	7bfb      	ldrb	r3, [r7, #15]
}
 800ddf0:	4618      	mov	r0, r3
 800ddf2:	3714      	adds	r7, #20
 800ddf4:	46bd      	mov	sp, r7
 800ddf6:	f85d 7b04 	ldr.w	r7, [sp], #4
 800ddfa:	4770      	bx	lr
 800ddfc:	50060400 	.word	0x50060400

0800de00 <HASH_ClearITPendingBit>:
  *            @arg HASH_IT_DINI: Data Input interrupt
  *            @arg HASH_IT_DCI: Digest Calculation Completion Interrupt
  * @retval None
  */
void HASH_ClearITPendingBit(uint8_t HASH_IT)
{
 800de00:	b480      	push	{r7}
 800de02:	b083      	sub	sp, #12
 800de04:	af00      	add	r7, sp, #0
 800de06:	4603      	mov	r3, r0
 800de08:	71fb      	strb	r3, [r7, #7]
  /* Check the parameters */
  assert_param(IS_HASH_IT(HASH_IT));

  /* Clear the selected HASH interrupt pending bit */
  HASH->SR = (uint8_t)~HASH_IT;
 800de0a:	4a05      	ldr	r2, [pc, #20]	; (800de20 <HASH_ClearITPendingBit+0x20>)
 800de0c:	79fb      	ldrb	r3, [r7, #7]
 800de0e:	43db      	mvns	r3, r3
 800de10:	b2db      	uxtb	r3, r3
 800de12:	6253      	str	r3, [r2, #36]	; 0x24
}
 800de14:	bf00      	nop
 800de16:	370c      	adds	r7, #12
 800de18:	46bd      	mov	sp, r7
 800de1a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800de1e:	4770      	bx	lr
 800de20:	50060400 	.word	0x50060400

0800de24 <HASH_MD5>:
  * @retval An ErrorStatus enumeration value:
  *          - SUCCESS: digest computation done
  *          - ERROR: digest computation failed
  */
ErrorStatus HASH_MD5(uint8_t *Input, uint32_t Ilen, uint8_t Output[16])
{
 800de24:	b580      	push	{r7, lr}
 800de26:	b09c      	sub	sp, #112	; 0x70
 800de28:	af00      	add	r7, sp, #0
 800de2a:	60f8      	str	r0, [r7, #12]
 800de2c:	60b9      	str	r1, [r7, #8]
 800de2e:	607a      	str	r2, [r7, #4]
  HASH_InitTypeDef MD5_HASH_InitStructure;
  HASH_MsgDigest MD5_MessageDigest;
  __IO uint16_t nbvalidbitsdata = 0;
 800de30:	2300      	movs	r3, #0
 800de32:	82fb      	strh	r3, [r7, #22]
  uint32_t i = 0;
 800de34:	2300      	movs	r3, #0
 800de36:	66fb      	str	r3, [r7, #108]	; 0x6c
  __IO uint32_t counter = 0;
 800de38:	2300      	movs	r3, #0
 800de3a:	613b      	str	r3, [r7, #16]
  uint32_t busystatus = 0;
 800de3c:	2300      	movs	r3, #0
 800de3e:	663b      	str	r3, [r7, #96]	; 0x60
  ErrorStatus status = SUCCESS;
 800de40:	2301      	movs	r3, #1
 800de42:	f887 306b 	strb.w	r3, [r7, #107]	; 0x6b
  uint32_t inputaddr  = (uint32_t)Input;
 800de46:	68fb      	ldr	r3, [r7, #12]
 800de48:	667b      	str	r3, [r7, #100]	; 0x64
  uint32_t outputaddr = (uint32_t)Output;
 800de4a:	687b      	ldr	r3, [r7, #4]
 800de4c:	65fb      	str	r3, [r7, #92]	; 0x5c


  /* Number of valid bits in last word of the Input data */
  nbvalidbitsdata = 8 * (Ilen % 4);
 800de4e:	68bb      	ldr	r3, [r7, #8]
 800de50:	b29b      	uxth	r3, r3
 800de52:	f003 0303 	and.w	r3, r3, #3
 800de56:	b29b      	uxth	r3, r3
 800de58:	00db      	lsls	r3, r3, #3
 800de5a:	b29b      	uxth	r3, r3
 800de5c:	82fb      	strh	r3, [r7, #22]

  /* HASH peripheral initialization */
  HASH_DeInit();
 800de5e:	f7ff fdfd 	bl	800da5c <HASH_DeInit>

  /* HASH Configuration */
  MD5_HASH_InitStructure.HASH_AlgoSelection = HASH_AlgoSelection_MD5;
 800de62:	2380      	movs	r3, #128	; 0x80
 800de64:	62fb      	str	r3, [r7, #44]	; 0x2c
  MD5_HASH_InitStructure.HASH_AlgoMode = HASH_AlgoMode_HASH;
 800de66:	2300      	movs	r3, #0
 800de68:	633b      	str	r3, [r7, #48]	; 0x30
  MD5_HASH_InitStructure.HASH_DataType = HASH_DataType_8b;
 800de6a:	2320      	movs	r3, #32
 800de6c:	637b      	str	r3, [r7, #52]	; 0x34
  HASH_Init(&MD5_HASH_InitStructure);
 800de6e:	f107 032c 	add.w	r3, r7, #44	; 0x2c
 800de72:	4618      	mov	r0, r3
 800de74:	f7ff fdfe 	bl	800da74 <HASH_Init>

  /* Configure the number of valid bits in last word of the data */
  HASH_SetLastWordValidBitsNbr(nbvalidbitsdata);
 800de78:	8afb      	ldrh	r3, [r7, #22]
 800de7a:	b29b      	uxth	r3, r3
 800de7c:	4618      	mov	r0, r3
 800de7e:	f7ff fe55 	bl	800db2c <HASH_SetLastWordValidBitsNbr>

  /* Write the Input block in the IN FIFO */
  for(i=0; i<Ilen; i+=4)
 800de82:	2300      	movs	r3, #0
 800de84:	66fb      	str	r3, [r7, #108]	; 0x6c
 800de86:	e00a      	b.n	800de9e <HASH_MD5+0x7a>
  {
    HASH_DataIn(*(uint32_t*)inputaddr);
 800de88:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 800de8a:	681b      	ldr	r3, [r3, #0]
 800de8c:	4618      	mov	r0, r3
 800de8e:	f7ff fe67 	bl	800db60 <HASH_DataIn>
    inputaddr+=4;
 800de92:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 800de94:	3304      	adds	r3, #4
 800de96:	667b      	str	r3, [r7, #100]	; 0x64
  for(i=0; i<Ilen; i+=4)
 800de98:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 800de9a:	3304      	adds	r3, #4
 800de9c:	66fb      	str	r3, [r7, #108]	; 0x6c
 800de9e:	6efa      	ldr	r2, [r7, #108]	; 0x6c
 800dea0:	68bb      	ldr	r3, [r7, #8]
 800dea2:	429a      	cmp	r2, r3
 800dea4:	d3f0      	bcc.n	800de88 <HASH_MD5+0x64>
  }

  /* Start the HASH processor */
  HASH_StartDigest();
 800dea6:	f7ff fe9b 	bl	800dbe0 <HASH_StartDigest>

  /* wait until the Busy flag is RESET */
  do
  {
    busystatus = HASH_GetFlagStatus(HASH_FLAG_BUSY);
 800deaa:	2008      	movs	r0, #8
 800deac:	f7ff ff4c 	bl	800dd48 <HASH_GetFlagStatus>
 800deb0:	4603      	mov	r3, r0
 800deb2:	663b      	str	r3, [r7, #96]	; 0x60
    counter++;
 800deb4:	693b      	ldr	r3, [r7, #16]
 800deb6:	3301      	adds	r3, #1
 800deb8:	613b      	str	r3, [r7, #16]
  }while ((counter != MD5BUSY_TIMEOUT) && (busystatus != RESET));
 800deba:	693b      	ldr	r3, [r7, #16]
 800debc:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 800dec0:	d002      	beq.n	800dec8 <HASH_MD5+0xa4>
 800dec2:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 800dec4:	2b00      	cmp	r3, #0
 800dec6:	d1f0      	bne.n	800deaa <HASH_MD5+0x86>

  if (busystatus != RESET)
 800dec8:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 800deca:	2b00      	cmp	r3, #0
 800decc:	d003      	beq.n	800ded6 <HASH_MD5+0xb2>
  {
     status = ERROR;
 800dece:	2300      	movs	r3, #0
 800ded0:	f887 306b 	strb.w	r3, [r7, #107]	; 0x6b
 800ded4:	e02d      	b.n	800df32 <HASH_MD5+0x10e>
  }
  else
  {
    /* Read the message digest */
    HASH_GetDigest(&MD5_MessageDigest);
 800ded6:	f107 0318 	add.w	r3, r7, #24
 800deda:	4618      	mov	r0, r3
 800dedc:	f7ff fe60 	bl	800dba0 <HASH_GetDigest>
    *(uint32_t*)(outputaddr)  = __REV(MD5_MessageDigest.Data[0]);
 800dee0:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 800dee2:	69ba      	ldr	r2, [r7, #24]
 800dee4:	643a      	str	r2, [r7, #64]	; 0x40
  __ASM volatile ("rev %0, %1" : "=r" (result) : "r" (value) );
 800dee6:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 800dee8:	ba12      	rev	r2, r2
 800deea:	63fa      	str	r2, [r7, #60]	; 0x3c
  return(result);
 800deec:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 800deee:	601a      	str	r2, [r3, #0]
    outputaddr+=4;
 800def0:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 800def2:	3304      	adds	r3, #4
 800def4:	65fb      	str	r3, [r7, #92]	; 0x5c
    *(uint32_t*)(outputaddr)  = __REV(MD5_MessageDigest.Data[1]);
 800def6:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 800def8:	69fa      	ldr	r2, [r7, #28]
 800defa:	64ba      	str	r2, [r7, #72]	; 0x48
  __ASM volatile ("rev %0, %1" : "=r" (result) : "r" (value) );
 800defc:	6cba      	ldr	r2, [r7, #72]	; 0x48
 800defe:	ba12      	rev	r2, r2
 800df00:	647a      	str	r2, [r7, #68]	; 0x44
  return(result);
 800df02:	6c7a      	ldr	r2, [r7, #68]	; 0x44
 800df04:	601a      	str	r2, [r3, #0]
    outputaddr+=4;
 800df06:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 800df08:	3304      	adds	r3, #4
 800df0a:	65fb      	str	r3, [r7, #92]	; 0x5c
    *(uint32_t*)(outputaddr)  = __REV(MD5_MessageDigest.Data[2]);
 800df0c:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 800df0e:	6a3a      	ldr	r2, [r7, #32]
 800df10:	653a      	str	r2, [r7, #80]	; 0x50
  __ASM volatile ("rev %0, %1" : "=r" (result) : "r" (value) );
 800df12:	6d3a      	ldr	r2, [r7, #80]	; 0x50
 800df14:	ba12      	rev	r2, r2
 800df16:	64fa      	str	r2, [r7, #76]	; 0x4c
  return(result);
 800df18:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
 800df1a:	601a      	str	r2, [r3, #0]
    outputaddr+=4;
 800df1c:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 800df1e:	3304      	adds	r3, #4
 800df20:	65fb      	str	r3, [r7, #92]	; 0x5c
    *(uint32_t*)(outputaddr)  = __REV(MD5_MessageDigest.Data[3]);
 800df22:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 800df24:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 800df26:	65ba      	str	r2, [r7, #88]	; 0x58
  __ASM volatile ("rev %0, %1" : "=r" (result) : "r" (value) );
 800df28:	6dba      	ldr	r2, [r7, #88]	; 0x58
 800df2a:	ba12      	rev	r2, r2
 800df2c:	657a      	str	r2, [r7, #84]	; 0x54
  return(result);
 800df2e:	6d7a      	ldr	r2, [r7, #84]	; 0x54
 800df30:	601a      	str	r2, [r3, #0]
  }
  return status; 
 800df32:	f897 306b 	ldrb.w	r3, [r7, #107]	; 0x6b
}
 800df36:	4618      	mov	r0, r3
 800df38:	3770      	adds	r7, #112	; 0x70
 800df3a:	46bd      	mov	sp, r7
 800df3c:	bd80      	pop	{r7, pc}

0800df3e <HMAC_MD5>:
  *          - SUCCESS: digest computation done
  *          - ERROR: digest computation failed
  */
ErrorStatus HMAC_MD5(uint8_t *Key, uint32_t Keylen, uint8_t *Input, 
                     uint32_t Ilen, uint8_t Output[16])
{
 800df3e:	b580      	push	{r7, lr}
 800df40:	b09e      	sub	sp, #120	; 0x78
 800df42:	af00      	add	r7, sp, #0
 800df44:	60f8      	str	r0, [r7, #12]
 800df46:	60b9      	str	r1, [r7, #8]
 800df48:	607a      	str	r2, [r7, #4]
 800df4a:	603b      	str	r3, [r7, #0]
  HASH_InitTypeDef MD5_HASH_InitStructure;
  HASH_MsgDigest MD5_MessageDigest;
  __IO uint16_t nbvalidbitsdata = 0;
 800df4c:	2300      	movs	r3, #0
 800df4e:	837b      	strh	r3, [r7, #26]
  __IO uint16_t nbvalidbitskey = 0;
 800df50:	2300      	movs	r3, #0
 800df52:	833b      	strh	r3, [r7, #24]
  uint32_t i = 0;
 800df54:	2300      	movs	r3, #0
 800df56:	677b      	str	r3, [r7, #116]	; 0x74
  __IO uint32_t counter = 0;
 800df58:	2300      	movs	r3, #0
 800df5a:	617b      	str	r3, [r7, #20]
  uint32_t busystatus = 0;
 800df5c:	2300      	movs	r3, #0
 800df5e:	667b      	str	r3, [r7, #100]	; 0x64
  ErrorStatus status = SUCCESS;
 800df60:	2301      	movs	r3, #1
 800df62:	f887 3073 	strb.w	r3, [r7, #115]	; 0x73
  uint32_t keyaddr    = (uint32_t)Key;
 800df66:	68fb      	ldr	r3, [r7, #12]
 800df68:	66fb      	str	r3, [r7, #108]	; 0x6c
  uint32_t inputaddr  = (uint32_t)Input;
 800df6a:	687b      	ldr	r3, [r7, #4]
 800df6c:	66bb      	str	r3, [r7, #104]	; 0x68
  uint32_t outputaddr = (uint32_t)Output;
 800df6e:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
 800df72:	663b      	str	r3, [r7, #96]	; 0x60

  /* Number of valid bits in last word of the Input data */
  nbvalidbitsdata = 8 * (Ilen % 4);
 800df74:	683b      	ldr	r3, [r7, #0]
 800df76:	b29b      	uxth	r3, r3
 800df78:	f003 0303 	and.w	r3, r3, #3
 800df7c:	b29b      	uxth	r3, r3
 800df7e:	00db      	lsls	r3, r3, #3
 800df80:	b29b      	uxth	r3, r3
 800df82:	837b      	strh	r3, [r7, #26]

  /* Number of valid bits in last word of the Key */
  nbvalidbitskey = 8 * (Keylen % 4);
 800df84:	68bb      	ldr	r3, [r7, #8]
 800df86:	b29b      	uxth	r3, r3
 800df88:	f003 0303 	and.w	r3, r3, #3
 800df8c:	b29b      	uxth	r3, r3
 800df8e:	00db      	lsls	r3, r3, #3
 800df90:	b29b      	uxth	r3, r3
 800df92:	833b      	strh	r3, [r7, #24]
   
  /* HASH peripheral initialization */
  HASH_DeInit();
 800df94:	f7ff fd62 	bl	800da5c <HASH_DeInit>

  /* HASH Configuration */
  MD5_HASH_InitStructure.HASH_AlgoSelection = HASH_AlgoSelection_MD5;
 800df98:	2380      	movs	r3, #128	; 0x80
 800df9a:	633b      	str	r3, [r7, #48]	; 0x30
  MD5_HASH_InitStructure.HASH_AlgoMode = HASH_AlgoMode_HMAC;
 800df9c:	2340      	movs	r3, #64	; 0x40
 800df9e:	637b      	str	r3, [r7, #52]	; 0x34
  MD5_HASH_InitStructure.HASH_DataType = HASH_DataType_8b;
 800dfa0:	2320      	movs	r3, #32
 800dfa2:	63bb      	str	r3, [r7, #56]	; 0x38
  if(Keylen > 64)
 800dfa4:	68bb      	ldr	r3, [r7, #8]
 800dfa6:	2b40      	cmp	r3, #64	; 0x40
 800dfa8:	d903      	bls.n	800dfb2 <HMAC_MD5+0x74>
  {
    /* HMAC long Key */
    MD5_HASH_InitStructure.HASH_HMACKeyType = HASH_HMACKeyType_LongKey;
 800dfaa:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 800dfae:	63fb      	str	r3, [r7, #60]	; 0x3c
 800dfb0:	e001      	b.n	800dfb6 <HMAC_MD5+0x78>
  }
  else
  {
    /* HMAC short Key */
    MD5_HASH_InitStructure.HASH_HMACKeyType = HASH_HMACKeyType_ShortKey;
 800dfb2:	2300      	movs	r3, #0
 800dfb4:	63fb      	str	r3, [r7, #60]	; 0x3c
  }
  HASH_Init(&MD5_HASH_InitStructure);
 800dfb6:	f107 0330 	add.w	r3, r7, #48	; 0x30
 800dfba:	4618      	mov	r0, r3
 800dfbc:	f7ff fd5a 	bl	800da74 <HASH_Init>

  /* Configure the number of valid bits in last word of the Key */
  HASH_SetLastWordValidBitsNbr(nbvalidbitskey);
 800dfc0:	8b3b      	ldrh	r3, [r7, #24]
 800dfc2:	b29b      	uxth	r3, r3
 800dfc4:	4618      	mov	r0, r3
 800dfc6:	f7ff fdb1 	bl	800db2c <HASH_SetLastWordValidBitsNbr>

  /* Write the Key */
  for(i=0; i<Keylen; i+=4)
 800dfca:	2300      	movs	r3, #0
 800dfcc:	677b      	str	r3, [r7, #116]	; 0x74
 800dfce:	e00a      	b.n	800dfe6 <HMAC_MD5+0xa8>
  {
    HASH_DataIn(*(uint32_t*)keyaddr);
 800dfd0:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 800dfd2:	681b      	ldr	r3, [r3, #0]
 800dfd4:	4618      	mov	r0, r3
 800dfd6:	f7ff fdc3 	bl	800db60 <HASH_DataIn>
    keyaddr+=4;
 800dfda:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 800dfdc:	3304      	adds	r3, #4
 800dfde:	66fb      	str	r3, [r7, #108]	; 0x6c
  for(i=0; i<Keylen; i+=4)
 800dfe0:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 800dfe2:	3304      	adds	r3, #4
 800dfe4:	677b      	str	r3, [r7, #116]	; 0x74
 800dfe6:	6f7a      	ldr	r2, [r7, #116]	; 0x74
 800dfe8:	68bb      	ldr	r3, [r7, #8]
 800dfea:	429a      	cmp	r2, r3
 800dfec:	d3f0      	bcc.n	800dfd0 <HMAC_MD5+0x92>
  }
  
  /* Start the HASH processor */
  HASH_StartDigest();
 800dfee:	f7ff fdf7 	bl	800dbe0 <HASH_StartDigest>

  /* wait until the Busy flag is RESET */
  do
  {
    busystatus = HASH_GetFlagStatus(HASH_FLAG_BUSY);
 800dff2:	2008      	movs	r0, #8
 800dff4:	f7ff fea8 	bl	800dd48 <HASH_GetFlagStatus>
 800dff8:	4603      	mov	r3, r0
 800dffa:	667b      	str	r3, [r7, #100]	; 0x64
    counter++;
 800dffc:	697b      	ldr	r3, [r7, #20]
 800dffe:	3301      	adds	r3, #1
 800e000:	617b      	str	r3, [r7, #20]
  }while ((counter != MD5BUSY_TIMEOUT) && (busystatus != RESET));
 800e002:	697b      	ldr	r3, [r7, #20]
 800e004:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 800e008:	d002      	beq.n	800e010 <HMAC_MD5+0xd2>
 800e00a:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 800e00c:	2b00      	cmp	r3, #0
 800e00e:	d1f0      	bne.n	800dff2 <HMAC_MD5+0xb4>

  if (busystatus != RESET)
 800e010:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 800e012:	2b00      	cmp	r3, #0
 800e014:	d003      	beq.n	800e01e <HMAC_MD5+0xe0>
  {
     status = ERROR;
 800e016:	2300      	movs	r3, #0
 800e018:	f887 3073 	strb.w	r3, [r7, #115]	; 0x73
 800e01c:	e091      	b.n	800e142 <HMAC_MD5+0x204>
  }
  else
  {
    /* Configure the number of valid bits in last word of the Input data */
    HASH_SetLastWordValidBitsNbr(nbvalidbitsdata);
 800e01e:	8b7b      	ldrh	r3, [r7, #26]
 800e020:	b29b      	uxth	r3, r3
 800e022:	4618      	mov	r0, r3
 800e024:	f7ff fd82 	bl	800db2c <HASH_SetLastWordValidBitsNbr>

    /* Write the Input block in the IN FIFO */
    for(i=0; i<Ilen; i+=4)
 800e028:	2300      	movs	r3, #0
 800e02a:	677b      	str	r3, [r7, #116]	; 0x74
 800e02c:	e00a      	b.n	800e044 <HMAC_MD5+0x106>
    {
      HASH_DataIn(*(uint32_t*)inputaddr);
 800e02e:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 800e030:	681b      	ldr	r3, [r3, #0]
 800e032:	4618      	mov	r0, r3
 800e034:	f7ff fd94 	bl	800db60 <HASH_DataIn>
      inputaddr+=4;
 800e038:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 800e03a:	3304      	adds	r3, #4
 800e03c:	66bb      	str	r3, [r7, #104]	; 0x68
    for(i=0; i<Ilen; i+=4)
 800e03e:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 800e040:	3304      	adds	r3, #4
 800e042:	677b      	str	r3, [r7, #116]	; 0x74
 800e044:	6f7a      	ldr	r2, [r7, #116]	; 0x74
 800e046:	683b      	ldr	r3, [r7, #0]
 800e048:	429a      	cmp	r2, r3
 800e04a:	d3f0      	bcc.n	800e02e <HMAC_MD5+0xf0>
    }

    /* Start the HASH processor */
    HASH_StartDigest();
 800e04c:	f7ff fdc8 	bl	800dbe0 <HASH_StartDigest>

    /* wait until the Busy flag is RESET */
    counter =0;
 800e050:	2300      	movs	r3, #0
 800e052:	617b      	str	r3, [r7, #20]
    do
    {
       busystatus = HASH_GetFlagStatus(HASH_FLAG_BUSY);
 800e054:	2008      	movs	r0, #8
 800e056:	f7ff fe77 	bl	800dd48 <HASH_GetFlagStatus>
 800e05a:	4603      	mov	r3, r0
 800e05c:	667b      	str	r3, [r7, #100]	; 0x64
       counter++;
 800e05e:	697b      	ldr	r3, [r7, #20]
 800e060:	3301      	adds	r3, #1
 800e062:	617b      	str	r3, [r7, #20]
    }while ((counter != MD5BUSY_TIMEOUT) && (busystatus != RESET));
 800e064:	697b      	ldr	r3, [r7, #20]
 800e066:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 800e06a:	d002      	beq.n	800e072 <HMAC_MD5+0x134>
 800e06c:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 800e06e:	2b00      	cmp	r3, #0
 800e070:	d1f0      	bne.n	800e054 <HMAC_MD5+0x116>

    if (busystatus != RESET)
 800e072:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 800e074:	2b00      	cmp	r3, #0
 800e076:	d003      	beq.n	800e080 <HMAC_MD5+0x142>
    {
      status = ERROR;
 800e078:	2300      	movs	r3, #0
 800e07a:	f887 3073 	strb.w	r3, [r7, #115]	; 0x73
 800e07e:	e060      	b.n	800e142 <HMAC_MD5+0x204>
    }
    else
    {  
      /* Configure the number of valid bits in last word of the Key */
      HASH_SetLastWordValidBitsNbr(nbvalidbitskey);
 800e080:	8b3b      	ldrh	r3, [r7, #24]
 800e082:	b29b      	uxth	r3, r3
 800e084:	4618      	mov	r0, r3
 800e086:	f7ff fd51 	bl	800db2c <HASH_SetLastWordValidBitsNbr>

      /* Write the Key */
      keyaddr = (uint32_t)Key;
 800e08a:	68fb      	ldr	r3, [r7, #12]
 800e08c:	66fb      	str	r3, [r7, #108]	; 0x6c
      for(i=0; i<Keylen; i+=4)
 800e08e:	2300      	movs	r3, #0
 800e090:	677b      	str	r3, [r7, #116]	; 0x74
 800e092:	e00a      	b.n	800e0aa <HMAC_MD5+0x16c>
      {
        HASH_DataIn(*(uint32_t*)keyaddr);
 800e094:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 800e096:	681b      	ldr	r3, [r3, #0]
 800e098:	4618      	mov	r0, r3
 800e09a:	f7ff fd61 	bl	800db60 <HASH_DataIn>
        keyaddr+=4;
 800e09e:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 800e0a0:	3304      	adds	r3, #4
 800e0a2:	66fb      	str	r3, [r7, #108]	; 0x6c
      for(i=0; i<Keylen; i+=4)
 800e0a4:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 800e0a6:	3304      	adds	r3, #4
 800e0a8:	677b      	str	r3, [r7, #116]	; 0x74
 800e0aa:	6f7a      	ldr	r2, [r7, #116]	; 0x74
 800e0ac:	68bb      	ldr	r3, [r7, #8]
 800e0ae:	429a      	cmp	r2, r3
 800e0b0:	d3f0      	bcc.n	800e094 <HMAC_MD5+0x156>
      }
  
       /* Start the HASH processor */
       HASH_StartDigest();
 800e0b2:	f7ff fd95 	bl	800dbe0 <HASH_StartDigest>

       /* wait until the Busy flag is RESET */
       counter =0;
 800e0b6:	2300      	movs	r3, #0
 800e0b8:	617b      	str	r3, [r7, #20]
       do
       {
          busystatus = HASH_GetFlagStatus(HASH_FLAG_BUSY);
 800e0ba:	2008      	movs	r0, #8
 800e0bc:	f7ff fe44 	bl	800dd48 <HASH_GetFlagStatus>
 800e0c0:	4603      	mov	r3, r0
 800e0c2:	667b      	str	r3, [r7, #100]	; 0x64
          counter++;
 800e0c4:	697b      	ldr	r3, [r7, #20]
 800e0c6:	3301      	adds	r3, #1
 800e0c8:	617b      	str	r3, [r7, #20]
      }while ((counter != MD5BUSY_TIMEOUT) && (busystatus != RESET));
 800e0ca:	697b      	ldr	r3, [r7, #20]
 800e0cc:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 800e0d0:	d002      	beq.n	800e0d8 <HMAC_MD5+0x19a>
 800e0d2:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 800e0d4:	2b00      	cmp	r3, #0
 800e0d6:	d1f0      	bne.n	800e0ba <HMAC_MD5+0x17c>

      if (busystatus != RESET)
 800e0d8:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 800e0da:	2b00      	cmp	r3, #0
 800e0dc:	d003      	beq.n	800e0e6 <HMAC_MD5+0x1a8>
      {
         status = ERROR;
 800e0de:	2300      	movs	r3, #0
 800e0e0:	f887 3073 	strb.w	r3, [r7, #115]	; 0x73
 800e0e4:	e02d      	b.n	800e142 <HMAC_MD5+0x204>
      }
      else
      {
         /* Read the message digest */
         HASH_GetDigest(&MD5_MessageDigest);
 800e0e6:	f107 031c 	add.w	r3, r7, #28
 800e0ea:	4618      	mov	r0, r3
 800e0ec:	f7ff fd58 	bl	800dba0 <HASH_GetDigest>
         *(uint32_t*)(outputaddr)  = __REV(MD5_MessageDigest.Data[0]);
 800e0f0:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 800e0f2:	69fa      	ldr	r2, [r7, #28]
 800e0f4:	647a      	str	r2, [r7, #68]	; 0x44
  __ASM volatile ("rev %0, %1" : "=r" (result) : "r" (value) );
 800e0f6:	6c7a      	ldr	r2, [r7, #68]	; 0x44
 800e0f8:	ba12      	rev	r2, r2
 800e0fa:	643a      	str	r2, [r7, #64]	; 0x40
  return(result);
 800e0fc:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 800e0fe:	601a      	str	r2, [r3, #0]
         outputaddr+=4;
 800e100:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 800e102:	3304      	adds	r3, #4
 800e104:	663b      	str	r3, [r7, #96]	; 0x60
         *(uint32_t*)(outputaddr)  = __REV(MD5_MessageDigest.Data[1]);
 800e106:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 800e108:	6a3a      	ldr	r2, [r7, #32]
 800e10a:	64fa      	str	r2, [r7, #76]	; 0x4c
  __ASM volatile ("rev %0, %1" : "=r" (result) : "r" (value) );
 800e10c:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
 800e10e:	ba12      	rev	r2, r2
 800e110:	64ba      	str	r2, [r7, #72]	; 0x48
  return(result);
 800e112:	6cba      	ldr	r2, [r7, #72]	; 0x48
 800e114:	601a      	str	r2, [r3, #0]
         outputaddr+=4;
 800e116:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 800e118:	3304      	adds	r3, #4
 800e11a:	663b      	str	r3, [r7, #96]	; 0x60
         *(uint32_t*)(outputaddr)  = __REV(MD5_MessageDigest.Data[2]);
 800e11c:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 800e11e:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 800e120:	657a      	str	r2, [r7, #84]	; 0x54
  __ASM volatile ("rev %0, %1" : "=r" (result) : "r" (value) );
 800e122:	6d7a      	ldr	r2, [r7, #84]	; 0x54
 800e124:	ba12      	rev	r2, r2
 800e126:	653a      	str	r2, [r7, #80]	; 0x50
  return(result);
 800e128:	6d3a      	ldr	r2, [r7, #80]	; 0x50
 800e12a:	601a      	str	r2, [r3, #0]
         outputaddr+=4;
 800e12c:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 800e12e:	3304      	adds	r3, #4
 800e130:	663b      	str	r3, [r7, #96]	; 0x60
         *(uint32_t*)(outputaddr)  = __REV(MD5_MessageDigest.Data[3]);
 800e132:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 800e134:	6aba      	ldr	r2, [r7, #40]	; 0x28
 800e136:	65fa      	str	r2, [r7, #92]	; 0x5c
  __ASM volatile ("rev %0, %1" : "=r" (result) : "r" (value) );
 800e138:	6dfa      	ldr	r2, [r7, #92]	; 0x5c
 800e13a:	ba12      	rev	r2, r2
 800e13c:	65ba      	str	r2, [r7, #88]	; 0x58
  return(result);
 800e13e:	6dba      	ldr	r2, [r7, #88]	; 0x58
 800e140:	601a      	str	r2, [r3, #0]
      }
    }
  }
  return status;  
 800e142:	f897 3073 	ldrb.w	r3, [r7, #115]	; 0x73
}
 800e146:	4618      	mov	r0, r3
 800e148:	3778      	adds	r7, #120	; 0x78
 800e14a:	46bd      	mov	sp, r7
 800e14c:	bd80      	pop	{r7, pc}

0800e14e <HASH_SHA1>:
  * @retval An ErrorStatus enumeration value:
  *          - SUCCESS: digest computation done
  *          - ERROR: digest computation failed
  */
ErrorStatus HASH_SHA1(uint8_t *Input, uint32_t Ilen, uint8_t Output[20])
{
 800e14e:	b580      	push	{r7, lr}
 800e150:	b09e      	sub	sp, #120	; 0x78
 800e152:	af00      	add	r7, sp, #0
 800e154:	60f8      	str	r0, [r7, #12]
 800e156:	60b9      	str	r1, [r7, #8]
 800e158:	607a      	str	r2, [r7, #4]
  HASH_InitTypeDef SHA1_HASH_InitStructure;
  HASH_MsgDigest SHA1_MessageDigest;
  __IO uint16_t nbvalidbitsdata = 0;
 800e15a:	2300      	movs	r3, #0
 800e15c:	82fb      	strh	r3, [r7, #22]
  uint32_t i = 0;
 800e15e:	2300      	movs	r3, #0
 800e160:	677b      	str	r3, [r7, #116]	; 0x74
  __IO uint32_t counter = 0;
 800e162:	2300      	movs	r3, #0
 800e164:	613b      	str	r3, [r7, #16]
  uint32_t busystatus = 0;
 800e166:	2300      	movs	r3, #0
 800e168:	66bb      	str	r3, [r7, #104]	; 0x68
  ErrorStatus status = SUCCESS;
 800e16a:	2301      	movs	r3, #1
 800e16c:	f887 3073 	strb.w	r3, [r7, #115]	; 0x73
  uint32_t inputaddr  = (uint32_t)Input;
 800e170:	68fb      	ldr	r3, [r7, #12]
 800e172:	66fb      	str	r3, [r7, #108]	; 0x6c
  uint32_t outputaddr = (uint32_t)Output;
 800e174:	687b      	ldr	r3, [r7, #4]
 800e176:	667b      	str	r3, [r7, #100]	; 0x64

  /* Number of valid bits in last word of the Input data */
  nbvalidbitsdata = 8 * (Ilen % 4);
 800e178:	68bb      	ldr	r3, [r7, #8]
 800e17a:	b29b      	uxth	r3, r3
 800e17c:	f003 0303 	and.w	r3, r3, #3
 800e180:	b29b      	uxth	r3, r3
 800e182:	00db      	lsls	r3, r3, #3
 800e184:	b29b      	uxth	r3, r3
 800e186:	82fb      	strh	r3, [r7, #22]

  /* HASH peripheral initialization */
  HASH_DeInit();
 800e188:	f7ff fc68 	bl	800da5c <HASH_DeInit>

  /* HASH Configuration */
  SHA1_HASH_InitStructure.HASH_AlgoSelection = HASH_AlgoSelection_SHA1;
 800e18c:	2300      	movs	r3, #0
 800e18e:	62fb      	str	r3, [r7, #44]	; 0x2c
  SHA1_HASH_InitStructure.HASH_AlgoMode = HASH_AlgoMode_HASH;
 800e190:	2300      	movs	r3, #0
 800e192:	633b      	str	r3, [r7, #48]	; 0x30
  SHA1_HASH_InitStructure.HASH_DataType = HASH_DataType_8b;
 800e194:	2320      	movs	r3, #32
 800e196:	637b      	str	r3, [r7, #52]	; 0x34
  HASH_Init(&SHA1_HASH_InitStructure);
 800e198:	f107 032c 	add.w	r3, r7, #44	; 0x2c
 800e19c:	4618      	mov	r0, r3
 800e19e:	f7ff fc69 	bl	800da74 <HASH_Init>

  /* Configure the number of valid bits in last word of the data */
  HASH_SetLastWordValidBitsNbr(nbvalidbitsdata);
 800e1a2:	8afb      	ldrh	r3, [r7, #22]
 800e1a4:	b29b      	uxth	r3, r3
 800e1a6:	4618      	mov	r0, r3
 800e1a8:	f7ff fcc0 	bl	800db2c <HASH_SetLastWordValidBitsNbr>

  /* Write the Input block in the IN FIFO */
  for(i=0; i<Ilen; i+=4)
 800e1ac:	2300      	movs	r3, #0
 800e1ae:	677b      	str	r3, [r7, #116]	; 0x74
 800e1b0:	e00a      	b.n	800e1c8 <HASH_SHA1+0x7a>
  {
    HASH_DataIn(*(uint32_t*)inputaddr);
 800e1b2:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 800e1b4:	681b      	ldr	r3, [r3, #0]
 800e1b6:	4618      	mov	r0, r3
 800e1b8:	f7ff fcd2 	bl	800db60 <HASH_DataIn>
    inputaddr+=4;
 800e1bc:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 800e1be:	3304      	adds	r3, #4
 800e1c0:	66fb      	str	r3, [r7, #108]	; 0x6c
  for(i=0; i<Ilen; i+=4)
 800e1c2:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 800e1c4:	3304      	adds	r3, #4
 800e1c6:	677b      	str	r3, [r7, #116]	; 0x74
 800e1c8:	6f7a      	ldr	r2, [r7, #116]	; 0x74
 800e1ca:	68bb      	ldr	r3, [r7, #8]
 800e1cc:	429a      	cmp	r2, r3
 800e1ce:	d3f0      	bcc.n	800e1b2 <HASH_SHA1+0x64>
  }

  /* Start the HASH processor */
  HASH_StartDigest();
 800e1d0:	f7ff fd06 	bl	800dbe0 <HASH_StartDigest>

  /* wait until the Busy flag is RESET */
  do
  {
    busystatus = HASH_GetFlagStatus(HASH_FLAG_BUSY);
 800e1d4:	2008      	movs	r0, #8
 800e1d6:	f7ff fdb7 	bl	800dd48 <HASH_GetFlagStatus>
 800e1da:	4603      	mov	r3, r0
 800e1dc:	66bb      	str	r3, [r7, #104]	; 0x68
    counter++;
 800e1de:	693b      	ldr	r3, [r7, #16]
 800e1e0:	3301      	adds	r3, #1
 800e1e2:	613b      	str	r3, [r7, #16]
  }while ((counter != SHA1BUSY_TIMEOUT) && (busystatus != RESET));
 800e1e4:	693b      	ldr	r3, [r7, #16]
 800e1e6:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 800e1ea:	d002      	beq.n	800e1f2 <HASH_SHA1+0xa4>
 800e1ec:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 800e1ee:	2b00      	cmp	r3, #0
 800e1f0:	d1f0      	bne.n	800e1d4 <HASH_SHA1+0x86>

  if (busystatus != RESET)
 800e1f2:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 800e1f4:	2b00      	cmp	r3, #0
 800e1f6:	d003      	beq.n	800e200 <HASH_SHA1+0xb2>
  {
     status = ERROR;
 800e1f8:	2300      	movs	r3, #0
 800e1fa:	f887 3073 	strb.w	r3, [r7, #115]	; 0x73
 800e1fe:	e038      	b.n	800e272 <HASH_SHA1+0x124>
  }
  else
  {
    /* Read the message digest */
    HASH_GetDigest(&SHA1_MessageDigest);
 800e200:	f107 0318 	add.w	r3, r7, #24
 800e204:	4618      	mov	r0, r3
 800e206:	f7ff fccb 	bl	800dba0 <HASH_GetDigest>
    *(uint32_t*)(outputaddr)  = __REV(SHA1_MessageDigest.Data[0]);
 800e20a:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 800e20c:	69ba      	ldr	r2, [r7, #24]
 800e20e:	643a      	str	r2, [r7, #64]	; 0x40
  __ASM volatile ("rev %0, %1" : "=r" (result) : "r" (value) );
 800e210:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 800e212:	ba12      	rev	r2, r2
 800e214:	63fa      	str	r2, [r7, #60]	; 0x3c
  return(result);
 800e216:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 800e218:	601a      	str	r2, [r3, #0]
    outputaddr+=4;
 800e21a:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 800e21c:	3304      	adds	r3, #4
 800e21e:	667b      	str	r3, [r7, #100]	; 0x64
    *(uint32_t*)(outputaddr)  = __REV(SHA1_MessageDigest.Data[1]);
 800e220:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 800e222:	69fa      	ldr	r2, [r7, #28]
 800e224:	64ba      	str	r2, [r7, #72]	; 0x48
  __ASM volatile ("rev %0, %1" : "=r" (result) : "r" (value) );
 800e226:	6cba      	ldr	r2, [r7, #72]	; 0x48
 800e228:	ba12      	rev	r2, r2
 800e22a:	647a      	str	r2, [r7, #68]	; 0x44
  return(result);
 800e22c:	6c7a      	ldr	r2, [r7, #68]	; 0x44
 800e22e:	601a      	str	r2, [r3, #0]
    outputaddr+=4;
 800e230:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 800e232:	3304      	adds	r3, #4
 800e234:	667b      	str	r3, [r7, #100]	; 0x64
    *(uint32_t*)(outputaddr)  = __REV(SHA1_MessageDigest.Data[2]);
 800e236:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 800e238:	6a3a      	ldr	r2, [r7, #32]
 800e23a:	653a      	str	r2, [r7, #80]	; 0x50
  __ASM volatile ("rev %0, %1" : "=r" (result) : "r" (value) );
 800e23c:	6d3a      	ldr	r2, [r7, #80]	; 0x50
 800e23e:	ba12      	rev	r2, r2
 800e240:	64fa      	str	r2, [r7, #76]	; 0x4c
  return(result);
 800e242:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
 800e244:	601a      	str	r2, [r3, #0]
    outputaddr+=4;
 800e246:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 800e248:	3304      	adds	r3, #4
 800e24a:	667b      	str	r3, [r7, #100]	; 0x64
    *(uint32_t*)(outputaddr)  = __REV(SHA1_MessageDigest.Data[3]);
 800e24c:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 800e24e:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 800e250:	65ba      	str	r2, [r7, #88]	; 0x58
  __ASM volatile ("rev %0, %1" : "=r" (result) : "r" (value) );
 800e252:	6dba      	ldr	r2, [r7, #88]	; 0x58
 800e254:	ba12      	rev	r2, r2
 800e256:	657a      	str	r2, [r7, #84]	; 0x54
  return(result);
 800e258:	6d7a      	ldr	r2, [r7, #84]	; 0x54
 800e25a:	601a      	str	r2, [r3, #0]
    outputaddr+=4;
 800e25c:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 800e25e:	3304      	adds	r3, #4
 800e260:	667b      	str	r3, [r7, #100]	; 0x64
    *(uint32_t*)(outputaddr)  = __REV(SHA1_MessageDigest.Data[4]);
 800e262:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 800e264:	6aba      	ldr	r2, [r7, #40]	; 0x28
 800e266:	663a      	str	r2, [r7, #96]	; 0x60
  __ASM volatile ("rev %0, %1" : "=r" (result) : "r" (value) );
 800e268:	6e3a      	ldr	r2, [r7, #96]	; 0x60
 800e26a:	ba12      	rev	r2, r2
 800e26c:	65fa      	str	r2, [r7, #92]	; 0x5c
  return(result);
 800e26e:	6dfa      	ldr	r2, [r7, #92]	; 0x5c
 800e270:	601a      	str	r2, [r3, #0]
  }
  return status;
 800e272:	f897 3073 	ldrb.w	r3, [r7, #115]	; 0x73
}
 800e276:	4618      	mov	r0, r3
 800e278:	3778      	adds	r7, #120	; 0x78
 800e27a:	46bd      	mov	sp, r7
 800e27c:	bd80      	pop	{r7, pc}

0800e27e <HMAC_SHA1>:
  *          - SUCCESS: digest computation done
  *          - ERROR: digest computation failed
  */
ErrorStatus HMAC_SHA1(uint8_t *Key, uint32_t Keylen, uint8_t *Input,
                      uint32_t Ilen, uint8_t Output[20])
{
 800e27e:	b580      	push	{r7, lr}
 800e280:	b0a0      	sub	sp, #128	; 0x80
 800e282:	af00      	add	r7, sp, #0
 800e284:	60f8      	str	r0, [r7, #12]
 800e286:	60b9      	str	r1, [r7, #8]
 800e288:	607a      	str	r2, [r7, #4]
 800e28a:	603b      	str	r3, [r7, #0]
  HASH_InitTypeDef SHA1_HASH_InitStructure;
  HASH_MsgDigest SHA1_MessageDigest;
  __IO uint16_t nbvalidbitsdata = 0;
 800e28c:	2300      	movs	r3, #0
 800e28e:	837b      	strh	r3, [r7, #26]
  __IO uint16_t nbvalidbitskey = 0;
 800e290:	2300      	movs	r3, #0
 800e292:	833b      	strh	r3, [r7, #24]
  uint32_t i = 0;
 800e294:	2300      	movs	r3, #0
 800e296:	67fb      	str	r3, [r7, #124]	; 0x7c
  __IO uint32_t counter = 0;
 800e298:	2300      	movs	r3, #0
 800e29a:	617b      	str	r3, [r7, #20]
  uint32_t busystatus = 0;
 800e29c:	2300      	movs	r3, #0
 800e29e:	66fb      	str	r3, [r7, #108]	; 0x6c
  ErrorStatus status = SUCCESS;
 800e2a0:	2301      	movs	r3, #1
 800e2a2:	f887 307b 	strb.w	r3, [r7, #123]	; 0x7b
  uint32_t keyaddr    = (uint32_t)Key;
 800e2a6:	68fb      	ldr	r3, [r7, #12]
 800e2a8:	677b      	str	r3, [r7, #116]	; 0x74
  uint32_t inputaddr  = (uint32_t)Input;
 800e2aa:	687b      	ldr	r3, [r7, #4]
 800e2ac:	673b      	str	r3, [r7, #112]	; 0x70
  uint32_t outputaddr = (uint32_t)Output;
 800e2ae:	f8d7 3088 	ldr.w	r3, [r7, #136]	; 0x88
 800e2b2:	66bb      	str	r3, [r7, #104]	; 0x68

  /* Number of valid bits in last word of the Input data */
  nbvalidbitsdata = 8 * (Ilen % 4);
 800e2b4:	683b      	ldr	r3, [r7, #0]
 800e2b6:	b29b      	uxth	r3, r3
 800e2b8:	f003 0303 	and.w	r3, r3, #3
 800e2bc:	b29b      	uxth	r3, r3
 800e2be:	00db      	lsls	r3, r3, #3
 800e2c0:	b29b      	uxth	r3, r3
 800e2c2:	837b      	strh	r3, [r7, #26]

  /* Number of valid bits in last word of the Key */
  nbvalidbitskey = 8 * (Keylen % 4);
 800e2c4:	68bb      	ldr	r3, [r7, #8]
 800e2c6:	b29b      	uxth	r3, r3
 800e2c8:	f003 0303 	and.w	r3, r3, #3
 800e2cc:	b29b      	uxth	r3, r3
 800e2ce:	00db      	lsls	r3, r3, #3
 800e2d0:	b29b      	uxth	r3, r3
 800e2d2:	833b      	strh	r3, [r7, #24]

  /* HASH peripheral initialization */
  HASH_DeInit();
 800e2d4:	f7ff fbc2 	bl	800da5c <HASH_DeInit>

  /* HASH Configuration */
  SHA1_HASH_InitStructure.HASH_AlgoSelection = HASH_AlgoSelection_SHA1;
 800e2d8:	2300      	movs	r3, #0
 800e2da:	633b      	str	r3, [r7, #48]	; 0x30
  SHA1_HASH_InitStructure.HASH_AlgoMode = HASH_AlgoMode_HMAC;
 800e2dc:	2340      	movs	r3, #64	; 0x40
 800e2de:	637b      	str	r3, [r7, #52]	; 0x34
  SHA1_HASH_InitStructure.HASH_DataType = HASH_DataType_8b;
 800e2e0:	2320      	movs	r3, #32
 800e2e2:	63bb      	str	r3, [r7, #56]	; 0x38
  if(Keylen > 64)
 800e2e4:	68bb      	ldr	r3, [r7, #8]
 800e2e6:	2b40      	cmp	r3, #64	; 0x40
 800e2e8:	d903      	bls.n	800e2f2 <HMAC_SHA1+0x74>
  {
    /* HMAC long Key */
    SHA1_HASH_InitStructure.HASH_HMACKeyType = HASH_HMACKeyType_LongKey;
 800e2ea:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 800e2ee:	63fb      	str	r3, [r7, #60]	; 0x3c
 800e2f0:	e001      	b.n	800e2f6 <HMAC_SHA1+0x78>
  }
  else
  {
    /* HMAC short Key */
    SHA1_HASH_InitStructure.HASH_HMACKeyType = HASH_HMACKeyType_ShortKey;
 800e2f2:	2300      	movs	r3, #0
 800e2f4:	63fb      	str	r3, [r7, #60]	; 0x3c
  }
  HASH_Init(&SHA1_HASH_InitStructure);
 800e2f6:	f107 0330 	add.w	r3, r7, #48	; 0x30
 800e2fa:	4618      	mov	r0, r3
 800e2fc:	f7ff fbba 	bl	800da74 <HASH_Init>

  /* Configure the number of valid bits in last word of the Key */
  HASH_SetLastWordValidBitsNbr(nbvalidbitskey);
 800e300:	8b3b      	ldrh	r3, [r7, #24]
 800e302:	b29b      	uxth	r3, r3
 800e304:	4618      	mov	r0, r3
 800e306:	f7ff fc11 	bl	800db2c <HASH_SetLastWordValidBitsNbr>

  /* Write the Key */
  for(i=0; i<Keylen; i+=4)
 800e30a:	2300      	movs	r3, #0
 800e30c:	67fb      	str	r3, [r7, #124]	; 0x7c
 800e30e:	e00a      	b.n	800e326 <HMAC_SHA1+0xa8>
  {
    HASH_DataIn(*(uint32_t*)keyaddr);
 800e310:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 800e312:	681b      	ldr	r3, [r3, #0]
 800e314:	4618      	mov	r0, r3
 800e316:	f7ff fc23 	bl	800db60 <HASH_DataIn>
    keyaddr+=4;
 800e31a:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 800e31c:	3304      	adds	r3, #4
 800e31e:	677b      	str	r3, [r7, #116]	; 0x74
  for(i=0; i<Keylen; i+=4)
 800e320:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
 800e322:	3304      	adds	r3, #4
 800e324:	67fb      	str	r3, [r7, #124]	; 0x7c
 800e326:	6ffa      	ldr	r2, [r7, #124]	; 0x7c
 800e328:	68bb      	ldr	r3, [r7, #8]
 800e32a:	429a      	cmp	r2, r3
 800e32c:	d3f0      	bcc.n	800e310 <HMAC_SHA1+0x92>
  }

  /* Start the HASH processor */
  HASH_StartDigest();
 800e32e:	f7ff fc57 	bl	800dbe0 <HASH_StartDigest>

  /* wait until the Busy flag is RESET */
  do
  {
    busystatus = HASH_GetFlagStatus(HASH_FLAG_BUSY);
 800e332:	2008      	movs	r0, #8
 800e334:	f7ff fd08 	bl	800dd48 <HASH_GetFlagStatus>
 800e338:	4603      	mov	r3, r0
 800e33a:	66fb      	str	r3, [r7, #108]	; 0x6c
    counter++;
 800e33c:	697b      	ldr	r3, [r7, #20]
 800e33e:	3301      	adds	r3, #1
 800e340:	617b      	str	r3, [r7, #20]
  }while ((counter != SHA1BUSY_TIMEOUT) && (busystatus != RESET));
 800e342:	697b      	ldr	r3, [r7, #20]
 800e344:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 800e348:	d002      	beq.n	800e350 <HMAC_SHA1+0xd2>
 800e34a:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 800e34c:	2b00      	cmp	r3, #0
 800e34e:	d1f0      	bne.n	800e332 <HMAC_SHA1+0xb4>

  if (busystatus != RESET)
 800e350:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 800e352:	2b00      	cmp	r3, #0
 800e354:	d003      	beq.n	800e35e <HMAC_SHA1+0xe0>
  {
     status = ERROR;
 800e356:	2300      	movs	r3, #0
 800e358:	f887 307b 	strb.w	r3, [r7, #123]	; 0x7b
 800e35c:	e09c      	b.n	800e498 <HMAC_SHA1+0x21a>
  }
  else
  {
    /* Configure the number of valid bits in last word of the Input data */
    HASH_SetLastWordValidBitsNbr(nbvalidbitsdata);
 800e35e:	8b7b      	ldrh	r3, [r7, #26]
 800e360:	b29b      	uxth	r3, r3
 800e362:	4618      	mov	r0, r3
 800e364:	f7ff fbe2 	bl	800db2c <HASH_SetLastWordValidBitsNbr>

    /* Write the Input block in the IN FIFO */
    for(i=0; i<Ilen; i+=4)
 800e368:	2300      	movs	r3, #0
 800e36a:	67fb      	str	r3, [r7, #124]	; 0x7c
 800e36c:	e00a      	b.n	800e384 <HMAC_SHA1+0x106>
    {
      HASH_DataIn(*(uint32_t*)inputaddr);
 800e36e:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 800e370:	681b      	ldr	r3, [r3, #0]
 800e372:	4618      	mov	r0, r3
 800e374:	f7ff fbf4 	bl	800db60 <HASH_DataIn>
      inputaddr+=4;
 800e378:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 800e37a:	3304      	adds	r3, #4
 800e37c:	673b      	str	r3, [r7, #112]	; 0x70
    for(i=0; i<Ilen; i+=4)
 800e37e:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
 800e380:	3304      	adds	r3, #4
 800e382:	67fb      	str	r3, [r7, #124]	; 0x7c
 800e384:	6ffa      	ldr	r2, [r7, #124]	; 0x7c
 800e386:	683b      	ldr	r3, [r7, #0]
 800e388:	429a      	cmp	r2, r3
 800e38a:	d3f0      	bcc.n	800e36e <HMAC_SHA1+0xf0>
    }

    /* Start the HASH processor */
    HASH_StartDigest();
 800e38c:	f7ff fc28 	bl	800dbe0 <HASH_StartDigest>


    /* wait until the Busy flag is RESET */
    counter =0;
 800e390:	2300      	movs	r3, #0
 800e392:	617b      	str	r3, [r7, #20]
    do
    {
      busystatus = HASH_GetFlagStatus(HASH_FLAG_BUSY);
 800e394:	2008      	movs	r0, #8
 800e396:	f7ff fcd7 	bl	800dd48 <HASH_GetFlagStatus>
 800e39a:	4603      	mov	r3, r0
 800e39c:	66fb      	str	r3, [r7, #108]	; 0x6c
      counter++;
 800e39e:	697b      	ldr	r3, [r7, #20]
 800e3a0:	3301      	adds	r3, #1
 800e3a2:	617b      	str	r3, [r7, #20]
    }while ((counter != SHA1BUSY_TIMEOUT) && (busystatus != RESET));
 800e3a4:	697b      	ldr	r3, [r7, #20]
 800e3a6:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 800e3aa:	d002      	beq.n	800e3b2 <HMAC_SHA1+0x134>
 800e3ac:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 800e3ae:	2b00      	cmp	r3, #0
 800e3b0:	d1f0      	bne.n	800e394 <HMAC_SHA1+0x116>

    if (busystatus != RESET)
 800e3b2:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 800e3b4:	2b00      	cmp	r3, #0
 800e3b6:	d003      	beq.n	800e3c0 <HMAC_SHA1+0x142>
    {
      status = ERROR;
 800e3b8:	2300      	movs	r3, #0
 800e3ba:	f887 307b 	strb.w	r3, [r7, #123]	; 0x7b
 800e3be:	e06b      	b.n	800e498 <HMAC_SHA1+0x21a>
    }
    else
    {  
      /* Configure the number of valid bits in last word of the Key */
      HASH_SetLastWordValidBitsNbr(nbvalidbitskey);
 800e3c0:	8b3b      	ldrh	r3, [r7, #24]
 800e3c2:	b29b      	uxth	r3, r3
 800e3c4:	4618      	mov	r0, r3
 800e3c6:	f7ff fbb1 	bl	800db2c <HASH_SetLastWordValidBitsNbr>

      /* Write the Key */
      keyaddr = (uint32_t)Key;
 800e3ca:	68fb      	ldr	r3, [r7, #12]
 800e3cc:	677b      	str	r3, [r7, #116]	; 0x74
      for(i=0; i<Keylen; i+=4)
 800e3ce:	2300      	movs	r3, #0
 800e3d0:	67fb      	str	r3, [r7, #124]	; 0x7c
 800e3d2:	e00a      	b.n	800e3ea <HMAC_SHA1+0x16c>
      {
        HASH_DataIn(*(uint32_t*)keyaddr);
 800e3d4:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 800e3d6:	681b      	ldr	r3, [r3, #0]
 800e3d8:	4618      	mov	r0, r3
 800e3da:	f7ff fbc1 	bl	800db60 <HASH_DataIn>
        keyaddr+=4;
 800e3de:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 800e3e0:	3304      	adds	r3, #4
 800e3e2:	677b      	str	r3, [r7, #116]	; 0x74
      for(i=0; i<Keylen; i+=4)
 800e3e4:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
 800e3e6:	3304      	adds	r3, #4
 800e3e8:	67fb      	str	r3, [r7, #124]	; 0x7c
 800e3ea:	6ffa      	ldr	r2, [r7, #124]	; 0x7c
 800e3ec:	68bb      	ldr	r3, [r7, #8]
 800e3ee:	429a      	cmp	r2, r3
 800e3f0:	d3f0      	bcc.n	800e3d4 <HMAC_SHA1+0x156>
      }

      /* Start the HASH processor */
      HASH_StartDigest();
 800e3f2:	f7ff fbf5 	bl	800dbe0 <HASH_StartDigest>

      /* wait until the Busy flag is RESET */
      counter =0;
 800e3f6:	2300      	movs	r3, #0
 800e3f8:	617b      	str	r3, [r7, #20]
      do
      {
        busystatus = HASH_GetFlagStatus(HASH_FLAG_BUSY);
 800e3fa:	2008      	movs	r0, #8
 800e3fc:	f7ff fca4 	bl	800dd48 <HASH_GetFlagStatus>
 800e400:	4603      	mov	r3, r0
 800e402:	66fb      	str	r3, [r7, #108]	; 0x6c
        counter++;
 800e404:	697b      	ldr	r3, [r7, #20]
 800e406:	3301      	adds	r3, #1
 800e408:	617b      	str	r3, [r7, #20]
      }while ((counter != SHA1BUSY_TIMEOUT) && (busystatus != RESET));
 800e40a:	697b      	ldr	r3, [r7, #20]
 800e40c:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 800e410:	d002      	beq.n	800e418 <HMAC_SHA1+0x19a>
 800e412:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 800e414:	2b00      	cmp	r3, #0
 800e416:	d1f0      	bne.n	800e3fa <HMAC_SHA1+0x17c>

      if (busystatus != RESET)
 800e418:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 800e41a:	2b00      	cmp	r3, #0
 800e41c:	d003      	beq.n	800e426 <HMAC_SHA1+0x1a8>
      {
        status = ERROR;
 800e41e:	2300      	movs	r3, #0
 800e420:	f887 307b 	strb.w	r3, [r7, #123]	; 0x7b
 800e424:	e038      	b.n	800e498 <HMAC_SHA1+0x21a>
      }
      else
      {
        /* Read the message digest */
        HASH_GetDigest(&SHA1_MessageDigest);
 800e426:	f107 031c 	add.w	r3, r7, #28
 800e42a:	4618      	mov	r0, r3
 800e42c:	f7ff fbb8 	bl	800dba0 <HASH_GetDigest>
        *(uint32_t*)(outputaddr)  = __REV(SHA1_MessageDigest.Data[0]);
 800e430:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 800e432:	69fa      	ldr	r2, [r7, #28]
 800e434:	647a      	str	r2, [r7, #68]	; 0x44
  __ASM volatile ("rev %0, %1" : "=r" (result) : "r" (value) );
 800e436:	6c7a      	ldr	r2, [r7, #68]	; 0x44
 800e438:	ba12      	rev	r2, r2
 800e43a:	643a      	str	r2, [r7, #64]	; 0x40
  return(result);
 800e43c:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 800e43e:	601a      	str	r2, [r3, #0]
        outputaddr+=4;
 800e440:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 800e442:	3304      	adds	r3, #4
 800e444:	66bb      	str	r3, [r7, #104]	; 0x68
        *(uint32_t*)(outputaddr)  = __REV(SHA1_MessageDigest.Data[1]);
 800e446:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 800e448:	6a3a      	ldr	r2, [r7, #32]
 800e44a:	64fa      	str	r2, [r7, #76]	; 0x4c
  __ASM volatile ("rev %0, %1" : "=r" (result) : "r" (value) );
 800e44c:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
 800e44e:	ba12      	rev	r2, r2
 800e450:	64ba      	str	r2, [r7, #72]	; 0x48
  return(result);
 800e452:	6cba      	ldr	r2, [r7, #72]	; 0x48
 800e454:	601a      	str	r2, [r3, #0]
        outputaddr+=4;
 800e456:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 800e458:	3304      	adds	r3, #4
 800e45a:	66bb      	str	r3, [r7, #104]	; 0x68
        *(uint32_t*)(outputaddr)  = __REV(SHA1_MessageDigest.Data[2]);
 800e45c:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 800e45e:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 800e460:	657a      	str	r2, [r7, #84]	; 0x54
  __ASM volatile ("rev %0, %1" : "=r" (result) : "r" (value) );
 800e462:	6d7a      	ldr	r2, [r7, #84]	; 0x54
 800e464:	ba12      	rev	r2, r2
 800e466:	653a      	str	r2, [r7, #80]	; 0x50
  return(result);
 800e468:	6d3a      	ldr	r2, [r7, #80]	; 0x50
 800e46a:	601a      	str	r2, [r3, #0]
        outputaddr+=4;
 800e46c:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 800e46e:	3304      	adds	r3, #4
 800e470:	66bb      	str	r3, [r7, #104]	; 0x68
        *(uint32_t*)(outputaddr)  = __REV(SHA1_MessageDigest.Data[3]);
 800e472:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 800e474:	6aba      	ldr	r2, [r7, #40]	; 0x28
 800e476:	65fa      	str	r2, [r7, #92]	; 0x5c
  __ASM volatile ("rev %0, %1" : "=r" (result) : "r" (value) );
 800e478:	6dfa      	ldr	r2, [r7, #92]	; 0x5c
 800e47a:	ba12      	rev	r2, r2
 800e47c:	65ba      	str	r2, [r7, #88]	; 0x58
  return(result);
 800e47e:	6dba      	ldr	r2, [r7, #88]	; 0x58
 800e480:	601a      	str	r2, [r3, #0]
        outputaddr+=4;
 800e482:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 800e484:	3304      	adds	r3, #4
 800e486:	66bb      	str	r3, [r7, #104]	; 0x68
        *(uint32_t*)(outputaddr)  = __REV(SHA1_MessageDigest.Data[4]);
 800e488:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 800e48a:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 800e48c:	667a      	str	r2, [r7, #100]	; 0x64
  __ASM volatile ("rev %0, %1" : "=r" (result) : "r" (value) );
 800e48e:	6e7a      	ldr	r2, [r7, #100]	; 0x64
 800e490:	ba12      	rev	r2, r2
 800e492:	663a      	str	r2, [r7, #96]	; 0x60
  return(result);
 800e494:	6e3a      	ldr	r2, [r7, #96]	; 0x60
 800e496:	601a      	str	r2, [r3, #0]
      }
    }  
  }
  return status;  
 800e498:	f897 307b 	ldrb.w	r3, [r7, #123]	; 0x7b
}
 800e49c:	4618      	mov	r0, r3
 800e49e:	3780      	adds	r7, #128	; 0x80
 800e4a0:	46bd      	mov	sp, r7
 800e4a2:	bd80      	pop	{r7, pc}

0800e4a4 <I2C_DeInit>:
  * @brief  Deinitialize the I2Cx peripheral registers to their default reset values.
  * @param  I2Cx: where x can be 1, 2 or 3 to select the I2C peripheral.
  * @retval None
  */
void I2C_DeInit(I2C_TypeDef* I2Cx)
{
 800e4a4:	b580      	push	{r7, lr}
 800e4a6:	b082      	sub	sp, #8
 800e4a8:	af00      	add	r7, sp, #0
 800e4aa:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));

  if (I2Cx == I2C1)
 800e4ac:	687b      	ldr	r3, [r7, #4]
 800e4ae:	4a17      	ldr	r2, [pc, #92]	; (800e50c <I2C_DeInit+0x68>)
 800e4b0:	4293      	cmp	r3, r2
 800e4b2:	d10a      	bne.n	800e4ca <I2C_DeInit+0x26>
  {
    /* Enable I2C1 reset state */
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C1, ENABLE);
 800e4b4:	2101      	movs	r1, #1
 800e4b6:	f44f 1000 	mov.w	r0, #2097152	; 0x200000
 800e4ba:	f001 fa2b 	bl	800f914 <RCC_APB1PeriphResetCmd>
    /* Release I2C1 from reset state */
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C1, DISABLE);    
 800e4be:	2100      	movs	r1, #0
 800e4c0:	f44f 1000 	mov.w	r0, #2097152	; 0x200000
 800e4c4:	f001 fa26 	bl	800f914 <RCC_APB1PeriphResetCmd>
      RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C3, ENABLE);
      /* Release I2C3 from reset state */
      RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C3, DISABLE);     
    }
  }
}
 800e4c8:	e01c      	b.n	800e504 <I2C_DeInit+0x60>
  else if (I2Cx == I2C2)
 800e4ca:	687b      	ldr	r3, [r7, #4]
 800e4cc:	4a10      	ldr	r2, [pc, #64]	; (800e510 <I2C_DeInit+0x6c>)
 800e4ce:	4293      	cmp	r3, r2
 800e4d0:	d10a      	bne.n	800e4e8 <I2C_DeInit+0x44>
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C2, ENABLE);
 800e4d2:	2101      	movs	r1, #1
 800e4d4:	f44f 0080 	mov.w	r0, #4194304	; 0x400000
 800e4d8:	f001 fa1c 	bl	800f914 <RCC_APB1PeriphResetCmd>
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C2, DISABLE);      
 800e4dc:	2100      	movs	r1, #0
 800e4de:	f44f 0080 	mov.w	r0, #4194304	; 0x400000
 800e4e2:	f001 fa17 	bl	800f914 <RCC_APB1PeriphResetCmd>
}
 800e4e6:	e00d      	b.n	800e504 <I2C_DeInit+0x60>
    if (I2Cx == I2C3)
 800e4e8:	687b      	ldr	r3, [r7, #4]
 800e4ea:	4a0a      	ldr	r2, [pc, #40]	; (800e514 <I2C_DeInit+0x70>)
 800e4ec:	4293      	cmp	r3, r2
 800e4ee:	d109      	bne.n	800e504 <I2C_DeInit+0x60>
      RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C3, ENABLE);
 800e4f0:	2101      	movs	r1, #1
 800e4f2:	f44f 0000 	mov.w	r0, #8388608	; 0x800000
 800e4f6:	f001 fa0d 	bl	800f914 <RCC_APB1PeriphResetCmd>
      RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C3, DISABLE);     
 800e4fa:	2100      	movs	r1, #0
 800e4fc:	f44f 0000 	mov.w	r0, #8388608	; 0x800000
 800e500:	f001 fa08 	bl	800f914 <RCC_APB1PeriphResetCmd>
}
 800e504:	bf00      	nop
 800e506:	3708      	adds	r7, #8
 800e508:	46bd      	mov	sp, r7
 800e50a:	bd80      	pop	{r7, pc}
 800e50c:	40005400 	.word	0x40005400
 800e510:	40005800 	.word	0x40005800
 800e514:	40005c00 	.word	0x40005c00

0800e518 <I2C_Init>:
  * @param  I2C_InitStruct: pointer to a I2C_InitTypeDef structure that contains 
  *         the configuration information for the specified I2C peripheral.
  * @retval None
  */
void I2C_Init(I2C_TypeDef* I2Cx, I2C_InitTypeDef* I2C_InitStruct)
{
 800e518:	b580      	push	{r7, lr}
 800e51a:	b08a      	sub	sp, #40	; 0x28
 800e51c:	af00      	add	r7, sp, #0
 800e51e:	6078      	str	r0, [r7, #4]
 800e520:	6039      	str	r1, [r7, #0]
  uint16_t tmpreg = 0, freqrange = 0;
 800e522:	2300      	movs	r3, #0
 800e524:	84fb      	strh	r3, [r7, #38]	; 0x26
 800e526:	2300      	movs	r3, #0
 800e528:	847b      	strh	r3, [r7, #34]	; 0x22
  uint16_t result = 0x04;
 800e52a:	2304      	movs	r3, #4
 800e52c:	84bb      	strh	r3, [r7, #36]	; 0x24
  uint32_t pclk1 = 8000000;
 800e52e:	4b57      	ldr	r3, [pc, #348]	; (800e68c <I2C_Init+0x174>)
 800e530:	61fb      	str	r3, [r7, #28]
  assert_param(IS_I2C_ACK_STATE(I2C_InitStruct->I2C_Ack));
  assert_param(IS_I2C_ACKNOWLEDGE_ADDRESS(I2C_InitStruct->I2C_AcknowledgedAddress));

/*---------------------------- I2Cx CR2 Configuration ------------------------*/
  /* Get the I2Cx CR2 value */
  tmpreg = I2Cx->CR2;
 800e532:	687b      	ldr	r3, [r7, #4]
 800e534:	889b      	ldrh	r3, [r3, #4]
 800e536:	84fb      	strh	r3, [r7, #38]	; 0x26
  /* Clear frequency FREQ[5:0] bits */
  tmpreg &= (uint16_t)~((uint16_t)I2C_CR2_FREQ);
 800e538:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
 800e53a:	f023 033f 	bic.w	r3, r3, #63	; 0x3f
 800e53e:	84fb      	strh	r3, [r7, #38]	; 0x26
  /* Get pclk1 frequency value */
  RCC_GetClocksFreq(&rcc_clocks);
 800e540:	f107 030c 	add.w	r3, r7, #12
 800e544:	4618      	mov	r0, r3
 800e546:	f000 ffdf 	bl	800f508 <RCC_GetClocksFreq>
  pclk1 = rcc_clocks.PCLK1_Frequency;
 800e54a:	697b      	ldr	r3, [r7, #20]
 800e54c:	61fb      	str	r3, [r7, #28]
  /* Set frequency bits depending on pclk1 value */
  freqrange = (uint16_t)(pclk1 / 1000000);
 800e54e:	69fb      	ldr	r3, [r7, #28]
 800e550:	4a4f      	ldr	r2, [pc, #316]	; (800e690 <I2C_Init+0x178>)
 800e552:	fba2 2303 	umull	r2, r3, r2, r3
 800e556:	0c9b      	lsrs	r3, r3, #18
 800e558:	847b      	strh	r3, [r7, #34]	; 0x22
  tmpreg |= freqrange;
 800e55a:	8cfa      	ldrh	r2, [r7, #38]	; 0x26
 800e55c:	8c7b      	ldrh	r3, [r7, #34]	; 0x22
 800e55e:	4313      	orrs	r3, r2
 800e560:	84fb      	strh	r3, [r7, #38]	; 0x26
  /* Write to I2Cx CR2 */
  I2Cx->CR2 = tmpreg;
 800e562:	687b      	ldr	r3, [r7, #4]
 800e564:	8cfa      	ldrh	r2, [r7, #38]	; 0x26
 800e566:	809a      	strh	r2, [r3, #4]

/*---------------------------- I2Cx CCR Configuration ------------------------*/
  /* Disable the selected I2C peripheral to configure TRISE */
  I2Cx->CR1 &= (uint16_t)~((uint16_t)I2C_CR1_PE);
 800e568:	687b      	ldr	r3, [r7, #4]
 800e56a:	881b      	ldrh	r3, [r3, #0]
 800e56c:	b29b      	uxth	r3, r3
 800e56e:	f023 0301 	bic.w	r3, r3, #1
 800e572:	b29a      	uxth	r2, r3
 800e574:	687b      	ldr	r3, [r7, #4]
 800e576:	801a      	strh	r2, [r3, #0]
  /* Reset tmpreg value */
  /* Clear F/S, DUTY and CCR[11:0] bits */
  tmpreg = 0;
 800e578:	2300      	movs	r3, #0
 800e57a:	84fb      	strh	r3, [r7, #38]	; 0x26

  /* Configure speed in standard mode */
  if (I2C_InitStruct->I2C_ClockSpeed <= 100000)
 800e57c:	683b      	ldr	r3, [r7, #0]
 800e57e:	681b      	ldr	r3, [r3, #0]
 800e580:	4a44      	ldr	r2, [pc, #272]	; (800e694 <I2C_Init+0x17c>)
 800e582:	4293      	cmp	r3, r2
 800e584:	d815      	bhi.n	800e5b2 <I2C_Init+0x9a>
  {
    /* Standard mode speed calculate */
    result = (uint16_t)(pclk1 / (I2C_InitStruct->I2C_ClockSpeed << 1));
 800e586:	683b      	ldr	r3, [r7, #0]
 800e588:	681b      	ldr	r3, [r3, #0]
 800e58a:	005b      	lsls	r3, r3, #1
 800e58c:	69fa      	ldr	r2, [r7, #28]
 800e58e:	fbb2 f3f3 	udiv	r3, r2, r3
 800e592:	84bb      	strh	r3, [r7, #36]	; 0x24
    /* Test if CCR value is under 0x4*/
    if (result < 0x04)
 800e594:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
 800e596:	2b03      	cmp	r3, #3
 800e598:	d801      	bhi.n	800e59e <I2C_Init+0x86>
    {
      /* Set minimum allowed value */
      result = 0x04;  
 800e59a:	2304      	movs	r3, #4
 800e59c:	84bb      	strh	r3, [r7, #36]	; 0x24
    }
    /* Set speed value for standard mode */
    tmpreg |= result;	  
 800e59e:	8cfa      	ldrh	r2, [r7, #38]	; 0x26
 800e5a0:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
 800e5a2:	4313      	orrs	r3, r2
 800e5a4:	84fb      	strh	r3, [r7, #38]	; 0x26
    /* Set Maximum Rise Time for standard mode */
    I2Cx->TRISE = freqrange + 1; 
 800e5a6:	8c7b      	ldrh	r3, [r7, #34]	; 0x22
 800e5a8:	3301      	adds	r3, #1
 800e5aa:	b29a      	uxth	r2, r3
 800e5ac:	687b      	ldr	r3, [r7, #4]
 800e5ae:	841a      	strh	r2, [r3, #32]
 800e5b0:	e040      	b.n	800e634 <I2C_Init+0x11c>
  /* Configure speed in fast mode */
  /* To use the I2C at 400 KHz (in fast mode), the PCLK1 frequency (I2C peripheral
     input clock) must be a multiple of 10 MHz */
  else /*(I2C_InitStruct->I2C_ClockSpeed <= 400000)*/
  {
    if (I2C_InitStruct->I2C_DutyCycle == I2C_DutyCycle_2)
 800e5b2:	683b      	ldr	r3, [r7, #0]
 800e5b4:	88db      	ldrh	r3, [r3, #6]
 800e5b6:	f64b 72ff 	movw	r2, #49151	; 0xbfff
 800e5ba:	4293      	cmp	r3, r2
 800e5bc:	d109      	bne.n	800e5d2 <I2C_Init+0xba>
    {
      /* Fast mode speed calculate: Tlow/Thigh = 2 */
      result = (uint16_t)(pclk1 / (I2C_InitStruct->I2C_ClockSpeed * 3));
 800e5be:	683b      	ldr	r3, [r7, #0]
 800e5c0:	681a      	ldr	r2, [r3, #0]
 800e5c2:	4613      	mov	r3, r2
 800e5c4:	005b      	lsls	r3, r3, #1
 800e5c6:	4413      	add	r3, r2
 800e5c8:	69fa      	ldr	r2, [r7, #28]
 800e5ca:	fbb2 f3f3 	udiv	r3, r2, r3
 800e5ce:	84bb      	strh	r3, [r7, #36]	; 0x24
 800e5d0:	e00e      	b.n	800e5f0 <I2C_Init+0xd8>
    }
    else /*I2C_InitStruct->I2C_DutyCycle == I2C_DutyCycle_16_9*/
    {
      /* Fast mode speed calculate: Tlow/Thigh = 16/9 */
      result = (uint16_t)(pclk1 / (I2C_InitStruct->I2C_ClockSpeed * 25));
 800e5d2:	683b      	ldr	r3, [r7, #0]
 800e5d4:	681a      	ldr	r2, [r3, #0]
 800e5d6:	4613      	mov	r3, r2
 800e5d8:	009b      	lsls	r3, r3, #2
 800e5da:	4413      	add	r3, r2
 800e5dc:	009a      	lsls	r2, r3, #2
 800e5de:	4413      	add	r3, r2
 800e5e0:	69fa      	ldr	r2, [r7, #28]
 800e5e2:	fbb2 f3f3 	udiv	r3, r2, r3
 800e5e6:	84bb      	strh	r3, [r7, #36]	; 0x24
      /* Set DUTY bit */
      result |= I2C_DutyCycle_16_9;
 800e5e8:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
 800e5ea:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 800e5ee:	84bb      	strh	r3, [r7, #36]	; 0x24
    }

    /* Test if CCR value is under 0x1*/
    if ((result & I2C_CCR_CCR) == 0)
 800e5f0:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
 800e5f2:	f3c3 030b 	ubfx	r3, r3, #0, #12
 800e5f6:	2b00      	cmp	r3, #0
 800e5f8:	d103      	bne.n	800e602 <I2C_Init+0xea>
    {
      /* Set minimum allowed value */
      result |= (uint16_t)0x0001;  
 800e5fa:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
 800e5fc:	f043 0301 	orr.w	r3, r3, #1
 800e600:	84bb      	strh	r3, [r7, #36]	; 0x24
    }
    /* Set speed value and set F/S bit for fast mode */
    tmpreg |= (uint16_t)(result | I2C_CCR_FS);
 800e602:	8cba      	ldrh	r2, [r7, #36]	; 0x24
 800e604:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
 800e606:	4313      	orrs	r3, r2
 800e608:	b29b      	uxth	r3, r3
 800e60a:	ea6f 4343 	mvn.w	r3, r3, lsl #17
 800e60e:	ea6f 4353 	mvn.w	r3, r3, lsr #17
 800e612:	84fb      	strh	r3, [r7, #38]	; 0x26
    /* Set Maximum Rise Time for fast mode */
    I2Cx->TRISE = (uint16_t)(((freqrange * (uint16_t)300) / (uint16_t)1000) + (uint16_t)1);  
 800e614:	8c7b      	ldrh	r3, [r7, #34]	; 0x22
 800e616:	f44f 7296 	mov.w	r2, #300	; 0x12c
 800e61a:	fb02 f303 	mul.w	r3, r2, r3
 800e61e:	4a1e      	ldr	r2, [pc, #120]	; (800e698 <I2C_Init+0x180>)
 800e620:	fb82 1203 	smull	r1, r2, r2, r3
 800e624:	1192      	asrs	r2, r2, #6
 800e626:	17db      	asrs	r3, r3, #31
 800e628:	1ad3      	subs	r3, r2, r3
 800e62a:	b29b      	uxth	r3, r3
 800e62c:	3301      	adds	r3, #1
 800e62e:	b29a      	uxth	r2, r3
 800e630:	687b      	ldr	r3, [r7, #4]
 800e632:	841a      	strh	r2, [r3, #32]
  }

  /* Write to I2Cx CCR */
  I2Cx->CCR = tmpreg;
 800e634:	687b      	ldr	r3, [r7, #4]
 800e636:	8cfa      	ldrh	r2, [r7, #38]	; 0x26
 800e638:	839a      	strh	r2, [r3, #28]
  /* Enable the selected I2C peripheral */
  I2Cx->CR1 |= I2C_CR1_PE;
 800e63a:	687b      	ldr	r3, [r7, #4]
 800e63c:	881b      	ldrh	r3, [r3, #0]
 800e63e:	b29b      	uxth	r3, r3
 800e640:	f043 0301 	orr.w	r3, r3, #1
 800e644:	b29a      	uxth	r2, r3
 800e646:	687b      	ldr	r3, [r7, #4]
 800e648:	801a      	strh	r2, [r3, #0]

/*---------------------------- I2Cx CR1 Configuration ------------------------*/
  /* Get the I2Cx CR1 value */
  tmpreg = I2Cx->CR1;
 800e64a:	687b      	ldr	r3, [r7, #4]
 800e64c:	881b      	ldrh	r3, [r3, #0]
 800e64e:	84fb      	strh	r3, [r7, #38]	; 0x26
  /* Clear ACK, SMBTYPE and  SMBUS bits */
  tmpreg &= CR1_CLEAR_MASK;
 800e650:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
 800e652:	f423 6381 	bic.w	r3, r3, #1032	; 0x408
 800e656:	f023 0302 	bic.w	r3, r3, #2
 800e65a:	84fb      	strh	r3, [r7, #38]	; 0x26
  /* Configure I2Cx: mode and acknowledgement */
  /* Set SMBTYPE and SMBUS bits according to I2C_Mode value */
  /* Set ACK bit according to I2C_Ack value */
  tmpreg |= (uint16_t)((uint32_t)I2C_InitStruct->I2C_Mode | I2C_InitStruct->I2C_Ack);
 800e65c:	683b      	ldr	r3, [r7, #0]
 800e65e:	889a      	ldrh	r2, [r3, #4]
 800e660:	683b      	ldr	r3, [r7, #0]
 800e662:	895b      	ldrh	r3, [r3, #10]
 800e664:	4313      	orrs	r3, r2
 800e666:	b29a      	uxth	r2, r3
 800e668:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
 800e66a:	4313      	orrs	r3, r2
 800e66c:	84fb      	strh	r3, [r7, #38]	; 0x26
  /* Write to I2Cx CR1 */
  I2Cx->CR1 = tmpreg;
 800e66e:	687b      	ldr	r3, [r7, #4]
 800e670:	8cfa      	ldrh	r2, [r7, #38]	; 0x26
 800e672:	801a      	strh	r2, [r3, #0]

/*---------------------------- I2Cx OAR1 Configuration -----------------------*/
  /* Set I2Cx Own Address1 and acknowledged address */
  I2Cx->OAR1 = (I2C_InitStruct->I2C_AcknowledgedAddress | I2C_InitStruct->I2C_OwnAddress1);
 800e674:	683b      	ldr	r3, [r7, #0]
 800e676:	899a      	ldrh	r2, [r3, #12]
 800e678:	683b      	ldr	r3, [r7, #0]
 800e67a:	891b      	ldrh	r3, [r3, #8]
 800e67c:	4313      	orrs	r3, r2
 800e67e:	b29a      	uxth	r2, r3
 800e680:	687b      	ldr	r3, [r7, #4]
 800e682:	811a      	strh	r2, [r3, #8]
}
 800e684:	bf00      	nop
 800e686:	3728      	adds	r7, #40	; 0x28
 800e688:	46bd      	mov	sp, r7
 800e68a:	bd80      	pop	{r7, pc}
 800e68c:	007a1200 	.word	0x007a1200
 800e690:	431bde83 	.word	0x431bde83
 800e694:	000186a0 	.word	0x000186a0
 800e698:	10624dd3 	.word	0x10624dd3

0800e69c <I2C_StructInit>:
  * @brief  Fills each I2C_InitStruct member with its default value.
  * @param  I2C_InitStruct: pointer to an I2C_InitTypeDef structure which will be initialized.
  * @retval None
  */
void I2C_StructInit(I2C_InitTypeDef* I2C_InitStruct)
{
 800e69c:	b480      	push	{r7}
 800e69e:	b083      	sub	sp, #12
 800e6a0:	af00      	add	r7, sp, #0
 800e6a2:	6078      	str	r0, [r7, #4]
/*---------------- Reset I2C init structure parameters values ----------------*/
  /* initialize the I2C_ClockSpeed member */
  I2C_InitStruct->I2C_ClockSpeed = 5000;
 800e6a4:	687b      	ldr	r3, [r7, #4]
 800e6a6:	f241 3288 	movw	r2, #5000	; 0x1388
 800e6aa:	601a      	str	r2, [r3, #0]
  /* Initialize the I2C_Mode member */
  I2C_InitStruct->I2C_Mode = I2C_Mode_I2C;
 800e6ac:	687b      	ldr	r3, [r7, #4]
 800e6ae:	2200      	movs	r2, #0
 800e6b0:	809a      	strh	r2, [r3, #4]
  /* Initialize the I2C_DutyCycle member */
  I2C_InitStruct->I2C_DutyCycle = I2C_DutyCycle_2;
 800e6b2:	687b      	ldr	r3, [r7, #4]
 800e6b4:	f64b 72ff 	movw	r2, #49151	; 0xbfff
 800e6b8:	80da      	strh	r2, [r3, #6]
  /* Initialize the I2C_OwnAddress1 member */
  I2C_InitStruct->I2C_OwnAddress1 = 0;
 800e6ba:	687b      	ldr	r3, [r7, #4]
 800e6bc:	2200      	movs	r2, #0
 800e6be:	811a      	strh	r2, [r3, #8]
  /* Initialize the I2C_Ack member */
  I2C_InitStruct->I2C_Ack = I2C_Ack_Disable;
 800e6c0:	687b      	ldr	r3, [r7, #4]
 800e6c2:	2200      	movs	r2, #0
 800e6c4:	815a      	strh	r2, [r3, #10]
  /* Initialize the I2C_AcknowledgedAddress member */
  I2C_InitStruct->I2C_AcknowledgedAddress = I2C_AcknowledgedAddress_7bit;
 800e6c6:	687b      	ldr	r3, [r7, #4]
 800e6c8:	f44f 4280 	mov.w	r2, #16384	; 0x4000
 800e6cc:	819a      	strh	r2, [r3, #12]
}
 800e6ce:	bf00      	nop
 800e6d0:	370c      	adds	r7, #12
 800e6d2:	46bd      	mov	sp, r7
 800e6d4:	f85d 7b04 	ldr.w	r7, [sp], #4
 800e6d8:	4770      	bx	lr

0800e6da <I2C_Cmd>:
  * @param  NewState: new state of the I2Cx peripheral. 
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void I2C_Cmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
{
 800e6da:	b480      	push	{r7}
 800e6dc:	b083      	sub	sp, #12
 800e6de:	af00      	add	r7, sp, #0
 800e6e0:	6078      	str	r0, [r7, #4]
 800e6e2:	460b      	mov	r3, r1
 800e6e4:	70fb      	strb	r3, [r7, #3]
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 800e6e6:	78fb      	ldrb	r3, [r7, #3]
 800e6e8:	2b00      	cmp	r3, #0
 800e6ea:	d008      	beq.n	800e6fe <I2C_Cmd+0x24>
  {
    /* Enable the selected I2C peripheral */
    I2Cx->CR1 |= I2C_CR1_PE;
 800e6ec:	687b      	ldr	r3, [r7, #4]
 800e6ee:	881b      	ldrh	r3, [r3, #0]
 800e6f0:	b29b      	uxth	r3, r3
 800e6f2:	f043 0301 	orr.w	r3, r3, #1
 800e6f6:	b29a      	uxth	r2, r3
 800e6f8:	687b      	ldr	r3, [r7, #4]
 800e6fa:	801a      	strh	r2, [r3, #0]
  else
  {
    /* Disable the selected I2C peripheral */
    I2Cx->CR1 &= (uint16_t)~((uint16_t)I2C_CR1_PE);
  }
}
 800e6fc:	e007      	b.n	800e70e <I2C_Cmd+0x34>
    I2Cx->CR1 &= (uint16_t)~((uint16_t)I2C_CR1_PE);
 800e6fe:	687b      	ldr	r3, [r7, #4]
 800e700:	881b      	ldrh	r3, [r3, #0]
 800e702:	b29b      	uxth	r3, r3
 800e704:	f023 0301 	bic.w	r3, r3, #1
 800e708:	b29a      	uxth	r2, r3
 800e70a:	687b      	ldr	r3, [r7, #4]
 800e70c:	801a      	strh	r2, [r3, #0]
}
 800e70e:	bf00      	nop
 800e710:	370c      	adds	r7, #12
 800e712:	46bd      	mov	sp, r7
 800e714:	f85d 7b04 	ldr.w	r7, [sp], #4
 800e718:	4770      	bx	lr

0800e71a <I2C_GenerateSTART>:
  * @param  NewState: new state of the I2C START condition generation.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None.
  */
void I2C_GenerateSTART(I2C_TypeDef* I2Cx, FunctionalState NewState)
{
 800e71a:	b480      	push	{r7}
 800e71c:	b083      	sub	sp, #12
 800e71e:	af00      	add	r7, sp, #0
 800e720:	6078      	str	r0, [r7, #4]
 800e722:	460b      	mov	r3, r1
 800e724:	70fb      	strb	r3, [r7, #3]
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 800e726:	78fb      	ldrb	r3, [r7, #3]
 800e728:	2b00      	cmp	r3, #0
 800e72a:	d008      	beq.n	800e73e <I2C_GenerateSTART+0x24>
  {
    /* Generate a START condition */
    I2Cx->CR1 |= I2C_CR1_START;
 800e72c:	687b      	ldr	r3, [r7, #4]
 800e72e:	881b      	ldrh	r3, [r3, #0]
 800e730:	b29b      	uxth	r3, r3
 800e732:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 800e736:	b29a      	uxth	r2, r3
 800e738:	687b      	ldr	r3, [r7, #4]
 800e73a:	801a      	strh	r2, [r3, #0]
  else
  {
    /* Disable the START condition generation */
    I2Cx->CR1 &= (uint16_t)~((uint16_t)I2C_CR1_START);
  }
}
 800e73c:	e007      	b.n	800e74e <I2C_GenerateSTART+0x34>
    I2Cx->CR1 &= (uint16_t)~((uint16_t)I2C_CR1_START);
 800e73e:	687b      	ldr	r3, [r7, #4]
 800e740:	881b      	ldrh	r3, [r3, #0]
 800e742:	b29b      	uxth	r3, r3
 800e744:	f423 7380 	bic.w	r3, r3, #256	; 0x100
 800e748:	b29a      	uxth	r2, r3
 800e74a:	687b      	ldr	r3, [r7, #4]
 800e74c:	801a      	strh	r2, [r3, #0]
}
 800e74e:	bf00      	nop
 800e750:	370c      	adds	r7, #12
 800e752:	46bd      	mov	sp, r7
 800e754:	f85d 7b04 	ldr.w	r7, [sp], #4
 800e758:	4770      	bx	lr

0800e75a <I2C_GenerateSTOP>:
  * @param  NewState: new state of the I2C STOP condition generation.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None.
  */
void I2C_GenerateSTOP(I2C_TypeDef* I2Cx, FunctionalState NewState)
{
 800e75a:	b480      	push	{r7}
 800e75c:	b083      	sub	sp, #12
 800e75e:	af00      	add	r7, sp, #0
 800e760:	6078      	str	r0, [r7, #4]
 800e762:	460b      	mov	r3, r1
 800e764:	70fb      	strb	r3, [r7, #3]
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 800e766:	78fb      	ldrb	r3, [r7, #3]
 800e768:	2b00      	cmp	r3, #0
 800e76a:	d008      	beq.n	800e77e <I2C_GenerateSTOP+0x24>
  {
    /* Generate a STOP condition */
    I2Cx->CR1 |= I2C_CR1_STOP;
 800e76c:	687b      	ldr	r3, [r7, #4]
 800e76e:	881b      	ldrh	r3, [r3, #0]
 800e770:	b29b      	uxth	r3, r3
 800e772:	f443 7300 	orr.w	r3, r3, #512	; 0x200
 800e776:	b29a      	uxth	r2, r3
 800e778:	687b      	ldr	r3, [r7, #4]
 800e77a:	801a      	strh	r2, [r3, #0]
  else
  {
    /* Disable the STOP condition generation */
    I2Cx->CR1 &= (uint16_t)~((uint16_t)I2C_CR1_STOP);
  }
}
 800e77c:	e007      	b.n	800e78e <I2C_GenerateSTOP+0x34>
    I2Cx->CR1 &= (uint16_t)~((uint16_t)I2C_CR1_STOP);
 800e77e:	687b      	ldr	r3, [r7, #4]
 800e780:	881b      	ldrh	r3, [r3, #0]
 800e782:	b29b      	uxth	r3, r3
 800e784:	f423 7300 	bic.w	r3, r3, #512	; 0x200
 800e788:	b29a      	uxth	r2, r3
 800e78a:	687b      	ldr	r3, [r7, #4]
 800e78c:	801a      	strh	r2, [r3, #0]
}
 800e78e:	bf00      	nop
 800e790:	370c      	adds	r7, #12
 800e792:	46bd      	mov	sp, r7
 800e794:	f85d 7b04 	ldr.w	r7, [sp], #4
 800e798:	4770      	bx	lr

0800e79a <I2C_Send7bitAddress>:
  *            @arg I2C_Direction_Transmitter: Transmitter mode
  *            @arg I2C_Direction_Receiver: Receiver mode
  * @retval None.
  */
void I2C_Send7bitAddress(I2C_TypeDef* I2Cx, uint8_t Address, uint8_t I2C_Direction)
{
 800e79a:	b480      	push	{r7}
 800e79c:	b083      	sub	sp, #12
 800e79e:	af00      	add	r7, sp, #0
 800e7a0:	6078      	str	r0, [r7, #4]
 800e7a2:	460b      	mov	r3, r1
 800e7a4:	70fb      	strb	r3, [r7, #3]
 800e7a6:	4613      	mov	r3, r2
 800e7a8:	70bb      	strb	r3, [r7, #2]
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_I2C_DIRECTION(I2C_Direction));
  /* Test on the direction to set/reset the read/write bit */
  if (I2C_Direction != I2C_Direction_Transmitter)
 800e7aa:	78bb      	ldrb	r3, [r7, #2]
 800e7ac:	2b00      	cmp	r3, #0
 800e7ae:	d004      	beq.n	800e7ba <I2C_Send7bitAddress+0x20>
  {
    /* Set the address bit0 for read */
    Address |= I2C_OAR1_ADD0;
 800e7b0:	78fb      	ldrb	r3, [r7, #3]
 800e7b2:	f043 0301 	orr.w	r3, r3, #1
 800e7b6:	70fb      	strb	r3, [r7, #3]
 800e7b8:	e003      	b.n	800e7c2 <I2C_Send7bitAddress+0x28>
  }
  else
  {
    /* Reset the address bit0 for write */
    Address &= (uint8_t)~((uint8_t)I2C_OAR1_ADD0);
 800e7ba:	78fb      	ldrb	r3, [r7, #3]
 800e7bc:	f023 0301 	bic.w	r3, r3, #1
 800e7c0:	70fb      	strb	r3, [r7, #3]
  }
  /* Send the address */
  I2Cx->DR = Address;
 800e7c2:	78fb      	ldrb	r3, [r7, #3]
 800e7c4:	b29a      	uxth	r2, r3
 800e7c6:	687b      	ldr	r3, [r7, #4]
 800e7c8:	821a      	strh	r2, [r3, #16]
}
 800e7ca:	bf00      	nop
 800e7cc:	370c      	adds	r7, #12
 800e7ce:	46bd      	mov	sp, r7
 800e7d0:	f85d 7b04 	ldr.w	r7, [sp], #4
 800e7d4:	4770      	bx	lr

0800e7d6 <I2C_AcknowledgeConfig>:
  * @param  NewState: new state of the I2C Acknowledgement.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None.
  */
void I2C_AcknowledgeConfig(I2C_TypeDef* I2Cx, FunctionalState NewState)
{
 800e7d6:	b480      	push	{r7}
 800e7d8:	b083      	sub	sp, #12
 800e7da:	af00      	add	r7, sp, #0
 800e7dc:	6078      	str	r0, [r7, #4]
 800e7de:	460b      	mov	r3, r1
 800e7e0:	70fb      	strb	r3, [r7, #3]
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 800e7e2:	78fb      	ldrb	r3, [r7, #3]
 800e7e4:	2b00      	cmp	r3, #0
 800e7e6:	d008      	beq.n	800e7fa <I2C_AcknowledgeConfig+0x24>
  {
    /* Enable the acknowledgement */
    I2Cx->CR1 |= I2C_CR1_ACK;
 800e7e8:	687b      	ldr	r3, [r7, #4]
 800e7ea:	881b      	ldrh	r3, [r3, #0]
 800e7ec:	b29b      	uxth	r3, r3
 800e7ee:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
 800e7f2:	b29a      	uxth	r2, r3
 800e7f4:	687b      	ldr	r3, [r7, #4]
 800e7f6:	801a      	strh	r2, [r3, #0]
  else
  {
    /* Disable the acknowledgement */
    I2Cx->CR1 &= (uint16_t)~((uint16_t)I2C_CR1_ACK);
  }
}
 800e7f8:	e007      	b.n	800e80a <I2C_AcknowledgeConfig+0x34>
    I2Cx->CR1 &= (uint16_t)~((uint16_t)I2C_CR1_ACK);
 800e7fa:	687b      	ldr	r3, [r7, #4]
 800e7fc:	881b      	ldrh	r3, [r3, #0]
 800e7fe:	b29b      	uxth	r3, r3
 800e800:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 800e804:	b29a      	uxth	r2, r3
 800e806:	687b      	ldr	r3, [r7, #4]
 800e808:	801a      	strh	r2, [r3, #0]
}
 800e80a:	bf00      	nop
 800e80c:	370c      	adds	r7, #12
 800e80e:	46bd      	mov	sp, r7
 800e810:	f85d 7b04 	ldr.w	r7, [sp], #4
 800e814:	4770      	bx	lr

0800e816 <I2C_OwnAddress2Config>:
  * @param  I2Cx: where x can be 1, 2 or 3 to select the I2C peripheral.
  * @param  Address: specifies the 7bit I2C own address2.
  * @retval None.
  */
void I2C_OwnAddress2Config(I2C_TypeDef* I2Cx, uint8_t Address)
{
 800e816:	b480      	push	{r7}
 800e818:	b085      	sub	sp, #20
 800e81a:	af00      	add	r7, sp, #0
 800e81c:	6078      	str	r0, [r7, #4]
 800e81e:	460b      	mov	r3, r1
 800e820:	70fb      	strb	r3, [r7, #3]
  uint16_t tmpreg = 0;
 800e822:	2300      	movs	r3, #0
 800e824:	81fb      	strh	r3, [r7, #14]

  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));

  /* Get the old register value */
  tmpreg = I2Cx->OAR2;
 800e826:	687b      	ldr	r3, [r7, #4]
 800e828:	899b      	ldrh	r3, [r3, #12]
 800e82a:	81fb      	strh	r3, [r7, #14]

  /* Reset I2Cx Own address2 bit [7:1] */
  tmpreg &= (uint16_t)~((uint16_t)I2C_OAR2_ADD2);
 800e82c:	89fb      	ldrh	r3, [r7, #14]
 800e82e:	f023 03fe 	bic.w	r3, r3, #254	; 0xfe
 800e832:	81fb      	strh	r3, [r7, #14]

  /* Set I2Cx Own address2 */
  tmpreg |= (uint16_t)((uint16_t)Address & (uint16_t)0x00FE);
 800e834:	78fb      	ldrb	r3, [r7, #3]
 800e836:	b21b      	sxth	r3, r3
 800e838:	f003 03fe 	and.w	r3, r3, #254	; 0xfe
 800e83c:	b21a      	sxth	r2, r3
 800e83e:	f9b7 300e 	ldrsh.w	r3, [r7, #14]
 800e842:	4313      	orrs	r3, r2
 800e844:	b21b      	sxth	r3, r3
 800e846:	81fb      	strh	r3, [r7, #14]

  /* Store the new register value */
  I2Cx->OAR2 = tmpreg;
 800e848:	687b      	ldr	r3, [r7, #4]
 800e84a:	89fa      	ldrh	r2, [r7, #14]
 800e84c:	819a      	strh	r2, [r3, #12]
}
 800e84e:	bf00      	nop
 800e850:	3714      	adds	r7, #20
 800e852:	46bd      	mov	sp, r7
 800e854:	f85d 7b04 	ldr.w	r7, [sp], #4
 800e858:	4770      	bx	lr

0800e85a <I2C_DualAddressCmd>:
  * @param  NewState: new state of the I2C dual addressing mode.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void I2C_DualAddressCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
{
 800e85a:	b480      	push	{r7}
 800e85c:	b083      	sub	sp, #12
 800e85e:	af00      	add	r7, sp, #0
 800e860:	6078      	str	r0, [r7, #4]
 800e862:	460b      	mov	r3, r1
 800e864:	70fb      	strb	r3, [r7, #3]
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 800e866:	78fb      	ldrb	r3, [r7, #3]
 800e868:	2b00      	cmp	r3, #0
 800e86a:	d008      	beq.n	800e87e <I2C_DualAddressCmd+0x24>
  {
    /* Enable dual addressing mode */
    I2Cx->OAR2 |= I2C_OAR2_ENDUAL;
 800e86c:	687b      	ldr	r3, [r7, #4]
 800e86e:	899b      	ldrh	r3, [r3, #12]
 800e870:	b29b      	uxth	r3, r3
 800e872:	f043 0301 	orr.w	r3, r3, #1
 800e876:	b29a      	uxth	r2, r3
 800e878:	687b      	ldr	r3, [r7, #4]
 800e87a:	819a      	strh	r2, [r3, #12]
  else
  {
    /* Disable dual addressing mode */
    I2Cx->OAR2 &= (uint16_t)~((uint16_t)I2C_OAR2_ENDUAL);
  }
}
 800e87c:	e007      	b.n	800e88e <I2C_DualAddressCmd+0x34>
    I2Cx->OAR2 &= (uint16_t)~((uint16_t)I2C_OAR2_ENDUAL);
 800e87e:	687b      	ldr	r3, [r7, #4]
 800e880:	899b      	ldrh	r3, [r3, #12]
 800e882:	b29b      	uxth	r3, r3
 800e884:	f023 0301 	bic.w	r3, r3, #1
 800e888:	b29a      	uxth	r2, r3
 800e88a:	687b      	ldr	r3, [r7, #4]
 800e88c:	819a      	strh	r2, [r3, #12]
}
 800e88e:	bf00      	nop
 800e890:	370c      	adds	r7, #12
 800e892:	46bd      	mov	sp, r7
 800e894:	f85d 7b04 	ldr.w	r7, [sp], #4
 800e898:	4770      	bx	lr

0800e89a <I2C_GeneralCallCmd>:
  * @param  NewState: new state of the I2C General call.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void I2C_GeneralCallCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
{
 800e89a:	b480      	push	{r7}
 800e89c:	b083      	sub	sp, #12
 800e89e:	af00      	add	r7, sp, #0
 800e8a0:	6078      	str	r0, [r7, #4]
 800e8a2:	460b      	mov	r3, r1
 800e8a4:	70fb      	strb	r3, [r7, #3]
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 800e8a6:	78fb      	ldrb	r3, [r7, #3]
 800e8a8:	2b00      	cmp	r3, #0
 800e8aa:	d008      	beq.n	800e8be <I2C_GeneralCallCmd+0x24>
  {
    /* Enable generall call */
    I2Cx->CR1 |= I2C_CR1_ENGC;
 800e8ac:	687b      	ldr	r3, [r7, #4]
 800e8ae:	881b      	ldrh	r3, [r3, #0]
 800e8b0:	b29b      	uxth	r3, r3
 800e8b2:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 800e8b6:	b29a      	uxth	r2, r3
 800e8b8:	687b      	ldr	r3, [r7, #4]
 800e8ba:	801a      	strh	r2, [r3, #0]
  else
  {
    /* Disable generall call */
    I2Cx->CR1 &= (uint16_t)~((uint16_t)I2C_CR1_ENGC);
  }
}
 800e8bc:	e007      	b.n	800e8ce <I2C_GeneralCallCmd+0x34>
    I2Cx->CR1 &= (uint16_t)~((uint16_t)I2C_CR1_ENGC);
 800e8be:	687b      	ldr	r3, [r7, #4]
 800e8c0:	881b      	ldrh	r3, [r3, #0]
 800e8c2:	b29b      	uxth	r3, r3
 800e8c4:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 800e8c8:	b29a      	uxth	r2, r3
 800e8ca:	687b      	ldr	r3, [r7, #4]
 800e8cc:	801a      	strh	r2, [r3, #0]
}
 800e8ce:	bf00      	nop
 800e8d0:	370c      	adds	r7, #12
 800e8d2:	46bd      	mov	sp, r7
 800e8d4:	f85d 7b04 	ldr.w	r7, [sp], #4
 800e8d8:	4770      	bx	lr

0800e8da <I2C_SoftwareResetCmd>:
  * @param  NewState: new state of the I2C software reset.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void I2C_SoftwareResetCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
{
 800e8da:	b480      	push	{r7}
 800e8dc:	b083      	sub	sp, #12
 800e8de:	af00      	add	r7, sp, #0
 800e8e0:	6078      	str	r0, [r7, #4]
 800e8e2:	460b      	mov	r3, r1
 800e8e4:	70fb      	strb	r3, [r7, #3]
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 800e8e6:	78fb      	ldrb	r3, [r7, #3]
 800e8e8:	2b00      	cmp	r3, #0
 800e8ea:	d00a      	beq.n	800e902 <I2C_SoftwareResetCmd+0x28>
  {
    /* Peripheral under reset */
    I2Cx->CR1 |= I2C_CR1_SWRST;
 800e8ec:	687b      	ldr	r3, [r7, #4]
 800e8ee:	881b      	ldrh	r3, [r3, #0]
 800e8f0:	b29b      	uxth	r3, r3
 800e8f2:	ea6f 4343 	mvn.w	r3, r3, lsl #17
 800e8f6:	ea6f 4353 	mvn.w	r3, r3, lsr #17
 800e8fa:	b29a      	uxth	r2, r3
 800e8fc:	687b      	ldr	r3, [r7, #4]
 800e8fe:	801a      	strh	r2, [r3, #0]
  else
  {
    /* Peripheral not under reset */
    I2Cx->CR1 &= (uint16_t)~((uint16_t)I2C_CR1_SWRST);
  }
}
 800e900:	e007      	b.n	800e912 <I2C_SoftwareResetCmd+0x38>
    I2Cx->CR1 &= (uint16_t)~((uint16_t)I2C_CR1_SWRST);
 800e902:	687b      	ldr	r3, [r7, #4]
 800e904:	881b      	ldrh	r3, [r3, #0]
 800e906:	b29b      	uxth	r3, r3
 800e908:	f3c3 030e 	ubfx	r3, r3, #0, #15
 800e90c:	b29a      	uxth	r2, r3
 800e90e:	687b      	ldr	r3, [r7, #4]
 800e910:	801a      	strh	r2, [r3, #0]
}
 800e912:	bf00      	nop
 800e914:	370c      	adds	r7, #12
 800e916:	46bd      	mov	sp, r7
 800e918:	f85d 7b04 	ldr.w	r7, [sp], #4
 800e91c:	4770      	bx	lr

0800e91e <I2C_StretchClockCmd>:
  * @param  NewState: new state of the I2Cx Clock stretching.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void I2C_StretchClockCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
{
 800e91e:	b480      	push	{r7}
 800e920:	b083      	sub	sp, #12
 800e922:	af00      	add	r7, sp, #0
 800e924:	6078      	str	r0, [r7, #4]
 800e926:	460b      	mov	r3, r1
 800e928:	70fb      	strb	r3, [r7, #3]
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState == DISABLE)
 800e92a:	78fb      	ldrb	r3, [r7, #3]
 800e92c:	2b00      	cmp	r3, #0
 800e92e:	d108      	bne.n	800e942 <I2C_StretchClockCmd+0x24>
  {
    /* Enable the selected I2C Clock stretching */
    I2Cx->CR1 |= I2C_CR1_NOSTRETCH;
 800e930:	687b      	ldr	r3, [r7, #4]
 800e932:	881b      	ldrh	r3, [r3, #0]
 800e934:	b29b      	uxth	r3, r3
 800e936:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 800e93a:	b29a      	uxth	r2, r3
 800e93c:	687b      	ldr	r3, [r7, #4]
 800e93e:	801a      	strh	r2, [r3, #0]
  else
  {
    /* Disable the selected I2C Clock stretching */
    I2Cx->CR1 &= (uint16_t)~((uint16_t)I2C_CR1_NOSTRETCH);
  }
}
 800e940:	e007      	b.n	800e952 <I2C_StretchClockCmd+0x34>
    I2Cx->CR1 &= (uint16_t)~((uint16_t)I2C_CR1_NOSTRETCH);
 800e942:	687b      	ldr	r3, [r7, #4]
 800e944:	881b      	ldrh	r3, [r3, #0]
 800e946:	b29b      	uxth	r3, r3
 800e948:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 800e94c:	b29a      	uxth	r2, r3
 800e94e:	687b      	ldr	r3, [r7, #4]
 800e950:	801a      	strh	r2, [r3, #0]
}
 800e952:	bf00      	nop
 800e954:	370c      	adds	r7, #12
 800e956:	46bd      	mov	sp, r7
 800e958:	f85d 7b04 	ldr.w	r7, [sp], #4
 800e95c:	4770      	bx	lr

0800e95e <I2C_FastModeDutyCycleConfig>:
  *            @arg I2C_DutyCycle_2: I2C fast mode Tlow/Thigh = 2
  *            @arg I2C_DutyCycle_16_9: I2C fast mode Tlow/Thigh = 16/9
  * @retval None
  */
void I2C_FastModeDutyCycleConfig(I2C_TypeDef* I2Cx, uint16_t I2C_DutyCycle)
{
 800e95e:	b480      	push	{r7}
 800e960:	b083      	sub	sp, #12
 800e962:	af00      	add	r7, sp, #0
 800e964:	6078      	str	r0, [r7, #4]
 800e966:	460b      	mov	r3, r1
 800e968:	807b      	strh	r3, [r7, #2]
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_I2C_DUTY_CYCLE(I2C_DutyCycle));
  if (I2C_DutyCycle != I2C_DutyCycle_16_9)
 800e96a:	887b      	ldrh	r3, [r7, #2]
 800e96c:	f5b3 4f80 	cmp.w	r3, #16384	; 0x4000
 800e970:	d008      	beq.n	800e984 <I2C_FastModeDutyCycleConfig+0x26>
  {
    /* I2C fast mode Tlow/Thigh=2 */
    I2Cx->CCR &= I2C_DutyCycle_2;
 800e972:	687b      	ldr	r3, [r7, #4]
 800e974:	8b9b      	ldrh	r3, [r3, #28]
 800e976:	b29b      	uxth	r3, r3
 800e978:	f423 4380 	bic.w	r3, r3, #16384	; 0x4000
 800e97c:	b29a      	uxth	r2, r3
 800e97e:	687b      	ldr	r3, [r7, #4]
 800e980:	839a      	strh	r2, [r3, #28]
  else
  {
    /* I2C fast mode Tlow/Thigh=16/9 */
    I2Cx->CCR |= I2C_DutyCycle_16_9;
  }
}
 800e982:	e007      	b.n	800e994 <I2C_FastModeDutyCycleConfig+0x36>
    I2Cx->CCR |= I2C_DutyCycle_16_9;
 800e984:	687b      	ldr	r3, [r7, #4]
 800e986:	8b9b      	ldrh	r3, [r3, #28]
 800e988:	b29b      	uxth	r3, r3
 800e98a:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 800e98e:	b29a      	uxth	r2, r3
 800e990:	687b      	ldr	r3, [r7, #4]
 800e992:	839a      	strh	r2, [r3, #28]
}
 800e994:	bf00      	nop
 800e996:	370c      	adds	r7, #12
 800e998:	46bd      	mov	sp, r7
 800e99a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800e99e:	4770      	bx	lr

0800e9a0 <I2C_NACKPositionConfig>:
  *          is intended to used in SMBUS mode. 
  *            
  * @retval None
  */
void I2C_NACKPositionConfig(I2C_TypeDef* I2Cx, uint16_t I2C_NACKPosition)
{
 800e9a0:	b480      	push	{r7}
 800e9a2:	b083      	sub	sp, #12
 800e9a4:	af00      	add	r7, sp, #0
 800e9a6:	6078      	str	r0, [r7, #4]
 800e9a8:	460b      	mov	r3, r1
 800e9aa:	807b      	strh	r3, [r7, #2]
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_I2C_NACK_POSITION(I2C_NACKPosition));
  
  /* Check the input parameter */
  if (I2C_NACKPosition == I2C_NACKPosition_Next)
 800e9ac:	887b      	ldrh	r3, [r7, #2]
 800e9ae:	f5b3 6f00 	cmp.w	r3, #2048	; 0x800
 800e9b2:	d108      	bne.n	800e9c6 <I2C_NACKPositionConfig+0x26>
  {
    /* Next byte in shift register is the last received byte */
    I2Cx->CR1 |= I2C_NACKPosition_Next;
 800e9b4:	687b      	ldr	r3, [r7, #4]
 800e9b6:	881b      	ldrh	r3, [r3, #0]
 800e9b8:	b29b      	uxth	r3, r3
 800e9ba:	f443 6300 	orr.w	r3, r3, #2048	; 0x800
 800e9be:	b29a      	uxth	r2, r3
 800e9c0:	687b      	ldr	r3, [r7, #4]
 800e9c2:	801a      	strh	r2, [r3, #0]
  else
  {
    /* Current byte in shift register is the last received byte */
    I2Cx->CR1 &= I2C_NACKPosition_Current;
  }
}
 800e9c4:	e007      	b.n	800e9d6 <I2C_NACKPositionConfig+0x36>
    I2Cx->CR1 &= I2C_NACKPosition_Current;
 800e9c6:	687b      	ldr	r3, [r7, #4]
 800e9c8:	881b      	ldrh	r3, [r3, #0]
 800e9ca:	b29b      	uxth	r3, r3
 800e9cc:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
 800e9d0:	b29a      	uxth	r2, r3
 800e9d2:	687b      	ldr	r3, [r7, #4]
 800e9d4:	801a      	strh	r2, [r3, #0]
}
 800e9d6:	bf00      	nop
 800e9d8:	370c      	adds	r7, #12
 800e9da:	46bd      	mov	sp, r7
 800e9dc:	f85d 7b04 	ldr.w	r7, [sp], #4
 800e9e0:	4770      	bx	lr

0800e9e2 <I2C_SMBusAlertConfig>:
  *            @arg I2C_SMBusAlert_Low: SMBAlert pin driven low
  *            @arg I2C_SMBusAlert_High: SMBAlert pin driven high
  * @retval None
  */
void I2C_SMBusAlertConfig(I2C_TypeDef* I2Cx, uint16_t I2C_SMBusAlert)
{
 800e9e2:	b480      	push	{r7}
 800e9e4:	b083      	sub	sp, #12
 800e9e6:	af00      	add	r7, sp, #0
 800e9e8:	6078      	str	r0, [r7, #4]
 800e9ea:	460b      	mov	r3, r1
 800e9ec:	807b      	strh	r3, [r7, #2]
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_I2C_SMBUS_ALERT(I2C_SMBusAlert));
  if (I2C_SMBusAlert == I2C_SMBusAlert_Low)
 800e9ee:	887b      	ldrh	r3, [r7, #2]
 800e9f0:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
 800e9f4:	d108      	bne.n	800ea08 <I2C_SMBusAlertConfig+0x26>
  {
    /* Drive the SMBusAlert pin Low */
    I2Cx->CR1 |= I2C_SMBusAlert_Low;
 800e9f6:	687b      	ldr	r3, [r7, #4]
 800e9f8:	881b      	ldrh	r3, [r3, #0]
 800e9fa:	b29b      	uxth	r3, r3
 800e9fc:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
 800ea00:	b29a      	uxth	r2, r3
 800ea02:	687b      	ldr	r3, [r7, #4]
 800ea04:	801a      	strh	r2, [r3, #0]
  else
  {
    /* Drive the SMBusAlert pin High  */
    I2Cx->CR1 &= I2C_SMBusAlert_High;
  }
}
 800ea06:	e007      	b.n	800ea18 <I2C_SMBusAlertConfig+0x36>
    I2Cx->CR1 &= I2C_SMBusAlert_High;
 800ea08:	687b      	ldr	r3, [r7, #4]
 800ea0a:	881b      	ldrh	r3, [r3, #0]
 800ea0c:	b29b      	uxth	r3, r3
 800ea0e:	f423 5300 	bic.w	r3, r3, #8192	; 0x2000
 800ea12:	b29a      	uxth	r2, r3
 800ea14:	687b      	ldr	r3, [r7, #4]
 800ea16:	801a      	strh	r2, [r3, #0]
}
 800ea18:	bf00      	nop
 800ea1a:	370c      	adds	r7, #12
 800ea1c:	46bd      	mov	sp, r7
 800ea1e:	f85d 7b04 	ldr.w	r7, [sp], #4
 800ea22:	4770      	bx	lr

0800ea24 <I2C_ARPCmd>:
  * @param  NewState: new state of the I2Cx ARP. 
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void I2C_ARPCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
{
 800ea24:	b480      	push	{r7}
 800ea26:	b083      	sub	sp, #12
 800ea28:	af00      	add	r7, sp, #0
 800ea2a:	6078      	str	r0, [r7, #4]
 800ea2c:	460b      	mov	r3, r1
 800ea2e:	70fb      	strb	r3, [r7, #3]
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 800ea30:	78fb      	ldrb	r3, [r7, #3]
 800ea32:	2b00      	cmp	r3, #0
 800ea34:	d008      	beq.n	800ea48 <I2C_ARPCmd+0x24>
  {
    /* Enable the selected I2C ARP */
    I2Cx->CR1 |= I2C_CR1_ENARP;
 800ea36:	687b      	ldr	r3, [r7, #4]
 800ea38:	881b      	ldrh	r3, [r3, #0]
 800ea3a:	b29b      	uxth	r3, r3
 800ea3c:	f043 0310 	orr.w	r3, r3, #16
 800ea40:	b29a      	uxth	r2, r3
 800ea42:	687b      	ldr	r3, [r7, #4]
 800ea44:	801a      	strh	r2, [r3, #0]
  else
  {
    /* Disable the selected I2C ARP */
    I2Cx->CR1 &= (uint16_t)~((uint16_t)I2C_CR1_ENARP);
  }
}
 800ea46:	e007      	b.n	800ea58 <I2C_ARPCmd+0x34>
    I2Cx->CR1 &= (uint16_t)~((uint16_t)I2C_CR1_ENARP);
 800ea48:	687b      	ldr	r3, [r7, #4]
 800ea4a:	881b      	ldrh	r3, [r3, #0]
 800ea4c:	b29b      	uxth	r3, r3
 800ea4e:	f023 0310 	bic.w	r3, r3, #16
 800ea52:	b29a      	uxth	r2, r3
 800ea54:	687b      	ldr	r3, [r7, #4]
 800ea56:	801a      	strh	r2, [r3, #0]
}
 800ea58:	bf00      	nop
 800ea5a:	370c      	adds	r7, #12
 800ea5c:	46bd      	mov	sp, r7
 800ea5e:	f85d 7b04 	ldr.w	r7, [sp], #4
 800ea62:	4770      	bx	lr

0800ea64 <I2C_SendData>:
  * @param  I2Cx: where x can be 1, 2 or 3 to select the I2C peripheral.
  * @param  Data: Byte to be transmitted..
  * @retval None
  */
void I2C_SendData(I2C_TypeDef* I2Cx, uint8_t Data)
{
 800ea64:	b480      	push	{r7}
 800ea66:	b083      	sub	sp, #12
 800ea68:	af00      	add	r7, sp, #0
 800ea6a:	6078      	str	r0, [r7, #4]
 800ea6c:	460b      	mov	r3, r1
 800ea6e:	70fb      	strb	r3, [r7, #3]
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  /* Write in the DR register the data to be sent */
  I2Cx->DR = Data;
 800ea70:	78fb      	ldrb	r3, [r7, #3]
 800ea72:	b29a      	uxth	r2, r3
 800ea74:	687b      	ldr	r3, [r7, #4]
 800ea76:	821a      	strh	r2, [r3, #16]
}
 800ea78:	bf00      	nop
 800ea7a:	370c      	adds	r7, #12
 800ea7c:	46bd      	mov	sp, r7
 800ea7e:	f85d 7b04 	ldr.w	r7, [sp], #4
 800ea82:	4770      	bx	lr

0800ea84 <I2C_ReceiveData>:
  * @brief  Returns the most recent received data by the I2Cx peripheral.
  * @param  I2Cx: where x can be 1, 2 or 3 to select the I2C peripheral.
  * @retval The value of the received data.
  */
uint8_t I2C_ReceiveData(I2C_TypeDef* I2Cx)
{
 800ea84:	b480      	push	{r7}
 800ea86:	b083      	sub	sp, #12
 800ea88:	af00      	add	r7, sp, #0
 800ea8a:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  /* Return the data in the DR register */
  return (uint8_t)I2Cx->DR;
 800ea8c:	687b      	ldr	r3, [r7, #4]
 800ea8e:	8a1b      	ldrh	r3, [r3, #16]
 800ea90:	b29b      	uxth	r3, r3
 800ea92:	b2db      	uxtb	r3, r3
}
 800ea94:	4618      	mov	r0, r3
 800ea96:	370c      	adds	r7, #12
 800ea98:	46bd      	mov	sp, r7
 800ea9a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800ea9e:	4770      	bx	lr

0800eaa0 <I2C_TransmitPEC>:
  * @param  NewState: new state of the I2C PEC transmission.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void I2C_TransmitPEC(I2C_TypeDef* I2Cx, FunctionalState NewState)
{
 800eaa0:	b480      	push	{r7}
 800eaa2:	b083      	sub	sp, #12
 800eaa4:	af00      	add	r7, sp, #0
 800eaa6:	6078      	str	r0, [r7, #4]
 800eaa8:	460b      	mov	r3, r1
 800eaaa:	70fb      	strb	r3, [r7, #3]
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 800eaac:	78fb      	ldrb	r3, [r7, #3]
 800eaae:	2b00      	cmp	r3, #0
 800eab0:	d008      	beq.n	800eac4 <I2C_TransmitPEC+0x24>
  {
    /* Enable the selected I2C PEC transmission */
    I2Cx->CR1 |= I2C_CR1_PEC;
 800eab2:	687b      	ldr	r3, [r7, #4]
 800eab4:	881b      	ldrh	r3, [r3, #0]
 800eab6:	b29b      	uxth	r3, r3
 800eab8:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
 800eabc:	b29a      	uxth	r2, r3
 800eabe:	687b      	ldr	r3, [r7, #4]
 800eac0:	801a      	strh	r2, [r3, #0]
  else
  {
    /* Disable the selected I2C PEC transmission */
    I2Cx->CR1 &= (uint16_t)~((uint16_t)I2C_CR1_PEC);
  }
}
 800eac2:	e007      	b.n	800ead4 <I2C_TransmitPEC+0x34>
    I2Cx->CR1 &= (uint16_t)~((uint16_t)I2C_CR1_PEC);
 800eac4:	687b      	ldr	r3, [r7, #4]
 800eac6:	881b      	ldrh	r3, [r3, #0]
 800eac8:	b29b      	uxth	r3, r3
 800eaca:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
 800eace:	b29a      	uxth	r2, r3
 800ead0:	687b      	ldr	r3, [r7, #4]
 800ead2:	801a      	strh	r2, [r3, #0]
}
 800ead4:	bf00      	nop
 800ead6:	370c      	adds	r7, #12
 800ead8:	46bd      	mov	sp, r7
 800eada:	f85d 7b04 	ldr.w	r7, [sp], #4
 800eade:	4770      	bx	lr

0800eae0 <I2C_PECPositionConfig>:
  *          is intended to used in I2C mode.
  *                
  * @retval None
  */
void I2C_PECPositionConfig(I2C_TypeDef* I2Cx, uint16_t I2C_PECPosition)
{
 800eae0:	b480      	push	{r7}
 800eae2:	b083      	sub	sp, #12
 800eae4:	af00      	add	r7, sp, #0
 800eae6:	6078      	str	r0, [r7, #4]
 800eae8:	460b      	mov	r3, r1
 800eaea:	807b      	strh	r3, [r7, #2]
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_I2C_PEC_POSITION(I2C_PECPosition));
  if (I2C_PECPosition == I2C_PECPosition_Next)
 800eaec:	887b      	ldrh	r3, [r7, #2]
 800eaee:	f5b3 6f00 	cmp.w	r3, #2048	; 0x800
 800eaf2:	d108      	bne.n	800eb06 <I2C_PECPositionConfig+0x26>
  {
    /* Next byte in shift register is PEC */
    I2Cx->CR1 |= I2C_PECPosition_Next;
 800eaf4:	687b      	ldr	r3, [r7, #4]
 800eaf6:	881b      	ldrh	r3, [r3, #0]
 800eaf8:	b29b      	uxth	r3, r3
 800eafa:	f443 6300 	orr.w	r3, r3, #2048	; 0x800
 800eafe:	b29a      	uxth	r2, r3
 800eb00:	687b      	ldr	r3, [r7, #4]
 800eb02:	801a      	strh	r2, [r3, #0]
  else
  {
    /* Current byte in shift register is PEC */
    I2Cx->CR1 &= I2C_PECPosition_Current;
  }
}
 800eb04:	e007      	b.n	800eb16 <I2C_PECPositionConfig+0x36>
    I2Cx->CR1 &= I2C_PECPosition_Current;
 800eb06:	687b      	ldr	r3, [r7, #4]
 800eb08:	881b      	ldrh	r3, [r3, #0]
 800eb0a:	b29b      	uxth	r3, r3
 800eb0c:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
 800eb10:	b29a      	uxth	r2, r3
 800eb12:	687b      	ldr	r3, [r7, #4]
 800eb14:	801a      	strh	r2, [r3, #0]
}
 800eb16:	bf00      	nop
 800eb18:	370c      	adds	r7, #12
 800eb1a:	46bd      	mov	sp, r7
 800eb1c:	f85d 7b04 	ldr.w	r7, [sp], #4
 800eb20:	4770      	bx	lr

0800eb22 <I2C_CalculatePEC>:
  * @param  NewState: new state of the I2Cx PEC value calculation.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void I2C_CalculatePEC(I2C_TypeDef* I2Cx, FunctionalState NewState)
{
 800eb22:	b480      	push	{r7}
 800eb24:	b083      	sub	sp, #12
 800eb26:	af00      	add	r7, sp, #0
 800eb28:	6078      	str	r0, [r7, #4]
 800eb2a:	460b      	mov	r3, r1
 800eb2c:	70fb      	strb	r3, [r7, #3]
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 800eb2e:	78fb      	ldrb	r3, [r7, #3]
 800eb30:	2b00      	cmp	r3, #0
 800eb32:	d008      	beq.n	800eb46 <I2C_CalculatePEC+0x24>
  {
    /* Enable the selected I2C PEC calculation */
    I2Cx->CR1 |= I2C_CR1_ENPEC;
 800eb34:	687b      	ldr	r3, [r7, #4]
 800eb36:	881b      	ldrh	r3, [r3, #0]
 800eb38:	b29b      	uxth	r3, r3
 800eb3a:	f043 0320 	orr.w	r3, r3, #32
 800eb3e:	b29a      	uxth	r2, r3
 800eb40:	687b      	ldr	r3, [r7, #4]
 800eb42:	801a      	strh	r2, [r3, #0]
  else
  {
    /* Disable the selected I2C PEC calculation */
    I2Cx->CR1 &= (uint16_t)~((uint16_t)I2C_CR1_ENPEC);
  }
}
 800eb44:	e007      	b.n	800eb56 <I2C_CalculatePEC+0x34>
    I2Cx->CR1 &= (uint16_t)~((uint16_t)I2C_CR1_ENPEC);
 800eb46:	687b      	ldr	r3, [r7, #4]
 800eb48:	881b      	ldrh	r3, [r3, #0]
 800eb4a:	b29b      	uxth	r3, r3
 800eb4c:	f023 0320 	bic.w	r3, r3, #32
 800eb50:	b29a      	uxth	r2, r3
 800eb52:	687b      	ldr	r3, [r7, #4]
 800eb54:	801a      	strh	r2, [r3, #0]
}
 800eb56:	bf00      	nop
 800eb58:	370c      	adds	r7, #12
 800eb5a:	46bd      	mov	sp, r7
 800eb5c:	f85d 7b04 	ldr.w	r7, [sp], #4
 800eb60:	4770      	bx	lr

0800eb62 <I2C_GetPEC>:
  * @brief  Returns the PEC value for the specified I2C.
  * @param  I2Cx: where x can be 1, 2 or 3 to select the I2C peripheral.
  * @retval The PEC value.
  */
uint8_t I2C_GetPEC(I2C_TypeDef* I2Cx)
{
 800eb62:	b480      	push	{r7}
 800eb64:	b083      	sub	sp, #12
 800eb66:	af00      	add	r7, sp, #0
 800eb68:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  /* Return the selected I2C PEC value */
  return ((I2Cx->SR2) >> 8);
 800eb6a:	687b      	ldr	r3, [r7, #4]
 800eb6c:	8b1b      	ldrh	r3, [r3, #24]
 800eb6e:	b29b      	uxth	r3, r3
 800eb70:	0a1b      	lsrs	r3, r3, #8
 800eb72:	b29b      	uxth	r3, r3
 800eb74:	b2db      	uxtb	r3, r3
}
 800eb76:	4618      	mov	r0, r3
 800eb78:	370c      	adds	r7, #12
 800eb7a:	46bd      	mov	sp, r7
 800eb7c:	f85d 7b04 	ldr.w	r7, [sp], #4
 800eb80:	4770      	bx	lr

0800eb82 <I2C_DMACmd>:
  * @param  NewState: new state of the I2C DMA transfer.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void I2C_DMACmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
{
 800eb82:	b480      	push	{r7}
 800eb84:	b083      	sub	sp, #12
 800eb86:	af00      	add	r7, sp, #0
 800eb88:	6078      	str	r0, [r7, #4]
 800eb8a:	460b      	mov	r3, r1
 800eb8c:	70fb      	strb	r3, [r7, #3]
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 800eb8e:	78fb      	ldrb	r3, [r7, #3]
 800eb90:	2b00      	cmp	r3, #0
 800eb92:	d008      	beq.n	800eba6 <I2C_DMACmd+0x24>
  {
    /* Enable the selected I2C DMA requests */
    I2Cx->CR2 |= I2C_CR2_DMAEN;
 800eb94:	687b      	ldr	r3, [r7, #4]
 800eb96:	889b      	ldrh	r3, [r3, #4]
 800eb98:	b29b      	uxth	r3, r3
 800eb9a:	f443 6300 	orr.w	r3, r3, #2048	; 0x800
 800eb9e:	b29a      	uxth	r2, r3
 800eba0:	687b      	ldr	r3, [r7, #4]
 800eba2:	809a      	strh	r2, [r3, #4]
  else
  {
    /* Disable the selected I2C DMA requests */
    I2Cx->CR2 &= (uint16_t)~((uint16_t)I2C_CR2_DMAEN);
  }
}
 800eba4:	e007      	b.n	800ebb6 <I2C_DMACmd+0x34>
    I2Cx->CR2 &= (uint16_t)~((uint16_t)I2C_CR2_DMAEN);
 800eba6:	687b      	ldr	r3, [r7, #4]
 800eba8:	889b      	ldrh	r3, [r3, #4]
 800ebaa:	b29b      	uxth	r3, r3
 800ebac:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
 800ebb0:	b29a      	uxth	r2, r3
 800ebb2:	687b      	ldr	r3, [r7, #4]
 800ebb4:	809a      	strh	r2, [r3, #4]
}
 800ebb6:	bf00      	nop
 800ebb8:	370c      	adds	r7, #12
 800ebba:	46bd      	mov	sp, r7
 800ebbc:	f85d 7b04 	ldr.w	r7, [sp], #4
 800ebc0:	4770      	bx	lr

0800ebc2 <I2C_DMALastTransferCmd>:
  * @param  NewState: new state of the I2C DMA last transfer.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void I2C_DMALastTransferCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
{
 800ebc2:	b480      	push	{r7}
 800ebc4:	b083      	sub	sp, #12
 800ebc6:	af00      	add	r7, sp, #0
 800ebc8:	6078      	str	r0, [r7, #4]
 800ebca:	460b      	mov	r3, r1
 800ebcc:	70fb      	strb	r3, [r7, #3]
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 800ebce:	78fb      	ldrb	r3, [r7, #3]
 800ebd0:	2b00      	cmp	r3, #0
 800ebd2:	d008      	beq.n	800ebe6 <I2C_DMALastTransferCmd+0x24>
  {
    /* Next DMA transfer is the last transfer */
    I2Cx->CR2 |= I2C_CR2_LAST;
 800ebd4:	687b      	ldr	r3, [r7, #4]
 800ebd6:	889b      	ldrh	r3, [r3, #4]
 800ebd8:	b29b      	uxth	r3, r3
 800ebda:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
 800ebde:	b29a      	uxth	r2, r3
 800ebe0:	687b      	ldr	r3, [r7, #4]
 800ebe2:	809a      	strh	r2, [r3, #4]
  else
  {
    /* Next DMA transfer is not the last transfer */
    I2Cx->CR2 &= (uint16_t)~((uint16_t)I2C_CR2_LAST);
  }
}
 800ebe4:	e007      	b.n	800ebf6 <I2C_DMALastTransferCmd+0x34>
    I2Cx->CR2 &= (uint16_t)~((uint16_t)I2C_CR2_LAST);
 800ebe6:	687b      	ldr	r3, [r7, #4]
 800ebe8:	889b      	ldrh	r3, [r3, #4]
 800ebea:	b29b      	uxth	r3, r3
 800ebec:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
 800ebf0:	b29a      	uxth	r2, r3
 800ebf2:	687b      	ldr	r3, [r7, #4]
 800ebf4:	809a      	strh	r2, [r3, #4]
}
 800ebf6:	bf00      	nop
 800ebf8:	370c      	adds	r7, #12
 800ebfa:	46bd      	mov	sp, r7
 800ebfc:	f85d 7b04 	ldr.w	r7, [sp], #4
 800ec00:	4770      	bx	lr

0800ec02 <I2C_ReadRegister>:
  *            @arg I2C_Register_CCR:   CCR register.
  *            @arg I2C_Register_TRISE: TRISE register.
  * @retval The value of the read register.
  */
uint16_t I2C_ReadRegister(I2C_TypeDef* I2Cx, uint8_t I2C_Register)
{
 800ec02:	b480      	push	{r7}
 800ec04:	b085      	sub	sp, #20
 800ec06:	af00      	add	r7, sp, #0
 800ec08:	6078      	str	r0, [r7, #4]
 800ec0a:	460b      	mov	r3, r1
 800ec0c:	70fb      	strb	r3, [r7, #3]
  __IO uint32_t tmp = 0;
 800ec0e:	2300      	movs	r3, #0
 800ec10:	60fb      	str	r3, [r7, #12]

  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_I2C_REGISTER(I2C_Register));

  tmp = (uint32_t) I2Cx;
 800ec12:	687b      	ldr	r3, [r7, #4]
 800ec14:	60fb      	str	r3, [r7, #12]
  tmp += I2C_Register;
 800ec16:	78fa      	ldrb	r2, [r7, #3]
 800ec18:	68fb      	ldr	r3, [r7, #12]
 800ec1a:	4413      	add	r3, r2
 800ec1c:	60fb      	str	r3, [r7, #12]

  /* Return the selected register value */
  return (*(__IO uint16_t *) tmp);
 800ec1e:	68fb      	ldr	r3, [r7, #12]
 800ec20:	881b      	ldrh	r3, [r3, #0]
 800ec22:	b29b      	uxth	r3, r3
}
 800ec24:	4618      	mov	r0, r3
 800ec26:	3714      	adds	r7, #20
 800ec28:	46bd      	mov	sp, r7
 800ec2a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800ec2e:	4770      	bx	lr

0800ec30 <I2C_ITConfig>:
  * @param  NewState: new state of the specified I2C interrupts.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void I2C_ITConfig(I2C_TypeDef* I2Cx, uint16_t I2C_IT, FunctionalState NewState)
{
 800ec30:	b480      	push	{r7}
 800ec32:	b083      	sub	sp, #12
 800ec34:	af00      	add	r7, sp, #0
 800ec36:	6078      	str	r0, [r7, #4]
 800ec38:	460b      	mov	r3, r1
 800ec3a:	807b      	strh	r3, [r7, #2]
 800ec3c:	4613      	mov	r3, r2
 800ec3e:	707b      	strb	r3, [r7, #1]
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  assert_param(IS_I2C_CONFIG_IT(I2C_IT));
  
  if (NewState != DISABLE)
 800ec40:	787b      	ldrb	r3, [r7, #1]
 800ec42:	2b00      	cmp	r3, #0
 800ec44:	d008      	beq.n	800ec58 <I2C_ITConfig+0x28>
  {
    /* Enable the selected I2C interrupts */
    I2Cx->CR2 |= I2C_IT;
 800ec46:	687b      	ldr	r3, [r7, #4]
 800ec48:	889b      	ldrh	r3, [r3, #4]
 800ec4a:	b29a      	uxth	r2, r3
 800ec4c:	887b      	ldrh	r3, [r7, #2]
 800ec4e:	4313      	orrs	r3, r2
 800ec50:	b29a      	uxth	r2, r3
 800ec52:	687b      	ldr	r3, [r7, #4]
 800ec54:	809a      	strh	r2, [r3, #4]
  else
  {
    /* Disable the selected I2C interrupts */
    I2Cx->CR2 &= (uint16_t)~I2C_IT;
  }
}
 800ec56:	e009      	b.n	800ec6c <I2C_ITConfig+0x3c>
    I2Cx->CR2 &= (uint16_t)~I2C_IT;
 800ec58:	687b      	ldr	r3, [r7, #4]
 800ec5a:	889b      	ldrh	r3, [r3, #4]
 800ec5c:	b29a      	uxth	r2, r3
 800ec5e:	887b      	ldrh	r3, [r7, #2]
 800ec60:	43db      	mvns	r3, r3
 800ec62:	b29b      	uxth	r3, r3
 800ec64:	4013      	ands	r3, r2
 800ec66:	b29a      	uxth	r2, r3
 800ec68:	687b      	ldr	r3, [r7, #4]
 800ec6a:	809a      	strh	r2, [r3, #4]
}
 800ec6c:	bf00      	nop
 800ec6e:	370c      	adds	r7, #12
 800ec70:	46bd      	mov	sp, r7
 800ec72:	f85d 7b04 	ldr.w	r7, [sp], #4
 800ec76:	4770      	bx	lr

0800ec78 <I2C_CheckEvent>:
  * @retval An ErrorStatus enumeration value:
  *           - SUCCESS: Last event is equal to the I2C_EVENT
  *           - ERROR: Last event is different from the I2C_EVENT
  */
ErrorStatus I2C_CheckEvent(I2C_TypeDef* I2Cx, uint32_t I2C_EVENT)
{
 800ec78:	b480      	push	{r7}
 800ec7a:	b087      	sub	sp, #28
 800ec7c:	af00      	add	r7, sp, #0
 800ec7e:	6078      	str	r0, [r7, #4]
 800ec80:	6039      	str	r1, [r7, #0]
  uint32_t lastevent = 0;
 800ec82:	2300      	movs	r3, #0
 800ec84:	613b      	str	r3, [r7, #16]
  uint32_t flag1 = 0, flag2 = 0;
 800ec86:	2300      	movs	r3, #0
 800ec88:	60fb      	str	r3, [r7, #12]
 800ec8a:	2300      	movs	r3, #0
 800ec8c:	60bb      	str	r3, [r7, #8]
  ErrorStatus status = ERROR;
 800ec8e:	2300      	movs	r3, #0
 800ec90:	75fb      	strb	r3, [r7, #23]
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_I2C_EVENT(I2C_EVENT));

  /* Read the I2Cx status register */
  flag1 = I2Cx->SR1;
 800ec92:	687b      	ldr	r3, [r7, #4]
 800ec94:	8a9b      	ldrh	r3, [r3, #20]
 800ec96:	b29b      	uxth	r3, r3
 800ec98:	60fb      	str	r3, [r7, #12]
  flag2 = I2Cx->SR2;
 800ec9a:	687b      	ldr	r3, [r7, #4]
 800ec9c:	8b1b      	ldrh	r3, [r3, #24]
 800ec9e:	b29b      	uxth	r3, r3
 800eca0:	60bb      	str	r3, [r7, #8]
  flag2 = flag2 << 16;
 800eca2:	68bb      	ldr	r3, [r7, #8]
 800eca4:	041b      	lsls	r3, r3, #16
 800eca6:	60bb      	str	r3, [r7, #8]

  /* Get the last event value from I2C status register */
  lastevent = (flag1 | flag2) & FLAG_MASK;
 800eca8:	68fa      	ldr	r2, [r7, #12]
 800ecaa:	68bb      	ldr	r3, [r7, #8]
 800ecac:	4313      	orrs	r3, r2
 800ecae:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
 800ecb2:	613b      	str	r3, [r7, #16]

  /* Check whether the last event contains the I2C_EVENT */
  if ((lastevent & I2C_EVENT) == I2C_EVENT)
 800ecb4:	693a      	ldr	r2, [r7, #16]
 800ecb6:	683b      	ldr	r3, [r7, #0]
 800ecb8:	401a      	ands	r2, r3
 800ecba:	683b      	ldr	r3, [r7, #0]
 800ecbc:	429a      	cmp	r2, r3
 800ecbe:	d102      	bne.n	800ecc6 <I2C_CheckEvent+0x4e>
  {
    /* SUCCESS: last event is equal to I2C_EVENT */
    status = SUCCESS;
 800ecc0:	2301      	movs	r3, #1
 800ecc2:	75fb      	strb	r3, [r7, #23]
 800ecc4:	e001      	b.n	800ecca <I2C_CheckEvent+0x52>
  }
  else
  {
    /* ERROR: last event is different from I2C_EVENT */
    status = ERROR;
 800ecc6:	2300      	movs	r3, #0
 800ecc8:	75fb      	strb	r3, [r7, #23]
  }
  /* Return status */
  return status;
 800ecca:	7dfb      	ldrb	r3, [r7, #23]
}
 800eccc:	4618      	mov	r0, r3
 800ecce:	371c      	adds	r7, #28
 800ecd0:	46bd      	mov	sp, r7
 800ecd2:	f85d 7b04 	ldr.w	r7, [sp], #4
 800ecd6:	4770      	bx	lr

0800ecd8 <I2C_GetLastEvent>:
  *         in stm32f4xx_i2c.h file.
  *    
  * @retval The last event
  */
uint32_t I2C_GetLastEvent(I2C_TypeDef* I2Cx)
{
 800ecd8:	b480      	push	{r7}
 800ecda:	b087      	sub	sp, #28
 800ecdc:	af00      	add	r7, sp, #0
 800ecde:	6078      	str	r0, [r7, #4]
  uint32_t lastevent = 0;
 800ece0:	2300      	movs	r3, #0
 800ece2:	617b      	str	r3, [r7, #20]
  uint32_t flag1 = 0, flag2 = 0;
 800ece4:	2300      	movs	r3, #0
 800ece6:	613b      	str	r3, [r7, #16]
 800ece8:	2300      	movs	r3, #0
 800ecea:	60fb      	str	r3, [r7, #12]

  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));

  /* Read the I2Cx status register */
  flag1 = I2Cx->SR1;
 800ecec:	687b      	ldr	r3, [r7, #4]
 800ecee:	8a9b      	ldrh	r3, [r3, #20]
 800ecf0:	b29b      	uxth	r3, r3
 800ecf2:	613b      	str	r3, [r7, #16]
  flag2 = I2Cx->SR2;
 800ecf4:	687b      	ldr	r3, [r7, #4]
 800ecf6:	8b1b      	ldrh	r3, [r3, #24]
 800ecf8:	b29b      	uxth	r3, r3
 800ecfa:	60fb      	str	r3, [r7, #12]
  flag2 = flag2 << 16;
 800ecfc:	68fb      	ldr	r3, [r7, #12]
 800ecfe:	041b      	lsls	r3, r3, #16
 800ed00:	60fb      	str	r3, [r7, #12]

  /* Get the last event value from I2C status register */
  lastevent = (flag1 | flag2) & FLAG_MASK;
 800ed02:	693a      	ldr	r2, [r7, #16]
 800ed04:	68fb      	ldr	r3, [r7, #12]
 800ed06:	4313      	orrs	r3, r2
 800ed08:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
 800ed0c:	617b      	str	r3, [r7, #20]

  /* Return status */
  return lastevent;
 800ed0e:	697b      	ldr	r3, [r7, #20]
}
 800ed10:	4618      	mov	r0, r3
 800ed12:	371c      	adds	r7, #28
 800ed14:	46bd      	mov	sp, r7
 800ed16:	f85d 7b04 	ldr.w	r7, [sp], #4
 800ed1a:	4770      	bx	lr

0800ed1c <I2C_GetFlagStatus>:
  *                                Address matched flag (Slave mode)"ENDAD"
  *            @arg I2C_FLAG_SB: Start bit flag (Master mode)
  * @retval The new state of I2C_FLAG (SET or RESET).
  */
FlagStatus I2C_GetFlagStatus(I2C_TypeDef* I2Cx, uint32_t I2C_FLAG)
{
 800ed1c:	b480      	push	{r7}
 800ed1e:	b087      	sub	sp, #28
 800ed20:	af00      	add	r7, sp, #0
 800ed22:	6078      	str	r0, [r7, #4]
 800ed24:	6039      	str	r1, [r7, #0]
  FlagStatus bitstatus = RESET;
 800ed26:	2300      	movs	r3, #0
 800ed28:	75fb      	strb	r3, [r7, #23]
  __IO uint32_t i2creg = 0, i2cxbase = 0;
 800ed2a:	2300      	movs	r3, #0
 800ed2c:	613b      	str	r3, [r7, #16]
 800ed2e:	2300      	movs	r3, #0
 800ed30:	60fb      	str	r3, [r7, #12]
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_I2C_GET_FLAG(I2C_FLAG));

  /* Get the I2Cx peripheral base address */
  i2cxbase = (uint32_t)I2Cx;
 800ed32:	687b      	ldr	r3, [r7, #4]
 800ed34:	60fb      	str	r3, [r7, #12]
  
  /* Read flag register index */
  i2creg = I2C_FLAG >> 28;
 800ed36:	683b      	ldr	r3, [r7, #0]
 800ed38:	0f1b      	lsrs	r3, r3, #28
 800ed3a:	613b      	str	r3, [r7, #16]
  
  /* Get bit[23:0] of the flag */
  I2C_FLAG &= FLAG_MASK;
 800ed3c:	683b      	ldr	r3, [r7, #0]
 800ed3e:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
 800ed42:	603b      	str	r3, [r7, #0]
  
  if(i2creg != 0)
 800ed44:	693b      	ldr	r3, [r7, #16]
 800ed46:	2b00      	cmp	r3, #0
 800ed48:	d003      	beq.n	800ed52 <I2C_GetFlagStatus+0x36>
  {
    /* Get the I2Cx SR1 register address */
    i2cxbase += 0x14;
 800ed4a:	68fb      	ldr	r3, [r7, #12]
 800ed4c:	3314      	adds	r3, #20
 800ed4e:	60fb      	str	r3, [r7, #12]
 800ed50:	e005      	b.n	800ed5e <I2C_GetFlagStatus+0x42>
  }
  else
  {
    /* Flag in I2Cx SR2 Register */
    I2C_FLAG = (uint32_t)(I2C_FLAG >> 16);
 800ed52:	683b      	ldr	r3, [r7, #0]
 800ed54:	0c1b      	lsrs	r3, r3, #16
 800ed56:	603b      	str	r3, [r7, #0]
    /* Get the I2Cx SR2 register address */
    i2cxbase += 0x18;
 800ed58:	68fb      	ldr	r3, [r7, #12]
 800ed5a:	3318      	adds	r3, #24
 800ed5c:	60fb      	str	r3, [r7, #12]
  }
  
  if(((*(__IO uint32_t *)i2cxbase) & I2C_FLAG) != (uint32_t)RESET)
 800ed5e:	68fb      	ldr	r3, [r7, #12]
 800ed60:	681a      	ldr	r2, [r3, #0]
 800ed62:	683b      	ldr	r3, [r7, #0]
 800ed64:	4013      	ands	r3, r2
 800ed66:	2b00      	cmp	r3, #0
 800ed68:	d002      	beq.n	800ed70 <I2C_GetFlagStatus+0x54>
  {
    /* I2C_FLAG is set */
    bitstatus = SET;
 800ed6a:	2301      	movs	r3, #1
 800ed6c:	75fb      	strb	r3, [r7, #23]
 800ed6e:	e001      	b.n	800ed74 <I2C_GetFlagStatus+0x58>
  }
  else
  {
    /* I2C_FLAG is reset */
    bitstatus = RESET;
 800ed70:	2300      	movs	r3, #0
 800ed72:	75fb      	strb	r3, [r7, #23]
  }
  
  /* Return the I2C_FLAG status */
  return  bitstatus;
 800ed74:	7dfb      	ldrb	r3, [r7, #23]
}
 800ed76:	4618      	mov	r0, r3
 800ed78:	371c      	adds	r7, #28
 800ed7a:	46bd      	mov	sp, r7
 800ed7c:	f85d 7b04 	ldr.w	r7, [sp], #4
 800ed80:	4770      	bx	lr

0800ed82 <I2C_ClearFlag>:
  *          register (I2C_SendData()).
  *  
  * @retval None
  */
void I2C_ClearFlag(I2C_TypeDef* I2Cx, uint32_t I2C_FLAG)
{
 800ed82:	b480      	push	{r7}
 800ed84:	b085      	sub	sp, #20
 800ed86:	af00      	add	r7, sp, #0
 800ed88:	6078      	str	r0, [r7, #4]
 800ed8a:	6039      	str	r1, [r7, #0]
  uint32_t flagpos = 0;
 800ed8c:	2300      	movs	r3, #0
 800ed8e:	60fb      	str	r3, [r7, #12]
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_I2C_CLEAR_FLAG(I2C_FLAG));
  /* Get the I2C flag position */
  flagpos = I2C_FLAG & FLAG_MASK;
 800ed90:	683b      	ldr	r3, [r7, #0]
 800ed92:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
 800ed96:	60fb      	str	r3, [r7, #12]
  /* Clear the selected I2C flag */
  I2Cx->SR1 = (uint16_t)~flagpos;
 800ed98:	68fb      	ldr	r3, [r7, #12]
 800ed9a:	b29b      	uxth	r3, r3
 800ed9c:	43db      	mvns	r3, r3
 800ed9e:	b29a      	uxth	r2, r3
 800eda0:	687b      	ldr	r3, [r7, #4]
 800eda2:	829a      	strh	r2, [r3, #20]
}
 800eda4:	bf00      	nop
 800eda6:	3714      	adds	r7, #20
 800eda8:	46bd      	mov	sp, r7
 800edaa:	f85d 7b04 	ldr.w	r7, [sp], #4
 800edae:	4770      	bx	lr

0800edb0 <I2C_GetITStatus>:
  *                              Address matched flag (Slave mode)"ENDAD"
  *            @arg I2C_IT_SB: Start bit flag (Master mode)
  * @retval The new state of I2C_IT (SET or RESET).
  */
ITStatus I2C_GetITStatus(I2C_TypeDef* I2Cx, uint32_t I2C_IT)
{
 800edb0:	b480      	push	{r7}
 800edb2:	b085      	sub	sp, #20
 800edb4:	af00      	add	r7, sp, #0
 800edb6:	6078      	str	r0, [r7, #4]
 800edb8:	6039      	str	r1, [r7, #0]
  ITStatus bitstatus = RESET;
 800edba:	2300      	movs	r3, #0
 800edbc:	73fb      	strb	r3, [r7, #15]
  uint32_t enablestatus = 0;
 800edbe:	2300      	movs	r3, #0
 800edc0:	60bb      	str	r3, [r7, #8]
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_I2C_GET_IT(I2C_IT));

  /* Check if the interrupt source is enabled or not */
  enablestatus = (uint32_t)(((I2C_IT & ITEN_MASK) >> 16) & (I2Cx->CR2)) ;
 800edc2:	683b      	ldr	r3, [r7, #0]
 800edc4:	0c1b      	lsrs	r3, r3, #16
 800edc6:	687a      	ldr	r2, [r7, #4]
 800edc8:	8892      	ldrh	r2, [r2, #4]
 800edca:	b292      	uxth	r2, r2
 800edcc:	4013      	ands	r3, r2
 800edce:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
 800edd2:	60bb      	str	r3, [r7, #8]
  
  /* Get bit[23:0] of the flag */
  I2C_IT &= FLAG_MASK;
 800edd4:	683b      	ldr	r3, [r7, #0]
 800edd6:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
 800edda:	603b      	str	r3, [r7, #0]

  /* Check the status of the specified I2C flag */
  if (((I2Cx->SR1 & I2C_IT) != (uint32_t)RESET) && enablestatus)
 800eddc:	687b      	ldr	r3, [r7, #4]
 800edde:	8a9b      	ldrh	r3, [r3, #20]
 800ede0:	b29b      	uxth	r3, r3
 800ede2:	461a      	mov	r2, r3
 800ede4:	683b      	ldr	r3, [r7, #0]
 800ede6:	4013      	ands	r3, r2
 800ede8:	2b00      	cmp	r3, #0
 800edea:	d005      	beq.n	800edf8 <I2C_GetITStatus+0x48>
 800edec:	68bb      	ldr	r3, [r7, #8]
 800edee:	2b00      	cmp	r3, #0
 800edf0:	d002      	beq.n	800edf8 <I2C_GetITStatus+0x48>
  {
    /* I2C_IT is set */
    bitstatus = SET;
 800edf2:	2301      	movs	r3, #1
 800edf4:	73fb      	strb	r3, [r7, #15]
 800edf6:	e001      	b.n	800edfc <I2C_GetITStatus+0x4c>
  }
  else
  {
    /* I2C_IT is reset */
    bitstatus = RESET;
 800edf8:	2300      	movs	r3, #0
 800edfa:	73fb      	strb	r3, [r7, #15]
  }
  /* Return the I2C_IT status */
  return  bitstatus;
 800edfc:	7bfb      	ldrb	r3, [r7, #15]
}
 800edfe:	4618      	mov	r0, r3
 800ee00:	3714      	adds	r7, #20
 800ee02:	46bd      	mov	sp, r7
 800ee04:	f85d 7b04 	ldr.w	r7, [sp], #4
 800ee08:	4770      	bx	lr

0800ee0a <I2C_ClearITPendingBit>:
  *          I2C_SR1 register (I2C_GetITStatus()) followed by a write operation to 
  *          I2C_DR register (I2C_SendData()).
  * @retval None
  */
void I2C_ClearITPendingBit(I2C_TypeDef* I2Cx, uint32_t I2C_IT)
{
 800ee0a:	b480      	push	{r7}
 800ee0c:	b085      	sub	sp, #20
 800ee0e:	af00      	add	r7, sp, #0
 800ee10:	6078      	str	r0, [r7, #4]
 800ee12:	6039      	str	r1, [r7, #0]
  uint32_t flagpos = 0;
 800ee14:	2300      	movs	r3, #0
 800ee16:	60fb      	str	r3, [r7, #12]
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_I2C_CLEAR_IT(I2C_IT));

  /* Get the I2C flag position */
  flagpos = I2C_IT & FLAG_MASK;
 800ee18:	683b      	ldr	r3, [r7, #0]
 800ee1a:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
 800ee1e:	60fb      	str	r3, [r7, #12]

  /* Clear the selected I2C flag */
  I2Cx->SR1 = (uint16_t)~flagpos;
 800ee20:	68fb      	ldr	r3, [r7, #12]
 800ee22:	b29b      	uxth	r3, r3
 800ee24:	43db      	mvns	r3, r3
 800ee26:	b29a      	uxth	r2, r3
 800ee28:	687b      	ldr	r3, [r7, #4]
 800ee2a:	829a      	strh	r2, [r3, #20]
}
 800ee2c:	bf00      	nop
 800ee2e:	3714      	adds	r7, #20
 800ee30:	46bd      	mov	sp, r7
 800ee32:	f85d 7b04 	ldr.w	r7, [sp], #4
 800ee36:	4770      	bx	lr

0800ee38 <IWDG_WriteAccessCmd>:
  *            @arg IWDG_WriteAccess_Enable: Enable write access to IWDG_PR and IWDG_RLR registers
  *            @arg IWDG_WriteAccess_Disable: Disable write access to IWDG_PR and IWDG_RLR registers
  * @retval None
  */
void IWDG_WriteAccessCmd(uint16_t IWDG_WriteAccess)
{
 800ee38:	b480      	push	{r7}
 800ee3a:	b083      	sub	sp, #12
 800ee3c:	af00      	add	r7, sp, #0
 800ee3e:	4603      	mov	r3, r0
 800ee40:	80fb      	strh	r3, [r7, #6]
  /* Check the parameters */
  assert_param(IS_IWDG_WRITE_ACCESS(IWDG_WriteAccess));
  IWDG->KR = IWDG_WriteAccess;
 800ee42:	4a04      	ldr	r2, [pc, #16]	; (800ee54 <IWDG_WriteAccessCmd+0x1c>)
 800ee44:	88fb      	ldrh	r3, [r7, #6]
 800ee46:	6013      	str	r3, [r2, #0]
}
 800ee48:	bf00      	nop
 800ee4a:	370c      	adds	r7, #12
 800ee4c:	46bd      	mov	sp, r7
 800ee4e:	f85d 7b04 	ldr.w	r7, [sp], #4
 800ee52:	4770      	bx	lr
 800ee54:	40003000 	.word	0x40003000

0800ee58 <IWDG_SetPrescaler>:
  *            @arg IWDG_Prescaler_128: IWDG prescaler set to 128
  *            @arg IWDG_Prescaler_256: IWDG prescaler set to 256
  * @retval None
  */
void IWDG_SetPrescaler(uint8_t IWDG_Prescaler)
{
 800ee58:	b480      	push	{r7}
 800ee5a:	b083      	sub	sp, #12
 800ee5c:	af00      	add	r7, sp, #0
 800ee5e:	4603      	mov	r3, r0
 800ee60:	71fb      	strb	r3, [r7, #7]
  /* Check the parameters */
  assert_param(IS_IWDG_PRESCALER(IWDG_Prescaler));
  IWDG->PR = IWDG_Prescaler;
 800ee62:	4a04      	ldr	r2, [pc, #16]	; (800ee74 <IWDG_SetPrescaler+0x1c>)
 800ee64:	79fb      	ldrb	r3, [r7, #7]
 800ee66:	6053      	str	r3, [r2, #4]
}
 800ee68:	bf00      	nop
 800ee6a:	370c      	adds	r7, #12
 800ee6c:	46bd      	mov	sp, r7
 800ee6e:	f85d 7b04 	ldr.w	r7, [sp], #4
 800ee72:	4770      	bx	lr
 800ee74:	40003000 	.word	0x40003000

0800ee78 <IWDG_SetReload>:
  * @param  Reload: specifies the IWDG Reload value.
  *          This parameter must be a number between 0 and 0x0FFF.
  * @retval None
  */
void IWDG_SetReload(uint16_t Reload)
{
 800ee78:	b480      	push	{r7}
 800ee7a:	b083      	sub	sp, #12
 800ee7c:	af00      	add	r7, sp, #0
 800ee7e:	4603      	mov	r3, r0
 800ee80:	80fb      	strh	r3, [r7, #6]
  /* Check the parameters */
  assert_param(IS_IWDG_RELOAD(Reload));
  IWDG->RLR = Reload;
 800ee82:	4a04      	ldr	r2, [pc, #16]	; (800ee94 <IWDG_SetReload+0x1c>)
 800ee84:	88fb      	ldrh	r3, [r7, #6]
 800ee86:	6093      	str	r3, [r2, #8]
}
 800ee88:	bf00      	nop
 800ee8a:	370c      	adds	r7, #12
 800ee8c:	46bd      	mov	sp, r7
 800ee8e:	f85d 7b04 	ldr.w	r7, [sp], #4
 800ee92:	4770      	bx	lr
 800ee94:	40003000 	.word	0x40003000

0800ee98 <IWDG_ReloadCounter>:
  *         (write access to IWDG_PR and IWDG_RLR registers disabled).
  * @param  None
  * @retval None
  */
void IWDG_ReloadCounter(void)
{
 800ee98:	b480      	push	{r7}
 800ee9a:	af00      	add	r7, sp, #0
  IWDG->KR = KR_KEY_RELOAD;
 800ee9c:	4b04      	ldr	r3, [pc, #16]	; (800eeb0 <IWDG_ReloadCounter+0x18>)
 800ee9e:	f64a 22aa 	movw	r2, #43690	; 0xaaaa
 800eea2:	601a      	str	r2, [r3, #0]
}
 800eea4:	bf00      	nop
 800eea6:	46bd      	mov	sp, r7
 800eea8:	f85d 7b04 	ldr.w	r7, [sp], #4
 800eeac:	4770      	bx	lr
 800eeae:	bf00      	nop
 800eeb0:	40003000 	.word	0x40003000

0800eeb4 <IWDG_Enable>:
  * @brief  Enables IWDG (write access to IWDG_PR and IWDG_RLR registers disabled).
  * @param  None
  * @retval None
  */
void IWDG_Enable(void)
{
 800eeb4:	b480      	push	{r7}
 800eeb6:	af00      	add	r7, sp, #0
  IWDG->KR = KR_KEY_ENABLE;
 800eeb8:	4b04      	ldr	r3, [pc, #16]	; (800eecc <IWDG_Enable+0x18>)
 800eeba:	f64c 42cc 	movw	r2, #52428	; 0xcccc
 800eebe:	601a      	str	r2, [r3, #0]
}
 800eec0:	bf00      	nop
 800eec2:	46bd      	mov	sp, r7
 800eec4:	f85d 7b04 	ldr.w	r7, [sp], #4
 800eec8:	4770      	bx	lr
 800eeca:	bf00      	nop
 800eecc:	40003000 	.word	0x40003000

0800eed0 <IWDG_GetFlagStatus>:
  *            @arg IWDG_FLAG_PVU: Prescaler Value Update on going
  *            @arg IWDG_FLAG_RVU: Reload Value Update on going
  * @retval The new state of IWDG_FLAG (SET or RESET).
  */
FlagStatus IWDG_GetFlagStatus(uint16_t IWDG_FLAG)
{
 800eed0:	b480      	push	{r7}
 800eed2:	b085      	sub	sp, #20
 800eed4:	af00      	add	r7, sp, #0
 800eed6:	4603      	mov	r3, r0
 800eed8:	80fb      	strh	r3, [r7, #6]
  FlagStatus bitstatus = RESET;
 800eeda:	2300      	movs	r3, #0
 800eedc:	73fb      	strb	r3, [r7, #15]
  /* Check the parameters */
  assert_param(IS_IWDG_FLAG(IWDG_FLAG));
  if ((IWDG->SR & IWDG_FLAG) != (uint32_t)RESET)
 800eede:	4b09      	ldr	r3, [pc, #36]	; (800ef04 <IWDG_GetFlagStatus+0x34>)
 800eee0:	68da      	ldr	r2, [r3, #12]
 800eee2:	88fb      	ldrh	r3, [r7, #6]
 800eee4:	4013      	ands	r3, r2
 800eee6:	2b00      	cmp	r3, #0
 800eee8:	d002      	beq.n	800eef0 <IWDG_GetFlagStatus+0x20>
  {
    bitstatus = SET;
 800eeea:	2301      	movs	r3, #1
 800eeec:	73fb      	strb	r3, [r7, #15]
 800eeee:	e001      	b.n	800eef4 <IWDG_GetFlagStatus+0x24>
  }
  else
  {
    bitstatus = RESET;
 800eef0:	2300      	movs	r3, #0
 800eef2:	73fb      	strb	r3, [r7, #15]
  }
  /* Return the flag status */
  return bitstatus;
 800eef4:	7bfb      	ldrb	r3, [r7, #15]
}
 800eef6:	4618      	mov	r0, r3
 800eef8:	3714      	adds	r7, #20
 800eefa:	46bd      	mov	sp, r7
 800eefc:	f85d 7b04 	ldr.w	r7, [sp], #4
 800ef00:	4770      	bx	lr
 800ef02:	bf00      	nop
 800ef04:	40003000 	.word	0x40003000

0800ef08 <PWR_DeInit>:
  * @brief  Deinitializes the PWR peripheral registers to their default reset values.     
  * @param  None
  * @retval None
  */
void PWR_DeInit(void)
{
 800ef08:	b580      	push	{r7, lr}
 800ef0a:	af00      	add	r7, sp, #0
  RCC_APB1PeriphResetCmd(RCC_APB1Periph_PWR, ENABLE);
 800ef0c:	2101      	movs	r1, #1
 800ef0e:	f04f 5080 	mov.w	r0, #268435456	; 0x10000000
 800ef12:	f000 fcff 	bl	800f914 <RCC_APB1PeriphResetCmd>
  RCC_APB1PeriphResetCmd(RCC_APB1Periph_PWR, DISABLE);
 800ef16:	2100      	movs	r1, #0
 800ef18:	f04f 5080 	mov.w	r0, #268435456	; 0x10000000
 800ef1c:	f000 fcfa 	bl	800f914 <RCC_APB1PeriphResetCmd>
}
 800ef20:	bf00      	nop
 800ef22:	bd80      	pop	{r7, pc}

0800ef24 <PWR_BackupAccessCmd>:
  * @param  NewState: new state of the access to the backup domain.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void PWR_BackupAccessCmd(FunctionalState NewState)
{
 800ef24:	b480      	push	{r7}
 800ef26:	b083      	sub	sp, #12
 800ef28:	af00      	add	r7, sp, #0
 800ef2a:	4603      	mov	r3, r0
 800ef2c:	71fb      	strb	r3, [r7, #7]
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  *(__IO uint32_t *) CR_DBP_BB = (uint32_t)NewState;
 800ef2e:	4a04      	ldr	r2, [pc, #16]	; (800ef40 <PWR_BackupAccessCmd+0x1c>)
 800ef30:	79fb      	ldrb	r3, [r7, #7]
 800ef32:	6013      	str	r3, [r2, #0]
}
 800ef34:	bf00      	nop
 800ef36:	370c      	adds	r7, #12
 800ef38:	46bd      	mov	sp, r7
 800ef3a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800ef3e:	4770      	bx	lr
 800ef40:	420e0020 	.word	0x420e0020

0800ef44 <PWR_PVDLevelConfig>:
  *         more details about the voltage threshold corresponding to each 
  *         detection level.
  * @retval None
  */
void PWR_PVDLevelConfig(uint32_t PWR_PVDLevel)
{
 800ef44:	b480      	push	{r7}
 800ef46:	b085      	sub	sp, #20
 800ef48:	af00      	add	r7, sp, #0
 800ef4a:	6078      	str	r0, [r7, #4]
  uint32_t tmpreg = 0;
 800ef4c:	2300      	movs	r3, #0
 800ef4e:	60fb      	str	r3, [r7, #12]
  
  /* Check the parameters */
  assert_param(IS_PWR_PVD_LEVEL(PWR_PVDLevel));
  
  tmpreg = PWR->CR;
 800ef50:	4b09      	ldr	r3, [pc, #36]	; (800ef78 <PWR_PVDLevelConfig+0x34>)
 800ef52:	681b      	ldr	r3, [r3, #0]
 800ef54:	60fb      	str	r3, [r7, #12]
  
  /* Clear PLS[7:5] bits */
  tmpreg &= CR_PLS_MASK;
 800ef56:	68fb      	ldr	r3, [r7, #12]
 800ef58:	f023 03e0 	bic.w	r3, r3, #224	; 0xe0
 800ef5c:	60fb      	str	r3, [r7, #12]
  
  /* Set PLS[7:5] bits according to PWR_PVDLevel value */
  tmpreg |= PWR_PVDLevel;
 800ef5e:	68fa      	ldr	r2, [r7, #12]
 800ef60:	687b      	ldr	r3, [r7, #4]
 800ef62:	4313      	orrs	r3, r2
 800ef64:	60fb      	str	r3, [r7, #12]
  
  /* Store the new value */
  PWR->CR = tmpreg;
 800ef66:	4a04      	ldr	r2, [pc, #16]	; (800ef78 <PWR_PVDLevelConfig+0x34>)
 800ef68:	68fb      	ldr	r3, [r7, #12]
 800ef6a:	6013      	str	r3, [r2, #0]
}
 800ef6c:	bf00      	nop
 800ef6e:	3714      	adds	r7, #20
 800ef70:	46bd      	mov	sp, r7
 800ef72:	f85d 7b04 	ldr.w	r7, [sp], #4
 800ef76:	4770      	bx	lr
 800ef78:	40007000 	.word	0x40007000

0800ef7c <PWR_PVDCmd>:
  * @param  NewState: new state of the PVD.
  *         This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void PWR_PVDCmd(FunctionalState NewState)
{
 800ef7c:	b480      	push	{r7}
 800ef7e:	b083      	sub	sp, #12
 800ef80:	af00      	add	r7, sp, #0
 800ef82:	4603      	mov	r3, r0
 800ef84:	71fb      	strb	r3, [r7, #7]
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  *(__IO uint32_t *) CR_PVDE_BB = (uint32_t)NewState;
 800ef86:	4a04      	ldr	r2, [pc, #16]	; (800ef98 <PWR_PVDCmd+0x1c>)
 800ef88:	79fb      	ldrb	r3, [r7, #7]
 800ef8a:	6013      	str	r3, [r2, #0]
}
 800ef8c:	bf00      	nop
 800ef8e:	370c      	adds	r7, #12
 800ef90:	46bd      	mov	sp, r7
 800ef92:	f85d 7b04 	ldr.w	r7, [sp], #4
 800ef96:	4770      	bx	lr
 800ef98:	420e0010 	.word	0x420e0010

0800ef9c <PWR_WakeUpPinCmd>:
  * @param  NewState: new state of the WakeUp Pin functionality.
  *         This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void PWR_WakeUpPinCmd(FunctionalState NewState)
{
 800ef9c:	b480      	push	{r7}
 800ef9e:	b083      	sub	sp, #12
 800efa0:	af00      	add	r7, sp, #0
 800efa2:	4603      	mov	r3, r0
 800efa4:	71fb      	strb	r3, [r7, #7]
  /* Check the parameters */  
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  *(__IO uint32_t *) CSR_EWUP_BB = (uint32_t)NewState;
 800efa6:	4a04      	ldr	r2, [pc, #16]	; (800efb8 <PWR_WakeUpPinCmd+0x1c>)
 800efa8:	79fb      	ldrb	r3, [r7, #7]
 800efaa:	6013      	str	r3, [r2, #0]
}
 800efac:	bf00      	nop
 800efae:	370c      	adds	r7, #12
 800efb0:	46bd      	mov	sp, r7
 800efb2:	f85d 7b04 	ldr.w	r7, [sp], #4
 800efb6:	4770      	bx	lr
 800efb8:	420e00a0 	.word	0x420e00a0

0800efbc <PWR_BackupRegulatorCmd>:
  * @param  NewState: new state of the Backup Regulator.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void PWR_BackupRegulatorCmd(FunctionalState NewState)
{
 800efbc:	b480      	push	{r7}
 800efbe:	b083      	sub	sp, #12
 800efc0:	af00      	add	r7, sp, #0
 800efc2:	4603      	mov	r3, r0
 800efc4:	71fb      	strb	r3, [r7, #7]
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  *(__IO uint32_t *) CSR_BRE_BB = (uint32_t)NewState;
 800efc6:	4a04      	ldr	r2, [pc, #16]	; (800efd8 <PWR_BackupRegulatorCmd+0x1c>)
 800efc8:	79fb      	ldrb	r3, [r7, #7]
 800efca:	6013      	str	r3, [r2, #0]
}
 800efcc:	bf00      	nop
 800efce:	370c      	adds	r7, #12
 800efd0:	46bd      	mov	sp, r7
 800efd2:	f85d 7b04 	ldr.w	r7, [sp], #4
 800efd6:	4770      	bx	lr
 800efd8:	420e00a4 	.word	0x420e00a4

0800efdc <PWR_MainRegulatorModeConfig>:
  *            @arg PWR_Regulator_Voltage_Scale2: Regulator voltage output Scale 2 mode, 
  *                                                System frequency up to 144 MHz.    
  * @retval None
  */
void PWR_MainRegulatorModeConfig(uint32_t PWR_Regulator_Voltage)
{
 800efdc:	b480      	push	{r7}
 800efde:	b083      	sub	sp, #12
 800efe0:	af00      	add	r7, sp, #0
 800efe2:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_PWR_REGULATOR_VOLTAGE(PWR_Regulator_Voltage));

  if (PWR_Regulator_Voltage == PWR_Regulator_Voltage_Scale2)
 800efe4:	687b      	ldr	r3, [r7, #4]
 800efe6:	2b00      	cmp	r3, #0
 800efe8:	d106      	bne.n	800eff8 <PWR_MainRegulatorModeConfig+0x1c>
  {
    PWR->CR &= ~PWR_Regulator_Voltage_Scale1;
 800efea:	4a09      	ldr	r2, [pc, #36]	; (800f010 <PWR_MainRegulatorModeConfig+0x34>)
 800efec:	4b08      	ldr	r3, [pc, #32]	; (800f010 <PWR_MainRegulatorModeConfig+0x34>)
 800efee:	681b      	ldr	r3, [r3, #0]
 800eff0:	f423 4380 	bic.w	r3, r3, #16384	; 0x4000
 800eff4:	6013      	str	r3, [r2, #0]
  }
  else
  {    
    PWR->CR |= PWR_Regulator_Voltage_Scale1;
  }
}
 800eff6:	e005      	b.n	800f004 <PWR_MainRegulatorModeConfig+0x28>
    PWR->CR |= PWR_Regulator_Voltage_Scale1;
 800eff8:	4a05      	ldr	r2, [pc, #20]	; (800f010 <PWR_MainRegulatorModeConfig+0x34>)
 800effa:	4b05      	ldr	r3, [pc, #20]	; (800f010 <PWR_MainRegulatorModeConfig+0x34>)
 800effc:	681b      	ldr	r3, [r3, #0]
 800effe:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 800f002:	6013      	str	r3, [r2, #0]
}
 800f004:	bf00      	nop
 800f006:	370c      	adds	r7, #12
 800f008:	46bd      	mov	sp, r7
 800f00a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800f00e:	4770      	bx	lr
 800f010:	40007000 	.word	0x40007000

0800f014 <PWR_FlashPowerDownCmd>:
  * @param  NewState: new state of the Flash power mode.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void PWR_FlashPowerDownCmd(FunctionalState NewState)
{
 800f014:	b480      	push	{r7}
 800f016:	b083      	sub	sp, #12
 800f018:	af00      	add	r7, sp, #0
 800f01a:	4603      	mov	r3, r0
 800f01c:	71fb      	strb	r3, [r7, #7]
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  *(__IO uint32_t *) CR_FPDS_BB = (uint32_t)NewState;
 800f01e:	4a04      	ldr	r2, [pc, #16]	; (800f030 <PWR_FlashPowerDownCmd+0x1c>)
 800f020:	79fb      	ldrb	r3, [r7, #7]
 800f022:	6013      	str	r3, [r2, #0]
}
 800f024:	bf00      	nop
 800f026:	370c      	adds	r7, #12
 800f028:	46bd      	mov	sp, r7
 800f02a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800f02e:	4770      	bx	lr
 800f030:	420e0024 	.word	0x420e0024

0800f034 <PWR_EnterSTOPMode>:
  *            @arg PWR_STOPEntry_WFI: enter STOP mode with WFI instruction
  *            @arg PWR_STOPEntry_WFE: enter STOP mode with WFE instruction
  * @retval None
  */
void PWR_EnterSTOPMode(uint32_t PWR_Regulator, uint8_t PWR_STOPEntry)
{
 800f034:	b480      	push	{r7}
 800f036:	b085      	sub	sp, #20
 800f038:	af00      	add	r7, sp, #0
 800f03a:	6078      	str	r0, [r7, #4]
 800f03c:	460b      	mov	r3, r1
 800f03e:	70fb      	strb	r3, [r7, #3]
  uint32_t tmpreg = 0;
 800f040:	2300      	movs	r3, #0
 800f042:	60fb      	str	r3, [r7, #12]
  /* Check the parameters */
  assert_param(IS_PWR_REGULATOR(PWR_Regulator));
  assert_param(IS_PWR_STOP_ENTRY(PWR_STOPEntry));
  
  /* Select the regulator state in STOP mode ---------------------------------*/
  tmpreg = PWR->CR;
 800f044:	4b12      	ldr	r3, [pc, #72]	; (800f090 <PWR_EnterSTOPMode+0x5c>)
 800f046:	681b      	ldr	r3, [r3, #0]
 800f048:	60fb      	str	r3, [r7, #12]
  /* Clear PDDS and LPDSR bits */
  tmpreg &= CR_DS_MASK;
 800f04a:	68fb      	ldr	r3, [r7, #12]
 800f04c:	f023 0303 	bic.w	r3, r3, #3
 800f050:	60fb      	str	r3, [r7, #12]
  
  /* Set LPDSR bit according to PWR_Regulator value */
  tmpreg |= PWR_Regulator;
 800f052:	68fa      	ldr	r2, [r7, #12]
 800f054:	687b      	ldr	r3, [r7, #4]
 800f056:	4313      	orrs	r3, r2
 800f058:	60fb      	str	r3, [r7, #12]
  
  /* Store the new value */
  PWR->CR = tmpreg;
 800f05a:	4a0d      	ldr	r2, [pc, #52]	; (800f090 <PWR_EnterSTOPMode+0x5c>)
 800f05c:	68fb      	ldr	r3, [r7, #12]
 800f05e:	6013      	str	r3, [r2, #0]
  
  /* Set SLEEPDEEP bit of Cortex System Control Register */
  SCB->SCR |= SCB_SCR_SLEEPDEEP_Msk;
 800f060:	4a0c      	ldr	r2, [pc, #48]	; (800f094 <PWR_EnterSTOPMode+0x60>)
 800f062:	4b0c      	ldr	r3, [pc, #48]	; (800f094 <PWR_EnterSTOPMode+0x60>)
 800f064:	691b      	ldr	r3, [r3, #16]
 800f066:	f043 0304 	orr.w	r3, r3, #4
 800f06a:	6113      	str	r3, [r2, #16]
  
  /* Select STOP mode entry --------------------------------------------------*/
  if(PWR_STOPEntry == PWR_STOPEntry_WFI)
 800f06c:	78fb      	ldrb	r3, [r7, #3]
 800f06e:	2b01      	cmp	r3, #1
 800f070:	d101      	bne.n	800f076 <PWR_EnterSTOPMode+0x42>
  __ASM volatile ("wfi");
 800f072:	bf30      	wfi
 800f074:	e000      	b.n	800f078 <PWR_EnterSTOPMode+0x44>
  __ASM volatile ("wfe");
 800f076:	bf20      	wfe
  {
    /* Request Wait For Event */
    __WFE();
  }
  /* Reset SLEEPDEEP bit of Cortex System Control Register */
  SCB->SCR &= (uint32_t)~((uint32_t)SCB_SCR_SLEEPDEEP_Msk);  
 800f078:	4a06      	ldr	r2, [pc, #24]	; (800f094 <PWR_EnterSTOPMode+0x60>)
 800f07a:	4b06      	ldr	r3, [pc, #24]	; (800f094 <PWR_EnterSTOPMode+0x60>)
 800f07c:	691b      	ldr	r3, [r3, #16]
 800f07e:	f023 0304 	bic.w	r3, r3, #4
 800f082:	6113      	str	r3, [r2, #16]
}
 800f084:	bf00      	nop
 800f086:	3714      	adds	r7, #20
 800f088:	46bd      	mov	sp, r7
 800f08a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800f08e:	4770      	bx	lr
 800f090:	40007000 	.word	0x40007000
 800f094:	e000ed00 	.word	0xe000ed00

0800f098 <PWR_EnterSTANDBYMode>:
  *          - WKUP pin 1 (PA0) if enabled.       
  * @param  None
  * @retval None
  */
void PWR_EnterSTANDBYMode(void)
{
 800f098:	b480      	push	{r7}
 800f09a:	af00      	add	r7, sp, #0
  /* Clear Wakeup flag */
  PWR->CR |= PWR_CR_CWUF;
 800f09c:	4a0b      	ldr	r2, [pc, #44]	; (800f0cc <PWR_EnterSTANDBYMode+0x34>)
 800f09e:	4b0b      	ldr	r3, [pc, #44]	; (800f0cc <PWR_EnterSTANDBYMode+0x34>)
 800f0a0:	681b      	ldr	r3, [r3, #0]
 800f0a2:	f043 0304 	orr.w	r3, r3, #4
 800f0a6:	6013      	str	r3, [r2, #0]
  
  /* Select STANDBY mode */
  PWR->CR |= PWR_CR_PDDS;
 800f0a8:	4a08      	ldr	r2, [pc, #32]	; (800f0cc <PWR_EnterSTANDBYMode+0x34>)
 800f0aa:	4b08      	ldr	r3, [pc, #32]	; (800f0cc <PWR_EnterSTANDBYMode+0x34>)
 800f0ac:	681b      	ldr	r3, [r3, #0]
 800f0ae:	f043 0302 	orr.w	r3, r3, #2
 800f0b2:	6013      	str	r3, [r2, #0]
  
  /* Set SLEEPDEEP bit of Cortex System Control Register */
  SCB->SCR |= SCB_SCR_SLEEPDEEP_Msk;
 800f0b4:	4a06      	ldr	r2, [pc, #24]	; (800f0d0 <PWR_EnterSTANDBYMode+0x38>)
 800f0b6:	4b06      	ldr	r3, [pc, #24]	; (800f0d0 <PWR_EnterSTANDBYMode+0x38>)
 800f0b8:	691b      	ldr	r3, [r3, #16]
 800f0ba:	f043 0304 	orr.w	r3, r3, #4
 800f0be:	6113      	str	r3, [r2, #16]
  __ASM volatile ("wfi");
 800f0c0:	bf30      	wfi
#if defined ( __CC_ARM   )
  __force_stores();
#endif
  /* Request Wait For Interrupt */
  __WFI();
}
 800f0c2:	bf00      	nop
 800f0c4:	46bd      	mov	sp, r7
 800f0c6:	f85d 7b04 	ldr.w	r7, [sp], #4
 800f0ca:	4770      	bx	lr
 800f0cc:	40007000 	.word	0x40007000
 800f0d0:	e000ed00 	.word	0xe000ed00

0800f0d4 <PWR_GetFlagStatus>:
  *            @arg PWR_FLAG_VOSRDY: This flag indicates that the Regulator voltage 
  *                 scaling output selection is ready. 
  * @retval The new state of PWR_FLAG (SET or RESET).
  */
FlagStatus PWR_GetFlagStatus(uint32_t PWR_FLAG)
{
 800f0d4:	b480      	push	{r7}
 800f0d6:	b085      	sub	sp, #20
 800f0d8:	af00      	add	r7, sp, #0
 800f0da:	6078      	str	r0, [r7, #4]
  FlagStatus bitstatus = RESET;
 800f0dc:	2300      	movs	r3, #0
 800f0de:	73fb      	strb	r3, [r7, #15]
  
  /* Check the parameters */
  assert_param(IS_PWR_GET_FLAG(PWR_FLAG));
  
  if ((PWR->CSR & PWR_FLAG) != (uint32_t)RESET)
 800f0e0:	4b08      	ldr	r3, [pc, #32]	; (800f104 <PWR_GetFlagStatus+0x30>)
 800f0e2:	685a      	ldr	r2, [r3, #4]
 800f0e4:	687b      	ldr	r3, [r7, #4]
 800f0e6:	4013      	ands	r3, r2
 800f0e8:	2b00      	cmp	r3, #0
 800f0ea:	d002      	beq.n	800f0f2 <PWR_GetFlagStatus+0x1e>
  {
    bitstatus = SET;
 800f0ec:	2301      	movs	r3, #1
 800f0ee:	73fb      	strb	r3, [r7, #15]
 800f0f0:	e001      	b.n	800f0f6 <PWR_GetFlagStatus+0x22>
  }
  else
  {
    bitstatus = RESET;
 800f0f2:	2300      	movs	r3, #0
 800f0f4:	73fb      	strb	r3, [r7, #15]
  }
  /* Return the flag status */
  return bitstatus;
 800f0f6:	7bfb      	ldrb	r3, [r7, #15]
}
 800f0f8:	4618      	mov	r0, r3
 800f0fa:	3714      	adds	r7, #20
 800f0fc:	46bd      	mov	sp, r7
 800f0fe:	f85d 7b04 	ldr.w	r7, [sp], #4
 800f102:	4770      	bx	lr
 800f104:	40007000 	.word	0x40007000

0800f108 <PWR_ClearFlag>:
  *            @arg PWR_FLAG_WU: Wake Up flag
  *            @arg PWR_FLAG_SB: StandBy flag
  * @retval None
  */
void PWR_ClearFlag(uint32_t PWR_FLAG)
{
 800f108:	b480      	push	{r7}
 800f10a:	b083      	sub	sp, #12
 800f10c:	af00      	add	r7, sp, #0
 800f10e:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_PWR_CLEAR_FLAG(PWR_FLAG));
         
  PWR->CR |=  PWR_FLAG << 2;
 800f110:	4906      	ldr	r1, [pc, #24]	; (800f12c <PWR_ClearFlag+0x24>)
 800f112:	4b06      	ldr	r3, [pc, #24]	; (800f12c <PWR_ClearFlag+0x24>)
 800f114:	681a      	ldr	r2, [r3, #0]
 800f116:	687b      	ldr	r3, [r7, #4]
 800f118:	009b      	lsls	r3, r3, #2
 800f11a:	4313      	orrs	r3, r2
 800f11c:	600b      	str	r3, [r1, #0]
}
 800f11e:	bf00      	nop
 800f120:	370c      	adds	r7, #12
 800f122:	46bd      	mov	sp, r7
 800f124:	f85d 7b04 	ldr.w	r7, [sp], #4
 800f128:	4770      	bx	lr
 800f12a:	bf00      	nop
 800f12c:	40007000 	.word	0x40007000

0800f130 <RCC_DeInit>:
  *            - LSI, LSE and RTC clocks 
  * @param  None
  * @retval None
  */
void RCC_DeInit(void)
{
 800f130:	b480      	push	{r7}
 800f132:	af00      	add	r7, sp, #0
  /* Set HSION bit */
  RCC->CR |= (uint32_t)0x00000001;
 800f134:	4a10      	ldr	r2, [pc, #64]	; (800f178 <RCC_DeInit+0x48>)
 800f136:	4b10      	ldr	r3, [pc, #64]	; (800f178 <RCC_DeInit+0x48>)
 800f138:	681b      	ldr	r3, [r3, #0]
 800f13a:	f043 0301 	orr.w	r3, r3, #1
 800f13e:	6013      	str	r3, [r2, #0]

  /* Reset CFGR register */
  RCC->CFGR = 0x00000000;
 800f140:	4b0d      	ldr	r3, [pc, #52]	; (800f178 <RCC_DeInit+0x48>)
 800f142:	2200      	movs	r2, #0
 800f144:	609a      	str	r2, [r3, #8]

  /* Reset HSEON, CSSON and PLLON bits */
  RCC->CR &= (uint32_t)0xFEF6FFFF;
 800f146:	4a0c      	ldr	r2, [pc, #48]	; (800f178 <RCC_DeInit+0x48>)
 800f148:	4b0b      	ldr	r3, [pc, #44]	; (800f178 <RCC_DeInit+0x48>)
 800f14a:	681b      	ldr	r3, [r3, #0]
 800f14c:	f023 7384 	bic.w	r3, r3, #17301504	; 0x1080000
 800f150:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 800f154:	6013      	str	r3, [r2, #0]

  /* Reset PLLCFGR register */
  RCC->PLLCFGR = 0x24003010;
 800f156:	4b08      	ldr	r3, [pc, #32]	; (800f178 <RCC_DeInit+0x48>)
 800f158:	4a08      	ldr	r2, [pc, #32]	; (800f17c <RCC_DeInit+0x4c>)
 800f15a:	605a      	str	r2, [r3, #4]

  /* Reset HSEBYP bit */
  RCC->CR &= (uint32_t)0xFFFBFFFF;
 800f15c:	4a06      	ldr	r2, [pc, #24]	; (800f178 <RCC_DeInit+0x48>)
 800f15e:	4b06      	ldr	r3, [pc, #24]	; (800f178 <RCC_DeInit+0x48>)
 800f160:	681b      	ldr	r3, [r3, #0]
 800f162:	f423 2380 	bic.w	r3, r3, #262144	; 0x40000
 800f166:	6013      	str	r3, [r2, #0]

  /* Disable all interrupts */
  RCC->CIR = 0x00000000;
 800f168:	4b03      	ldr	r3, [pc, #12]	; (800f178 <RCC_DeInit+0x48>)
 800f16a:	2200      	movs	r2, #0
 800f16c:	60da      	str	r2, [r3, #12]
}
 800f16e:	bf00      	nop
 800f170:	46bd      	mov	sp, r7
 800f172:	f85d 7b04 	ldr.w	r7, [sp], #4
 800f176:	4770      	bx	lr
 800f178:	40023800 	.word	0x40023800
 800f17c:	24003010 	.word	0x24003010

0800f180 <RCC_HSEConfig>:
  *            @arg RCC_HSE_ON: turn ON the HSE oscillator
  *            @arg RCC_HSE_Bypass: HSE oscillator bypassed with external clock
  * @retval None
  */
void RCC_HSEConfig(uint8_t RCC_HSE)
{
 800f180:	b480      	push	{r7}
 800f182:	b083      	sub	sp, #12
 800f184:	af00      	add	r7, sp, #0
 800f186:	4603      	mov	r3, r0
 800f188:	71fb      	strb	r3, [r7, #7]
  /* Check the parameters */
  assert_param(IS_RCC_HSE(RCC_HSE));

  /* Reset HSEON and HSEBYP bits before configuring the HSE ------------------*/
  *(__IO uint8_t *) CR_BYTE3_ADDRESS = RCC_HSE_OFF;
 800f18a:	4b06      	ldr	r3, [pc, #24]	; (800f1a4 <RCC_HSEConfig+0x24>)
 800f18c:	2200      	movs	r2, #0
 800f18e:	701a      	strb	r2, [r3, #0]

  /* Set the new HSE configuration -------------------------------------------*/
  *(__IO uint8_t *) CR_BYTE3_ADDRESS = RCC_HSE;
 800f190:	4a04      	ldr	r2, [pc, #16]	; (800f1a4 <RCC_HSEConfig+0x24>)
 800f192:	79fb      	ldrb	r3, [r7, #7]
 800f194:	7013      	strb	r3, [r2, #0]
}
 800f196:	bf00      	nop
 800f198:	370c      	adds	r7, #12
 800f19a:	46bd      	mov	sp, r7
 800f19c:	f85d 7b04 	ldr.w	r7, [sp], #4
 800f1a0:	4770      	bx	lr
 800f1a2:	bf00      	nop
 800f1a4:	40023802 	.word	0x40023802

0800f1a8 <RCC_WaitForHSEStartUp>:
  * @retval An ErrorStatus enumeration value:
  *          - SUCCESS: HSE oscillator is stable and ready to use
  *          - ERROR: HSE oscillator not yet ready
  */
ErrorStatus RCC_WaitForHSEStartUp(void)
{
 800f1a8:	b580      	push	{r7, lr}
 800f1aa:	b082      	sub	sp, #8
 800f1ac:	af00      	add	r7, sp, #0
  __IO uint32_t startupcounter = 0;
 800f1ae:	2300      	movs	r3, #0
 800f1b0:	603b      	str	r3, [r7, #0]
  ErrorStatus status = ERROR;
 800f1b2:	2300      	movs	r3, #0
 800f1b4:	71fb      	strb	r3, [r7, #7]
  FlagStatus hsestatus = RESET;
 800f1b6:	2300      	movs	r3, #0
 800f1b8:	71bb      	strb	r3, [r7, #6]
  /* Wait till HSE is ready and if Time out is reached exit */
  do
  {
    hsestatus = RCC_GetFlagStatus(RCC_FLAG_HSERDY);
 800f1ba:	2031      	movs	r0, #49	; 0x31
 800f1bc:	f000 fcb0 	bl	800fb20 <RCC_GetFlagStatus>
 800f1c0:	4603      	mov	r3, r0
 800f1c2:	71bb      	strb	r3, [r7, #6]
    startupcounter++;
 800f1c4:	683b      	ldr	r3, [r7, #0]
 800f1c6:	3301      	adds	r3, #1
 800f1c8:	603b      	str	r3, [r7, #0]
  } while((startupcounter != HSE_STARTUP_TIMEOUT) && (hsestatus == RESET));
 800f1ca:	683b      	ldr	r3, [r7, #0]
 800f1cc:	f5b3 6fa0 	cmp.w	r3, #1280	; 0x500
 800f1d0:	d002      	beq.n	800f1d8 <RCC_WaitForHSEStartUp+0x30>
 800f1d2:	79bb      	ldrb	r3, [r7, #6]
 800f1d4:	2b00      	cmp	r3, #0
 800f1d6:	d0f0      	beq.n	800f1ba <RCC_WaitForHSEStartUp+0x12>

  if (RCC_GetFlagStatus(RCC_FLAG_HSERDY) != RESET)
 800f1d8:	2031      	movs	r0, #49	; 0x31
 800f1da:	f000 fca1 	bl	800fb20 <RCC_GetFlagStatus>
 800f1de:	4603      	mov	r3, r0
 800f1e0:	2b00      	cmp	r3, #0
 800f1e2:	d002      	beq.n	800f1ea <RCC_WaitForHSEStartUp+0x42>
  {
    status = SUCCESS;
 800f1e4:	2301      	movs	r3, #1
 800f1e6:	71fb      	strb	r3, [r7, #7]
 800f1e8:	e001      	b.n	800f1ee <RCC_WaitForHSEStartUp+0x46>
  }
  else
  {
    status = ERROR;
 800f1ea:	2300      	movs	r3, #0
 800f1ec:	71fb      	strb	r3, [r7, #7]
  }
  return (status);
 800f1ee:	79fb      	ldrb	r3, [r7, #7]
}
 800f1f0:	4618      	mov	r0, r3
 800f1f2:	3708      	adds	r7, #8
 800f1f4:	46bd      	mov	sp, r7
 800f1f6:	bd80      	pop	{r7, pc}

0800f1f8 <RCC_AdjustHSICalibrationValue>:
  * @param  HSICalibrationValue: specifies the calibration trimming value.
  *         This parameter must be a number between 0 and 0x1F.
  * @retval None
  */
void RCC_AdjustHSICalibrationValue(uint8_t HSICalibrationValue)
{
 800f1f8:	b480      	push	{r7}
 800f1fa:	b085      	sub	sp, #20
 800f1fc:	af00      	add	r7, sp, #0
 800f1fe:	4603      	mov	r3, r0
 800f200:	71fb      	strb	r3, [r7, #7]
  uint32_t tmpreg = 0;
 800f202:	2300      	movs	r3, #0
 800f204:	60fb      	str	r3, [r7, #12]
  /* Check the parameters */
  assert_param(IS_RCC_CALIBRATION_VALUE(HSICalibrationValue));

  tmpreg = RCC->CR;
 800f206:	4b0a      	ldr	r3, [pc, #40]	; (800f230 <RCC_AdjustHSICalibrationValue+0x38>)
 800f208:	681b      	ldr	r3, [r3, #0]
 800f20a:	60fb      	str	r3, [r7, #12]

  /* Clear HSITRIM[4:0] bits */
  tmpreg &= ~RCC_CR_HSITRIM;
 800f20c:	68fb      	ldr	r3, [r7, #12]
 800f20e:	f023 03f8 	bic.w	r3, r3, #248	; 0xf8
 800f212:	60fb      	str	r3, [r7, #12]

  /* Set the HSITRIM[4:0] bits according to HSICalibrationValue value */
  tmpreg |= (uint32_t)HSICalibrationValue << 3;
 800f214:	79fb      	ldrb	r3, [r7, #7]
 800f216:	00db      	lsls	r3, r3, #3
 800f218:	68fa      	ldr	r2, [r7, #12]
 800f21a:	4313      	orrs	r3, r2
 800f21c:	60fb      	str	r3, [r7, #12]

  /* Store the new value */
  RCC->CR = tmpreg;
 800f21e:	4a04      	ldr	r2, [pc, #16]	; (800f230 <RCC_AdjustHSICalibrationValue+0x38>)
 800f220:	68fb      	ldr	r3, [r7, #12]
 800f222:	6013      	str	r3, [r2, #0]
}
 800f224:	bf00      	nop
 800f226:	3714      	adds	r7, #20
 800f228:	46bd      	mov	sp, r7
 800f22a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800f22e:	4770      	bx	lr
 800f230:	40023800 	.word	0x40023800

0800f234 <RCC_HSICmd>:
  * @note   When the HSI is stopped, HSIRDY flag goes low after 6 HSI oscillator
  *         clock cycles.  
  * @retval None
  */
void RCC_HSICmd(FunctionalState NewState)
{
 800f234:	b480      	push	{r7}
 800f236:	b083      	sub	sp, #12
 800f238:	af00      	add	r7, sp, #0
 800f23a:	4603      	mov	r3, r0
 800f23c:	71fb      	strb	r3, [r7, #7]
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  *(__IO uint32_t *) CR_HSION_BB = (uint32_t)NewState;
 800f23e:	4a04      	ldr	r2, [pc, #16]	; (800f250 <RCC_HSICmd+0x1c>)
 800f240:	79fb      	ldrb	r3, [r7, #7]
 800f242:	6013      	str	r3, [r2, #0]
}
 800f244:	bf00      	nop
 800f246:	370c      	adds	r7, #12
 800f248:	46bd      	mov	sp, r7
 800f24a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800f24e:	4770      	bx	lr
 800f250:	42470000 	.word	0x42470000

0800f254 <RCC_LSEConfig>:
  *            @arg RCC_LSE_ON: turn ON the LSE oscillator
  *            @arg RCC_LSE_Bypass: LSE oscillator bypassed with external clock
  * @retval None
  */
void RCC_LSEConfig(uint8_t RCC_LSE)
{
 800f254:	b480      	push	{r7}
 800f256:	b083      	sub	sp, #12
 800f258:	af00      	add	r7, sp, #0
 800f25a:	4603      	mov	r3, r0
 800f25c:	71fb      	strb	r3, [r7, #7]
  /* Check the parameters */
  assert_param(IS_RCC_LSE(RCC_LSE));

  /* Reset LSEON and LSEBYP bits before configuring the LSE ------------------*/
  /* Reset LSEON bit */
  *(__IO uint8_t *) BDCR_ADDRESS = RCC_LSE_OFF;
 800f25e:	4b0d      	ldr	r3, [pc, #52]	; (800f294 <RCC_LSEConfig+0x40>)
 800f260:	2200      	movs	r2, #0
 800f262:	701a      	strb	r2, [r3, #0]

  /* Reset LSEBYP bit */
  *(__IO uint8_t *) BDCR_ADDRESS = RCC_LSE_OFF;
 800f264:	4b0b      	ldr	r3, [pc, #44]	; (800f294 <RCC_LSEConfig+0x40>)
 800f266:	2200      	movs	r2, #0
 800f268:	701a      	strb	r2, [r3, #0]

  /* Configure LSE (RCC_LSE_OFF is already covered by the code section above) */
  switch (RCC_LSE)
 800f26a:	79fb      	ldrb	r3, [r7, #7]
 800f26c:	2b01      	cmp	r3, #1
 800f26e:	d002      	beq.n	800f276 <RCC_LSEConfig+0x22>
 800f270:	2b04      	cmp	r3, #4
 800f272:	d004      	beq.n	800f27e <RCC_LSEConfig+0x2a>
    case RCC_LSE_Bypass:
      /* Set LSEBYP and LSEON bits */
      *(__IO uint8_t *) BDCR_ADDRESS = RCC_LSE_Bypass | RCC_LSE_ON;
      break;
    default:
      break;
 800f274:	e007      	b.n	800f286 <RCC_LSEConfig+0x32>
      *(__IO uint8_t *) BDCR_ADDRESS = RCC_LSE_ON;
 800f276:	4b07      	ldr	r3, [pc, #28]	; (800f294 <RCC_LSEConfig+0x40>)
 800f278:	2201      	movs	r2, #1
 800f27a:	701a      	strb	r2, [r3, #0]
      break;
 800f27c:	e003      	b.n	800f286 <RCC_LSEConfig+0x32>
      *(__IO uint8_t *) BDCR_ADDRESS = RCC_LSE_Bypass | RCC_LSE_ON;
 800f27e:	4b05      	ldr	r3, [pc, #20]	; (800f294 <RCC_LSEConfig+0x40>)
 800f280:	2205      	movs	r2, #5
 800f282:	701a      	strb	r2, [r3, #0]
      break;
 800f284:	bf00      	nop
  }
}
 800f286:	bf00      	nop
 800f288:	370c      	adds	r7, #12
 800f28a:	46bd      	mov	sp, r7
 800f28c:	f85d 7b04 	ldr.w	r7, [sp], #4
 800f290:	4770      	bx	lr
 800f292:	bf00      	nop
 800f294:	40023870 	.word	0x40023870

0800f298 <RCC_LSICmd>:
  * @note   When the LSI is stopped, LSIRDY flag goes low after 6 LSI oscillator
  *         clock cycles. 
  * @retval None
  */
void RCC_LSICmd(FunctionalState NewState)
{
 800f298:	b480      	push	{r7}
 800f29a:	b083      	sub	sp, #12
 800f29c:	af00      	add	r7, sp, #0
 800f29e:	4603      	mov	r3, r0
 800f2a0:	71fb      	strb	r3, [r7, #7]
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  *(__IO uint32_t *) CSR_LSION_BB = (uint32_t)NewState;
 800f2a2:	4a04      	ldr	r2, [pc, #16]	; (800f2b4 <RCC_LSICmd+0x1c>)
 800f2a4:	79fb      	ldrb	r3, [r7, #7]
 800f2a6:	6013      	str	r3, [r2, #0]
}
 800f2a8:	bf00      	nop
 800f2aa:	370c      	adds	r7, #12
 800f2ac:	46bd      	mov	sp, r7
 800f2ae:	f85d 7b04 	ldr.w	r7, [sp], #4
 800f2b2:	4770      	bx	lr
 800f2b4:	42470e80 	.word	0x42470e80

0800f2b8 <RCC_PLLConfig>:
  *         correctly.
  *   
  * @retval None
  */
void RCC_PLLConfig(uint32_t RCC_PLLSource, uint32_t PLLM, uint32_t PLLN, uint32_t PLLP, uint32_t PLLQ)
{
 800f2b8:	b480      	push	{r7}
 800f2ba:	b085      	sub	sp, #20
 800f2bc:	af00      	add	r7, sp, #0
 800f2be:	60f8      	str	r0, [r7, #12]
 800f2c0:	60b9      	str	r1, [r7, #8]
 800f2c2:	607a      	str	r2, [r7, #4]
 800f2c4:	603b      	str	r3, [r7, #0]
  assert_param(IS_RCC_PLLM_VALUE(PLLM));
  assert_param(IS_RCC_PLLN_VALUE(PLLN));
  assert_param(IS_RCC_PLLP_VALUE(PLLP));
  assert_param(IS_RCC_PLLQ_VALUE(PLLQ));

  RCC->PLLCFGR = PLLM | (PLLN << 6) | (((PLLP >> 1) -1) << 16) | (RCC_PLLSource) |
 800f2c6:	490b      	ldr	r1, [pc, #44]	; (800f2f4 <RCC_PLLConfig+0x3c>)
 800f2c8:	687b      	ldr	r3, [r7, #4]
 800f2ca:	019a      	lsls	r2, r3, #6
 800f2cc:	68bb      	ldr	r3, [r7, #8]
 800f2ce:	431a      	orrs	r2, r3
 800f2d0:	683b      	ldr	r3, [r7, #0]
 800f2d2:	085b      	lsrs	r3, r3, #1
 800f2d4:	3b01      	subs	r3, #1
 800f2d6:	041b      	lsls	r3, r3, #16
 800f2d8:	431a      	orrs	r2, r3
 800f2da:	68fb      	ldr	r3, [r7, #12]
 800f2dc:	431a      	orrs	r2, r3
                 (PLLQ << 24);
 800f2de:	69bb      	ldr	r3, [r7, #24]
 800f2e0:	061b      	lsls	r3, r3, #24
  RCC->PLLCFGR = PLLM | (PLLN << 6) | (((PLLP >> 1) -1) << 16) | (RCC_PLLSource) |
 800f2e2:	4313      	orrs	r3, r2
 800f2e4:	604b      	str	r3, [r1, #4]
}
 800f2e6:	bf00      	nop
 800f2e8:	3714      	adds	r7, #20
 800f2ea:	46bd      	mov	sp, r7
 800f2ec:	f85d 7b04 	ldr.w	r7, [sp], #4
 800f2f0:	4770      	bx	lr
 800f2f2:	bf00      	nop
 800f2f4:	40023800 	.word	0x40023800

0800f2f8 <RCC_PLLCmd>:
  * @note   The main PLL is disabled by hardware when entering STOP and STANDBY modes.
  * @param  NewState: new state of the main PLL. This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void RCC_PLLCmd(FunctionalState NewState)
{
 800f2f8:	b480      	push	{r7}
 800f2fa:	b083      	sub	sp, #12
 800f2fc:	af00      	add	r7, sp, #0
 800f2fe:	4603      	mov	r3, r0
 800f300:	71fb      	strb	r3, [r7, #7]
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  *(__IO uint32_t *) CR_PLLON_BB = (uint32_t)NewState;
 800f302:	4a04      	ldr	r2, [pc, #16]	; (800f314 <RCC_PLLCmd+0x1c>)
 800f304:	79fb      	ldrb	r3, [r7, #7]
 800f306:	6013      	str	r3, [r2, #0]
}
 800f308:	bf00      	nop
 800f30a:	370c      	adds	r7, #12
 800f30c:	46bd      	mov	sp, r7
 800f30e:	f85d 7b04 	ldr.w	r7, [sp], #4
 800f312:	4770      	bx	lr
 800f314:	42470060 	.word	0x42470060

0800f318 <RCC_PLLI2SConfig>:
  *         on the I2S clock frequency.
  *   
  * @retval None
  */
void RCC_PLLI2SConfig(uint32_t PLLI2SN, uint32_t PLLI2SR)
{
 800f318:	b480      	push	{r7}
 800f31a:	b083      	sub	sp, #12
 800f31c:	af00      	add	r7, sp, #0
 800f31e:	6078      	str	r0, [r7, #4]
 800f320:	6039      	str	r1, [r7, #0]
  /* Check the parameters */
  assert_param(IS_RCC_PLLI2SN_VALUE(PLLI2SN));
  assert_param(IS_RCC_PLLI2SR_VALUE(PLLI2SR));

  RCC->PLLI2SCFGR = (PLLI2SN << 6) | (PLLI2SR << 28);
 800f322:	4907      	ldr	r1, [pc, #28]	; (800f340 <RCC_PLLI2SConfig+0x28>)
 800f324:	687b      	ldr	r3, [r7, #4]
 800f326:	019a      	lsls	r2, r3, #6
 800f328:	683b      	ldr	r3, [r7, #0]
 800f32a:	071b      	lsls	r3, r3, #28
 800f32c:	4313      	orrs	r3, r2
 800f32e:	f8c1 3084 	str.w	r3, [r1, #132]	; 0x84
}
 800f332:	bf00      	nop
 800f334:	370c      	adds	r7, #12
 800f336:	46bd      	mov	sp, r7
 800f338:	f85d 7b04 	ldr.w	r7, [sp], #4
 800f33c:	4770      	bx	lr
 800f33e:	bf00      	nop
 800f340:	40023800 	.word	0x40023800

0800f344 <RCC_PLLI2SCmd>:
  * @note   The PLLI2S is disabled by hardware when entering STOP and STANDBY modes.  
  * @param  NewState: new state of the PLLI2S. This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void RCC_PLLI2SCmd(FunctionalState NewState)
{
 800f344:	b480      	push	{r7}
 800f346:	b083      	sub	sp, #12
 800f348:	af00      	add	r7, sp, #0
 800f34a:	4603      	mov	r3, r0
 800f34c:	71fb      	strb	r3, [r7, #7]
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  *(__IO uint32_t *) CR_PLLI2SON_BB = (uint32_t)NewState;
 800f34e:	4a04      	ldr	r2, [pc, #16]	; (800f360 <RCC_PLLI2SCmd+0x1c>)
 800f350:	79fb      	ldrb	r3, [r7, #7]
 800f352:	6013      	str	r3, [r2, #0]
}
 800f354:	bf00      	nop
 800f356:	370c      	adds	r7, #12
 800f358:	46bd      	mov	sp, r7
 800f35a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800f35e:	4770      	bx	lr
 800f360:	42470068 	.word	0x42470068

0800f364 <RCC_ClockSecuritySystemCmd>:
  * @param  NewState: new state of the Clock Security System.
  *         This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void RCC_ClockSecuritySystemCmd(FunctionalState NewState)
{
 800f364:	b480      	push	{r7}
 800f366:	b083      	sub	sp, #12
 800f368:	af00      	add	r7, sp, #0
 800f36a:	4603      	mov	r3, r0
 800f36c:	71fb      	strb	r3, [r7, #7]
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  *(__IO uint32_t *) CR_CSSON_BB = (uint32_t)NewState;
 800f36e:	4a04      	ldr	r2, [pc, #16]	; (800f380 <RCC_ClockSecuritySystemCmd+0x1c>)
 800f370:	79fb      	ldrb	r3, [r7, #7]
 800f372:	6013      	str	r3, [r2, #0]
}
 800f374:	bf00      	nop
 800f376:	370c      	adds	r7, #12
 800f378:	46bd      	mov	sp, r7
 800f37a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800f37e:	4770      	bx	lr
 800f380:	4247004c 	.word	0x4247004c

0800f384 <RCC_MCO1Config>:
  *            @arg RCC_MCO1Div_4: division by 4 applied to MCO1 clock
  *            @arg RCC_MCO1Div_5: division by 5 applied to MCO1 clock
  * @retval None
  */
void RCC_MCO1Config(uint32_t RCC_MCO1Source, uint32_t RCC_MCO1Div)
{
 800f384:	b480      	push	{r7}
 800f386:	b085      	sub	sp, #20
 800f388:	af00      	add	r7, sp, #0
 800f38a:	6078      	str	r0, [r7, #4]
 800f38c:	6039      	str	r1, [r7, #0]
  uint32_t tmpreg = 0;
 800f38e:	2300      	movs	r3, #0
 800f390:	60fb      	str	r3, [r7, #12]
  
  /* Check the parameters */
  assert_param(IS_RCC_MCO1SOURCE(RCC_MCO1Source));
  assert_param(IS_RCC_MCO1DIV(RCC_MCO1Div));  

  tmpreg = RCC->CFGR;
 800f392:	4b0b      	ldr	r3, [pc, #44]	; (800f3c0 <RCC_MCO1Config+0x3c>)
 800f394:	689b      	ldr	r3, [r3, #8]
 800f396:	60fb      	str	r3, [r7, #12]

  /* Clear MCO1[1:0] and MCO1PRE[2:0] bits */
  tmpreg &= CFGR_MCO1_RESET_MASK;
 800f398:	68fb      	ldr	r3, [r7, #12]
 800f39a:	f023 63ec 	bic.w	r3, r3, #123731968	; 0x7600000
 800f39e:	60fb      	str	r3, [r7, #12]

  /* Select MCO1 clock source and prescaler */
  tmpreg |= RCC_MCO1Source | RCC_MCO1Div;
 800f3a0:	687a      	ldr	r2, [r7, #4]
 800f3a2:	683b      	ldr	r3, [r7, #0]
 800f3a4:	4313      	orrs	r3, r2
 800f3a6:	68fa      	ldr	r2, [r7, #12]
 800f3a8:	4313      	orrs	r3, r2
 800f3aa:	60fb      	str	r3, [r7, #12]

  /* Store the new value */
  RCC->CFGR = tmpreg;  
 800f3ac:	4a04      	ldr	r2, [pc, #16]	; (800f3c0 <RCC_MCO1Config+0x3c>)
 800f3ae:	68fb      	ldr	r3, [r7, #12]
 800f3b0:	6093      	str	r3, [r2, #8]
}
 800f3b2:	bf00      	nop
 800f3b4:	3714      	adds	r7, #20
 800f3b6:	46bd      	mov	sp, r7
 800f3b8:	f85d 7b04 	ldr.w	r7, [sp], #4
 800f3bc:	4770      	bx	lr
 800f3be:	bf00      	nop
 800f3c0:	40023800 	.word	0x40023800

0800f3c4 <RCC_MCO2Config>:
  *            @arg RCC_MCO2Div_4: division by 4 applied to MCO2 clock
  *            @arg RCC_MCO2Div_5: division by 5 applied to MCO2 clock
  * @retval None
  */
void RCC_MCO2Config(uint32_t RCC_MCO2Source, uint32_t RCC_MCO2Div)
{
 800f3c4:	b480      	push	{r7}
 800f3c6:	b085      	sub	sp, #20
 800f3c8:	af00      	add	r7, sp, #0
 800f3ca:	6078      	str	r0, [r7, #4]
 800f3cc:	6039      	str	r1, [r7, #0]
  uint32_t tmpreg = 0;
 800f3ce:	2300      	movs	r3, #0
 800f3d0:	60fb      	str	r3, [r7, #12]
  
  /* Check the parameters */
  assert_param(IS_RCC_MCO2SOURCE(RCC_MCO2Source));
  assert_param(IS_RCC_MCO2DIV(RCC_MCO2Div));
  
  tmpreg = RCC->CFGR;
 800f3d2:	4b0b      	ldr	r3, [pc, #44]	; (800f400 <RCC_MCO2Config+0x3c>)
 800f3d4:	689b      	ldr	r3, [r3, #8]
 800f3d6:	60fb      	str	r3, [r7, #12]
  
  /* Clear MCO2 and MCO2PRE[2:0] bits */
  tmpreg &= CFGR_MCO2_RESET_MASK;
 800f3d8:	68fb      	ldr	r3, [r7, #12]
 800f3da:	f023 4378 	bic.w	r3, r3, #4160749568	; 0xf8000000
 800f3de:	60fb      	str	r3, [r7, #12]

  /* Select MCO2 clock source and prescaler */
  tmpreg |= RCC_MCO2Source | RCC_MCO2Div;
 800f3e0:	687a      	ldr	r2, [r7, #4]
 800f3e2:	683b      	ldr	r3, [r7, #0]
 800f3e4:	4313      	orrs	r3, r2
 800f3e6:	68fa      	ldr	r2, [r7, #12]
 800f3e8:	4313      	orrs	r3, r2
 800f3ea:	60fb      	str	r3, [r7, #12]

  /* Store the new value */
  RCC->CFGR = tmpreg;  
 800f3ec:	4a04      	ldr	r2, [pc, #16]	; (800f400 <RCC_MCO2Config+0x3c>)
 800f3ee:	68fb      	ldr	r3, [r7, #12]
 800f3f0:	6093      	str	r3, [r2, #8]
}
 800f3f2:	bf00      	nop
 800f3f4:	3714      	adds	r7, #20
 800f3f6:	46bd      	mov	sp, r7
 800f3f8:	f85d 7b04 	ldr.w	r7, [sp], #4
 800f3fc:	4770      	bx	lr
 800f3fe:	bf00      	nop
 800f400:	40023800 	.word	0x40023800

0800f404 <RCC_SYSCLKConfig>:
  *            @arg RCC_SYSCLKSource_HSE:    HSE selected as system clock source
  *            @arg RCC_SYSCLKSource_PLLCLK: PLL selected as system clock source
  * @retval None
  */
void RCC_SYSCLKConfig(uint32_t RCC_SYSCLKSource)
{
 800f404:	b480      	push	{r7}
 800f406:	b085      	sub	sp, #20
 800f408:	af00      	add	r7, sp, #0
 800f40a:	6078      	str	r0, [r7, #4]
  uint32_t tmpreg = 0;
 800f40c:	2300      	movs	r3, #0
 800f40e:	60fb      	str	r3, [r7, #12]

  /* Check the parameters */
  assert_param(IS_RCC_SYSCLK_SOURCE(RCC_SYSCLKSource));

  tmpreg = RCC->CFGR;
 800f410:	4b09      	ldr	r3, [pc, #36]	; (800f438 <RCC_SYSCLKConfig+0x34>)
 800f412:	689b      	ldr	r3, [r3, #8]
 800f414:	60fb      	str	r3, [r7, #12]

  /* Clear SW[1:0] bits */
  tmpreg &= ~RCC_CFGR_SW;
 800f416:	68fb      	ldr	r3, [r7, #12]
 800f418:	f023 0303 	bic.w	r3, r3, #3
 800f41c:	60fb      	str	r3, [r7, #12]

  /* Set SW[1:0] bits according to RCC_SYSCLKSource value */
  tmpreg |= RCC_SYSCLKSource;
 800f41e:	68fa      	ldr	r2, [r7, #12]
 800f420:	687b      	ldr	r3, [r7, #4]
 800f422:	4313      	orrs	r3, r2
 800f424:	60fb      	str	r3, [r7, #12]

  /* Store the new value */
  RCC->CFGR = tmpreg;
 800f426:	4a04      	ldr	r2, [pc, #16]	; (800f438 <RCC_SYSCLKConfig+0x34>)
 800f428:	68fb      	ldr	r3, [r7, #12]
 800f42a:	6093      	str	r3, [r2, #8]
}
 800f42c:	bf00      	nop
 800f42e:	3714      	adds	r7, #20
 800f430:	46bd      	mov	sp, r7
 800f432:	f85d 7b04 	ldr.w	r7, [sp], #4
 800f436:	4770      	bx	lr
 800f438:	40023800 	.word	0x40023800

0800f43c <RCC_GetSYSCLKSource>:
  *              - 0x00: HSI used as system clock
  *              - 0x04: HSE used as system clock
  *              - 0x08: PLL used as system clock
  */
uint8_t RCC_GetSYSCLKSource(void)
{
 800f43c:	b480      	push	{r7}
 800f43e:	af00      	add	r7, sp, #0
  return ((uint8_t)(RCC->CFGR & RCC_CFGR_SWS));
 800f440:	4b05      	ldr	r3, [pc, #20]	; (800f458 <RCC_GetSYSCLKSource+0x1c>)
 800f442:	689b      	ldr	r3, [r3, #8]
 800f444:	b2db      	uxtb	r3, r3
 800f446:	f003 030c 	and.w	r3, r3, #12
 800f44a:	b2db      	uxtb	r3, r3
}
 800f44c:	4618      	mov	r0, r3
 800f44e:	46bd      	mov	sp, r7
 800f450:	f85d 7b04 	ldr.w	r7, [sp], #4
 800f454:	4770      	bx	lr
 800f456:	bf00      	nop
 800f458:	40023800 	.word	0x40023800

0800f45c <RCC_HCLKConfig>:
  *            @arg RCC_SYSCLK_Div256: AHB clock = SYSCLK/256
  *            @arg RCC_SYSCLK_Div512: AHB clock = SYSCLK/512
  * @retval None
  */
void RCC_HCLKConfig(uint32_t RCC_SYSCLK)
{
 800f45c:	b480      	push	{r7}
 800f45e:	b085      	sub	sp, #20
 800f460:	af00      	add	r7, sp, #0
 800f462:	6078      	str	r0, [r7, #4]
  uint32_t tmpreg = 0;
 800f464:	2300      	movs	r3, #0
 800f466:	60fb      	str	r3, [r7, #12]
  
  /* Check the parameters */
  assert_param(IS_RCC_HCLK(RCC_SYSCLK));

  tmpreg = RCC->CFGR;
 800f468:	4b09      	ldr	r3, [pc, #36]	; (800f490 <RCC_HCLKConfig+0x34>)
 800f46a:	689b      	ldr	r3, [r3, #8]
 800f46c:	60fb      	str	r3, [r7, #12]

  /* Clear HPRE[3:0] bits */
  tmpreg &= ~RCC_CFGR_HPRE;
 800f46e:	68fb      	ldr	r3, [r7, #12]
 800f470:	f023 03f0 	bic.w	r3, r3, #240	; 0xf0
 800f474:	60fb      	str	r3, [r7, #12]

  /* Set HPRE[3:0] bits according to RCC_SYSCLK value */
  tmpreg |= RCC_SYSCLK;
 800f476:	68fa      	ldr	r2, [r7, #12]
 800f478:	687b      	ldr	r3, [r7, #4]
 800f47a:	4313      	orrs	r3, r2
 800f47c:	60fb      	str	r3, [r7, #12]

  /* Store the new value */
  RCC->CFGR = tmpreg;
 800f47e:	4a04      	ldr	r2, [pc, #16]	; (800f490 <RCC_HCLKConfig+0x34>)
 800f480:	68fb      	ldr	r3, [r7, #12]
 800f482:	6093      	str	r3, [r2, #8]
}
 800f484:	bf00      	nop
 800f486:	3714      	adds	r7, #20
 800f488:	46bd      	mov	sp, r7
 800f48a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800f48e:	4770      	bx	lr
 800f490:	40023800 	.word	0x40023800

0800f494 <RCC_PCLK1Config>:
  *            @arg RCC_HCLK_Div8:  APB1 clock = HCLK/8
  *            @arg RCC_HCLK_Div16: APB1 clock = HCLK/16
  * @retval None
  */
void RCC_PCLK1Config(uint32_t RCC_HCLK)
{
 800f494:	b480      	push	{r7}
 800f496:	b085      	sub	sp, #20
 800f498:	af00      	add	r7, sp, #0
 800f49a:	6078      	str	r0, [r7, #4]
  uint32_t tmpreg = 0;
 800f49c:	2300      	movs	r3, #0
 800f49e:	60fb      	str	r3, [r7, #12]

  /* Check the parameters */
  assert_param(IS_RCC_PCLK(RCC_HCLK));

  tmpreg = RCC->CFGR;
 800f4a0:	4b09      	ldr	r3, [pc, #36]	; (800f4c8 <RCC_PCLK1Config+0x34>)
 800f4a2:	689b      	ldr	r3, [r3, #8]
 800f4a4:	60fb      	str	r3, [r7, #12]

  /* Clear PPRE1[2:0] bits */
  tmpreg &= ~RCC_CFGR_PPRE1;
 800f4a6:	68fb      	ldr	r3, [r7, #12]
 800f4a8:	f423 53e0 	bic.w	r3, r3, #7168	; 0x1c00
 800f4ac:	60fb      	str	r3, [r7, #12]

  /* Set PPRE1[2:0] bits according to RCC_HCLK value */
  tmpreg |= RCC_HCLK;
 800f4ae:	68fa      	ldr	r2, [r7, #12]
 800f4b0:	687b      	ldr	r3, [r7, #4]
 800f4b2:	4313      	orrs	r3, r2
 800f4b4:	60fb      	str	r3, [r7, #12]

  /* Store the new value */
  RCC->CFGR = tmpreg;
 800f4b6:	4a04      	ldr	r2, [pc, #16]	; (800f4c8 <RCC_PCLK1Config+0x34>)
 800f4b8:	68fb      	ldr	r3, [r7, #12]
 800f4ba:	6093      	str	r3, [r2, #8]
}
 800f4bc:	bf00      	nop
 800f4be:	3714      	adds	r7, #20
 800f4c0:	46bd      	mov	sp, r7
 800f4c2:	f85d 7b04 	ldr.w	r7, [sp], #4
 800f4c6:	4770      	bx	lr
 800f4c8:	40023800 	.word	0x40023800

0800f4cc <RCC_PCLK2Config>:
  *            @arg RCC_HCLK_Div8:  APB2 clock = HCLK/8
  *            @arg RCC_HCLK_Div16: APB2 clock = HCLK/16
  * @retval None
  */
void RCC_PCLK2Config(uint32_t RCC_HCLK)
{
 800f4cc:	b480      	push	{r7}
 800f4ce:	b085      	sub	sp, #20
 800f4d0:	af00      	add	r7, sp, #0
 800f4d2:	6078      	str	r0, [r7, #4]
  uint32_t tmpreg = 0;
 800f4d4:	2300      	movs	r3, #0
 800f4d6:	60fb      	str	r3, [r7, #12]

  /* Check the parameters */
  assert_param(IS_RCC_PCLK(RCC_HCLK));

  tmpreg = RCC->CFGR;
 800f4d8:	4b0a      	ldr	r3, [pc, #40]	; (800f504 <RCC_PCLK2Config+0x38>)
 800f4da:	689b      	ldr	r3, [r3, #8]
 800f4dc:	60fb      	str	r3, [r7, #12]

  /* Clear PPRE2[2:0] bits */
  tmpreg &= ~RCC_CFGR_PPRE2;
 800f4de:	68fb      	ldr	r3, [r7, #12]
 800f4e0:	f423 4360 	bic.w	r3, r3, #57344	; 0xe000
 800f4e4:	60fb      	str	r3, [r7, #12]

  /* Set PPRE2[2:0] bits according to RCC_HCLK value */
  tmpreg |= RCC_HCLK << 3;
 800f4e6:	687b      	ldr	r3, [r7, #4]
 800f4e8:	00db      	lsls	r3, r3, #3
 800f4ea:	68fa      	ldr	r2, [r7, #12]
 800f4ec:	4313      	orrs	r3, r2
 800f4ee:	60fb      	str	r3, [r7, #12]

  /* Store the new value */
  RCC->CFGR = tmpreg;
 800f4f0:	4a04      	ldr	r2, [pc, #16]	; (800f504 <RCC_PCLK2Config+0x38>)
 800f4f2:	68fb      	ldr	r3, [r7, #12]
 800f4f4:	6093      	str	r3, [r2, #8]
}
 800f4f6:	bf00      	nop
 800f4f8:	3714      	adds	r7, #20
 800f4fa:	46bd      	mov	sp, r7
 800f4fc:	f85d 7b04 	ldr.w	r7, [sp], #4
 800f500:	4770      	bx	lr
 800f502:	bf00      	nop
 800f504:	40023800 	.word	0x40023800

0800f508 <RCC_GetClocksFreq>:
  *         configuration based on this function will be incorrect.
  *    
  * @retval None
  */
void RCC_GetClocksFreq(RCC_ClocksTypeDef* RCC_Clocks)
{
 800f508:	b480      	push	{r7}
 800f50a:	b089      	sub	sp, #36	; 0x24
 800f50c:	af00      	add	r7, sp, #0
 800f50e:	6078      	str	r0, [r7, #4]
  uint32_t tmp = 0, presc = 0, pllvco = 0, pllp = 2, pllsource = 0, pllm = 2;
 800f510:	2300      	movs	r3, #0
 800f512:	61bb      	str	r3, [r7, #24]
 800f514:	2300      	movs	r3, #0
 800f516:	617b      	str	r3, [r7, #20]
 800f518:	2300      	movs	r3, #0
 800f51a:	61fb      	str	r3, [r7, #28]
 800f51c:	2302      	movs	r3, #2
 800f51e:	613b      	str	r3, [r7, #16]
 800f520:	2300      	movs	r3, #0
 800f522:	60fb      	str	r3, [r7, #12]
 800f524:	2302      	movs	r3, #2
 800f526:	60bb      	str	r3, [r7, #8]

  /* Get SYSCLK source -------------------------------------------------------*/
  tmp = RCC->CFGR & RCC_CFGR_SWS;
 800f528:	4b47      	ldr	r3, [pc, #284]	; (800f648 <RCC_GetClocksFreq+0x140>)
 800f52a:	689b      	ldr	r3, [r3, #8]
 800f52c:	f003 030c 	and.w	r3, r3, #12
 800f530:	61bb      	str	r3, [r7, #24]

  switch (tmp)
 800f532:	69bb      	ldr	r3, [r7, #24]
 800f534:	2b04      	cmp	r3, #4
 800f536:	d007      	beq.n	800f548 <RCC_GetClocksFreq+0x40>
 800f538:	2b08      	cmp	r3, #8
 800f53a:	d009      	beq.n	800f550 <RCC_GetClocksFreq+0x48>
 800f53c:	2b00      	cmp	r3, #0
 800f53e:	d13d      	bne.n	800f5bc <RCC_GetClocksFreq+0xb4>
  {
    case 0x00:  /* HSI used as system clock source */
      RCC_Clocks->SYSCLK_Frequency = HSI_VALUE;
 800f540:	687b      	ldr	r3, [r7, #4]
 800f542:	4a42      	ldr	r2, [pc, #264]	; (800f64c <RCC_GetClocksFreq+0x144>)
 800f544:	601a      	str	r2, [r3, #0]
      break;
 800f546:	e03d      	b.n	800f5c4 <RCC_GetClocksFreq+0xbc>
    case 0x04:  /* HSE used as system clock  source */
      RCC_Clocks->SYSCLK_Frequency = HSE_VALUE;
 800f548:	687b      	ldr	r3, [r7, #4]
 800f54a:	4a41      	ldr	r2, [pc, #260]	; (800f650 <RCC_GetClocksFreq+0x148>)
 800f54c:	601a      	str	r2, [r3, #0]
      break;
 800f54e:	e039      	b.n	800f5c4 <RCC_GetClocksFreq+0xbc>
    case 0x08:  /* PLL used as system clock  source */

      /* PLL_VCO = (HSE_VALUE or HSI_VALUE / PLLM) * PLLN
         SYSCLK = PLL_VCO / PLLP
         */    
      pllsource = (RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) >> 22;
 800f550:	4b3d      	ldr	r3, [pc, #244]	; (800f648 <RCC_GetClocksFreq+0x140>)
 800f552:	685b      	ldr	r3, [r3, #4]
 800f554:	0d9b      	lsrs	r3, r3, #22
 800f556:	f003 0301 	and.w	r3, r3, #1
 800f55a:	60fb      	str	r3, [r7, #12]
      pllm = RCC->PLLCFGR & RCC_PLLCFGR_PLLM;
 800f55c:	4b3a      	ldr	r3, [pc, #232]	; (800f648 <RCC_GetClocksFreq+0x140>)
 800f55e:	685b      	ldr	r3, [r3, #4]
 800f560:	f003 033f 	and.w	r3, r3, #63	; 0x3f
 800f564:	60bb      	str	r3, [r7, #8]
      
      if (pllsource != 0)
 800f566:	68fb      	ldr	r3, [r7, #12]
 800f568:	2b00      	cmp	r3, #0
 800f56a:	d00c      	beq.n	800f586 <RCC_GetClocksFreq+0x7e>
      {
        /* HSE used as PLL clock source */
        pllvco = (HSE_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> 6);
 800f56c:	4a38      	ldr	r2, [pc, #224]	; (800f650 <RCC_GetClocksFreq+0x148>)
 800f56e:	68bb      	ldr	r3, [r7, #8]
 800f570:	fbb2 f3f3 	udiv	r3, r2, r3
 800f574:	4a34      	ldr	r2, [pc, #208]	; (800f648 <RCC_GetClocksFreq+0x140>)
 800f576:	6852      	ldr	r2, [r2, #4]
 800f578:	0992      	lsrs	r2, r2, #6
 800f57a:	f3c2 0208 	ubfx	r2, r2, #0, #9
 800f57e:	fb02 f303 	mul.w	r3, r2, r3
 800f582:	61fb      	str	r3, [r7, #28]
 800f584:	e00b      	b.n	800f59e <RCC_GetClocksFreq+0x96>
      }
      else
      {
        /* HSI used as PLL clock source */
        pllvco = (HSI_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> 6);      
 800f586:	4a31      	ldr	r2, [pc, #196]	; (800f64c <RCC_GetClocksFreq+0x144>)
 800f588:	68bb      	ldr	r3, [r7, #8]
 800f58a:	fbb2 f3f3 	udiv	r3, r2, r3
 800f58e:	4a2e      	ldr	r2, [pc, #184]	; (800f648 <RCC_GetClocksFreq+0x140>)
 800f590:	6852      	ldr	r2, [r2, #4]
 800f592:	0992      	lsrs	r2, r2, #6
 800f594:	f3c2 0208 	ubfx	r2, r2, #0, #9
 800f598:	fb02 f303 	mul.w	r3, r2, r3
 800f59c:	61fb      	str	r3, [r7, #28]
      }

      pllp = (((RCC->PLLCFGR & RCC_PLLCFGR_PLLP) >>16) + 1 ) *2;
 800f59e:	4b2a      	ldr	r3, [pc, #168]	; (800f648 <RCC_GetClocksFreq+0x140>)
 800f5a0:	685b      	ldr	r3, [r3, #4]
 800f5a2:	0c1b      	lsrs	r3, r3, #16
 800f5a4:	f003 0303 	and.w	r3, r3, #3
 800f5a8:	3301      	adds	r3, #1
 800f5aa:	005b      	lsls	r3, r3, #1
 800f5ac:	613b      	str	r3, [r7, #16]
      RCC_Clocks->SYSCLK_Frequency = pllvco/pllp;
 800f5ae:	69fa      	ldr	r2, [r7, #28]
 800f5b0:	693b      	ldr	r3, [r7, #16]
 800f5b2:	fbb2 f2f3 	udiv	r2, r2, r3
 800f5b6:	687b      	ldr	r3, [r7, #4]
 800f5b8:	601a      	str	r2, [r3, #0]
      break;
 800f5ba:	e003      	b.n	800f5c4 <RCC_GetClocksFreq+0xbc>
    default:
      RCC_Clocks->SYSCLK_Frequency = HSI_VALUE;
 800f5bc:	687b      	ldr	r3, [r7, #4]
 800f5be:	4a23      	ldr	r2, [pc, #140]	; (800f64c <RCC_GetClocksFreq+0x144>)
 800f5c0:	601a      	str	r2, [r3, #0]
      break;
 800f5c2:	bf00      	nop
  }
  /* Compute HCLK, PCLK1 and PCLK2 clocks frequencies ------------------------*/

  /* Get HCLK prescaler */
  tmp = RCC->CFGR & RCC_CFGR_HPRE;
 800f5c4:	4b20      	ldr	r3, [pc, #128]	; (800f648 <RCC_GetClocksFreq+0x140>)
 800f5c6:	689b      	ldr	r3, [r3, #8]
 800f5c8:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
 800f5cc:	61bb      	str	r3, [r7, #24]
  tmp = tmp >> 4;
 800f5ce:	69bb      	ldr	r3, [r7, #24]
 800f5d0:	091b      	lsrs	r3, r3, #4
 800f5d2:	61bb      	str	r3, [r7, #24]
  presc = APBAHBPrescTable[tmp];
 800f5d4:	4a1f      	ldr	r2, [pc, #124]	; (800f654 <RCC_GetClocksFreq+0x14c>)
 800f5d6:	69bb      	ldr	r3, [r7, #24]
 800f5d8:	4413      	add	r3, r2
 800f5da:	781b      	ldrb	r3, [r3, #0]
 800f5dc:	b2db      	uxtb	r3, r3
 800f5de:	617b      	str	r3, [r7, #20]
  /* HCLK clock frequency */
  RCC_Clocks->HCLK_Frequency = RCC_Clocks->SYSCLK_Frequency >> presc;
 800f5e0:	687b      	ldr	r3, [r7, #4]
 800f5e2:	681a      	ldr	r2, [r3, #0]
 800f5e4:	697b      	ldr	r3, [r7, #20]
 800f5e6:	40da      	lsrs	r2, r3
 800f5e8:	687b      	ldr	r3, [r7, #4]
 800f5ea:	605a      	str	r2, [r3, #4]

  /* Get PCLK1 prescaler */
  tmp = RCC->CFGR & RCC_CFGR_PPRE1;
 800f5ec:	4b16      	ldr	r3, [pc, #88]	; (800f648 <RCC_GetClocksFreq+0x140>)
 800f5ee:	689b      	ldr	r3, [r3, #8]
 800f5f0:	f403 53e0 	and.w	r3, r3, #7168	; 0x1c00
 800f5f4:	61bb      	str	r3, [r7, #24]
  tmp = tmp >> 10;
 800f5f6:	69bb      	ldr	r3, [r7, #24]
 800f5f8:	0a9b      	lsrs	r3, r3, #10
 800f5fa:	61bb      	str	r3, [r7, #24]
  presc = APBAHBPrescTable[tmp];
 800f5fc:	4a15      	ldr	r2, [pc, #84]	; (800f654 <RCC_GetClocksFreq+0x14c>)
 800f5fe:	69bb      	ldr	r3, [r7, #24]
 800f600:	4413      	add	r3, r2
 800f602:	781b      	ldrb	r3, [r3, #0]
 800f604:	b2db      	uxtb	r3, r3
 800f606:	617b      	str	r3, [r7, #20]
  /* PCLK1 clock frequency */
  RCC_Clocks->PCLK1_Frequency = RCC_Clocks->HCLK_Frequency >> presc;
 800f608:	687b      	ldr	r3, [r7, #4]
 800f60a:	685a      	ldr	r2, [r3, #4]
 800f60c:	697b      	ldr	r3, [r7, #20]
 800f60e:	40da      	lsrs	r2, r3
 800f610:	687b      	ldr	r3, [r7, #4]
 800f612:	609a      	str	r2, [r3, #8]

  /* Get PCLK2 prescaler */
  tmp = RCC->CFGR & RCC_CFGR_PPRE2;
 800f614:	4b0c      	ldr	r3, [pc, #48]	; (800f648 <RCC_GetClocksFreq+0x140>)
 800f616:	689b      	ldr	r3, [r3, #8]
 800f618:	f403 4360 	and.w	r3, r3, #57344	; 0xe000
 800f61c:	61bb      	str	r3, [r7, #24]
  tmp = tmp >> 13;
 800f61e:	69bb      	ldr	r3, [r7, #24]
 800f620:	0b5b      	lsrs	r3, r3, #13
 800f622:	61bb      	str	r3, [r7, #24]
  presc = APBAHBPrescTable[tmp];
 800f624:	4a0b      	ldr	r2, [pc, #44]	; (800f654 <RCC_GetClocksFreq+0x14c>)
 800f626:	69bb      	ldr	r3, [r7, #24]
 800f628:	4413      	add	r3, r2
 800f62a:	781b      	ldrb	r3, [r3, #0]
 800f62c:	b2db      	uxtb	r3, r3
 800f62e:	617b      	str	r3, [r7, #20]
  /* PCLK2 clock frequency */
  RCC_Clocks->PCLK2_Frequency = RCC_Clocks->HCLK_Frequency >> presc;
 800f630:	687b      	ldr	r3, [r7, #4]
 800f632:	685a      	ldr	r2, [r3, #4]
 800f634:	697b      	ldr	r3, [r7, #20]
 800f636:	40da      	lsrs	r2, r3
 800f638:	687b      	ldr	r3, [r7, #4]
 800f63a:	60da      	str	r2, [r3, #12]
}
 800f63c:	bf00      	nop
 800f63e:	3724      	adds	r7, #36	; 0x24
 800f640:	46bd      	mov	sp, r7
 800f642:	f85d 7b04 	ldr.w	r7, [sp], #4
 800f646:	4770      	bx	lr
 800f648:	40023800 	.word	0x40023800
 800f64c:	00f42400 	.word	0x00f42400
 800f650:	017d7840 	.word	0x017d7840
 800f654:	20000004 	.word	0x20000004

0800f658 <RCC_RTCCLKConfig>:
  *         RTC clock source).
  *  
  * @retval None
  */
void RCC_RTCCLKConfig(uint32_t RCC_RTCCLKSource)
{
 800f658:	b480      	push	{r7}
 800f65a:	b085      	sub	sp, #20
 800f65c:	af00      	add	r7, sp, #0
 800f65e:	6078      	str	r0, [r7, #4]
  uint32_t tmpreg = 0;
 800f660:	2300      	movs	r3, #0
 800f662:	60fb      	str	r3, [r7, #12]

  /* Check the parameters */
  assert_param(IS_RCC_RTCCLK_SOURCE(RCC_RTCCLKSource));

  if ((RCC_RTCCLKSource & 0x00000300) == 0x00000300)
 800f664:	687b      	ldr	r3, [r7, #4]
 800f666:	f403 7340 	and.w	r3, r3, #768	; 0x300
 800f66a:	f5b3 7f40 	cmp.w	r3, #768	; 0x300
 800f66e:	d111      	bne.n	800f694 <RCC_RTCCLKConfig+0x3c>
  { /* If HSE is selected as RTC clock source, configure HSE division factor for RTC clock */
    tmpreg = RCC->CFGR;
 800f670:	4b0f      	ldr	r3, [pc, #60]	; (800f6b0 <RCC_RTCCLKConfig+0x58>)
 800f672:	689b      	ldr	r3, [r3, #8]
 800f674:	60fb      	str	r3, [r7, #12]

    /* Clear RTCPRE[4:0] bits */
    tmpreg &= ~RCC_CFGR_RTCPRE;
 800f676:	68fb      	ldr	r3, [r7, #12]
 800f678:	f423 13f8 	bic.w	r3, r3, #2031616	; 0x1f0000
 800f67c:	60fb      	str	r3, [r7, #12]

    /* Configure HSE division factor for RTC clock */
    tmpreg |= (RCC_RTCCLKSource & 0xFFFFCFF);
 800f67e:	687b      	ldr	r3, [r7, #4]
 800f680:	f023 4370 	bic.w	r3, r3, #4026531840	; 0xf0000000
 800f684:	f423 7340 	bic.w	r3, r3, #768	; 0x300
 800f688:	68fa      	ldr	r2, [r7, #12]
 800f68a:	4313      	orrs	r3, r2
 800f68c:	60fb      	str	r3, [r7, #12]

    /* Store the new value */
    RCC->CFGR = tmpreg;
 800f68e:	4a08      	ldr	r2, [pc, #32]	; (800f6b0 <RCC_RTCCLKConfig+0x58>)
 800f690:	68fb      	ldr	r3, [r7, #12]
 800f692:	6093      	str	r3, [r2, #8]
  }
    
  /* Select the RTC clock source */
  RCC->BDCR |= (RCC_RTCCLKSource & 0x00000FFF);
 800f694:	4906      	ldr	r1, [pc, #24]	; (800f6b0 <RCC_RTCCLKConfig+0x58>)
 800f696:	4b06      	ldr	r3, [pc, #24]	; (800f6b0 <RCC_RTCCLKConfig+0x58>)
 800f698:	6f1a      	ldr	r2, [r3, #112]	; 0x70
 800f69a:	687b      	ldr	r3, [r7, #4]
 800f69c:	f3c3 030b 	ubfx	r3, r3, #0, #12
 800f6a0:	4313      	orrs	r3, r2
 800f6a2:	670b      	str	r3, [r1, #112]	; 0x70
}
 800f6a4:	bf00      	nop
 800f6a6:	3714      	adds	r7, #20
 800f6a8:	46bd      	mov	sp, r7
 800f6aa:	f85d 7b04 	ldr.w	r7, [sp], #4
 800f6ae:	4770      	bx	lr
 800f6b0:	40023800 	.word	0x40023800

0800f6b4 <RCC_RTCCLKCmd>:
  *         using the RCC_RTCCLKConfig function.
  * @param  NewState: new state of the RTC clock. This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void RCC_RTCCLKCmd(FunctionalState NewState)
{
 800f6b4:	b480      	push	{r7}
 800f6b6:	b083      	sub	sp, #12
 800f6b8:	af00      	add	r7, sp, #0
 800f6ba:	4603      	mov	r3, r0
 800f6bc:	71fb      	strb	r3, [r7, #7]
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  *(__IO uint32_t *) BDCR_RTCEN_BB = (uint32_t)NewState;
 800f6be:	4a04      	ldr	r2, [pc, #16]	; (800f6d0 <RCC_RTCCLKCmd+0x1c>)
 800f6c0:	79fb      	ldrb	r3, [r7, #7]
 800f6c2:	6013      	str	r3, [r2, #0]
}
 800f6c4:	bf00      	nop
 800f6c6:	370c      	adds	r7, #12
 800f6c8:	46bd      	mov	sp, r7
 800f6ca:	f85d 7b04 	ldr.w	r7, [sp], #4
 800f6ce:	4770      	bx	lr
 800f6d0:	42470e3c 	.word	0x42470e3c

0800f6d4 <RCC_BackupResetCmd>:
  * @param  NewState: new state of the Backup domain reset.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void RCC_BackupResetCmd(FunctionalState NewState)
{
 800f6d4:	b480      	push	{r7}
 800f6d6:	b083      	sub	sp, #12
 800f6d8:	af00      	add	r7, sp, #0
 800f6da:	4603      	mov	r3, r0
 800f6dc:	71fb      	strb	r3, [r7, #7]
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  *(__IO uint32_t *) BDCR_BDRST_BB = (uint32_t)NewState;
 800f6de:	4a04      	ldr	r2, [pc, #16]	; (800f6f0 <RCC_BackupResetCmd+0x1c>)
 800f6e0:	79fb      	ldrb	r3, [r7, #7]
 800f6e2:	6013      	str	r3, [r2, #0]
}
 800f6e4:	bf00      	nop
 800f6e6:	370c      	adds	r7, #12
 800f6e8:	46bd      	mov	sp, r7
 800f6ea:	f85d 7b04 	ldr.w	r7, [sp], #4
 800f6ee:	4770      	bx	lr
 800f6f0:	42470e40 	.word	0x42470e40

0800f6f4 <RCC_I2SCLKConfig>:
  *            @arg RCC_I2S2CLKSource_Ext: External clock mapped on the I2S_CKIN pin
  *                                        used as I2S clock source
  * @retval None
  */
void RCC_I2SCLKConfig(uint32_t RCC_I2SCLKSource)
{
 800f6f4:	b480      	push	{r7}
 800f6f6:	b083      	sub	sp, #12
 800f6f8:	af00      	add	r7, sp, #0
 800f6fa:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_RCC_I2SCLK_SOURCE(RCC_I2SCLKSource));

  *(__IO uint32_t *) CFGR_I2SSRC_BB = RCC_I2SCLKSource;
 800f6fc:	4a04      	ldr	r2, [pc, #16]	; (800f710 <RCC_I2SCLKConfig+0x1c>)
 800f6fe:	687b      	ldr	r3, [r7, #4]
 800f700:	6013      	str	r3, [r2, #0]
}
 800f702:	bf00      	nop
 800f704:	370c      	adds	r7, #12
 800f706:	46bd      	mov	sp, r7
 800f708:	f85d 7b04 	ldr.w	r7, [sp], #4
 800f70c:	4770      	bx	lr
 800f70e:	bf00      	nop
 800f710:	4247015c 	.word	0x4247015c

0800f714 <RCC_AHB1PeriphClockCmd>:
  * @param  NewState: new state of the specified peripheral clock.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void RCC_AHB1PeriphClockCmd(uint32_t RCC_AHB1Periph, FunctionalState NewState)
{
 800f714:	b480      	push	{r7}
 800f716:	b083      	sub	sp, #12
 800f718:	af00      	add	r7, sp, #0
 800f71a:	6078      	str	r0, [r7, #4]
 800f71c:	460b      	mov	r3, r1
 800f71e:	70fb      	strb	r3, [r7, #3]
  /* Check the parameters */
  assert_param(IS_RCC_AHB1_CLOCK_PERIPH(RCC_AHB1Periph));

  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 800f720:	78fb      	ldrb	r3, [r7, #3]
 800f722:	2b00      	cmp	r3, #0
 800f724:	d006      	beq.n	800f734 <RCC_AHB1PeriphClockCmd+0x20>
  {
    RCC->AHB1ENR |= RCC_AHB1Periph;
 800f726:	490a      	ldr	r1, [pc, #40]	; (800f750 <RCC_AHB1PeriphClockCmd+0x3c>)
 800f728:	4b09      	ldr	r3, [pc, #36]	; (800f750 <RCC_AHB1PeriphClockCmd+0x3c>)
 800f72a:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 800f72c:	687b      	ldr	r3, [r7, #4]
 800f72e:	4313      	orrs	r3, r2
 800f730:	630b      	str	r3, [r1, #48]	; 0x30
  }
  else
  {
    RCC->AHB1ENR &= ~RCC_AHB1Periph;
  }
}
 800f732:	e006      	b.n	800f742 <RCC_AHB1PeriphClockCmd+0x2e>
    RCC->AHB1ENR &= ~RCC_AHB1Periph;
 800f734:	4906      	ldr	r1, [pc, #24]	; (800f750 <RCC_AHB1PeriphClockCmd+0x3c>)
 800f736:	4b06      	ldr	r3, [pc, #24]	; (800f750 <RCC_AHB1PeriphClockCmd+0x3c>)
 800f738:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 800f73a:	687b      	ldr	r3, [r7, #4]
 800f73c:	43db      	mvns	r3, r3
 800f73e:	4013      	ands	r3, r2
 800f740:	630b      	str	r3, [r1, #48]	; 0x30
}
 800f742:	bf00      	nop
 800f744:	370c      	adds	r7, #12
 800f746:	46bd      	mov	sp, r7
 800f748:	f85d 7b04 	ldr.w	r7, [sp], #4
 800f74c:	4770      	bx	lr
 800f74e:	bf00      	nop
 800f750:	40023800 	.word	0x40023800

0800f754 <RCC_AHB2PeriphClockCmd>:
  * @param  NewState: new state of the specified peripheral clock.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void RCC_AHB2PeriphClockCmd(uint32_t RCC_AHB2Periph, FunctionalState NewState)
{
 800f754:	b480      	push	{r7}
 800f756:	b083      	sub	sp, #12
 800f758:	af00      	add	r7, sp, #0
 800f75a:	6078      	str	r0, [r7, #4]
 800f75c:	460b      	mov	r3, r1
 800f75e:	70fb      	strb	r3, [r7, #3]
  /* Check the parameters */
  assert_param(IS_RCC_AHB2_PERIPH(RCC_AHB2Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 800f760:	78fb      	ldrb	r3, [r7, #3]
 800f762:	2b00      	cmp	r3, #0
 800f764:	d006      	beq.n	800f774 <RCC_AHB2PeriphClockCmd+0x20>
  {
    RCC->AHB2ENR |= RCC_AHB2Periph;
 800f766:	490a      	ldr	r1, [pc, #40]	; (800f790 <RCC_AHB2PeriphClockCmd+0x3c>)
 800f768:	4b09      	ldr	r3, [pc, #36]	; (800f790 <RCC_AHB2PeriphClockCmd+0x3c>)
 800f76a:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 800f76c:	687b      	ldr	r3, [r7, #4]
 800f76e:	4313      	orrs	r3, r2
 800f770:	634b      	str	r3, [r1, #52]	; 0x34
  }
  else
  {
    RCC->AHB2ENR &= ~RCC_AHB2Periph;
  }
}
 800f772:	e006      	b.n	800f782 <RCC_AHB2PeriphClockCmd+0x2e>
    RCC->AHB2ENR &= ~RCC_AHB2Periph;
 800f774:	4906      	ldr	r1, [pc, #24]	; (800f790 <RCC_AHB2PeriphClockCmd+0x3c>)
 800f776:	4b06      	ldr	r3, [pc, #24]	; (800f790 <RCC_AHB2PeriphClockCmd+0x3c>)
 800f778:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 800f77a:	687b      	ldr	r3, [r7, #4]
 800f77c:	43db      	mvns	r3, r3
 800f77e:	4013      	ands	r3, r2
 800f780:	634b      	str	r3, [r1, #52]	; 0x34
}
 800f782:	bf00      	nop
 800f784:	370c      	adds	r7, #12
 800f786:	46bd      	mov	sp, r7
 800f788:	f85d 7b04 	ldr.w	r7, [sp], #4
 800f78c:	4770      	bx	lr
 800f78e:	bf00      	nop
 800f790:	40023800 	.word	0x40023800

0800f794 <RCC_AHB3PeriphClockCmd>:
  * @param  NewState: new state of the specified peripheral clock.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void RCC_AHB3PeriphClockCmd(uint32_t RCC_AHB3Periph, FunctionalState NewState)
{
 800f794:	b480      	push	{r7}
 800f796:	b083      	sub	sp, #12
 800f798:	af00      	add	r7, sp, #0
 800f79a:	6078      	str	r0, [r7, #4]
 800f79c:	460b      	mov	r3, r1
 800f79e:	70fb      	strb	r3, [r7, #3]
  /* Check the parameters */
  assert_param(IS_RCC_AHB3_PERIPH(RCC_AHB3Periph));  
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 800f7a0:	78fb      	ldrb	r3, [r7, #3]
 800f7a2:	2b00      	cmp	r3, #0
 800f7a4:	d006      	beq.n	800f7b4 <RCC_AHB3PeriphClockCmd+0x20>
  {
    RCC->AHB3ENR |= RCC_AHB3Periph;
 800f7a6:	490a      	ldr	r1, [pc, #40]	; (800f7d0 <RCC_AHB3PeriphClockCmd+0x3c>)
 800f7a8:	4b09      	ldr	r3, [pc, #36]	; (800f7d0 <RCC_AHB3PeriphClockCmd+0x3c>)
 800f7aa:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 800f7ac:	687b      	ldr	r3, [r7, #4]
 800f7ae:	4313      	orrs	r3, r2
 800f7b0:	638b      	str	r3, [r1, #56]	; 0x38
  }
  else
  {
    RCC->AHB3ENR &= ~RCC_AHB3Periph;
  }
}
 800f7b2:	e006      	b.n	800f7c2 <RCC_AHB3PeriphClockCmd+0x2e>
    RCC->AHB3ENR &= ~RCC_AHB3Periph;
 800f7b4:	4906      	ldr	r1, [pc, #24]	; (800f7d0 <RCC_AHB3PeriphClockCmd+0x3c>)
 800f7b6:	4b06      	ldr	r3, [pc, #24]	; (800f7d0 <RCC_AHB3PeriphClockCmd+0x3c>)
 800f7b8:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 800f7ba:	687b      	ldr	r3, [r7, #4]
 800f7bc:	43db      	mvns	r3, r3
 800f7be:	4013      	ands	r3, r2
 800f7c0:	638b      	str	r3, [r1, #56]	; 0x38
}
 800f7c2:	bf00      	nop
 800f7c4:	370c      	adds	r7, #12
 800f7c6:	46bd      	mov	sp, r7
 800f7c8:	f85d 7b04 	ldr.w	r7, [sp], #4
 800f7cc:	4770      	bx	lr
 800f7ce:	bf00      	nop
 800f7d0:	40023800 	.word	0x40023800

0800f7d4 <RCC_APB1PeriphClockCmd>:
  * @param  NewState: new state of the specified peripheral clock.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void RCC_APB1PeriphClockCmd(uint32_t RCC_APB1Periph, FunctionalState NewState)
{
 800f7d4:	b480      	push	{r7}
 800f7d6:	b083      	sub	sp, #12
 800f7d8:	af00      	add	r7, sp, #0
 800f7da:	6078      	str	r0, [r7, #4]
 800f7dc:	460b      	mov	r3, r1
 800f7de:	70fb      	strb	r3, [r7, #3]
  /* Check the parameters */
  assert_param(IS_RCC_APB1_PERIPH(RCC_APB1Periph));  
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 800f7e0:	78fb      	ldrb	r3, [r7, #3]
 800f7e2:	2b00      	cmp	r3, #0
 800f7e4:	d006      	beq.n	800f7f4 <RCC_APB1PeriphClockCmd+0x20>
  {
    RCC->APB1ENR |= RCC_APB1Periph;
 800f7e6:	490a      	ldr	r1, [pc, #40]	; (800f810 <RCC_APB1PeriphClockCmd+0x3c>)
 800f7e8:	4b09      	ldr	r3, [pc, #36]	; (800f810 <RCC_APB1PeriphClockCmd+0x3c>)
 800f7ea:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 800f7ec:	687b      	ldr	r3, [r7, #4]
 800f7ee:	4313      	orrs	r3, r2
 800f7f0:	640b      	str	r3, [r1, #64]	; 0x40
  }
  else
  {
    RCC->APB1ENR &= ~RCC_APB1Periph;
  }
}
 800f7f2:	e006      	b.n	800f802 <RCC_APB1PeriphClockCmd+0x2e>
    RCC->APB1ENR &= ~RCC_APB1Periph;
 800f7f4:	4906      	ldr	r1, [pc, #24]	; (800f810 <RCC_APB1PeriphClockCmd+0x3c>)
 800f7f6:	4b06      	ldr	r3, [pc, #24]	; (800f810 <RCC_APB1PeriphClockCmd+0x3c>)
 800f7f8:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 800f7fa:	687b      	ldr	r3, [r7, #4]
 800f7fc:	43db      	mvns	r3, r3
 800f7fe:	4013      	ands	r3, r2
 800f800:	640b      	str	r3, [r1, #64]	; 0x40
}
 800f802:	bf00      	nop
 800f804:	370c      	adds	r7, #12
 800f806:	46bd      	mov	sp, r7
 800f808:	f85d 7b04 	ldr.w	r7, [sp], #4
 800f80c:	4770      	bx	lr
 800f80e:	bf00      	nop
 800f810:	40023800 	.word	0x40023800

0800f814 <RCC_APB2PeriphClockCmd>:
  * @param  NewState: new state of the specified peripheral clock.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void RCC_APB2PeriphClockCmd(uint32_t RCC_APB2Periph, FunctionalState NewState)
{
 800f814:	b480      	push	{r7}
 800f816:	b083      	sub	sp, #12
 800f818:	af00      	add	r7, sp, #0
 800f81a:	6078      	str	r0, [r7, #4]
 800f81c:	460b      	mov	r3, r1
 800f81e:	70fb      	strb	r3, [r7, #3]
  /* Check the parameters */
  assert_param(IS_RCC_APB2_PERIPH(RCC_APB2Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 800f820:	78fb      	ldrb	r3, [r7, #3]
 800f822:	2b00      	cmp	r3, #0
 800f824:	d006      	beq.n	800f834 <RCC_APB2PeriphClockCmd+0x20>
  {
    RCC->APB2ENR |= RCC_APB2Periph;
 800f826:	490a      	ldr	r1, [pc, #40]	; (800f850 <RCC_APB2PeriphClockCmd+0x3c>)
 800f828:	4b09      	ldr	r3, [pc, #36]	; (800f850 <RCC_APB2PeriphClockCmd+0x3c>)
 800f82a:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 800f82c:	687b      	ldr	r3, [r7, #4]
 800f82e:	4313      	orrs	r3, r2
 800f830:	644b      	str	r3, [r1, #68]	; 0x44
  }
  else
  {
    RCC->APB2ENR &= ~RCC_APB2Periph;
  }
}
 800f832:	e006      	b.n	800f842 <RCC_APB2PeriphClockCmd+0x2e>
    RCC->APB2ENR &= ~RCC_APB2Periph;
 800f834:	4906      	ldr	r1, [pc, #24]	; (800f850 <RCC_APB2PeriphClockCmd+0x3c>)
 800f836:	4b06      	ldr	r3, [pc, #24]	; (800f850 <RCC_APB2PeriphClockCmd+0x3c>)
 800f838:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 800f83a:	687b      	ldr	r3, [r7, #4]
 800f83c:	43db      	mvns	r3, r3
 800f83e:	4013      	ands	r3, r2
 800f840:	644b      	str	r3, [r1, #68]	; 0x44
}
 800f842:	bf00      	nop
 800f844:	370c      	adds	r7, #12
 800f846:	46bd      	mov	sp, r7
 800f848:	f85d 7b04 	ldr.w	r7, [sp], #4
 800f84c:	4770      	bx	lr
 800f84e:	bf00      	nop
 800f850:	40023800 	.word	0x40023800

0800f854 <RCC_AHB1PeriphResetCmd>:
  * @param  NewState: new state of the specified peripheral reset.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void RCC_AHB1PeriphResetCmd(uint32_t RCC_AHB1Periph, FunctionalState NewState)
{
 800f854:	b480      	push	{r7}
 800f856:	b083      	sub	sp, #12
 800f858:	af00      	add	r7, sp, #0
 800f85a:	6078      	str	r0, [r7, #4]
 800f85c:	460b      	mov	r3, r1
 800f85e:	70fb      	strb	r3, [r7, #3]
  /* Check the parameters */
  assert_param(IS_RCC_AHB1_RESET_PERIPH(RCC_AHB1Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 800f860:	78fb      	ldrb	r3, [r7, #3]
 800f862:	2b00      	cmp	r3, #0
 800f864:	d006      	beq.n	800f874 <RCC_AHB1PeriphResetCmd+0x20>
  {
    RCC->AHB1RSTR |= RCC_AHB1Periph;
 800f866:	490a      	ldr	r1, [pc, #40]	; (800f890 <RCC_AHB1PeriphResetCmd+0x3c>)
 800f868:	4b09      	ldr	r3, [pc, #36]	; (800f890 <RCC_AHB1PeriphResetCmd+0x3c>)
 800f86a:	691a      	ldr	r2, [r3, #16]
 800f86c:	687b      	ldr	r3, [r7, #4]
 800f86e:	4313      	orrs	r3, r2
 800f870:	610b      	str	r3, [r1, #16]
  }
  else
  {
    RCC->AHB1RSTR &= ~RCC_AHB1Periph;
  }
}
 800f872:	e006      	b.n	800f882 <RCC_AHB1PeriphResetCmd+0x2e>
    RCC->AHB1RSTR &= ~RCC_AHB1Periph;
 800f874:	4906      	ldr	r1, [pc, #24]	; (800f890 <RCC_AHB1PeriphResetCmd+0x3c>)
 800f876:	4b06      	ldr	r3, [pc, #24]	; (800f890 <RCC_AHB1PeriphResetCmd+0x3c>)
 800f878:	691a      	ldr	r2, [r3, #16]
 800f87a:	687b      	ldr	r3, [r7, #4]
 800f87c:	43db      	mvns	r3, r3
 800f87e:	4013      	ands	r3, r2
 800f880:	610b      	str	r3, [r1, #16]
}
 800f882:	bf00      	nop
 800f884:	370c      	adds	r7, #12
 800f886:	46bd      	mov	sp, r7
 800f888:	f85d 7b04 	ldr.w	r7, [sp], #4
 800f88c:	4770      	bx	lr
 800f88e:	bf00      	nop
 800f890:	40023800 	.word	0x40023800

0800f894 <RCC_AHB2PeriphResetCmd>:
  * @param  NewState: new state of the specified peripheral reset.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void RCC_AHB2PeriphResetCmd(uint32_t RCC_AHB2Periph, FunctionalState NewState)
{
 800f894:	b480      	push	{r7}
 800f896:	b083      	sub	sp, #12
 800f898:	af00      	add	r7, sp, #0
 800f89a:	6078      	str	r0, [r7, #4]
 800f89c:	460b      	mov	r3, r1
 800f89e:	70fb      	strb	r3, [r7, #3]
  /* Check the parameters */
  assert_param(IS_RCC_AHB2_PERIPH(RCC_AHB2Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 800f8a0:	78fb      	ldrb	r3, [r7, #3]
 800f8a2:	2b00      	cmp	r3, #0
 800f8a4:	d006      	beq.n	800f8b4 <RCC_AHB2PeriphResetCmd+0x20>
  {
    RCC->AHB2RSTR |= RCC_AHB2Periph;
 800f8a6:	490a      	ldr	r1, [pc, #40]	; (800f8d0 <RCC_AHB2PeriphResetCmd+0x3c>)
 800f8a8:	4b09      	ldr	r3, [pc, #36]	; (800f8d0 <RCC_AHB2PeriphResetCmd+0x3c>)
 800f8aa:	695a      	ldr	r2, [r3, #20]
 800f8ac:	687b      	ldr	r3, [r7, #4]
 800f8ae:	4313      	orrs	r3, r2
 800f8b0:	614b      	str	r3, [r1, #20]
  }
  else
  {
    RCC->AHB2RSTR &= ~RCC_AHB2Periph;
  }
}
 800f8b2:	e006      	b.n	800f8c2 <RCC_AHB2PeriphResetCmd+0x2e>
    RCC->AHB2RSTR &= ~RCC_AHB2Periph;
 800f8b4:	4906      	ldr	r1, [pc, #24]	; (800f8d0 <RCC_AHB2PeriphResetCmd+0x3c>)
 800f8b6:	4b06      	ldr	r3, [pc, #24]	; (800f8d0 <RCC_AHB2PeriphResetCmd+0x3c>)
 800f8b8:	695a      	ldr	r2, [r3, #20]
 800f8ba:	687b      	ldr	r3, [r7, #4]
 800f8bc:	43db      	mvns	r3, r3
 800f8be:	4013      	ands	r3, r2
 800f8c0:	614b      	str	r3, [r1, #20]
}
 800f8c2:	bf00      	nop
 800f8c4:	370c      	adds	r7, #12
 800f8c6:	46bd      	mov	sp, r7
 800f8c8:	f85d 7b04 	ldr.w	r7, [sp], #4
 800f8cc:	4770      	bx	lr
 800f8ce:	bf00      	nop
 800f8d0:	40023800 	.word	0x40023800

0800f8d4 <RCC_AHB3PeriphResetCmd>:
  * @param  NewState: new state of the specified peripheral reset.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void RCC_AHB3PeriphResetCmd(uint32_t RCC_AHB3Periph, FunctionalState NewState)
{
 800f8d4:	b480      	push	{r7}
 800f8d6:	b083      	sub	sp, #12
 800f8d8:	af00      	add	r7, sp, #0
 800f8da:	6078      	str	r0, [r7, #4]
 800f8dc:	460b      	mov	r3, r1
 800f8de:	70fb      	strb	r3, [r7, #3]
  /* Check the parameters */
  assert_param(IS_RCC_AHB3_PERIPH(RCC_AHB3Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 800f8e0:	78fb      	ldrb	r3, [r7, #3]
 800f8e2:	2b00      	cmp	r3, #0
 800f8e4:	d006      	beq.n	800f8f4 <RCC_AHB3PeriphResetCmd+0x20>
  {
    RCC->AHB3RSTR |= RCC_AHB3Periph;
 800f8e6:	490a      	ldr	r1, [pc, #40]	; (800f910 <RCC_AHB3PeriphResetCmd+0x3c>)
 800f8e8:	4b09      	ldr	r3, [pc, #36]	; (800f910 <RCC_AHB3PeriphResetCmd+0x3c>)
 800f8ea:	699a      	ldr	r2, [r3, #24]
 800f8ec:	687b      	ldr	r3, [r7, #4]
 800f8ee:	4313      	orrs	r3, r2
 800f8f0:	618b      	str	r3, [r1, #24]
  }
  else
  {
    RCC->AHB3RSTR &= ~RCC_AHB3Periph;
  }
}
 800f8f2:	e006      	b.n	800f902 <RCC_AHB3PeriphResetCmd+0x2e>
    RCC->AHB3RSTR &= ~RCC_AHB3Periph;
 800f8f4:	4906      	ldr	r1, [pc, #24]	; (800f910 <RCC_AHB3PeriphResetCmd+0x3c>)
 800f8f6:	4b06      	ldr	r3, [pc, #24]	; (800f910 <RCC_AHB3PeriphResetCmd+0x3c>)
 800f8f8:	699a      	ldr	r2, [r3, #24]
 800f8fa:	687b      	ldr	r3, [r7, #4]
 800f8fc:	43db      	mvns	r3, r3
 800f8fe:	4013      	ands	r3, r2
 800f900:	618b      	str	r3, [r1, #24]
}
 800f902:	bf00      	nop
 800f904:	370c      	adds	r7, #12
 800f906:	46bd      	mov	sp, r7
 800f908:	f85d 7b04 	ldr.w	r7, [sp], #4
 800f90c:	4770      	bx	lr
 800f90e:	bf00      	nop
 800f910:	40023800 	.word	0x40023800

0800f914 <RCC_APB1PeriphResetCmd>:
  * @param  NewState: new state of the specified peripheral reset.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void RCC_APB1PeriphResetCmd(uint32_t RCC_APB1Periph, FunctionalState NewState)
{
 800f914:	b480      	push	{r7}
 800f916:	b083      	sub	sp, #12
 800f918:	af00      	add	r7, sp, #0
 800f91a:	6078      	str	r0, [r7, #4]
 800f91c:	460b      	mov	r3, r1
 800f91e:	70fb      	strb	r3, [r7, #3]
  /* Check the parameters */
  assert_param(IS_RCC_APB1_PERIPH(RCC_APB1Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 800f920:	78fb      	ldrb	r3, [r7, #3]
 800f922:	2b00      	cmp	r3, #0
 800f924:	d006      	beq.n	800f934 <RCC_APB1PeriphResetCmd+0x20>
  {
    RCC->APB1RSTR |= RCC_APB1Periph;
 800f926:	490a      	ldr	r1, [pc, #40]	; (800f950 <RCC_APB1PeriphResetCmd+0x3c>)
 800f928:	4b09      	ldr	r3, [pc, #36]	; (800f950 <RCC_APB1PeriphResetCmd+0x3c>)
 800f92a:	6a1a      	ldr	r2, [r3, #32]
 800f92c:	687b      	ldr	r3, [r7, #4]
 800f92e:	4313      	orrs	r3, r2
 800f930:	620b      	str	r3, [r1, #32]
  }
  else
  {
    RCC->APB1RSTR &= ~RCC_APB1Periph;
  }
}
 800f932:	e006      	b.n	800f942 <RCC_APB1PeriphResetCmd+0x2e>
    RCC->APB1RSTR &= ~RCC_APB1Periph;
 800f934:	4906      	ldr	r1, [pc, #24]	; (800f950 <RCC_APB1PeriphResetCmd+0x3c>)
 800f936:	4b06      	ldr	r3, [pc, #24]	; (800f950 <RCC_APB1PeriphResetCmd+0x3c>)
 800f938:	6a1a      	ldr	r2, [r3, #32]
 800f93a:	687b      	ldr	r3, [r7, #4]
 800f93c:	43db      	mvns	r3, r3
 800f93e:	4013      	ands	r3, r2
 800f940:	620b      	str	r3, [r1, #32]
}
 800f942:	bf00      	nop
 800f944:	370c      	adds	r7, #12
 800f946:	46bd      	mov	sp, r7
 800f948:	f85d 7b04 	ldr.w	r7, [sp], #4
 800f94c:	4770      	bx	lr
 800f94e:	bf00      	nop
 800f950:	40023800 	.word	0x40023800

0800f954 <RCC_APB2PeriphResetCmd>:
  * @param  NewState: new state of the specified peripheral reset.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void RCC_APB2PeriphResetCmd(uint32_t RCC_APB2Periph, FunctionalState NewState)
{
 800f954:	b480      	push	{r7}
 800f956:	b083      	sub	sp, #12
 800f958:	af00      	add	r7, sp, #0
 800f95a:	6078      	str	r0, [r7, #4]
 800f95c:	460b      	mov	r3, r1
 800f95e:	70fb      	strb	r3, [r7, #3]
  /* Check the parameters */
  assert_param(IS_RCC_APB2_RESET_PERIPH(RCC_APB2Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 800f960:	78fb      	ldrb	r3, [r7, #3]
 800f962:	2b00      	cmp	r3, #0
 800f964:	d006      	beq.n	800f974 <RCC_APB2PeriphResetCmd+0x20>
  {
    RCC->APB2RSTR |= RCC_APB2Periph;
 800f966:	490a      	ldr	r1, [pc, #40]	; (800f990 <RCC_APB2PeriphResetCmd+0x3c>)
 800f968:	4b09      	ldr	r3, [pc, #36]	; (800f990 <RCC_APB2PeriphResetCmd+0x3c>)
 800f96a:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 800f96c:	687b      	ldr	r3, [r7, #4]
 800f96e:	4313      	orrs	r3, r2
 800f970:	624b      	str	r3, [r1, #36]	; 0x24
  }
  else
  {
    RCC->APB2RSTR &= ~RCC_APB2Periph;
  }
}
 800f972:	e006      	b.n	800f982 <RCC_APB2PeriphResetCmd+0x2e>
    RCC->APB2RSTR &= ~RCC_APB2Periph;
 800f974:	4906      	ldr	r1, [pc, #24]	; (800f990 <RCC_APB2PeriphResetCmd+0x3c>)
 800f976:	4b06      	ldr	r3, [pc, #24]	; (800f990 <RCC_APB2PeriphResetCmd+0x3c>)
 800f978:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 800f97a:	687b      	ldr	r3, [r7, #4]
 800f97c:	43db      	mvns	r3, r3
 800f97e:	4013      	ands	r3, r2
 800f980:	624b      	str	r3, [r1, #36]	; 0x24
}
 800f982:	bf00      	nop
 800f984:	370c      	adds	r7, #12
 800f986:	46bd      	mov	sp, r7
 800f988:	f85d 7b04 	ldr.w	r7, [sp], #4
 800f98c:	4770      	bx	lr
 800f98e:	bf00      	nop
 800f990:	40023800 	.word	0x40023800

0800f994 <RCC_AHB1PeriphClockLPModeCmd>:
  * @param  NewState: new state of the specified peripheral clock.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void RCC_AHB1PeriphClockLPModeCmd(uint32_t RCC_AHB1Periph, FunctionalState NewState)
{
 800f994:	b480      	push	{r7}
 800f996:	b083      	sub	sp, #12
 800f998:	af00      	add	r7, sp, #0
 800f99a:	6078      	str	r0, [r7, #4]
 800f99c:	460b      	mov	r3, r1
 800f99e:	70fb      	strb	r3, [r7, #3]
  /* Check the parameters */
  assert_param(IS_RCC_AHB1_LPMODE_PERIPH(RCC_AHB1Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 800f9a0:	78fb      	ldrb	r3, [r7, #3]
 800f9a2:	2b00      	cmp	r3, #0
 800f9a4:	d006      	beq.n	800f9b4 <RCC_AHB1PeriphClockLPModeCmd+0x20>
  {
    RCC->AHB1LPENR |= RCC_AHB1Periph;
 800f9a6:	490a      	ldr	r1, [pc, #40]	; (800f9d0 <RCC_AHB1PeriphClockLPModeCmd+0x3c>)
 800f9a8:	4b09      	ldr	r3, [pc, #36]	; (800f9d0 <RCC_AHB1PeriphClockLPModeCmd+0x3c>)
 800f9aa:	6d1a      	ldr	r2, [r3, #80]	; 0x50
 800f9ac:	687b      	ldr	r3, [r7, #4]
 800f9ae:	4313      	orrs	r3, r2
 800f9b0:	650b      	str	r3, [r1, #80]	; 0x50
  }
  else
  {
    RCC->AHB1LPENR &= ~RCC_AHB1Periph;
  }
}
 800f9b2:	e006      	b.n	800f9c2 <RCC_AHB1PeriphClockLPModeCmd+0x2e>
    RCC->AHB1LPENR &= ~RCC_AHB1Periph;
 800f9b4:	4906      	ldr	r1, [pc, #24]	; (800f9d0 <RCC_AHB1PeriphClockLPModeCmd+0x3c>)
 800f9b6:	4b06      	ldr	r3, [pc, #24]	; (800f9d0 <RCC_AHB1PeriphClockLPModeCmd+0x3c>)
 800f9b8:	6d1a      	ldr	r2, [r3, #80]	; 0x50
 800f9ba:	687b      	ldr	r3, [r7, #4]
 800f9bc:	43db      	mvns	r3, r3
 800f9be:	4013      	ands	r3, r2
 800f9c0:	650b      	str	r3, [r1, #80]	; 0x50
}
 800f9c2:	bf00      	nop
 800f9c4:	370c      	adds	r7, #12
 800f9c6:	46bd      	mov	sp, r7
 800f9c8:	f85d 7b04 	ldr.w	r7, [sp], #4
 800f9cc:	4770      	bx	lr
 800f9ce:	bf00      	nop
 800f9d0:	40023800 	.word	0x40023800

0800f9d4 <RCC_AHB2PeriphClockLPModeCmd>:
  * @param  NewState: new state of the specified peripheral clock.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void RCC_AHB2PeriphClockLPModeCmd(uint32_t RCC_AHB2Periph, FunctionalState NewState)
{
 800f9d4:	b480      	push	{r7}
 800f9d6:	b083      	sub	sp, #12
 800f9d8:	af00      	add	r7, sp, #0
 800f9da:	6078      	str	r0, [r7, #4]
 800f9dc:	460b      	mov	r3, r1
 800f9de:	70fb      	strb	r3, [r7, #3]
  /* Check the parameters */
  assert_param(IS_RCC_AHB2_PERIPH(RCC_AHB2Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 800f9e0:	78fb      	ldrb	r3, [r7, #3]
 800f9e2:	2b00      	cmp	r3, #0
 800f9e4:	d006      	beq.n	800f9f4 <RCC_AHB2PeriphClockLPModeCmd+0x20>
  {
    RCC->AHB2LPENR |= RCC_AHB2Periph;
 800f9e6:	490a      	ldr	r1, [pc, #40]	; (800fa10 <RCC_AHB2PeriphClockLPModeCmd+0x3c>)
 800f9e8:	4b09      	ldr	r3, [pc, #36]	; (800fa10 <RCC_AHB2PeriphClockLPModeCmd+0x3c>)
 800f9ea:	6d5a      	ldr	r2, [r3, #84]	; 0x54
 800f9ec:	687b      	ldr	r3, [r7, #4]
 800f9ee:	4313      	orrs	r3, r2
 800f9f0:	654b      	str	r3, [r1, #84]	; 0x54
  }
  else
  {
    RCC->AHB2LPENR &= ~RCC_AHB2Periph;
  }
}
 800f9f2:	e006      	b.n	800fa02 <RCC_AHB2PeriphClockLPModeCmd+0x2e>
    RCC->AHB2LPENR &= ~RCC_AHB2Periph;
 800f9f4:	4906      	ldr	r1, [pc, #24]	; (800fa10 <RCC_AHB2PeriphClockLPModeCmd+0x3c>)
 800f9f6:	4b06      	ldr	r3, [pc, #24]	; (800fa10 <RCC_AHB2PeriphClockLPModeCmd+0x3c>)
 800f9f8:	6d5a      	ldr	r2, [r3, #84]	; 0x54
 800f9fa:	687b      	ldr	r3, [r7, #4]
 800f9fc:	43db      	mvns	r3, r3
 800f9fe:	4013      	ands	r3, r2
 800fa00:	654b      	str	r3, [r1, #84]	; 0x54
}
 800fa02:	bf00      	nop
 800fa04:	370c      	adds	r7, #12
 800fa06:	46bd      	mov	sp, r7
 800fa08:	f85d 7b04 	ldr.w	r7, [sp], #4
 800fa0c:	4770      	bx	lr
 800fa0e:	bf00      	nop
 800fa10:	40023800 	.word	0x40023800

0800fa14 <RCC_AHB3PeriphClockLPModeCmd>:
  * @param  NewState: new state of the specified peripheral clock.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void RCC_AHB3PeriphClockLPModeCmd(uint32_t RCC_AHB3Periph, FunctionalState NewState)
{
 800fa14:	b480      	push	{r7}
 800fa16:	b083      	sub	sp, #12
 800fa18:	af00      	add	r7, sp, #0
 800fa1a:	6078      	str	r0, [r7, #4]
 800fa1c:	460b      	mov	r3, r1
 800fa1e:	70fb      	strb	r3, [r7, #3]
  /* Check the parameters */
  assert_param(IS_RCC_AHB3_PERIPH(RCC_AHB3Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 800fa20:	78fb      	ldrb	r3, [r7, #3]
 800fa22:	2b00      	cmp	r3, #0
 800fa24:	d006      	beq.n	800fa34 <RCC_AHB3PeriphClockLPModeCmd+0x20>
  {
    RCC->AHB3LPENR |= RCC_AHB3Periph;
 800fa26:	490a      	ldr	r1, [pc, #40]	; (800fa50 <RCC_AHB3PeriphClockLPModeCmd+0x3c>)
 800fa28:	4b09      	ldr	r3, [pc, #36]	; (800fa50 <RCC_AHB3PeriphClockLPModeCmd+0x3c>)
 800fa2a:	6d9a      	ldr	r2, [r3, #88]	; 0x58
 800fa2c:	687b      	ldr	r3, [r7, #4]
 800fa2e:	4313      	orrs	r3, r2
 800fa30:	658b      	str	r3, [r1, #88]	; 0x58
  }
  else
  {
    RCC->AHB3LPENR &= ~RCC_AHB3Periph;
  }
}
 800fa32:	e006      	b.n	800fa42 <RCC_AHB3PeriphClockLPModeCmd+0x2e>
    RCC->AHB3LPENR &= ~RCC_AHB3Periph;
 800fa34:	4906      	ldr	r1, [pc, #24]	; (800fa50 <RCC_AHB3PeriphClockLPModeCmd+0x3c>)
 800fa36:	4b06      	ldr	r3, [pc, #24]	; (800fa50 <RCC_AHB3PeriphClockLPModeCmd+0x3c>)
 800fa38:	6d9a      	ldr	r2, [r3, #88]	; 0x58
 800fa3a:	687b      	ldr	r3, [r7, #4]
 800fa3c:	43db      	mvns	r3, r3
 800fa3e:	4013      	ands	r3, r2
 800fa40:	658b      	str	r3, [r1, #88]	; 0x58
}
 800fa42:	bf00      	nop
 800fa44:	370c      	adds	r7, #12
 800fa46:	46bd      	mov	sp, r7
 800fa48:	f85d 7b04 	ldr.w	r7, [sp], #4
 800fa4c:	4770      	bx	lr
 800fa4e:	bf00      	nop
 800fa50:	40023800 	.word	0x40023800

0800fa54 <RCC_APB1PeriphClockLPModeCmd>:
  * @param  NewState: new state of the specified peripheral clock.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void RCC_APB1PeriphClockLPModeCmd(uint32_t RCC_APB1Periph, FunctionalState NewState)
{
 800fa54:	b480      	push	{r7}
 800fa56:	b083      	sub	sp, #12
 800fa58:	af00      	add	r7, sp, #0
 800fa5a:	6078      	str	r0, [r7, #4]
 800fa5c:	460b      	mov	r3, r1
 800fa5e:	70fb      	strb	r3, [r7, #3]
  /* Check the parameters */
  assert_param(IS_RCC_APB1_PERIPH(RCC_APB1Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 800fa60:	78fb      	ldrb	r3, [r7, #3]
 800fa62:	2b00      	cmp	r3, #0
 800fa64:	d006      	beq.n	800fa74 <RCC_APB1PeriphClockLPModeCmd+0x20>
  {
    RCC->APB1LPENR |= RCC_APB1Periph;
 800fa66:	490a      	ldr	r1, [pc, #40]	; (800fa90 <RCC_APB1PeriphClockLPModeCmd+0x3c>)
 800fa68:	4b09      	ldr	r3, [pc, #36]	; (800fa90 <RCC_APB1PeriphClockLPModeCmd+0x3c>)
 800fa6a:	6e1a      	ldr	r2, [r3, #96]	; 0x60
 800fa6c:	687b      	ldr	r3, [r7, #4]
 800fa6e:	4313      	orrs	r3, r2
 800fa70:	660b      	str	r3, [r1, #96]	; 0x60
  }
  else
  {
    RCC->APB1LPENR &= ~RCC_APB1Periph;
  }
}
 800fa72:	e006      	b.n	800fa82 <RCC_APB1PeriphClockLPModeCmd+0x2e>
    RCC->APB1LPENR &= ~RCC_APB1Periph;
 800fa74:	4906      	ldr	r1, [pc, #24]	; (800fa90 <RCC_APB1PeriphClockLPModeCmd+0x3c>)
 800fa76:	4b06      	ldr	r3, [pc, #24]	; (800fa90 <RCC_APB1PeriphClockLPModeCmd+0x3c>)
 800fa78:	6e1a      	ldr	r2, [r3, #96]	; 0x60
 800fa7a:	687b      	ldr	r3, [r7, #4]
 800fa7c:	43db      	mvns	r3, r3
 800fa7e:	4013      	ands	r3, r2
 800fa80:	660b      	str	r3, [r1, #96]	; 0x60
}
 800fa82:	bf00      	nop
 800fa84:	370c      	adds	r7, #12
 800fa86:	46bd      	mov	sp, r7
 800fa88:	f85d 7b04 	ldr.w	r7, [sp], #4
 800fa8c:	4770      	bx	lr
 800fa8e:	bf00      	nop
 800fa90:	40023800 	.word	0x40023800

0800fa94 <RCC_APB2PeriphClockLPModeCmd>:
  * @param  NewState: new state of the specified peripheral clock.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void RCC_APB2PeriphClockLPModeCmd(uint32_t RCC_APB2Periph, FunctionalState NewState)
{
 800fa94:	b480      	push	{r7}
 800fa96:	b083      	sub	sp, #12
 800fa98:	af00      	add	r7, sp, #0
 800fa9a:	6078      	str	r0, [r7, #4]
 800fa9c:	460b      	mov	r3, r1
 800fa9e:	70fb      	strb	r3, [r7, #3]
  /* Check the parameters */
  assert_param(IS_RCC_APB2_PERIPH(RCC_APB2Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 800faa0:	78fb      	ldrb	r3, [r7, #3]
 800faa2:	2b00      	cmp	r3, #0
 800faa4:	d006      	beq.n	800fab4 <RCC_APB2PeriphClockLPModeCmd+0x20>
  {
    RCC->APB2LPENR |= RCC_APB2Periph;
 800faa6:	490a      	ldr	r1, [pc, #40]	; (800fad0 <RCC_APB2PeriphClockLPModeCmd+0x3c>)
 800faa8:	4b09      	ldr	r3, [pc, #36]	; (800fad0 <RCC_APB2PeriphClockLPModeCmd+0x3c>)
 800faaa:	6e5a      	ldr	r2, [r3, #100]	; 0x64
 800faac:	687b      	ldr	r3, [r7, #4]
 800faae:	4313      	orrs	r3, r2
 800fab0:	664b      	str	r3, [r1, #100]	; 0x64
  }
  else
  {
    RCC->APB2LPENR &= ~RCC_APB2Periph;
  }
}
 800fab2:	e006      	b.n	800fac2 <RCC_APB2PeriphClockLPModeCmd+0x2e>
    RCC->APB2LPENR &= ~RCC_APB2Periph;
 800fab4:	4906      	ldr	r1, [pc, #24]	; (800fad0 <RCC_APB2PeriphClockLPModeCmd+0x3c>)
 800fab6:	4b06      	ldr	r3, [pc, #24]	; (800fad0 <RCC_APB2PeriphClockLPModeCmd+0x3c>)
 800fab8:	6e5a      	ldr	r2, [r3, #100]	; 0x64
 800faba:	687b      	ldr	r3, [r7, #4]
 800fabc:	43db      	mvns	r3, r3
 800fabe:	4013      	ands	r3, r2
 800fac0:	664b      	str	r3, [r1, #100]	; 0x64
}
 800fac2:	bf00      	nop
 800fac4:	370c      	adds	r7, #12
 800fac6:	46bd      	mov	sp, r7
 800fac8:	f85d 7b04 	ldr.w	r7, [sp], #4
 800facc:	4770      	bx	lr
 800face:	bf00      	nop
 800fad0:	40023800 	.word	0x40023800

0800fad4 <RCC_ITConfig>:
  * @param  NewState: new state of the specified RCC interrupts.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void RCC_ITConfig(uint8_t RCC_IT, FunctionalState NewState)
{
 800fad4:	b480      	push	{r7}
 800fad6:	b083      	sub	sp, #12
 800fad8:	af00      	add	r7, sp, #0
 800fada:	4603      	mov	r3, r0
 800fadc:	460a      	mov	r2, r1
 800fade:	71fb      	strb	r3, [r7, #7]
 800fae0:	4613      	mov	r3, r2
 800fae2:	71bb      	strb	r3, [r7, #6]
  /* Check the parameters */
  assert_param(IS_RCC_IT(RCC_IT));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 800fae4:	79bb      	ldrb	r3, [r7, #6]
 800fae6:	2b00      	cmp	r3, #0
 800fae8:	d008      	beq.n	800fafc <RCC_ITConfig+0x28>
  {
    /* Perform Byte access to RCC_CIR[14:8] bits to enable the selected interrupts */
    *(__IO uint8_t *) CIR_BYTE2_ADDRESS |= RCC_IT;
 800faea:	490c      	ldr	r1, [pc, #48]	; (800fb1c <RCC_ITConfig+0x48>)
 800faec:	4b0b      	ldr	r3, [pc, #44]	; (800fb1c <RCC_ITConfig+0x48>)
 800faee:	781b      	ldrb	r3, [r3, #0]
 800faf0:	b2da      	uxtb	r2, r3
 800faf2:	79fb      	ldrb	r3, [r7, #7]
 800faf4:	4313      	orrs	r3, r2
 800faf6:	b2db      	uxtb	r3, r3
 800faf8:	700b      	strb	r3, [r1, #0]
  else
  {
    /* Perform Byte access to RCC_CIR[14:8] bits to disable the selected interrupts */
    *(__IO uint8_t *) CIR_BYTE2_ADDRESS &= (uint8_t)~RCC_IT;
  }
}
 800fafa:	e009      	b.n	800fb10 <RCC_ITConfig+0x3c>
    *(__IO uint8_t *) CIR_BYTE2_ADDRESS &= (uint8_t)~RCC_IT;
 800fafc:	4907      	ldr	r1, [pc, #28]	; (800fb1c <RCC_ITConfig+0x48>)
 800fafe:	4b07      	ldr	r3, [pc, #28]	; (800fb1c <RCC_ITConfig+0x48>)
 800fb00:	781b      	ldrb	r3, [r3, #0]
 800fb02:	b2da      	uxtb	r2, r3
 800fb04:	79fb      	ldrb	r3, [r7, #7]
 800fb06:	43db      	mvns	r3, r3
 800fb08:	b2db      	uxtb	r3, r3
 800fb0a:	4013      	ands	r3, r2
 800fb0c:	b2db      	uxtb	r3, r3
 800fb0e:	700b      	strb	r3, [r1, #0]
}
 800fb10:	bf00      	nop
 800fb12:	370c      	adds	r7, #12
 800fb14:	46bd      	mov	sp, r7
 800fb16:	f85d 7b04 	ldr.w	r7, [sp], #4
 800fb1a:	4770      	bx	lr
 800fb1c:	4002380d 	.word	0x4002380d

0800fb20 <RCC_GetFlagStatus>:
  *            @arg RCC_FLAG_WWDGRST: Window Watchdog reset
  *            @arg RCC_FLAG_LPWRRST: Low Power reset
  * @retval The new state of RCC_FLAG (SET or RESET).
  */
FlagStatus RCC_GetFlagStatus(uint8_t RCC_FLAG)
{
 800fb20:	b480      	push	{r7}
 800fb22:	b087      	sub	sp, #28
 800fb24:	af00      	add	r7, sp, #0
 800fb26:	4603      	mov	r3, r0
 800fb28:	71fb      	strb	r3, [r7, #7]
  uint32_t tmp = 0;
 800fb2a:	2300      	movs	r3, #0
 800fb2c:	60fb      	str	r3, [r7, #12]
  uint32_t statusreg = 0;
 800fb2e:	2300      	movs	r3, #0
 800fb30:	617b      	str	r3, [r7, #20]
  FlagStatus bitstatus = RESET;
 800fb32:	2300      	movs	r3, #0
 800fb34:	74fb      	strb	r3, [r7, #19]

  /* Check the parameters */
  assert_param(IS_RCC_FLAG(RCC_FLAG));

  /* Get the RCC register index */
  tmp = RCC_FLAG >> 5;
 800fb36:	79fb      	ldrb	r3, [r7, #7]
 800fb38:	095b      	lsrs	r3, r3, #5
 800fb3a:	b2db      	uxtb	r3, r3
 800fb3c:	60fb      	str	r3, [r7, #12]
  if (tmp == 1)               /* The flag to check is in CR register */
 800fb3e:	68fb      	ldr	r3, [r7, #12]
 800fb40:	2b01      	cmp	r3, #1
 800fb42:	d103      	bne.n	800fb4c <RCC_GetFlagStatus+0x2c>
  {
    statusreg = RCC->CR;
 800fb44:	4b12      	ldr	r3, [pc, #72]	; (800fb90 <RCC_GetFlagStatus+0x70>)
 800fb46:	681b      	ldr	r3, [r3, #0]
 800fb48:	617b      	str	r3, [r7, #20]
 800fb4a:	e009      	b.n	800fb60 <RCC_GetFlagStatus+0x40>
  }
  else if (tmp == 2)          /* The flag to check is in BDCR register */
 800fb4c:	68fb      	ldr	r3, [r7, #12]
 800fb4e:	2b02      	cmp	r3, #2
 800fb50:	d103      	bne.n	800fb5a <RCC_GetFlagStatus+0x3a>
  {
    statusreg = RCC->BDCR;
 800fb52:	4b0f      	ldr	r3, [pc, #60]	; (800fb90 <RCC_GetFlagStatus+0x70>)
 800fb54:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 800fb56:	617b      	str	r3, [r7, #20]
 800fb58:	e002      	b.n	800fb60 <RCC_GetFlagStatus+0x40>
  }
  else                       /* The flag to check is in CSR register */
  {
    statusreg = RCC->CSR;
 800fb5a:	4b0d      	ldr	r3, [pc, #52]	; (800fb90 <RCC_GetFlagStatus+0x70>)
 800fb5c:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 800fb5e:	617b      	str	r3, [r7, #20]
  }

  /* Get the flag position */
  tmp = RCC_FLAG & FLAG_MASK;
 800fb60:	79fb      	ldrb	r3, [r7, #7]
 800fb62:	f003 031f 	and.w	r3, r3, #31
 800fb66:	60fb      	str	r3, [r7, #12]
  if ((statusreg & ((uint32_t)1 << tmp)) != (uint32_t)RESET)
 800fb68:	697a      	ldr	r2, [r7, #20]
 800fb6a:	68fb      	ldr	r3, [r7, #12]
 800fb6c:	fa22 f303 	lsr.w	r3, r2, r3
 800fb70:	f003 0301 	and.w	r3, r3, #1
 800fb74:	2b00      	cmp	r3, #0
 800fb76:	d002      	beq.n	800fb7e <RCC_GetFlagStatus+0x5e>
  {
    bitstatus = SET;
 800fb78:	2301      	movs	r3, #1
 800fb7a:	74fb      	strb	r3, [r7, #19]
 800fb7c:	e001      	b.n	800fb82 <RCC_GetFlagStatus+0x62>
  }
  else
  {
    bitstatus = RESET;
 800fb7e:	2300      	movs	r3, #0
 800fb80:	74fb      	strb	r3, [r7, #19]
  }
  /* Return the flag status */
  return bitstatus;
 800fb82:	7cfb      	ldrb	r3, [r7, #19]
}
 800fb84:	4618      	mov	r0, r3
 800fb86:	371c      	adds	r7, #28
 800fb88:	46bd      	mov	sp, r7
 800fb8a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800fb8e:	4770      	bx	lr
 800fb90:	40023800 	.word	0x40023800

0800fb94 <RCC_ClearFlag>:
  *         RCC_FLAG_IWDGRST, RCC_FLAG_WWDGRST, RCC_FLAG_LPWRRST
  * @param  None
  * @retval None
  */
void RCC_ClearFlag(void)
{
 800fb94:	b480      	push	{r7}
 800fb96:	af00      	add	r7, sp, #0
  /* Set RMVF bit to clear the reset flags */
  RCC->CSR |= RCC_CSR_RMVF;
 800fb98:	4a05      	ldr	r2, [pc, #20]	; (800fbb0 <RCC_ClearFlag+0x1c>)
 800fb9a:	4b05      	ldr	r3, [pc, #20]	; (800fbb0 <RCC_ClearFlag+0x1c>)
 800fb9c:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 800fb9e:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
 800fba2:	6753      	str	r3, [r2, #116]	; 0x74
}
 800fba4:	bf00      	nop
 800fba6:	46bd      	mov	sp, r7
 800fba8:	f85d 7b04 	ldr.w	r7, [sp], #4
 800fbac:	4770      	bx	lr
 800fbae:	bf00      	nop
 800fbb0:	40023800 	.word	0x40023800

0800fbb4 <RCC_GetITStatus>:
  *            @arg RCC_IT_PLLI2SRDY: PLLI2S ready interrupt  
  *            @arg RCC_IT_CSS: Clock Security System interrupt
  * @retval The new state of RCC_IT (SET or RESET).
  */
ITStatus RCC_GetITStatus(uint8_t RCC_IT)
{
 800fbb4:	b480      	push	{r7}
 800fbb6:	b085      	sub	sp, #20
 800fbb8:	af00      	add	r7, sp, #0
 800fbba:	4603      	mov	r3, r0
 800fbbc:	71fb      	strb	r3, [r7, #7]
  ITStatus bitstatus = RESET;
 800fbbe:	2300      	movs	r3, #0
 800fbc0:	73fb      	strb	r3, [r7, #15]

  /* Check the parameters */
  assert_param(IS_RCC_GET_IT(RCC_IT));

  /* Check the status of the specified RCC interrupt */
  if ((RCC->CIR & RCC_IT) != (uint32_t)RESET)
 800fbc2:	4b09      	ldr	r3, [pc, #36]	; (800fbe8 <RCC_GetITStatus+0x34>)
 800fbc4:	68da      	ldr	r2, [r3, #12]
 800fbc6:	79fb      	ldrb	r3, [r7, #7]
 800fbc8:	4013      	ands	r3, r2
 800fbca:	2b00      	cmp	r3, #0
 800fbcc:	d002      	beq.n	800fbd4 <RCC_GetITStatus+0x20>
  {
    bitstatus = SET;
 800fbce:	2301      	movs	r3, #1
 800fbd0:	73fb      	strb	r3, [r7, #15]
 800fbd2:	e001      	b.n	800fbd8 <RCC_GetITStatus+0x24>
  }
  else
  {
    bitstatus = RESET;
 800fbd4:	2300      	movs	r3, #0
 800fbd6:	73fb      	strb	r3, [r7, #15]
  }
  /* Return the RCC_IT status */
  return  bitstatus;
 800fbd8:	7bfb      	ldrb	r3, [r7, #15]
}
 800fbda:	4618      	mov	r0, r3
 800fbdc:	3714      	adds	r7, #20
 800fbde:	46bd      	mov	sp, r7
 800fbe0:	f85d 7b04 	ldr.w	r7, [sp], #4
 800fbe4:	4770      	bx	lr
 800fbe6:	bf00      	nop
 800fbe8:	40023800 	.word	0x40023800

0800fbec <RCC_ClearITPendingBit>:
  *            @arg RCC_IT_PLLI2SRDY: PLLI2S ready interrupt  
  *            @arg RCC_IT_CSS: Clock Security System interrupt
  * @retval None
  */
void RCC_ClearITPendingBit(uint8_t RCC_IT)
{
 800fbec:	b480      	push	{r7}
 800fbee:	b083      	sub	sp, #12
 800fbf0:	af00      	add	r7, sp, #0
 800fbf2:	4603      	mov	r3, r0
 800fbf4:	71fb      	strb	r3, [r7, #7]
  /* Check the parameters */
  assert_param(IS_RCC_CLEAR_IT(RCC_IT));

  /* Perform Byte access to RCC_CIR[23:16] bits to clear the selected interrupt
     pending bits */
  *(__IO uint8_t *) CIR_BYTE3_ADDRESS = RCC_IT;
 800fbf6:	4a04      	ldr	r2, [pc, #16]	; (800fc08 <RCC_ClearITPendingBit+0x1c>)
 800fbf8:	79fb      	ldrb	r3, [r7, #7]
 800fbfa:	7013      	strb	r3, [r2, #0]
}
 800fbfc:	bf00      	nop
 800fbfe:	370c      	adds	r7, #12
 800fc00:	46bd      	mov	sp, r7
 800fc02:	f85d 7b04 	ldr.w	r7, [sp], #4
 800fc06:	4770      	bx	lr
 800fc08:	4002380e 	.word	0x4002380e

0800fc0c <RNG_DeInit>:
  * @brief  Deinitializes the RNG peripheral registers to their default reset values.
  * @param  None
  * @retval None
  */
void RNG_DeInit(void)
{
 800fc0c:	b580      	push	{r7, lr}
 800fc0e:	af00      	add	r7, sp, #0
  /* Enable RNG reset state */
  RCC_AHB2PeriphResetCmd(RCC_AHB2Periph_RNG, ENABLE);
 800fc10:	2101      	movs	r1, #1
 800fc12:	2040      	movs	r0, #64	; 0x40
 800fc14:	f7ff fe3e 	bl	800f894 <RCC_AHB2PeriphResetCmd>

  /* Release RNG from reset state */
  RCC_AHB2PeriphResetCmd(RCC_AHB2Periph_RNG, DISABLE);
 800fc18:	2100      	movs	r1, #0
 800fc1a:	2040      	movs	r0, #64	; 0x40
 800fc1c:	f7ff fe3a 	bl	800f894 <RCC_AHB2PeriphResetCmd>
}
 800fc20:	bf00      	nop
 800fc22:	bd80      	pop	{r7, pc}

0800fc24 <RNG_Cmd>:
  * @param  NewState: new state of the RNG peripheral.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void RNG_Cmd(FunctionalState NewState)
{
 800fc24:	b480      	push	{r7}
 800fc26:	b083      	sub	sp, #12
 800fc28:	af00      	add	r7, sp, #0
 800fc2a:	4603      	mov	r3, r0
 800fc2c:	71fb      	strb	r3, [r7, #7]
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 800fc2e:	79fb      	ldrb	r3, [r7, #7]
 800fc30:	2b00      	cmp	r3, #0
 800fc32:	d006      	beq.n	800fc42 <RNG_Cmd+0x1e>
  {
    /* Enable the RNG */
    RNG->CR |= RNG_CR_RNGEN;
 800fc34:	4a09      	ldr	r2, [pc, #36]	; (800fc5c <RNG_Cmd+0x38>)
 800fc36:	4b09      	ldr	r3, [pc, #36]	; (800fc5c <RNG_Cmd+0x38>)
 800fc38:	681b      	ldr	r3, [r3, #0]
 800fc3a:	f043 0304 	orr.w	r3, r3, #4
 800fc3e:	6013      	str	r3, [r2, #0]
  else
  {
    /* Disable the RNG */
    RNG->CR &= ~RNG_CR_RNGEN;
  }
}
 800fc40:	e005      	b.n	800fc4e <RNG_Cmd+0x2a>
    RNG->CR &= ~RNG_CR_RNGEN;
 800fc42:	4a06      	ldr	r2, [pc, #24]	; (800fc5c <RNG_Cmd+0x38>)
 800fc44:	4b05      	ldr	r3, [pc, #20]	; (800fc5c <RNG_Cmd+0x38>)
 800fc46:	681b      	ldr	r3, [r3, #0]
 800fc48:	f023 0304 	bic.w	r3, r3, #4
 800fc4c:	6013      	str	r3, [r2, #0]
}
 800fc4e:	bf00      	nop
 800fc50:	370c      	adds	r7, #12
 800fc52:	46bd      	mov	sp, r7
 800fc54:	f85d 7b04 	ldr.w	r7, [sp], #4
 800fc58:	4770      	bx	lr
 800fc5a:	bf00      	nop
 800fc5c:	50060800 	.word	0x50060800

0800fc60 <RNG_GetRandomNumber>:
  *         
  * @param  None
  * @retval 32-bit random number.
  */
uint32_t RNG_GetRandomNumber(void)
{
 800fc60:	b480      	push	{r7}
 800fc62:	af00      	add	r7, sp, #0
  /* Return the 32 bit random number from the DR register */
  return RNG->DR;
 800fc64:	4b03      	ldr	r3, [pc, #12]	; (800fc74 <RNG_GetRandomNumber+0x14>)
 800fc66:	689b      	ldr	r3, [r3, #8]
}
 800fc68:	4618      	mov	r0, r3
 800fc6a:	46bd      	mov	sp, r7
 800fc6c:	f85d 7b04 	ldr.w	r7, [sp], #4
 800fc70:	4770      	bx	lr
 800fc72:	bf00      	nop
 800fc74:	50060800 	.word	0x50060800

0800fc78 <RNG_ITConfig>:
  * @param  NewState: new state of the RNG interrupt.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void RNG_ITConfig(FunctionalState NewState)
{
 800fc78:	b480      	push	{r7}
 800fc7a:	b083      	sub	sp, #12
 800fc7c:	af00      	add	r7, sp, #0
 800fc7e:	4603      	mov	r3, r0
 800fc80:	71fb      	strb	r3, [r7, #7]
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 800fc82:	79fb      	ldrb	r3, [r7, #7]
 800fc84:	2b00      	cmp	r3, #0
 800fc86:	d006      	beq.n	800fc96 <RNG_ITConfig+0x1e>
  {
    /* Enable the RNG interrupt */
    RNG->CR |= RNG_CR_IE;
 800fc88:	4a09      	ldr	r2, [pc, #36]	; (800fcb0 <RNG_ITConfig+0x38>)
 800fc8a:	4b09      	ldr	r3, [pc, #36]	; (800fcb0 <RNG_ITConfig+0x38>)
 800fc8c:	681b      	ldr	r3, [r3, #0]
 800fc8e:	f043 0308 	orr.w	r3, r3, #8
 800fc92:	6013      	str	r3, [r2, #0]
  else
  {
    /* Disable the RNG interrupt */
    RNG->CR &= ~RNG_CR_IE;
  }
}
 800fc94:	e005      	b.n	800fca2 <RNG_ITConfig+0x2a>
    RNG->CR &= ~RNG_CR_IE;
 800fc96:	4a06      	ldr	r2, [pc, #24]	; (800fcb0 <RNG_ITConfig+0x38>)
 800fc98:	4b05      	ldr	r3, [pc, #20]	; (800fcb0 <RNG_ITConfig+0x38>)
 800fc9a:	681b      	ldr	r3, [r3, #0]
 800fc9c:	f023 0308 	bic.w	r3, r3, #8
 800fca0:	6013      	str	r3, [r2, #0]
}
 800fca2:	bf00      	nop
 800fca4:	370c      	adds	r7, #12
 800fca6:	46bd      	mov	sp, r7
 800fca8:	f85d 7b04 	ldr.w	r7, [sp], #4
 800fcac:	4770      	bx	lr
 800fcae:	bf00      	nop
 800fcb0:	50060800 	.word	0x50060800

0800fcb4 <RNG_GetFlagStatus>:
  *            @arg RNG_FLAG_CECS: Clock Error Current flag.
  *            @arg RNG_FLAG_SECS: Seed Error Current flag.
  * @retval The new state of RNG_FLAG (SET or RESET).
  */
FlagStatus RNG_GetFlagStatus(uint8_t RNG_FLAG)
{
 800fcb4:	b480      	push	{r7}
 800fcb6:	b085      	sub	sp, #20
 800fcb8:	af00      	add	r7, sp, #0
 800fcba:	4603      	mov	r3, r0
 800fcbc:	71fb      	strb	r3, [r7, #7]
  FlagStatus bitstatus = RESET;
 800fcbe:	2300      	movs	r3, #0
 800fcc0:	73fb      	strb	r3, [r7, #15]
  /* Check the parameters */
  assert_param(IS_RNG_GET_FLAG(RNG_FLAG));

  /* Check the status of the specified RNG flag */
  if ((RNG->SR & RNG_FLAG) != (uint8_t)RESET)
 800fcc2:	4b09      	ldr	r3, [pc, #36]	; (800fce8 <RNG_GetFlagStatus+0x34>)
 800fcc4:	685a      	ldr	r2, [r3, #4]
 800fcc6:	79fb      	ldrb	r3, [r7, #7]
 800fcc8:	4013      	ands	r3, r2
 800fcca:	2b00      	cmp	r3, #0
 800fccc:	d002      	beq.n	800fcd4 <RNG_GetFlagStatus+0x20>
  {
    /* RNG_FLAG is set */
    bitstatus = SET;
 800fcce:	2301      	movs	r3, #1
 800fcd0:	73fb      	strb	r3, [r7, #15]
 800fcd2:	e001      	b.n	800fcd8 <RNG_GetFlagStatus+0x24>
  }
  else
  {
    /* RNG_FLAG is reset */
    bitstatus = RESET;
 800fcd4:	2300      	movs	r3, #0
 800fcd6:	73fb      	strb	r3, [r7, #15]
  }
  /* Return the RNG_FLAG status */
  return  bitstatus;
 800fcd8:	7bfb      	ldrb	r3, [r7, #15]
}
 800fcda:	4618      	mov	r0, r3
 800fcdc:	3714      	adds	r7, #20
 800fcde:	46bd      	mov	sp, r7
 800fce0:	f85d 7b04 	ldr.w	r7, [sp], #4
 800fce4:	4770      	bx	lr
 800fce6:	bf00      	nop
 800fce8:	50060800 	.word	0x50060800

0800fcec <RNG_ClearFlag>:
  *         This flag is cleared only by reading the Random number data (using 
  *         RNG_GetRandomNumber() function).                           
  * @retval None
  */
void RNG_ClearFlag(uint8_t RNG_FLAG)
{
 800fcec:	b480      	push	{r7}
 800fcee:	b083      	sub	sp, #12
 800fcf0:	af00      	add	r7, sp, #0
 800fcf2:	4603      	mov	r3, r0
 800fcf4:	71fb      	strb	r3, [r7, #7]
  /* Check the parameters */
  assert_param(IS_RNG_CLEAR_FLAG(RNG_FLAG));
  /* Clear the selected RNG flags */
  RNG->SR = ~(uint32_t)(((uint32_t)RNG_FLAG) << 4);
 800fcf6:	4a05      	ldr	r2, [pc, #20]	; (800fd0c <RNG_ClearFlag+0x20>)
 800fcf8:	79fb      	ldrb	r3, [r7, #7]
 800fcfa:	011b      	lsls	r3, r3, #4
 800fcfc:	43db      	mvns	r3, r3
 800fcfe:	6053      	str	r3, [r2, #4]
}
 800fd00:	bf00      	nop
 800fd02:	370c      	adds	r7, #12
 800fd04:	46bd      	mov	sp, r7
 800fd06:	f85d 7b04 	ldr.w	r7, [sp], #4
 800fd0a:	4770      	bx	lr
 800fd0c:	50060800 	.word	0x50060800

0800fd10 <RNG_GetITStatus>:
  *            @arg RNG_IT_CEI: Clock Error Interrupt.
  *            @arg RNG_IT_SEI: Seed Error Interrupt.                   
  * @retval The new state of RNG_IT (SET or RESET).
  */
ITStatus RNG_GetITStatus(uint8_t RNG_IT)
{
 800fd10:	b480      	push	{r7}
 800fd12:	b085      	sub	sp, #20
 800fd14:	af00      	add	r7, sp, #0
 800fd16:	4603      	mov	r3, r0
 800fd18:	71fb      	strb	r3, [r7, #7]
  ITStatus bitstatus = RESET;
 800fd1a:	2300      	movs	r3, #0
 800fd1c:	73fb      	strb	r3, [r7, #15]
  /* Check the parameters */
  assert_param(IS_RNG_GET_IT(RNG_IT));

  /* Check the status of the specified RNG interrupt */
  if ((RNG->SR & RNG_IT) != (uint8_t)RESET)
 800fd1e:	4b09      	ldr	r3, [pc, #36]	; (800fd44 <RNG_GetITStatus+0x34>)
 800fd20:	685a      	ldr	r2, [r3, #4]
 800fd22:	79fb      	ldrb	r3, [r7, #7]
 800fd24:	4013      	ands	r3, r2
 800fd26:	2b00      	cmp	r3, #0
 800fd28:	d002      	beq.n	800fd30 <RNG_GetITStatus+0x20>
  {
    /* RNG_IT is set */
    bitstatus = SET;
 800fd2a:	2301      	movs	r3, #1
 800fd2c:	73fb      	strb	r3, [r7, #15]
 800fd2e:	e001      	b.n	800fd34 <RNG_GetITStatus+0x24>
  }
  else
  {
    /* RNG_IT is reset */
    bitstatus = RESET;
 800fd30:	2300      	movs	r3, #0
 800fd32:	73fb      	strb	r3, [r7, #15]
  }
  /* Return the RNG_IT status */
  return bitstatus;
 800fd34:	7bfb      	ldrb	r3, [r7, #15]
}
 800fd36:	4618      	mov	r0, r3
 800fd38:	3714      	adds	r7, #20
 800fd3a:	46bd      	mov	sp, r7
 800fd3c:	f85d 7b04 	ldr.w	r7, [sp], #4
 800fd40:	4770      	bx	lr
 800fd42:	bf00      	nop
 800fd44:	50060800 	.word	0x50060800

0800fd48 <RNG_ClearITPendingBit>:
  *            @arg RNG_IT_CEI: Clock Error Interrupt.
  *            @arg RNG_IT_SEI: Seed Error Interrupt.
  * @retval None
  */
void RNG_ClearITPendingBit(uint8_t RNG_IT)
{
 800fd48:	b480      	push	{r7}
 800fd4a:	b083      	sub	sp, #12
 800fd4c:	af00      	add	r7, sp, #0
 800fd4e:	4603      	mov	r3, r0
 800fd50:	71fb      	strb	r3, [r7, #7]
  /* Check the parameters */
  assert_param(IS_RNG_IT(RNG_IT));

  /* Clear the selected RNG interrupt pending bit */
  RNG->SR = (uint8_t)~RNG_IT;
 800fd52:	4a05      	ldr	r2, [pc, #20]	; (800fd68 <RNG_ClearITPendingBit+0x20>)
 800fd54:	79fb      	ldrb	r3, [r7, #7]
 800fd56:	43db      	mvns	r3, r3
 800fd58:	b2db      	uxtb	r3, r3
 800fd5a:	6053      	str	r3, [r2, #4]
}
 800fd5c:	bf00      	nop
 800fd5e:	370c      	adds	r7, #12
 800fd60:	46bd      	mov	sp, r7
 800fd62:	f85d 7b04 	ldr.w	r7, [sp], #4
 800fd66:	4770      	bx	lr
 800fd68:	50060800 	.word	0x50060800

0800fd6c <RTC_DeInit>:
  * @retval An ErrorStatus enumeration value:
  *          - SUCCESS: RTC registers are deinitialized
  *          - ERROR: RTC registers are not deinitialized
  */
ErrorStatus RTC_DeInit(void)
{
 800fd6c:	b580      	push	{r7, lr}
 800fd6e:	b084      	sub	sp, #16
 800fd70:	af00      	add	r7, sp, #0
  __IO uint32_t wutcounter = 0x00;
 800fd72:	2300      	movs	r3, #0
 800fd74:	607b      	str	r3, [r7, #4]
  uint32_t wutwfstatus = 0x00;
 800fd76:	2300      	movs	r3, #0
 800fd78:	60bb      	str	r3, [r7, #8]
  ErrorStatus status = ERROR;
 800fd7a:	2300      	movs	r3, #0
 800fd7c:	73fb      	strb	r3, [r7, #15]
  
  /* Disable the write protection for RTC registers */
  RTC->WPR = 0xCA;
 800fd7e:	4b36      	ldr	r3, [pc, #216]	; (800fe58 <RTC_DeInit+0xec>)
 800fd80:	22ca      	movs	r2, #202	; 0xca
 800fd82:	625a      	str	r2, [r3, #36]	; 0x24
  RTC->WPR = 0x53;
 800fd84:	4b34      	ldr	r3, [pc, #208]	; (800fe58 <RTC_DeInit+0xec>)
 800fd86:	2253      	movs	r2, #83	; 0x53
 800fd88:	625a      	str	r2, [r3, #36]	; 0x24

  /* Set Initialization mode */
  if (RTC_EnterInitMode() == ERROR)
 800fd8a:	f000 f8d3 	bl	800ff34 <RTC_EnterInitMode>
 800fd8e:	4603      	mov	r3, r0
 800fd90:	2b00      	cmp	r3, #0
 800fd92:	d102      	bne.n	800fd9a <RTC_DeInit+0x2e>
  {
    status = ERROR;
 800fd94:	2300      	movs	r3, #0
 800fd96:	73fb      	strb	r3, [r7, #15]
 800fd98:	e055      	b.n	800fe46 <RTC_DeInit+0xda>
  }  
  else
  {
    /* Reset TR, DR and CR registers */
    RTC->TR = (uint32_t)0x00000000;
 800fd9a:	4b2f      	ldr	r3, [pc, #188]	; (800fe58 <RTC_DeInit+0xec>)
 800fd9c:	2200      	movs	r2, #0
 800fd9e:	601a      	str	r2, [r3, #0]
    RTC->DR = (uint32_t)0x00002101;
 800fda0:	4b2d      	ldr	r3, [pc, #180]	; (800fe58 <RTC_DeInit+0xec>)
 800fda2:	f242 1201 	movw	r2, #8449	; 0x2101
 800fda6:	605a      	str	r2, [r3, #4]
    /* Reset All CR bits except CR[2:0] */
    RTC->CR &= (uint32_t)0x00000007;
 800fda8:	4a2b      	ldr	r2, [pc, #172]	; (800fe58 <RTC_DeInit+0xec>)
 800fdaa:	4b2b      	ldr	r3, [pc, #172]	; (800fe58 <RTC_DeInit+0xec>)
 800fdac:	689b      	ldr	r3, [r3, #8]
 800fdae:	f003 0307 	and.w	r3, r3, #7
 800fdb2:	6093      	str	r3, [r2, #8]
  
    /* Wait till RTC WUTWF flag is set and if Time out is reached exit */
    do
    {
      wutwfstatus = RTC->ISR & RTC_ISR_WUTWF;
 800fdb4:	4b28      	ldr	r3, [pc, #160]	; (800fe58 <RTC_DeInit+0xec>)
 800fdb6:	68db      	ldr	r3, [r3, #12]
 800fdb8:	f003 0304 	and.w	r3, r3, #4
 800fdbc:	60bb      	str	r3, [r7, #8]
      wutcounter++;  
 800fdbe:	687b      	ldr	r3, [r7, #4]
 800fdc0:	3301      	adds	r3, #1
 800fdc2:	607b      	str	r3, [r7, #4]
    } while((wutcounter != INITMODE_TIMEOUT) && (wutwfstatus == 0x00));
 800fdc4:	687b      	ldr	r3, [r7, #4]
 800fdc6:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 800fdca:	d002      	beq.n	800fdd2 <RTC_DeInit+0x66>
 800fdcc:	68bb      	ldr	r3, [r7, #8]
 800fdce:	2b00      	cmp	r3, #0
 800fdd0:	d0f0      	beq.n	800fdb4 <RTC_DeInit+0x48>
    
    if ((RTC->ISR & RTC_ISR_WUTWF) == RESET)
 800fdd2:	4b21      	ldr	r3, [pc, #132]	; (800fe58 <RTC_DeInit+0xec>)
 800fdd4:	68db      	ldr	r3, [r3, #12]
 800fdd6:	f003 0304 	and.w	r3, r3, #4
 800fdda:	2b00      	cmp	r3, #0
 800fddc:	d102      	bne.n	800fde4 <RTC_DeInit+0x78>
    {
      status = ERROR;
 800fdde:	2300      	movs	r3, #0
 800fde0:	73fb      	strb	r3, [r7, #15]
 800fde2:	e030      	b.n	800fe46 <RTC_DeInit+0xda>
    }
    else
    {
      /* Reset all RTC CR register bits */
      RTC->CR &= (uint32_t)0x00000000;
 800fde4:	4b1c      	ldr	r3, [pc, #112]	; (800fe58 <RTC_DeInit+0xec>)
 800fde6:	689b      	ldr	r3, [r3, #8]
 800fde8:	4b1b      	ldr	r3, [pc, #108]	; (800fe58 <RTC_DeInit+0xec>)
 800fdea:	2200      	movs	r2, #0
 800fdec:	609a      	str	r2, [r3, #8]
      RTC->WUTR = (uint32_t)0x0000FFFF;
 800fdee:	4b1a      	ldr	r3, [pc, #104]	; (800fe58 <RTC_DeInit+0xec>)
 800fdf0:	f64f 72ff 	movw	r2, #65535	; 0xffff
 800fdf4:	615a      	str	r2, [r3, #20]
      RTC->PRER = (uint32_t)0x007F00FF;
 800fdf6:	4b18      	ldr	r3, [pc, #96]	; (800fe58 <RTC_DeInit+0xec>)
 800fdf8:	4a18      	ldr	r2, [pc, #96]	; (800fe5c <RTC_DeInit+0xf0>)
 800fdfa:	611a      	str	r2, [r3, #16]
      RTC->CALIBR = (uint32_t)0x00000000;
 800fdfc:	4b16      	ldr	r3, [pc, #88]	; (800fe58 <RTC_DeInit+0xec>)
 800fdfe:	2200      	movs	r2, #0
 800fe00:	619a      	str	r2, [r3, #24]
      RTC->ALRMAR = (uint32_t)0x00000000;        
 800fe02:	4b15      	ldr	r3, [pc, #84]	; (800fe58 <RTC_DeInit+0xec>)
 800fe04:	2200      	movs	r2, #0
 800fe06:	61da      	str	r2, [r3, #28]
      RTC->ALRMBR = (uint32_t)0x00000000;
 800fe08:	4b13      	ldr	r3, [pc, #76]	; (800fe58 <RTC_DeInit+0xec>)
 800fe0a:	2200      	movs	r2, #0
 800fe0c:	621a      	str	r2, [r3, #32]
      RTC->SHIFTR = (uint32_t)0x00000000;
 800fe0e:	4b12      	ldr	r3, [pc, #72]	; (800fe58 <RTC_DeInit+0xec>)
 800fe10:	2200      	movs	r2, #0
 800fe12:	62da      	str	r2, [r3, #44]	; 0x2c
      RTC->CALR = (uint32_t)0x00000000;
 800fe14:	4b10      	ldr	r3, [pc, #64]	; (800fe58 <RTC_DeInit+0xec>)
 800fe16:	2200      	movs	r2, #0
 800fe18:	63da      	str	r2, [r3, #60]	; 0x3c
      RTC->ALRMASSR = (uint32_t)0x00000000;
 800fe1a:	4b0f      	ldr	r3, [pc, #60]	; (800fe58 <RTC_DeInit+0xec>)
 800fe1c:	2200      	movs	r2, #0
 800fe1e:	645a      	str	r2, [r3, #68]	; 0x44
      RTC->ALRMBSSR = (uint32_t)0x00000000;
 800fe20:	4b0d      	ldr	r3, [pc, #52]	; (800fe58 <RTC_DeInit+0xec>)
 800fe22:	2200      	movs	r2, #0
 800fe24:	649a      	str	r2, [r3, #72]	; 0x48
      
      /* Reset ISR register and exit initialization mode */
      RTC->ISR = (uint32_t)0x00000000;
 800fe26:	4b0c      	ldr	r3, [pc, #48]	; (800fe58 <RTC_DeInit+0xec>)
 800fe28:	2200      	movs	r2, #0
 800fe2a:	60da      	str	r2, [r3, #12]
      
      /* Reset Tamper and alternate functions configuration register */
      RTC->TAFCR = 0x00000000;
 800fe2c:	4b0a      	ldr	r3, [pc, #40]	; (800fe58 <RTC_DeInit+0xec>)
 800fe2e:	2200      	movs	r2, #0
 800fe30:	641a      	str	r2, [r3, #64]	; 0x40
  
      if(RTC_WaitForSynchro() == ERROR)
 800fe32:	f000 f8c9 	bl	800ffc8 <RTC_WaitForSynchro>
 800fe36:	4603      	mov	r3, r0
 800fe38:	2b00      	cmp	r3, #0
 800fe3a:	d102      	bne.n	800fe42 <RTC_DeInit+0xd6>
      {
        status = ERROR;
 800fe3c:	2300      	movs	r3, #0
 800fe3e:	73fb      	strb	r3, [r7, #15]
 800fe40:	e001      	b.n	800fe46 <RTC_DeInit+0xda>
      }
      else
      {
        status = SUCCESS;      
 800fe42:	2301      	movs	r3, #1
 800fe44:	73fb      	strb	r3, [r7, #15]
      }
    }
  }
  
  /* Enable the write protection for RTC registers */
  RTC->WPR = 0xFF;  
 800fe46:	4b04      	ldr	r3, [pc, #16]	; (800fe58 <RTC_DeInit+0xec>)
 800fe48:	22ff      	movs	r2, #255	; 0xff
 800fe4a:	625a      	str	r2, [r3, #36]	; 0x24
  
  return status;
 800fe4c:	7bfb      	ldrb	r3, [r7, #15]
}
 800fe4e:	4618      	mov	r0, r3
 800fe50:	3710      	adds	r7, #16
 800fe52:	46bd      	mov	sp, r7
 800fe54:	bd80      	pop	{r7, pc}
 800fe56:	bf00      	nop
 800fe58:	40002800 	.word	0x40002800
 800fe5c:	007f00ff 	.word	0x007f00ff

0800fe60 <RTC_Init>:
  * @retval An ErrorStatus enumeration value:
  *          - SUCCESS: RTC registers are initialized
  *          - ERROR: RTC registers are not initialized  
  */
ErrorStatus RTC_Init(RTC_InitTypeDef* RTC_InitStruct)
{
 800fe60:	b580      	push	{r7, lr}
 800fe62:	b084      	sub	sp, #16
 800fe64:	af00      	add	r7, sp, #0
 800fe66:	6078      	str	r0, [r7, #4]
  ErrorStatus status = ERROR;
 800fe68:	2300      	movs	r3, #0
 800fe6a:	73fb      	strb	r3, [r7, #15]
  assert_param(IS_RTC_HOUR_FORMAT(RTC_InitStruct->RTC_HourFormat));
  assert_param(IS_RTC_ASYNCH_PREDIV(RTC_InitStruct->RTC_AsynchPrediv));
  assert_param(IS_RTC_SYNCH_PREDIV(RTC_InitStruct->RTC_SynchPrediv));

  /* Disable the write protection for RTC registers */
  RTC->WPR = 0xCA;
 800fe6c:	4b19      	ldr	r3, [pc, #100]	; (800fed4 <RTC_Init+0x74>)
 800fe6e:	22ca      	movs	r2, #202	; 0xca
 800fe70:	625a      	str	r2, [r3, #36]	; 0x24
  RTC->WPR = 0x53;
 800fe72:	4b18      	ldr	r3, [pc, #96]	; (800fed4 <RTC_Init+0x74>)
 800fe74:	2253      	movs	r2, #83	; 0x53
 800fe76:	625a      	str	r2, [r3, #36]	; 0x24

  /* Set Initialization mode */
  if (RTC_EnterInitMode() == ERROR)
 800fe78:	f000 f85c 	bl	800ff34 <RTC_EnterInitMode>
 800fe7c:	4603      	mov	r3, r0
 800fe7e:	2b00      	cmp	r3, #0
 800fe80:	d102      	bne.n	800fe88 <RTC_Init+0x28>
  {
    status = ERROR;
 800fe82:	2300      	movs	r3, #0
 800fe84:	73fb      	strb	r3, [r7, #15]
 800fe86:	e01c      	b.n	800fec2 <RTC_Init+0x62>
  } 
  else
  {
    /* Clear RTC CR FMT Bit */
    RTC->CR &= ((uint32_t)~(RTC_CR_FMT));
 800fe88:	4a12      	ldr	r2, [pc, #72]	; (800fed4 <RTC_Init+0x74>)
 800fe8a:	4b12      	ldr	r3, [pc, #72]	; (800fed4 <RTC_Init+0x74>)
 800fe8c:	689b      	ldr	r3, [r3, #8]
 800fe8e:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 800fe92:	6093      	str	r3, [r2, #8]
    /* Set RTC_CR register */
    RTC->CR |=  ((uint32_t)(RTC_InitStruct->RTC_HourFormat));
 800fe94:	490f      	ldr	r1, [pc, #60]	; (800fed4 <RTC_Init+0x74>)
 800fe96:	4b0f      	ldr	r3, [pc, #60]	; (800fed4 <RTC_Init+0x74>)
 800fe98:	689a      	ldr	r2, [r3, #8]
 800fe9a:	687b      	ldr	r3, [r7, #4]
 800fe9c:	681b      	ldr	r3, [r3, #0]
 800fe9e:	4313      	orrs	r3, r2
 800fea0:	608b      	str	r3, [r1, #8]
  
    /* Configure the RTC PRER */
    RTC->PRER = (uint32_t)(RTC_InitStruct->RTC_SynchPrediv);
 800fea2:	4a0c      	ldr	r2, [pc, #48]	; (800fed4 <RTC_Init+0x74>)
 800fea4:	687b      	ldr	r3, [r7, #4]
 800fea6:	689b      	ldr	r3, [r3, #8]
 800fea8:	6113      	str	r3, [r2, #16]
    RTC->PRER |= (uint32_t)(RTC_InitStruct->RTC_AsynchPrediv << 16);
 800feaa:	490a      	ldr	r1, [pc, #40]	; (800fed4 <RTC_Init+0x74>)
 800feac:	4b09      	ldr	r3, [pc, #36]	; (800fed4 <RTC_Init+0x74>)
 800feae:	691a      	ldr	r2, [r3, #16]
 800feb0:	687b      	ldr	r3, [r7, #4]
 800feb2:	685b      	ldr	r3, [r3, #4]
 800feb4:	041b      	lsls	r3, r3, #16
 800feb6:	4313      	orrs	r3, r2
 800feb8:	610b      	str	r3, [r1, #16]

    /* Exit Initialization mode */
    RTC_ExitInitMode();
 800feba:	f000 f875 	bl	800ffa8 <RTC_ExitInitMode>

    status = SUCCESS;    
 800febe:	2301      	movs	r3, #1
 800fec0:	73fb      	strb	r3, [r7, #15]
  }
  /* Enable the write protection for RTC registers */
  RTC->WPR = 0xFF; 
 800fec2:	4b04      	ldr	r3, [pc, #16]	; (800fed4 <RTC_Init+0x74>)
 800fec4:	22ff      	movs	r2, #255	; 0xff
 800fec6:	625a      	str	r2, [r3, #36]	; 0x24
  
  return status;
 800fec8:	7bfb      	ldrb	r3, [r7, #15]
}
 800feca:	4618      	mov	r0, r3
 800fecc:	3710      	adds	r7, #16
 800fece:	46bd      	mov	sp, r7
 800fed0:	bd80      	pop	{r7, pc}
 800fed2:	bf00      	nop
 800fed4:	40002800 	.word	0x40002800

0800fed8 <RTC_StructInit>:
  * @param  RTC_InitStruct: pointer to a RTC_InitTypeDef structure which will be 
  *         initialized.
  * @retval None
  */
void RTC_StructInit(RTC_InitTypeDef* RTC_InitStruct)
{
 800fed8:	b480      	push	{r7}
 800feda:	b083      	sub	sp, #12
 800fedc:	af00      	add	r7, sp, #0
 800fede:	6078      	str	r0, [r7, #4]
  /* Initialize the RTC_HourFormat member */
  RTC_InitStruct->RTC_HourFormat = RTC_HourFormat_24;
 800fee0:	687b      	ldr	r3, [r7, #4]
 800fee2:	2200      	movs	r2, #0
 800fee4:	601a      	str	r2, [r3, #0]
    
  /* Initialize the RTC_AsynchPrediv member */
  RTC_InitStruct->RTC_AsynchPrediv = (uint32_t)0x7F;
 800fee6:	687b      	ldr	r3, [r7, #4]
 800fee8:	227f      	movs	r2, #127	; 0x7f
 800feea:	605a      	str	r2, [r3, #4]

  /* Initialize the RTC_SynchPrediv member */
  RTC_InitStruct->RTC_SynchPrediv = (uint32_t)0xFF; 
 800feec:	687b      	ldr	r3, [r7, #4]
 800feee:	22ff      	movs	r2, #255	; 0xff
 800fef0:	609a      	str	r2, [r3, #8]
}
 800fef2:	bf00      	nop
 800fef4:	370c      	adds	r7, #12
 800fef6:	46bd      	mov	sp, r7
 800fef8:	f85d 7b04 	ldr.w	r7, [sp], #4
 800fefc:	4770      	bx	lr

0800fefe <RTC_WriteProtectionCmd>:
  * @param  NewState: new state of the write protection.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void RTC_WriteProtectionCmd(FunctionalState NewState)
{
 800fefe:	b480      	push	{r7}
 800ff00:	b083      	sub	sp, #12
 800ff02:	af00      	add	r7, sp, #0
 800ff04:	4603      	mov	r3, r0
 800ff06:	71fb      	strb	r3, [r7, #7]
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
    
  if (NewState != DISABLE)
 800ff08:	79fb      	ldrb	r3, [r7, #7]
 800ff0a:	2b00      	cmp	r3, #0
 800ff0c:	d003      	beq.n	800ff16 <RTC_WriteProtectionCmd+0x18>
  {
    /* Enable the write protection for RTC registers */
    RTC->WPR = 0xFF;   
 800ff0e:	4b08      	ldr	r3, [pc, #32]	; (800ff30 <RTC_WriteProtectionCmd+0x32>)
 800ff10:	22ff      	movs	r2, #255	; 0xff
 800ff12:	625a      	str	r2, [r3, #36]	; 0x24
  {
    /* Disable the write protection for RTC registers */
    RTC->WPR = 0xCA;
    RTC->WPR = 0x53;    
  }
}
 800ff14:	e005      	b.n	800ff22 <RTC_WriteProtectionCmd+0x24>
    RTC->WPR = 0xCA;
 800ff16:	4b06      	ldr	r3, [pc, #24]	; (800ff30 <RTC_WriteProtectionCmd+0x32>)
 800ff18:	22ca      	movs	r2, #202	; 0xca
 800ff1a:	625a      	str	r2, [r3, #36]	; 0x24
    RTC->WPR = 0x53;    
 800ff1c:	4b04      	ldr	r3, [pc, #16]	; (800ff30 <RTC_WriteProtectionCmd+0x32>)
 800ff1e:	2253      	movs	r2, #83	; 0x53
 800ff20:	625a      	str	r2, [r3, #36]	; 0x24
}
 800ff22:	bf00      	nop
 800ff24:	370c      	adds	r7, #12
 800ff26:	46bd      	mov	sp, r7
 800ff28:	f85d 7b04 	ldr.w	r7, [sp], #4
 800ff2c:	4770      	bx	lr
 800ff2e:	bf00      	nop
 800ff30:	40002800 	.word	0x40002800

0800ff34 <RTC_EnterInitMode>:
  * @retval An ErrorStatus enumeration value:
  *          - SUCCESS: RTC is in Init mode
  *          - ERROR: RTC is not in Init mode  
  */
ErrorStatus RTC_EnterInitMode(void)
{
 800ff34:	b480      	push	{r7}
 800ff36:	b085      	sub	sp, #20
 800ff38:	af00      	add	r7, sp, #0
  __IO uint32_t initcounter = 0x00;
 800ff3a:	2300      	movs	r3, #0
 800ff3c:	607b      	str	r3, [r7, #4]
  ErrorStatus status = ERROR;
 800ff3e:	2300      	movs	r3, #0
 800ff40:	73fb      	strb	r3, [r7, #15]
  uint32_t initstatus = 0x00;
 800ff42:	2300      	movs	r3, #0
 800ff44:	60bb      	str	r3, [r7, #8]
     
  /* Check if the Initialization mode is set */
  if ((RTC->ISR & RTC_ISR_INITF) == (uint32_t)RESET)
 800ff46:	4b17      	ldr	r3, [pc, #92]	; (800ffa4 <RTC_EnterInitMode+0x70>)
 800ff48:	68db      	ldr	r3, [r3, #12]
 800ff4a:	f003 0340 	and.w	r3, r3, #64	; 0x40
 800ff4e:	2b00      	cmp	r3, #0
 800ff50:	d11e      	bne.n	800ff90 <RTC_EnterInitMode+0x5c>
  {
    /* Set the Initialization mode */
    RTC->ISR = (uint32_t)RTC_INIT_MASK;
 800ff52:	4b14      	ldr	r3, [pc, #80]	; (800ffa4 <RTC_EnterInitMode+0x70>)
 800ff54:	f04f 32ff 	mov.w	r2, #4294967295
 800ff58:	60da      	str	r2, [r3, #12]
    
    /* Wait till RTC is in INIT state and if Time out is reached exit */
    do
    {
      initstatus = RTC->ISR & RTC_ISR_INITF;
 800ff5a:	4b12      	ldr	r3, [pc, #72]	; (800ffa4 <RTC_EnterInitMode+0x70>)
 800ff5c:	68db      	ldr	r3, [r3, #12]
 800ff5e:	f003 0340 	and.w	r3, r3, #64	; 0x40
 800ff62:	60bb      	str	r3, [r7, #8]
      initcounter++;  
 800ff64:	687b      	ldr	r3, [r7, #4]
 800ff66:	3301      	adds	r3, #1
 800ff68:	607b      	str	r3, [r7, #4]
    } while((initcounter != INITMODE_TIMEOUT) && (initstatus == 0x00));
 800ff6a:	687b      	ldr	r3, [r7, #4]
 800ff6c:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 800ff70:	d002      	beq.n	800ff78 <RTC_EnterInitMode+0x44>
 800ff72:	68bb      	ldr	r3, [r7, #8]
 800ff74:	2b00      	cmp	r3, #0
 800ff76:	d0f0      	beq.n	800ff5a <RTC_EnterInitMode+0x26>
    
    if ((RTC->ISR & RTC_ISR_INITF) != RESET)
 800ff78:	4b0a      	ldr	r3, [pc, #40]	; (800ffa4 <RTC_EnterInitMode+0x70>)
 800ff7a:	68db      	ldr	r3, [r3, #12]
 800ff7c:	f003 0340 	and.w	r3, r3, #64	; 0x40
 800ff80:	2b00      	cmp	r3, #0
 800ff82:	d002      	beq.n	800ff8a <RTC_EnterInitMode+0x56>
    {
      status = SUCCESS;
 800ff84:	2301      	movs	r3, #1
 800ff86:	73fb      	strb	r3, [r7, #15]
 800ff88:	e004      	b.n	800ff94 <RTC_EnterInitMode+0x60>
    }
    else
    {
      status = ERROR;
 800ff8a:	2300      	movs	r3, #0
 800ff8c:	73fb      	strb	r3, [r7, #15]
 800ff8e:	e001      	b.n	800ff94 <RTC_EnterInitMode+0x60>
    }        
  }
  else
  {
    status = SUCCESS;  
 800ff90:	2301      	movs	r3, #1
 800ff92:	73fb      	strb	r3, [r7, #15]
  } 
    
  return (status);  
 800ff94:	7bfb      	ldrb	r3, [r7, #15]
}
 800ff96:	4618      	mov	r0, r3
 800ff98:	3714      	adds	r7, #20
 800ff9a:	46bd      	mov	sp, r7
 800ff9c:	f85d 7b04 	ldr.w	r7, [sp], #4
 800ffa0:	4770      	bx	lr
 800ffa2:	bf00      	nop
 800ffa4:	40002800 	.word	0x40002800

0800ffa8 <RTC_ExitInitMode>:
  *         RTC_WriteProtectionCmd(DISABLE) before calling this function.      
  * @param  None
  * @retval None
  */
void RTC_ExitInitMode(void)
{ 
 800ffa8:	b480      	push	{r7}
 800ffaa:	af00      	add	r7, sp, #0
  /* Exit Initialization mode */
  RTC->ISR &= (uint32_t)~RTC_ISR_INIT;  
 800ffac:	4a05      	ldr	r2, [pc, #20]	; (800ffc4 <RTC_ExitInitMode+0x1c>)
 800ffae:	4b05      	ldr	r3, [pc, #20]	; (800ffc4 <RTC_ExitInitMode+0x1c>)
 800ffb0:	68db      	ldr	r3, [r3, #12]
 800ffb2:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 800ffb6:	60d3      	str	r3, [r2, #12]
}
 800ffb8:	bf00      	nop
 800ffba:	46bd      	mov	sp, r7
 800ffbc:	f85d 7b04 	ldr.w	r7, [sp], #4
 800ffc0:	4770      	bx	lr
 800ffc2:	bf00      	nop
 800ffc4:	40002800 	.word	0x40002800

0800ffc8 <RTC_WaitForSynchro>:
  * @retval An ErrorStatus enumeration value:
  *          - SUCCESS: RTC registers are synchronised
  *          - ERROR: RTC registers are not synchronised
  */
ErrorStatus RTC_WaitForSynchro(void)
{
 800ffc8:	b480      	push	{r7}
 800ffca:	b085      	sub	sp, #20
 800ffcc:	af00      	add	r7, sp, #0
  __IO uint32_t synchrocounter = 0;
 800ffce:	2300      	movs	r3, #0
 800ffd0:	607b      	str	r3, [r7, #4]
  ErrorStatus status = ERROR;
 800ffd2:	2300      	movs	r3, #0
 800ffd4:	73fb      	strb	r3, [r7, #15]
  uint32_t synchrostatus = 0x00;
 800ffd6:	2300      	movs	r3, #0
 800ffd8:	60bb      	str	r3, [r7, #8]

  /* Disable the write protection for RTC registers */
  RTC->WPR = 0xCA;
 800ffda:	4b18      	ldr	r3, [pc, #96]	; (801003c <RTC_WaitForSynchro+0x74>)
 800ffdc:	22ca      	movs	r2, #202	; 0xca
 800ffde:	625a      	str	r2, [r3, #36]	; 0x24
  RTC->WPR = 0x53;
 800ffe0:	4b16      	ldr	r3, [pc, #88]	; (801003c <RTC_WaitForSynchro+0x74>)
 800ffe2:	2253      	movs	r2, #83	; 0x53
 800ffe4:	625a      	str	r2, [r3, #36]	; 0x24
    
  /* Clear RSF flag */
  RTC->ISR &= (uint32_t)RTC_RSF_MASK;
 800ffe6:	4a15      	ldr	r2, [pc, #84]	; (801003c <RTC_WaitForSynchro+0x74>)
 800ffe8:	4b14      	ldr	r3, [pc, #80]	; (801003c <RTC_WaitForSynchro+0x74>)
 800ffea:	68db      	ldr	r3, [r3, #12]
 800ffec:	f023 03a0 	bic.w	r3, r3, #160	; 0xa0
 800fff0:	60d3      	str	r3, [r2, #12]
    
  /* Wait the registers to be synchronised */
  do
  {
    synchrostatus = RTC->ISR & RTC_ISR_RSF;
 800fff2:	4b12      	ldr	r3, [pc, #72]	; (801003c <RTC_WaitForSynchro+0x74>)
 800fff4:	68db      	ldr	r3, [r3, #12]
 800fff6:	f003 0320 	and.w	r3, r3, #32
 800fffa:	60bb      	str	r3, [r7, #8]
    synchrocounter++;  
 800fffc:	687b      	ldr	r3, [r7, #4]
 800fffe:	3301      	adds	r3, #1
 8010000:	607b      	str	r3, [r7, #4]
  } while((synchrocounter != SYNCHRO_TIMEOUT) && (synchrostatus == 0x00));
 8010002:	687b      	ldr	r3, [r7, #4]
 8010004:	f5b3 3f00 	cmp.w	r3, #131072	; 0x20000
 8010008:	d002      	beq.n	8010010 <RTC_WaitForSynchro+0x48>
 801000a:	68bb      	ldr	r3, [r7, #8]
 801000c:	2b00      	cmp	r3, #0
 801000e:	d0f0      	beq.n	800fff2 <RTC_WaitForSynchro+0x2a>
    
  if ((RTC->ISR & RTC_ISR_RSF) != RESET)
 8010010:	4b0a      	ldr	r3, [pc, #40]	; (801003c <RTC_WaitForSynchro+0x74>)
 8010012:	68db      	ldr	r3, [r3, #12]
 8010014:	f003 0320 	and.w	r3, r3, #32
 8010018:	2b00      	cmp	r3, #0
 801001a:	d002      	beq.n	8010022 <RTC_WaitForSynchro+0x5a>
  {
    status = SUCCESS;
 801001c:	2301      	movs	r3, #1
 801001e:	73fb      	strb	r3, [r7, #15]
 8010020:	e001      	b.n	8010026 <RTC_WaitForSynchro+0x5e>
  }
  else
  {
    status = ERROR;
 8010022:	2300      	movs	r3, #0
 8010024:	73fb      	strb	r3, [r7, #15]
  }        

  /* Enable the write protection for RTC registers */
  RTC->WPR = 0xFF; 
 8010026:	4b05      	ldr	r3, [pc, #20]	; (801003c <RTC_WaitForSynchro+0x74>)
 8010028:	22ff      	movs	r2, #255	; 0xff
 801002a:	625a      	str	r2, [r3, #36]	; 0x24
    
  return (status); 
 801002c:	7bfb      	ldrb	r3, [r7, #15]
}
 801002e:	4618      	mov	r0, r3
 8010030:	3714      	adds	r7, #20
 8010032:	46bd      	mov	sp, r7
 8010034:	f85d 7b04 	ldr.w	r7, [sp], #4
 8010038:	4770      	bx	lr
 801003a:	bf00      	nop
 801003c:	40002800 	.word	0x40002800

08010040 <RTC_RefClockCmd>:
  * @retval An ErrorStatus enumeration value:
  *          - SUCCESS: RTC reference clock detection is enabled
  *          - ERROR: RTC reference clock detection is disabled  
  */
ErrorStatus RTC_RefClockCmd(FunctionalState NewState)
{ 
 8010040:	b580      	push	{r7, lr}
 8010042:	b084      	sub	sp, #16
 8010044:	af00      	add	r7, sp, #0
 8010046:	4603      	mov	r3, r0
 8010048:	71fb      	strb	r3, [r7, #7]
  ErrorStatus status = ERROR;
 801004a:	2300      	movs	r3, #0
 801004c:	73fb      	strb	r3, [r7, #15]
  
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  /* Disable the write protection for RTC registers */
  RTC->WPR = 0xCA;
 801004e:	4b15      	ldr	r3, [pc, #84]	; (80100a4 <RTC_RefClockCmd+0x64>)
 8010050:	22ca      	movs	r2, #202	; 0xca
 8010052:	625a      	str	r2, [r3, #36]	; 0x24
  RTC->WPR = 0x53;
 8010054:	4b13      	ldr	r3, [pc, #76]	; (80100a4 <RTC_RefClockCmd+0x64>)
 8010056:	2253      	movs	r2, #83	; 0x53
 8010058:	625a      	str	r2, [r3, #36]	; 0x24
    
  /* Set Initialization mode */
  if (RTC_EnterInitMode() == ERROR)
 801005a:	f7ff ff6b 	bl	800ff34 <RTC_EnterInitMode>
 801005e:	4603      	mov	r3, r0
 8010060:	2b00      	cmp	r3, #0
 8010062:	d102      	bne.n	801006a <RTC_RefClockCmd+0x2a>
  {
    status = ERROR;
 8010064:	2300      	movs	r3, #0
 8010066:	73fb      	strb	r3, [r7, #15]
 8010068:	e013      	b.n	8010092 <RTC_RefClockCmd+0x52>
  } 
  else
  {  
    if (NewState != DISABLE)
 801006a:	79fb      	ldrb	r3, [r7, #7]
 801006c:	2b00      	cmp	r3, #0
 801006e:	d006      	beq.n	801007e <RTC_RefClockCmd+0x3e>
    {
      /* Enable the RTC reference clock detection */
      RTC->CR |= RTC_CR_REFCKON;   
 8010070:	4a0c      	ldr	r2, [pc, #48]	; (80100a4 <RTC_RefClockCmd+0x64>)
 8010072:	4b0c      	ldr	r3, [pc, #48]	; (80100a4 <RTC_RefClockCmd+0x64>)
 8010074:	689b      	ldr	r3, [r3, #8]
 8010076:	f043 0310 	orr.w	r3, r3, #16
 801007a:	6093      	str	r3, [r2, #8]
 801007c:	e005      	b.n	801008a <RTC_RefClockCmd+0x4a>
    }
    else
    {
      /* Disable the RTC reference clock detection */
      RTC->CR &= ~RTC_CR_REFCKON;    
 801007e:	4a09      	ldr	r2, [pc, #36]	; (80100a4 <RTC_RefClockCmd+0x64>)
 8010080:	4b08      	ldr	r3, [pc, #32]	; (80100a4 <RTC_RefClockCmd+0x64>)
 8010082:	689b      	ldr	r3, [r3, #8]
 8010084:	f023 0310 	bic.w	r3, r3, #16
 8010088:	6093      	str	r3, [r2, #8]
    }
    /* Exit Initialization mode */
    RTC_ExitInitMode();
 801008a:	f7ff ff8d 	bl	800ffa8 <RTC_ExitInitMode>
    
    status = SUCCESS;
 801008e:	2301      	movs	r3, #1
 8010090:	73fb      	strb	r3, [r7, #15]
  }
  
  /* Enable the write protection for RTC registers */
  RTC->WPR = 0xFF;  
 8010092:	4b04      	ldr	r3, [pc, #16]	; (80100a4 <RTC_RefClockCmd+0x64>)
 8010094:	22ff      	movs	r2, #255	; 0xff
 8010096:	625a      	str	r2, [r3, #36]	; 0x24
  
  return status; 
 8010098:	7bfb      	ldrb	r3, [r7, #15]
}
 801009a:	4618      	mov	r0, r3
 801009c:	3710      	adds	r7, #16
 801009e:	46bd      	mov	sp, r7
 80100a0:	bd80      	pop	{r7, pc}
 80100a2:	bf00      	nop
 80100a4:	40002800 	.word	0x40002800

080100a8 <RTC_BypassShadowCmd>:
  * @param  NewState: new state of the Bypass Shadow feature.
  *         This parameter can be: ENABLE or DISABLE.
  * @retval None
*/
void RTC_BypassShadowCmd(FunctionalState NewState)
{
 80100a8:	b480      	push	{r7}
 80100aa:	b083      	sub	sp, #12
 80100ac:	af00      	add	r7, sp, #0
 80100ae:	4603      	mov	r3, r0
 80100b0:	71fb      	strb	r3, [r7, #7]
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  /* Disable the write protection for RTC registers */
  RTC->WPR = 0xCA;
 80100b2:	4b0f      	ldr	r3, [pc, #60]	; (80100f0 <RTC_BypassShadowCmd+0x48>)
 80100b4:	22ca      	movs	r2, #202	; 0xca
 80100b6:	625a      	str	r2, [r3, #36]	; 0x24
  RTC->WPR = 0x53;
 80100b8:	4b0d      	ldr	r3, [pc, #52]	; (80100f0 <RTC_BypassShadowCmd+0x48>)
 80100ba:	2253      	movs	r2, #83	; 0x53
 80100bc:	625a      	str	r2, [r3, #36]	; 0x24
  
  if (NewState != DISABLE)
 80100be:	79fb      	ldrb	r3, [r7, #7]
 80100c0:	2b00      	cmp	r3, #0
 80100c2:	d006      	beq.n	80100d2 <RTC_BypassShadowCmd+0x2a>
  {
    /* Set the BYPSHAD bit */
    RTC->CR |= (uint8_t)RTC_CR_BYPSHAD;
 80100c4:	4a0a      	ldr	r2, [pc, #40]	; (80100f0 <RTC_BypassShadowCmd+0x48>)
 80100c6:	4b0a      	ldr	r3, [pc, #40]	; (80100f0 <RTC_BypassShadowCmd+0x48>)
 80100c8:	689b      	ldr	r3, [r3, #8]
 80100ca:	f043 0320 	orr.w	r3, r3, #32
 80100ce:	6093      	str	r3, [r2, #8]
 80100d0:	e005      	b.n	80100de <RTC_BypassShadowCmd+0x36>
  }
  else
  {
    /* Reset the BYPSHAD bit */
    RTC->CR &= (uint8_t)~RTC_CR_BYPSHAD;
 80100d2:	4a07      	ldr	r2, [pc, #28]	; (80100f0 <RTC_BypassShadowCmd+0x48>)
 80100d4:	4b06      	ldr	r3, [pc, #24]	; (80100f0 <RTC_BypassShadowCmd+0x48>)
 80100d6:	689b      	ldr	r3, [r3, #8]
 80100d8:	f003 03df 	and.w	r3, r3, #223	; 0xdf
 80100dc:	6093      	str	r3, [r2, #8]
  }

  /* Enable the write protection for RTC registers */
  RTC->WPR = 0xFF;
 80100de:	4b04      	ldr	r3, [pc, #16]	; (80100f0 <RTC_BypassShadowCmd+0x48>)
 80100e0:	22ff      	movs	r2, #255	; 0xff
 80100e2:	625a      	str	r2, [r3, #36]	; 0x24
}
 80100e4:	bf00      	nop
 80100e6:	370c      	adds	r7, #12
 80100e8:	46bd      	mov	sp, r7
 80100ea:	f85d 7b04 	ldr.w	r7, [sp], #4
 80100ee:	4770      	bx	lr
 80100f0:	40002800 	.word	0x40002800

080100f4 <RTC_SetTime>:
  * @retval An ErrorStatus enumeration value:
  *          - SUCCESS: RTC Time register is configured
  *          - ERROR: RTC Time register is not configured
  */
ErrorStatus RTC_SetTime(uint32_t RTC_Format, RTC_TimeTypeDef* RTC_TimeStruct)
{
 80100f4:	b590      	push	{r4, r7, lr}
 80100f6:	b085      	sub	sp, #20
 80100f8:	af00      	add	r7, sp, #0
 80100fa:	6078      	str	r0, [r7, #4]
 80100fc:	6039      	str	r1, [r7, #0]
  uint32_t tmpreg = 0;
 80100fe:	2300      	movs	r3, #0
 8010100:	60fb      	str	r3, [r7, #12]
  ErrorStatus status = ERROR;
 8010102:	2300      	movs	r3, #0
 8010104:	72fb      	strb	r3, [r7, #11]
    
  /* Check the parameters */
  assert_param(IS_RTC_FORMAT(RTC_Format));
  
  if (RTC_Format == RTC_Format_BIN)
 8010106:	687b      	ldr	r3, [r7, #4]
 8010108:	2b00      	cmp	r3, #0
 801010a:	d109      	bne.n	8010120 <RTC_SetTime+0x2c>
  {
    if ((RTC->CR & RTC_CR_FMT) != (uint32_t)RESET)
 801010c:	4b3d      	ldr	r3, [pc, #244]	; (8010204 <RTC_SetTime+0x110>)
 801010e:	689b      	ldr	r3, [r3, #8]
 8010110:	f003 0340 	and.w	r3, r3, #64	; 0x40
 8010114:	2b00      	cmp	r3, #0
 8010116:	d114      	bne.n	8010142 <RTC_SetTime+0x4e>
      assert_param(IS_RTC_HOUR12(RTC_TimeStruct->RTC_Hours));
      assert_param(IS_RTC_H12(RTC_TimeStruct->RTC_H12));
    } 
    else
    {
      RTC_TimeStruct->RTC_H12 = 0x00;
 8010118:	683b      	ldr	r3, [r7, #0]
 801011a:	2200      	movs	r2, #0
 801011c:	70da      	strb	r2, [r3, #3]
 801011e:	e010      	b.n	8010142 <RTC_SetTime+0x4e>
    assert_param(IS_RTC_MINUTES(RTC_TimeStruct->RTC_Minutes));
    assert_param(IS_RTC_SECONDS(RTC_TimeStruct->RTC_Seconds));
  }
  else
  {
    if ((RTC->CR & RTC_CR_FMT) != (uint32_t)RESET)
 8010120:	4b38      	ldr	r3, [pc, #224]	; (8010204 <RTC_SetTime+0x110>)
 8010122:	689b      	ldr	r3, [r3, #8]
 8010124:	f003 0340 	and.w	r3, r3, #64	; 0x40
 8010128:	2b00      	cmp	r3, #0
 801012a:	d007      	beq.n	801013c <RTC_SetTime+0x48>
    {
      tmpreg = RTC_Bcd2ToByte(RTC_TimeStruct->RTC_Hours);
 801012c:	683b      	ldr	r3, [r7, #0]
 801012e:	781b      	ldrb	r3, [r3, #0]
 8010130:	4618      	mov	r0, r3
 8010132:	f001 f8a6 	bl	8011282 <RTC_Bcd2ToByte>
 8010136:	4603      	mov	r3, r0
 8010138:	60fb      	str	r3, [r7, #12]
 801013a:	e002      	b.n	8010142 <RTC_SetTime+0x4e>
      assert_param(IS_RTC_HOUR12(tmpreg));
      assert_param(IS_RTC_H12(RTC_TimeStruct->RTC_H12)); 
    } 
    else
    {
      RTC_TimeStruct->RTC_H12 = 0x00;
 801013c:	683b      	ldr	r3, [r7, #0]
 801013e:	2200      	movs	r2, #0
 8010140:	70da      	strb	r2, [r3, #3]
    assert_param(IS_RTC_MINUTES(RTC_Bcd2ToByte(RTC_TimeStruct->RTC_Minutes)));
    assert_param(IS_RTC_SECONDS(RTC_Bcd2ToByte(RTC_TimeStruct->RTC_Seconds)));
  }
  
  /* Check the input parameters format */
  if (RTC_Format != RTC_Format_BIN)
 8010142:	687b      	ldr	r3, [r7, #4]
 8010144:	2b00      	cmp	r3, #0
 8010146:	d00f      	beq.n	8010168 <RTC_SetTime+0x74>
  {
    tmpreg = (((uint32_t)(RTC_TimeStruct->RTC_Hours) << 16) | \
 8010148:	683b      	ldr	r3, [r7, #0]
 801014a:	781b      	ldrb	r3, [r3, #0]
 801014c:	041a      	lsls	r2, r3, #16
             ((uint32_t)(RTC_TimeStruct->RTC_Minutes) << 8) | \
 801014e:	683b      	ldr	r3, [r7, #0]
 8010150:	785b      	ldrb	r3, [r3, #1]
 8010152:	021b      	lsls	r3, r3, #8
    tmpreg = (((uint32_t)(RTC_TimeStruct->RTC_Hours) << 16) | \
 8010154:	4313      	orrs	r3, r2
             ((uint32_t)RTC_TimeStruct->RTC_Seconds) | \
 8010156:	683a      	ldr	r2, [r7, #0]
 8010158:	7892      	ldrb	r2, [r2, #2]
             ((uint32_t)(RTC_TimeStruct->RTC_Minutes) << 8) | \
 801015a:	431a      	orrs	r2, r3
             ((uint32_t)(RTC_TimeStruct->RTC_H12) << 16)); 
 801015c:	683b      	ldr	r3, [r7, #0]
 801015e:	78db      	ldrb	r3, [r3, #3]
 8010160:	041b      	lsls	r3, r3, #16
    tmpreg = (((uint32_t)(RTC_TimeStruct->RTC_Hours) << 16) | \
 8010162:	4313      	orrs	r3, r2
 8010164:	60fb      	str	r3, [r7, #12]
 8010166:	e01b      	b.n	80101a0 <RTC_SetTime+0xac>
  }  
  else
  {
    tmpreg = (uint32_t)(((uint32_t)RTC_ByteToBcd2(RTC_TimeStruct->RTC_Hours) << 16) | \
 8010168:	683b      	ldr	r3, [r7, #0]
 801016a:	781b      	ldrb	r3, [r3, #0]
 801016c:	4618      	mov	r0, r3
 801016e:	f001 f86b 	bl	8011248 <RTC_ByteToBcd2>
 8010172:	4603      	mov	r3, r0
 8010174:	041c      	lsls	r4, r3, #16
                   ((uint32_t)RTC_ByteToBcd2(RTC_TimeStruct->RTC_Minutes) << 8) | \
 8010176:	683b      	ldr	r3, [r7, #0]
 8010178:	785b      	ldrb	r3, [r3, #1]
 801017a:	4618      	mov	r0, r3
 801017c:	f001 f864 	bl	8011248 <RTC_ByteToBcd2>
 8010180:	4603      	mov	r3, r0
 8010182:	021b      	lsls	r3, r3, #8
    tmpreg = (uint32_t)(((uint32_t)RTC_ByteToBcd2(RTC_TimeStruct->RTC_Hours) << 16) | \
 8010184:	431c      	orrs	r4, r3
                   ((uint32_t)RTC_ByteToBcd2(RTC_TimeStruct->RTC_Seconds)) | \
 8010186:	683b      	ldr	r3, [r7, #0]
 8010188:	789b      	ldrb	r3, [r3, #2]
 801018a:	4618      	mov	r0, r3
 801018c:	f001 f85c 	bl	8011248 <RTC_ByteToBcd2>
 8010190:	4603      	mov	r3, r0
                   ((uint32_t)RTC_ByteToBcd2(RTC_TimeStruct->RTC_Minutes) << 8) | \
 8010192:	ea44 0203 	orr.w	r2, r4, r3
                   (((uint32_t)RTC_TimeStruct->RTC_H12) << 16));
 8010196:	683b      	ldr	r3, [r7, #0]
 8010198:	78db      	ldrb	r3, [r3, #3]
 801019a:	041b      	lsls	r3, r3, #16
    tmpreg = (uint32_t)(((uint32_t)RTC_ByteToBcd2(RTC_TimeStruct->RTC_Hours) << 16) | \
 801019c:	4313      	orrs	r3, r2
 801019e:	60fb      	str	r3, [r7, #12]
  }  

  /* Disable the write protection for RTC registers */
  RTC->WPR = 0xCA;
 80101a0:	4b18      	ldr	r3, [pc, #96]	; (8010204 <RTC_SetTime+0x110>)
 80101a2:	22ca      	movs	r2, #202	; 0xca
 80101a4:	625a      	str	r2, [r3, #36]	; 0x24
  RTC->WPR = 0x53;
 80101a6:	4b17      	ldr	r3, [pc, #92]	; (8010204 <RTC_SetTime+0x110>)
 80101a8:	2253      	movs	r2, #83	; 0x53
 80101aa:	625a      	str	r2, [r3, #36]	; 0x24

  /* Set Initialization mode */
  if (RTC_EnterInitMode() == ERROR)
 80101ac:	f7ff fec2 	bl	800ff34 <RTC_EnterInitMode>
 80101b0:	4603      	mov	r3, r0
 80101b2:	2b00      	cmp	r3, #0
 80101b4:	d102      	bne.n	80101bc <RTC_SetTime+0xc8>
  {
    status = ERROR;
 80101b6:	2300      	movs	r3, #0
 80101b8:	72fb      	strb	r3, [r7, #11]
 80101ba:	e01b      	b.n	80101f4 <RTC_SetTime+0x100>
  } 
  else
  {
    /* Set the RTC_TR register */
    RTC->TR = (uint32_t)(tmpreg & RTC_TR_RESERVED_MASK);
 80101bc:	4a11      	ldr	r2, [pc, #68]	; (8010204 <RTC_SetTime+0x110>)
 80101be:	68fb      	ldr	r3, [r7, #12]
 80101c0:	f003 337f 	and.w	r3, r3, #2139062143	; 0x7f7f7f7f
 80101c4:	f023 43fe 	bic.w	r3, r3, #2130706432	; 0x7f000000
 80101c8:	6013      	str	r3, [r2, #0]

    /* Exit Initialization mode */
    RTC_ExitInitMode(); 
 80101ca:	f7ff feed 	bl	800ffa8 <RTC_ExitInitMode>

    /* If  RTC_CR_BYPSHAD bit = 0, wait for synchro else this check is not needed */
    if ((RTC->CR & RTC_CR_BYPSHAD) == RESET)
 80101ce:	4b0d      	ldr	r3, [pc, #52]	; (8010204 <RTC_SetTime+0x110>)
 80101d0:	689b      	ldr	r3, [r3, #8]
 80101d2:	f003 0320 	and.w	r3, r3, #32
 80101d6:	2b00      	cmp	r3, #0
 80101d8:	d10a      	bne.n	80101f0 <RTC_SetTime+0xfc>
    {
      if (RTC_WaitForSynchro() == ERROR)
 80101da:	f7ff fef5 	bl	800ffc8 <RTC_WaitForSynchro>
 80101de:	4603      	mov	r3, r0
 80101e0:	2b00      	cmp	r3, #0
 80101e2:	d102      	bne.n	80101ea <RTC_SetTime+0xf6>
      {
        status = ERROR;
 80101e4:	2300      	movs	r3, #0
 80101e6:	72fb      	strb	r3, [r7, #11]
 80101e8:	e004      	b.n	80101f4 <RTC_SetTime+0x100>
      }
      else
      {
        status = SUCCESS;
 80101ea:	2301      	movs	r3, #1
 80101ec:	72fb      	strb	r3, [r7, #11]
 80101ee:	e001      	b.n	80101f4 <RTC_SetTime+0x100>
      }
    }
    else
    {
      status = SUCCESS;
 80101f0:	2301      	movs	r3, #1
 80101f2:	72fb      	strb	r3, [r7, #11]
    }
  }
  /* Enable the write protection for RTC registers */
  RTC->WPR = 0xFF; 
 80101f4:	4b03      	ldr	r3, [pc, #12]	; (8010204 <RTC_SetTime+0x110>)
 80101f6:	22ff      	movs	r2, #255	; 0xff
 80101f8:	625a      	str	r2, [r3, #36]	; 0x24
    
  return status;
 80101fa:	7afb      	ldrb	r3, [r7, #11]
}
 80101fc:	4618      	mov	r0, r3
 80101fe:	3714      	adds	r7, #20
 8010200:	46bd      	mov	sp, r7
 8010202:	bd90      	pop	{r4, r7, pc}
 8010204:	40002800 	.word	0x40002800

08010208 <RTC_TimeStructInit>:
  * @param  RTC_TimeStruct: pointer to a RTC_TimeTypeDef structure which will be 
  *         initialized.
  * @retval None
  */
void RTC_TimeStructInit(RTC_TimeTypeDef* RTC_TimeStruct)
{
 8010208:	b480      	push	{r7}
 801020a:	b083      	sub	sp, #12
 801020c:	af00      	add	r7, sp, #0
 801020e:	6078      	str	r0, [r7, #4]
  /* Time = 00h:00min:00sec */
  RTC_TimeStruct->RTC_H12 = RTC_H12_AM;
 8010210:	687b      	ldr	r3, [r7, #4]
 8010212:	2200      	movs	r2, #0
 8010214:	70da      	strb	r2, [r3, #3]
  RTC_TimeStruct->RTC_Hours = 0;
 8010216:	687b      	ldr	r3, [r7, #4]
 8010218:	2200      	movs	r2, #0
 801021a:	701a      	strb	r2, [r3, #0]
  RTC_TimeStruct->RTC_Minutes = 0;
 801021c:	687b      	ldr	r3, [r7, #4]
 801021e:	2200      	movs	r2, #0
 8010220:	705a      	strb	r2, [r3, #1]
  RTC_TimeStruct->RTC_Seconds = 0; 
 8010222:	687b      	ldr	r3, [r7, #4]
 8010224:	2200      	movs	r2, #0
 8010226:	709a      	strb	r2, [r3, #2]
}
 8010228:	bf00      	nop
 801022a:	370c      	adds	r7, #12
 801022c:	46bd      	mov	sp, r7
 801022e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8010232:	4770      	bx	lr

08010234 <RTC_GetTime>:
  * @param  RTC_TimeStruct: pointer to a RTC_TimeTypeDef structure that will 
  *                        contain the returned current time configuration.     
  * @retval None
  */
void RTC_GetTime(uint32_t RTC_Format, RTC_TimeTypeDef* RTC_TimeStruct)
{
 8010234:	b580      	push	{r7, lr}
 8010236:	b084      	sub	sp, #16
 8010238:	af00      	add	r7, sp, #0
 801023a:	6078      	str	r0, [r7, #4]
 801023c:	6039      	str	r1, [r7, #0]
  uint32_t tmpreg = 0;
 801023e:	2300      	movs	r3, #0
 8010240:	60fb      	str	r3, [r7, #12]

  /* Check the parameters */
  assert_param(IS_RTC_FORMAT(RTC_Format));

  /* Get the RTC_TR register */
  tmpreg = (uint32_t)(RTC->TR & RTC_TR_RESERVED_MASK); 
 8010242:	4b24      	ldr	r3, [pc, #144]	; (80102d4 <RTC_GetTime+0xa0>)
 8010244:	681b      	ldr	r3, [r3, #0]
 8010246:	f003 337f 	and.w	r3, r3, #2139062143	; 0x7f7f7f7f
 801024a:	f023 43fe 	bic.w	r3, r3, #2130706432	; 0x7f000000
 801024e:	60fb      	str	r3, [r7, #12]
  
  /* Fill the structure fields with the read parameters */
  RTC_TimeStruct->RTC_Hours = (uint8_t)((tmpreg & (RTC_TR_HT | RTC_TR_HU)) >> 16);
 8010250:	68fb      	ldr	r3, [r7, #12]
 8010252:	0c1b      	lsrs	r3, r3, #16
 8010254:	b2db      	uxtb	r3, r3
 8010256:	f003 033f 	and.w	r3, r3, #63	; 0x3f
 801025a:	b2da      	uxtb	r2, r3
 801025c:	683b      	ldr	r3, [r7, #0]
 801025e:	701a      	strb	r2, [r3, #0]
  RTC_TimeStruct->RTC_Minutes = (uint8_t)((tmpreg & (RTC_TR_MNT | RTC_TR_MNU)) >>8);
 8010260:	68fb      	ldr	r3, [r7, #12]
 8010262:	0a1b      	lsrs	r3, r3, #8
 8010264:	b2db      	uxtb	r3, r3
 8010266:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 801026a:	b2da      	uxtb	r2, r3
 801026c:	683b      	ldr	r3, [r7, #0]
 801026e:	705a      	strb	r2, [r3, #1]
  RTC_TimeStruct->RTC_Seconds = (uint8_t)(tmpreg & (RTC_TR_ST | RTC_TR_SU));
 8010270:	68fb      	ldr	r3, [r7, #12]
 8010272:	b2db      	uxtb	r3, r3
 8010274:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 8010278:	b2da      	uxtb	r2, r3
 801027a:	683b      	ldr	r3, [r7, #0]
 801027c:	709a      	strb	r2, [r3, #2]
  RTC_TimeStruct->RTC_H12 = (uint8_t)((tmpreg & (RTC_TR_PM)) >> 16);  
 801027e:	68fb      	ldr	r3, [r7, #12]
 8010280:	0c1b      	lsrs	r3, r3, #16
 8010282:	b2db      	uxtb	r3, r3
 8010284:	f003 0340 	and.w	r3, r3, #64	; 0x40
 8010288:	b2da      	uxtb	r2, r3
 801028a:	683b      	ldr	r3, [r7, #0]
 801028c:	70da      	strb	r2, [r3, #3]

  /* Check the input parameters format */
  if (RTC_Format == RTC_Format_BIN)
 801028e:	687b      	ldr	r3, [r7, #4]
 8010290:	2b00      	cmp	r3, #0
 8010292:	d11a      	bne.n	80102ca <RTC_GetTime+0x96>
  {
    /* Convert the structure parameters to Binary format */
    RTC_TimeStruct->RTC_Hours = (uint8_t)RTC_Bcd2ToByte(RTC_TimeStruct->RTC_Hours);
 8010294:	683b      	ldr	r3, [r7, #0]
 8010296:	781b      	ldrb	r3, [r3, #0]
 8010298:	4618      	mov	r0, r3
 801029a:	f000 fff2 	bl	8011282 <RTC_Bcd2ToByte>
 801029e:	4603      	mov	r3, r0
 80102a0:	461a      	mov	r2, r3
 80102a2:	683b      	ldr	r3, [r7, #0]
 80102a4:	701a      	strb	r2, [r3, #0]
    RTC_TimeStruct->RTC_Minutes = (uint8_t)RTC_Bcd2ToByte(RTC_TimeStruct->RTC_Minutes);
 80102a6:	683b      	ldr	r3, [r7, #0]
 80102a8:	785b      	ldrb	r3, [r3, #1]
 80102aa:	4618      	mov	r0, r3
 80102ac:	f000 ffe9 	bl	8011282 <RTC_Bcd2ToByte>
 80102b0:	4603      	mov	r3, r0
 80102b2:	461a      	mov	r2, r3
 80102b4:	683b      	ldr	r3, [r7, #0]
 80102b6:	705a      	strb	r2, [r3, #1]
    RTC_TimeStruct->RTC_Seconds = (uint8_t)RTC_Bcd2ToByte(RTC_TimeStruct->RTC_Seconds);   
 80102b8:	683b      	ldr	r3, [r7, #0]
 80102ba:	789b      	ldrb	r3, [r3, #2]
 80102bc:	4618      	mov	r0, r3
 80102be:	f000 ffe0 	bl	8011282 <RTC_Bcd2ToByte>
 80102c2:	4603      	mov	r3, r0
 80102c4:	461a      	mov	r2, r3
 80102c6:	683b      	ldr	r3, [r7, #0]
 80102c8:	709a      	strb	r2, [r3, #2]
  }
}
 80102ca:	bf00      	nop
 80102cc:	3710      	adds	r7, #16
 80102ce:	46bd      	mov	sp, r7
 80102d0:	bd80      	pop	{r7, pc}
 80102d2:	bf00      	nop
 80102d4:	40002800 	.word	0x40002800

080102d8 <RTC_GetSubSecond>:
  *         SSR register.
  * @param  None
  * @retval RTC current Calendar Subseconds value.
  */
uint32_t RTC_GetSubSecond(void)
{
 80102d8:	b480      	push	{r7}
 80102da:	b083      	sub	sp, #12
 80102dc:	af00      	add	r7, sp, #0
  uint32_t tmpreg = 0;
 80102de:	2300      	movs	r3, #0
 80102e0:	607b      	str	r3, [r7, #4]
  
  /* Get subseconds values from the correspondent registers*/
  tmpreg = (uint32_t)(RTC->SSR);
 80102e2:	4b06      	ldr	r3, [pc, #24]	; (80102fc <RTC_GetSubSecond+0x24>)
 80102e4:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 80102e6:	607b      	str	r3, [r7, #4]
  
  /* Read DR register to unfroze calendar registers */
  (void) (RTC->DR);
 80102e8:	4b04      	ldr	r3, [pc, #16]	; (80102fc <RTC_GetSubSecond+0x24>)
 80102ea:	685b      	ldr	r3, [r3, #4]
  
  return (tmpreg);
 80102ec:	687b      	ldr	r3, [r7, #4]
}
 80102ee:	4618      	mov	r0, r3
 80102f0:	370c      	adds	r7, #12
 80102f2:	46bd      	mov	sp, r7
 80102f4:	f85d 7b04 	ldr.w	r7, [sp], #4
 80102f8:	4770      	bx	lr
 80102fa:	bf00      	nop
 80102fc:	40002800 	.word	0x40002800

08010300 <RTC_SetDate>:
  * @retval An ErrorStatus enumeration value:
  *          - SUCCESS: RTC Date register is configured
  *          - ERROR: RTC Date register is not configured
  */
ErrorStatus RTC_SetDate(uint32_t RTC_Format, RTC_DateTypeDef* RTC_DateStruct)
{
 8010300:	b590      	push	{r4, r7, lr}
 8010302:	b085      	sub	sp, #20
 8010304:	af00      	add	r7, sp, #0
 8010306:	6078      	str	r0, [r7, #4]
 8010308:	6039      	str	r1, [r7, #0]
  uint32_t tmpreg = 0;
 801030a:	2300      	movs	r3, #0
 801030c:	60fb      	str	r3, [r7, #12]
  ErrorStatus status = ERROR;
 801030e:	2300      	movs	r3, #0
 8010310:	72fb      	strb	r3, [r7, #11]
  
  /* Check the parameters */
  assert_param(IS_RTC_FORMAT(RTC_Format));

  if ((RTC_Format == RTC_Format_BIN) && ((RTC_DateStruct->RTC_Month & 0x10) == 0x10))
 8010312:	687b      	ldr	r3, [r7, #4]
 8010314:	2b00      	cmp	r3, #0
 8010316:	d10e      	bne.n	8010336 <RTC_SetDate+0x36>
 8010318:	683b      	ldr	r3, [r7, #0]
 801031a:	785b      	ldrb	r3, [r3, #1]
 801031c:	f003 0310 	and.w	r3, r3, #16
 8010320:	2b00      	cmp	r3, #0
 8010322:	d008      	beq.n	8010336 <RTC_SetDate+0x36>
  {
    RTC_DateStruct->RTC_Month = (RTC_DateStruct->RTC_Month & (uint32_t)~(0x10)) + 0x0A;
 8010324:	683b      	ldr	r3, [r7, #0]
 8010326:	785b      	ldrb	r3, [r3, #1]
 8010328:	f023 0310 	bic.w	r3, r3, #16
 801032c:	b2db      	uxtb	r3, r3
 801032e:	330a      	adds	r3, #10
 8010330:	b2da      	uxtb	r2, r3
 8010332:	683b      	ldr	r3, [r7, #0]
 8010334:	705a      	strb	r2, [r3, #1]
  }  
  if (RTC_Format == RTC_Format_BIN)
 8010336:	687b      	ldr	r3, [r7, #4]
 8010338:	2b00      	cmp	r3, #0
 801033a:	d00d      	beq.n	8010358 <RTC_SetDate+0x58>
    assert_param(IS_RTC_DATE(RTC_DateStruct->RTC_Date));
  }
  else
  {
    assert_param(IS_RTC_YEAR(RTC_Bcd2ToByte(RTC_DateStruct->RTC_Year)));
    tmpreg = RTC_Bcd2ToByte(RTC_DateStruct->RTC_Month);
 801033c:	683b      	ldr	r3, [r7, #0]
 801033e:	785b      	ldrb	r3, [r3, #1]
 8010340:	4618      	mov	r0, r3
 8010342:	f000 ff9e 	bl	8011282 <RTC_Bcd2ToByte>
 8010346:	4603      	mov	r3, r0
 8010348:	60fb      	str	r3, [r7, #12]
    assert_param(IS_RTC_MONTH(tmpreg));
    tmpreg = RTC_Bcd2ToByte(RTC_DateStruct->RTC_Date);
 801034a:	683b      	ldr	r3, [r7, #0]
 801034c:	789b      	ldrb	r3, [r3, #2]
 801034e:	4618      	mov	r0, r3
 8010350:	f000 ff97 	bl	8011282 <RTC_Bcd2ToByte>
 8010354:	4603      	mov	r3, r0
 8010356:	60fb      	str	r3, [r7, #12]
    assert_param(IS_RTC_DATE(tmpreg));
  }
  assert_param(IS_RTC_WEEKDAY(RTC_DateStruct->RTC_WeekDay));

  /* Check the input parameters format */
  if (RTC_Format != RTC_Format_BIN)
 8010358:	687b      	ldr	r3, [r7, #4]
 801035a:	2b00      	cmp	r3, #0
 801035c:	d00f      	beq.n	801037e <RTC_SetDate+0x7e>
  {
    tmpreg = ((((uint32_t)RTC_DateStruct->RTC_Year) << 16) | \
 801035e:	683b      	ldr	r3, [r7, #0]
 8010360:	78db      	ldrb	r3, [r3, #3]
 8010362:	041a      	lsls	r2, r3, #16
              (((uint32_t)RTC_DateStruct->RTC_Month) << 8) | \
 8010364:	683b      	ldr	r3, [r7, #0]
 8010366:	785b      	ldrb	r3, [r3, #1]
 8010368:	021b      	lsls	r3, r3, #8
    tmpreg = ((((uint32_t)RTC_DateStruct->RTC_Year) << 16) | \
 801036a:	4313      	orrs	r3, r2
              ((uint32_t)RTC_DateStruct->RTC_Date) | \
 801036c:	683a      	ldr	r2, [r7, #0]
 801036e:	7892      	ldrb	r2, [r2, #2]
              (((uint32_t)RTC_DateStruct->RTC_Month) << 8) | \
 8010370:	431a      	orrs	r2, r3
              (((uint32_t)RTC_DateStruct->RTC_WeekDay) << 13)); 
 8010372:	683b      	ldr	r3, [r7, #0]
 8010374:	781b      	ldrb	r3, [r3, #0]
 8010376:	035b      	lsls	r3, r3, #13
    tmpreg = ((((uint32_t)RTC_DateStruct->RTC_Year) << 16) | \
 8010378:	4313      	orrs	r3, r2
 801037a:	60fb      	str	r3, [r7, #12]
 801037c:	e01b      	b.n	80103b6 <RTC_SetDate+0xb6>
  }  
  else
  {
    tmpreg = (((uint32_t)RTC_ByteToBcd2(RTC_DateStruct->RTC_Year) << 16) | \
 801037e:	683b      	ldr	r3, [r7, #0]
 8010380:	78db      	ldrb	r3, [r3, #3]
 8010382:	4618      	mov	r0, r3
 8010384:	f000 ff60 	bl	8011248 <RTC_ByteToBcd2>
 8010388:	4603      	mov	r3, r0
 801038a:	041c      	lsls	r4, r3, #16
              ((uint32_t)RTC_ByteToBcd2(RTC_DateStruct->RTC_Month) << 8) | \
 801038c:	683b      	ldr	r3, [r7, #0]
 801038e:	785b      	ldrb	r3, [r3, #1]
 8010390:	4618      	mov	r0, r3
 8010392:	f000 ff59 	bl	8011248 <RTC_ByteToBcd2>
 8010396:	4603      	mov	r3, r0
 8010398:	021b      	lsls	r3, r3, #8
    tmpreg = (((uint32_t)RTC_ByteToBcd2(RTC_DateStruct->RTC_Year) << 16) | \
 801039a:	431c      	orrs	r4, r3
              ((uint32_t)RTC_ByteToBcd2(RTC_DateStruct->RTC_Date)) | \
 801039c:	683b      	ldr	r3, [r7, #0]
 801039e:	789b      	ldrb	r3, [r3, #2]
 80103a0:	4618      	mov	r0, r3
 80103a2:	f000 ff51 	bl	8011248 <RTC_ByteToBcd2>
 80103a6:	4603      	mov	r3, r0
              ((uint32_t)RTC_ByteToBcd2(RTC_DateStruct->RTC_Month) << 8) | \
 80103a8:	ea44 0203 	orr.w	r2, r4, r3
              ((uint32_t)RTC_DateStruct->RTC_WeekDay << 13));
 80103ac:	683b      	ldr	r3, [r7, #0]
 80103ae:	781b      	ldrb	r3, [r3, #0]
 80103b0:	035b      	lsls	r3, r3, #13
    tmpreg = (((uint32_t)RTC_ByteToBcd2(RTC_DateStruct->RTC_Year) << 16) | \
 80103b2:	4313      	orrs	r3, r2
 80103b4:	60fb      	str	r3, [r7, #12]
  }

  /* Disable the write protection for RTC registers */
  RTC->WPR = 0xCA;
 80103b6:	4b19      	ldr	r3, [pc, #100]	; (801041c <RTC_SetDate+0x11c>)
 80103b8:	22ca      	movs	r2, #202	; 0xca
 80103ba:	625a      	str	r2, [r3, #36]	; 0x24
  RTC->WPR = 0x53;
 80103bc:	4b17      	ldr	r3, [pc, #92]	; (801041c <RTC_SetDate+0x11c>)
 80103be:	2253      	movs	r2, #83	; 0x53
 80103c0:	625a      	str	r2, [r3, #36]	; 0x24

  /* Set Initialization mode */
  if (RTC_EnterInitMode() == ERROR)
 80103c2:	f7ff fdb7 	bl	800ff34 <RTC_EnterInitMode>
 80103c6:	4603      	mov	r3, r0
 80103c8:	2b00      	cmp	r3, #0
 80103ca:	d102      	bne.n	80103d2 <RTC_SetDate+0xd2>
  {
    status = ERROR;
 80103cc:	2300      	movs	r3, #0
 80103ce:	72fb      	strb	r3, [r7, #11]
 80103d0:	e01b      	b.n	801040a <RTC_SetDate+0x10a>
  } 
  else
  {
    /* Set the RTC_DR register */
    RTC->DR = (uint32_t)(tmpreg & RTC_DR_RESERVED_MASK);
 80103d2:	4a12      	ldr	r2, [pc, #72]	; (801041c <RTC_SetDate+0x11c>)
 80103d4:	68fb      	ldr	r3, [r7, #12]
 80103d6:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
 80103da:	f023 03c0 	bic.w	r3, r3, #192	; 0xc0
 80103de:	6053      	str	r3, [r2, #4]

    /* Exit Initialization mode */
    RTC_ExitInitMode(); 
 80103e0:	f7ff fde2 	bl	800ffa8 <RTC_ExitInitMode>

    /* If  RTC_CR_BYPSHAD bit = 0, wait for synchro else this check is not needed */
    if ((RTC->CR & RTC_CR_BYPSHAD) == RESET)
 80103e4:	4b0d      	ldr	r3, [pc, #52]	; (801041c <RTC_SetDate+0x11c>)
 80103e6:	689b      	ldr	r3, [r3, #8]
 80103e8:	f003 0320 	and.w	r3, r3, #32
 80103ec:	2b00      	cmp	r3, #0
 80103ee:	d10a      	bne.n	8010406 <RTC_SetDate+0x106>
    {
      if (RTC_WaitForSynchro() == ERROR)
 80103f0:	f7ff fdea 	bl	800ffc8 <RTC_WaitForSynchro>
 80103f4:	4603      	mov	r3, r0
 80103f6:	2b00      	cmp	r3, #0
 80103f8:	d102      	bne.n	8010400 <RTC_SetDate+0x100>
      {
        status = ERROR;
 80103fa:	2300      	movs	r3, #0
 80103fc:	72fb      	strb	r3, [r7, #11]
 80103fe:	e004      	b.n	801040a <RTC_SetDate+0x10a>
      }
      else
      {
        status = SUCCESS;
 8010400:	2301      	movs	r3, #1
 8010402:	72fb      	strb	r3, [r7, #11]
 8010404:	e001      	b.n	801040a <RTC_SetDate+0x10a>
      }
    }
    else
    {
      status = SUCCESS;
 8010406:	2301      	movs	r3, #1
 8010408:	72fb      	strb	r3, [r7, #11]
    }
  }
  /* Enable the write protection for RTC registers */
  RTC->WPR = 0xFF;   
 801040a:	4b04      	ldr	r3, [pc, #16]	; (801041c <RTC_SetDate+0x11c>)
 801040c:	22ff      	movs	r2, #255	; 0xff
 801040e:	625a      	str	r2, [r3, #36]	; 0x24
  
  return status;
 8010410:	7afb      	ldrb	r3, [r7, #11]
}
 8010412:	4618      	mov	r0, r3
 8010414:	3714      	adds	r7, #20
 8010416:	46bd      	mov	sp, r7
 8010418:	bd90      	pop	{r4, r7, pc}
 801041a:	bf00      	nop
 801041c:	40002800 	.word	0x40002800

08010420 <RTC_DateStructInit>:
  * @param  RTC_DateStruct: pointer to a RTC_DateTypeDef structure which will be 
  *         initialized.
  * @retval None
  */
void RTC_DateStructInit(RTC_DateTypeDef* RTC_DateStruct)
{
 8010420:	b480      	push	{r7}
 8010422:	b083      	sub	sp, #12
 8010424:	af00      	add	r7, sp, #0
 8010426:	6078      	str	r0, [r7, #4]
  /* Monday, January 01 xx00 */
  RTC_DateStruct->RTC_WeekDay = RTC_Weekday_Monday;
 8010428:	687b      	ldr	r3, [r7, #4]
 801042a:	2201      	movs	r2, #1
 801042c:	701a      	strb	r2, [r3, #0]
  RTC_DateStruct->RTC_Date = 1;
 801042e:	687b      	ldr	r3, [r7, #4]
 8010430:	2201      	movs	r2, #1
 8010432:	709a      	strb	r2, [r3, #2]
  RTC_DateStruct->RTC_Month = RTC_Month_January;
 8010434:	687b      	ldr	r3, [r7, #4]
 8010436:	2201      	movs	r2, #1
 8010438:	705a      	strb	r2, [r3, #1]
  RTC_DateStruct->RTC_Year = 0;
 801043a:	687b      	ldr	r3, [r7, #4]
 801043c:	2200      	movs	r2, #0
 801043e:	70da      	strb	r2, [r3, #3]
}
 8010440:	bf00      	nop
 8010442:	370c      	adds	r7, #12
 8010444:	46bd      	mov	sp, r7
 8010446:	f85d 7b04 	ldr.w	r7, [sp], #4
 801044a:	4770      	bx	lr

0801044c <RTC_GetDate>:
  * @param RTC_DateStruct: pointer to a RTC_DateTypeDef structure that will 
  *                        contain the returned current date configuration.     
  * @retval None
  */
void RTC_GetDate(uint32_t RTC_Format, RTC_DateTypeDef* RTC_DateStruct)
{
 801044c:	b580      	push	{r7, lr}
 801044e:	b084      	sub	sp, #16
 8010450:	af00      	add	r7, sp, #0
 8010452:	6078      	str	r0, [r7, #4]
 8010454:	6039      	str	r1, [r7, #0]
  uint32_t tmpreg = 0;
 8010456:	2300      	movs	r3, #0
 8010458:	60fb      	str	r3, [r7, #12]

  /* Check the parameters */
  assert_param(IS_RTC_FORMAT(RTC_Format));
  
  /* Get the RTC_TR register */
  tmpreg = (uint32_t)(RTC->DR & RTC_DR_RESERVED_MASK); 
 801045a:	4b22      	ldr	r3, [pc, #136]	; (80104e4 <RTC_GetDate+0x98>)
 801045c:	685b      	ldr	r3, [r3, #4]
 801045e:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
 8010462:	f023 03c0 	bic.w	r3, r3, #192	; 0xc0
 8010466:	60fb      	str	r3, [r7, #12]

  /* Fill the structure fields with the read parameters */
  RTC_DateStruct->RTC_Year = (uint8_t)((tmpreg & (RTC_DR_YT | RTC_DR_YU)) >> 16);
 8010468:	68fb      	ldr	r3, [r7, #12]
 801046a:	0c1b      	lsrs	r3, r3, #16
 801046c:	b2da      	uxtb	r2, r3
 801046e:	683b      	ldr	r3, [r7, #0]
 8010470:	70da      	strb	r2, [r3, #3]
  RTC_DateStruct->RTC_Month = (uint8_t)((tmpreg & (RTC_DR_MT | RTC_DR_MU)) >> 8);
 8010472:	68fb      	ldr	r3, [r7, #12]
 8010474:	0a1b      	lsrs	r3, r3, #8
 8010476:	b2db      	uxtb	r3, r3
 8010478:	f003 031f 	and.w	r3, r3, #31
 801047c:	b2da      	uxtb	r2, r3
 801047e:	683b      	ldr	r3, [r7, #0]
 8010480:	705a      	strb	r2, [r3, #1]
  RTC_DateStruct->RTC_Date = (uint8_t)(tmpreg & (RTC_DR_DT | RTC_DR_DU));
 8010482:	68fb      	ldr	r3, [r7, #12]
 8010484:	b2db      	uxtb	r3, r3
 8010486:	f003 033f 	and.w	r3, r3, #63	; 0x3f
 801048a:	b2da      	uxtb	r2, r3
 801048c:	683b      	ldr	r3, [r7, #0]
 801048e:	709a      	strb	r2, [r3, #2]
  RTC_DateStruct->RTC_WeekDay = (uint8_t)((tmpreg & (RTC_DR_WDU)) >> 13);
 8010490:	68fb      	ldr	r3, [r7, #12]
 8010492:	0b5b      	lsrs	r3, r3, #13
 8010494:	b2db      	uxtb	r3, r3
 8010496:	f003 0307 	and.w	r3, r3, #7
 801049a:	b2da      	uxtb	r2, r3
 801049c:	683b      	ldr	r3, [r7, #0]
 801049e:	701a      	strb	r2, [r3, #0]

  /* Check the input parameters format */
  if (RTC_Format == RTC_Format_BIN)
 80104a0:	687b      	ldr	r3, [r7, #4]
 80104a2:	2b00      	cmp	r3, #0
 80104a4:	d11a      	bne.n	80104dc <RTC_GetDate+0x90>
  {
    /* Convert the structure parameters to Binary format */
    RTC_DateStruct->RTC_Year = (uint8_t)RTC_Bcd2ToByte(RTC_DateStruct->RTC_Year);
 80104a6:	683b      	ldr	r3, [r7, #0]
 80104a8:	78db      	ldrb	r3, [r3, #3]
 80104aa:	4618      	mov	r0, r3
 80104ac:	f000 fee9 	bl	8011282 <RTC_Bcd2ToByte>
 80104b0:	4603      	mov	r3, r0
 80104b2:	461a      	mov	r2, r3
 80104b4:	683b      	ldr	r3, [r7, #0]
 80104b6:	70da      	strb	r2, [r3, #3]
    RTC_DateStruct->RTC_Month = (uint8_t)RTC_Bcd2ToByte(RTC_DateStruct->RTC_Month);
 80104b8:	683b      	ldr	r3, [r7, #0]
 80104ba:	785b      	ldrb	r3, [r3, #1]
 80104bc:	4618      	mov	r0, r3
 80104be:	f000 fee0 	bl	8011282 <RTC_Bcd2ToByte>
 80104c2:	4603      	mov	r3, r0
 80104c4:	461a      	mov	r2, r3
 80104c6:	683b      	ldr	r3, [r7, #0]
 80104c8:	705a      	strb	r2, [r3, #1]
    RTC_DateStruct->RTC_Date = (uint8_t)RTC_Bcd2ToByte(RTC_DateStruct->RTC_Date);
 80104ca:	683b      	ldr	r3, [r7, #0]
 80104cc:	789b      	ldrb	r3, [r3, #2]
 80104ce:	4618      	mov	r0, r3
 80104d0:	f000 fed7 	bl	8011282 <RTC_Bcd2ToByte>
 80104d4:	4603      	mov	r3, r0
 80104d6:	461a      	mov	r2, r3
 80104d8:	683b      	ldr	r3, [r7, #0]
 80104da:	709a      	strb	r2, [r3, #2]
  }
}
 80104dc:	bf00      	nop
 80104de:	3710      	adds	r7, #16
 80104e0:	46bd      	mov	sp, r7
 80104e2:	bd80      	pop	{r7, pc}
 80104e4:	40002800 	.word	0x40002800

080104e8 <RTC_SetAlarm>:
  * @param  RTC_AlarmStruct: pointer to a RTC_AlarmTypeDef structure that 
  *                          contains the alarm configuration parameters.     
  * @retval None
  */
void RTC_SetAlarm(uint32_t RTC_Format, uint32_t RTC_Alarm, RTC_AlarmTypeDef* RTC_AlarmStruct)
{
 80104e8:	b590      	push	{r4, r7, lr}
 80104ea:	b087      	sub	sp, #28
 80104ec:	af00      	add	r7, sp, #0
 80104ee:	60f8      	str	r0, [r7, #12]
 80104f0:	60b9      	str	r1, [r7, #8]
 80104f2:	607a      	str	r2, [r7, #4]
  uint32_t tmpreg = 0;
 80104f4:	2300      	movs	r3, #0
 80104f6:	617b      	str	r3, [r7, #20]
  assert_param(IS_RTC_FORMAT(RTC_Format));
  assert_param(IS_RTC_ALARM(RTC_Alarm));
  assert_param(IS_ALARM_MASK(RTC_AlarmStruct->RTC_AlarmMask));
  assert_param(IS_RTC_ALARM_DATE_WEEKDAY_SEL(RTC_AlarmStruct->RTC_AlarmDateWeekDaySel));

  if (RTC_Format == RTC_Format_BIN)
 80104f8:	68fb      	ldr	r3, [r7, #12]
 80104fa:	2b00      	cmp	r3, #0
 80104fc:	d109      	bne.n	8010512 <RTC_SetAlarm+0x2a>
  {
    if ((RTC->CR & RTC_CR_FMT) != (uint32_t)RESET)
 80104fe:	4b47      	ldr	r3, [pc, #284]	; (801061c <RTC_SetAlarm+0x134>)
 8010500:	689b      	ldr	r3, [r3, #8]
 8010502:	f003 0340 	and.w	r3, r3, #64	; 0x40
 8010506:	2b00      	cmp	r3, #0
 8010508:	d127      	bne.n	801055a <RTC_SetAlarm+0x72>
      assert_param(IS_RTC_HOUR12(RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours));
      assert_param(IS_RTC_H12(RTC_AlarmStruct->RTC_AlarmTime.RTC_H12));
    } 
    else
    {
      RTC_AlarmStruct->RTC_AlarmTime.RTC_H12 = 0x00;
 801050a:	687b      	ldr	r3, [r7, #4]
 801050c:	2200      	movs	r2, #0
 801050e:	70da      	strb	r2, [r3, #3]
 8010510:	e023      	b.n	801055a <RTC_SetAlarm+0x72>
      assert_param(IS_RTC_ALARM_DATE_WEEKDAY_WEEKDAY(RTC_AlarmStruct->RTC_AlarmDateWeekDay));
    }
  }
  else
  {
    if ((RTC->CR & RTC_CR_FMT) != (uint32_t)RESET)
 8010512:	4b42      	ldr	r3, [pc, #264]	; (801061c <RTC_SetAlarm+0x134>)
 8010514:	689b      	ldr	r3, [r3, #8]
 8010516:	f003 0340 	and.w	r3, r3, #64	; 0x40
 801051a:	2b00      	cmp	r3, #0
 801051c:	d007      	beq.n	801052e <RTC_SetAlarm+0x46>
    {
      tmpreg = RTC_Bcd2ToByte(RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours);
 801051e:	687b      	ldr	r3, [r7, #4]
 8010520:	781b      	ldrb	r3, [r3, #0]
 8010522:	4618      	mov	r0, r3
 8010524:	f000 fead 	bl	8011282 <RTC_Bcd2ToByte>
 8010528:	4603      	mov	r3, r0
 801052a:	617b      	str	r3, [r7, #20]
 801052c:	e002      	b.n	8010534 <RTC_SetAlarm+0x4c>
      assert_param(IS_RTC_HOUR12(tmpreg));
      assert_param(IS_RTC_H12(RTC_AlarmStruct->RTC_AlarmTime.RTC_H12));
    } 
    else
    {
      RTC_AlarmStruct->RTC_AlarmTime.RTC_H12 = 0x00;
 801052e:	687b      	ldr	r3, [r7, #4]
 8010530:	2200      	movs	r2, #0
 8010532:	70da      	strb	r2, [r3, #3]
    }
    
    assert_param(IS_RTC_MINUTES(RTC_Bcd2ToByte(RTC_AlarmStruct->RTC_AlarmTime.RTC_Minutes)));
    assert_param(IS_RTC_SECONDS(RTC_Bcd2ToByte(RTC_AlarmStruct->RTC_AlarmTime.RTC_Seconds)));
    
    if(RTC_AlarmStruct->RTC_AlarmDateWeekDaySel == RTC_AlarmDateWeekDaySel_Date)
 8010534:	687b      	ldr	r3, [r7, #4]
 8010536:	689b      	ldr	r3, [r3, #8]
 8010538:	2b00      	cmp	r3, #0
 801053a:	d107      	bne.n	801054c <RTC_SetAlarm+0x64>
    {
      tmpreg = RTC_Bcd2ToByte(RTC_AlarmStruct->RTC_AlarmDateWeekDay);
 801053c:	687b      	ldr	r3, [r7, #4]
 801053e:	7b1b      	ldrb	r3, [r3, #12]
 8010540:	4618      	mov	r0, r3
 8010542:	f000 fe9e 	bl	8011282 <RTC_Bcd2ToByte>
 8010546:	4603      	mov	r3, r0
 8010548:	617b      	str	r3, [r7, #20]
 801054a:	e006      	b.n	801055a <RTC_SetAlarm+0x72>
      assert_param(IS_RTC_ALARM_DATE_WEEKDAY_DATE(tmpreg));    
    }
    else
    {
      tmpreg = RTC_Bcd2ToByte(RTC_AlarmStruct->RTC_AlarmDateWeekDay);
 801054c:	687b      	ldr	r3, [r7, #4]
 801054e:	7b1b      	ldrb	r3, [r3, #12]
 8010550:	4618      	mov	r0, r3
 8010552:	f000 fe96 	bl	8011282 <RTC_Bcd2ToByte>
 8010556:	4603      	mov	r3, r0
 8010558:	617b      	str	r3, [r7, #20]
      assert_param(IS_RTC_ALARM_DATE_WEEKDAY_WEEKDAY(tmpreg));      
    }    
  }

  /* Check the input parameters format */
  if (RTC_Format != RTC_Format_BIN)
 801055a:	68fb      	ldr	r3, [r7, #12]
 801055c:	2b00      	cmp	r3, #0
 801055e:	d019      	beq.n	8010594 <RTC_SetAlarm+0xac>
  {
    tmpreg = (((uint32_t)(RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours) << 16) | \
 8010560:	687b      	ldr	r3, [r7, #4]
 8010562:	781b      	ldrb	r3, [r3, #0]
 8010564:	041a      	lsls	r2, r3, #16
              ((uint32_t)(RTC_AlarmStruct->RTC_AlarmTime.RTC_Minutes) << 8) | \
 8010566:	687b      	ldr	r3, [r7, #4]
 8010568:	785b      	ldrb	r3, [r3, #1]
 801056a:	021b      	lsls	r3, r3, #8
    tmpreg = (((uint32_t)(RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours) << 16) | \
 801056c:	4313      	orrs	r3, r2
              ((uint32_t)RTC_AlarmStruct->RTC_AlarmTime.RTC_Seconds) | \
 801056e:	687a      	ldr	r2, [r7, #4]
 8010570:	7892      	ldrb	r2, [r2, #2]
              ((uint32_t)(RTC_AlarmStruct->RTC_AlarmTime.RTC_Minutes) << 8) | \
 8010572:	431a      	orrs	r2, r3
              ((uint32_t)(RTC_AlarmStruct->RTC_AlarmTime.RTC_H12) << 16) | \
 8010574:	687b      	ldr	r3, [r7, #4]
 8010576:	78db      	ldrb	r3, [r3, #3]
 8010578:	041b      	lsls	r3, r3, #16
              ((uint32_t)RTC_AlarmStruct->RTC_AlarmTime.RTC_Seconds) | \
 801057a:	431a      	orrs	r2, r3
              ((uint32_t)(RTC_AlarmStruct->RTC_AlarmDateWeekDay) << 24) | \
 801057c:	687b      	ldr	r3, [r7, #4]
 801057e:	7b1b      	ldrb	r3, [r3, #12]
 8010580:	061b      	lsls	r3, r3, #24
              ((uint32_t)(RTC_AlarmStruct->RTC_AlarmTime.RTC_H12) << 16) | \
 8010582:	431a      	orrs	r2, r3
              ((uint32_t)RTC_AlarmStruct->RTC_AlarmDateWeekDaySel) | \
 8010584:	687b      	ldr	r3, [r7, #4]
 8010586:	689b      	ldr	r3, [r3, #8]
              ((uint32_t)(RTC_AlarmStruct->RTC_AlarmDateWeekDay) << 24) | \
 8010588:	431a      	orrs	r2, r3
              ((uint32_t)RTC_AlarmStruct->RTC_AlarmMask)); 
 801058a:	687b      	ldr	r3, [r7, #4]
 801058c:	685b      	ldr	r3, [r3, #4]
    tmpreg = (((uint32_t)(RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours) << 16) | \
 801058e:	4313      	orrs	r3, r2
 8010590:	617b      	str	r3, [r7, #20]
 8010592:	e02b      	b.n	80105ec <RTC_SetAlarm+0x104>
  }  
  else
  {
    tmpreg = (((uint32_t)RTC_ByteToBcd2(RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours) << 16) | \
 8010594:	687b      	ldr	r3, [r7, #4]
 8010596:	781b      	ldrb	r3, [r3, #0]
 8010598:	4618      	mov	r0, r3
 801059a:	f000 fe55 	bl	8011248 <RTC_ByteToBcd2>
 801059e:	4603      	mov	r3, r0
 80105a0:	041c      	lsls	r4, r3, #16
              ((uint32_t)RTC_ByteToBcd2(RTC_AlarmStruct->RTC_AlarmTime.RTC_Minutes) << 8) | \
 80105a2:	687b      	ldr	r3, [r7, #4]
 80105a4:	785b      	ldrb	r3, [r3, #1]
 80105a6:	4618      	mov	r0, r3
 80105a8:	f000 fe4e 	bl	8011248 <RTC_ByteToBcd2>
 80105ac:	4603      	mov	r3, r0
 80105ae:	021b      	lsls	r3, r3, #8
    tmpreg = (((uint32_t)RTC_ByteToBcd2(RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours) << 16) | \
 80105b0:	431c      	orrs	r4, r3
              ((uint32_t)RTC_ByteToBcd2(RTC_AlarmStruct->RTC_AlarmTime.RTC_Seconds)) | \
 80105b2:	687b      	ldr	r3, [r7, #4]
 80105b4:	789b      	ldrb	r3, [r3, #2]
 80105b6:	4618      	mov	r0, r3
 80105b8:	f000 fe46 	bl	8011248 <RTC_ByteToBcd2>
 80105bc:	4603      	mov	r3, r0
              ((uint32_t)RTC_ByteToBcd2(RTC_AlarmStruct->RTC_AlarmTime.RTC_Minutes) << 8) | \
 80105be:	ea44 0203 	orr.w	r2, r4, r3
              ((uint32_t)(RTC_AlarmStruct->RTC_AlarmTime.RTC_H12) << 16) | \
 80105c2:	687b      	ldr	r3, [r7, #4]
 80105c4:	78db      	ldrb	r3, [r3, #3]
 80105c6:	041b      	lsls	r3, r3, #16
              ((uint32_t)RTC_ByteToBcd2(RTC_AlarmStruct->RTC_AlarmTime.RTC_Seconds)) | \
 80105c8:	ea42 0403 	orr.w	r4, r2, r3
              ((uint32_t)RTC_ByteToBcd2(RTC_AlarmStruct->RTC_AlarmDateWeekDay) << 24) | \
 80105cc:	687b      	ldr	r3, [r7, #4]
 80105ce:	7b1b      	ldrb	r3, [r3, #12]
 80105d0:	4618      	mov	r0, r3
 80105d2:	f000 fe39 	bl	8011248 <RTC_ByteToBcd2>
 80105d6:	4603      	mov	r3, r0
 80105d8:	061b      	lsls	r3, r3, #24
              ((uint32_t)(RTC_AlarmStruct->RTC_AlarmTime.RTC_H12) << 16) | \
 80105da:	ea44 0203 	orr.w	r2, r4, r3
              ((uint32_t)RTC_AlarmStruct->RTC_AlarmDateWeekDaySel) | \
 80105de:	687b      	ldr	r3, [r7, #4]
 80105e0:	689b      	ldr	r3, [r3, #8]
              ((uint32_t)RTC_ByteToBcd2(RTC_AlarmStruct->RTC_AlarmDateWeekDay) << 24) | \
 80105e2:	431a      	orrs	r2, r3
              ((uint32_t)RTC_AlarmStruct->RTC_AlarmMask)); 
 80105e4:	687b      	ldr	r3, [r7, #4]
 80105e6:	685b      	ldr	r3, [r3, #4]
    tmpreg = (((uint32_t)RTC_ByteToBcd2(RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours) << 16) | \
 80105e8:	4313      	orrs	r3, r2
 80105ea:	617b      	str	r3, [r7, #20]
  } 

  /* Disable the write protection for RTC registers */
  RTC->WPR = 0xCA;
 80105ec:	4b0b      	ldr	r3, [pc, #44]	; (801061c <RTC_SetAlarm+0x134>)
 80105ee:	22ca      	movs	r2, #202	; 0xca
 80105f0:	625a      	str	r2, [r3, #36]	; 0x24
  RTC->WPR = 0x53;
 80105f2:	4b0a      	ldr	r3, [pc, #40]	; (801061c <RTC_SetAlarm+0x134>)
 80105f4:	2253      	movs	r2, #83	; 0x53
 80105f6:	625a      	str	r2, [r3, #36]	; 0x24

  /* Configure the Alarm register */
  if (RTC_Alarm == RTC_Alarm_A)
 80105f8:	68bb      	ldr	r3, [r7, #8]
 80105fa:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 80105fe:	d103      	bne.n	8010608 <RTC_SetAlarm+0x120>
  {
    RTC->ALRMAR = (uint32_t)tmpreg;
 8010600:	4a06      	ldr	r2, [pc, #24]	; (801061c <RTC_SetAlarm+0x134>)
 8010602:	697b      	ldr	r3, [r7, #20]
 8010604:	61d3      	str	r3, [r2, #28]
 8010606:	e002      	b.n	801060e <RTC_SetAlarm+0x126>
  }
  else
  {
    RTC->ALRMBR = (uint32_t)tmpreg;
 8010608:	4a04      	ldr	r2, [pc, #16]	; (801061c <RTC_SetAlarm+0x134>)
 801060a:	697b      	ldr	r3, [r7, #20]
 801060c:	6213      	str	r3, [r2, #32]
  }

  /* Enable the write protection for RTC registers */
  RTC->WPR = 0xFF;   
 801060e:	4b03      	ldr	r3, [pc, #12]	; (801061c <RTC_SetAlarm+0x134>)
 8010610:	22ff      	movs	r2, #255	; 0xff
 8010612:	625a      	str	r2, [r3, #36]	; 0x24
}
 8010614:	bf00      	nop
 8010616:	371c      	adds	r7, #28
 8010618:	46bd      	mov	sp, r7
 801061a:	bd90      	pop	{r4, r7, pc}
 801061c:	40002800 	.word	0x40002800

08010620 <RTC_AlarmStructInit>:
  * @param  RTC_AlarmStruct: pointer to a @ref RTC_AlarmTypeDef structure which
  *         will be initialized.
  * @retval None
  */
void RTC_AlarmStructInit(RTC_AlarmTypeDef* RTC_AlarmStruct)
{
 8010620:	b480      	push	{r7}
 8010622:	b083      	sub	sp, #12
 8010624:	af00      	add	r7, sp, #0
 8010626:	6078      	str	r0, [r7, #4]
  /* Alarm Time Settings : Time = 00h:00mn:00sec */
  RTC_AlarmStruct->RTC_AlarmTime.RTC_H12 = RTC_H12_AM;
 8010628:	687b      	ldr	r3, [r7, #4]
 801062a:	2200      	movs	r2, #0
 801062c:	70da      	strb	r2, [r3, #3]
  RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours = 0;
 801062e:	687b      	ldr	r3, [r7, #4]
 8010630:	2200      	movs	r2, #0
 8010632:	701a      	strb	r2, [r3, #0]
  RTC_AlarmStruct->RTC_AlarmTime.RTC_Minutes = 0;
 8010634:	687b      	ldr	r3, [r7, #4]
 8010636:	2200      	movs	r2, #0
 8010638:	705a      	strb	r2, [r3, #1]
  RTC_AlarmStruct->RTC_AlarmTime.RTC_Seconds = 0;
 801063a:	687b      	ldr	r3, [r7, #4]
 801063c:	2200      	movs	r2, #0
 801063e:	709a      	strb	r2, [r3, #2]

  /* Alarm Date Settings : Date = 1st day of the month */
  RTC_AlarmStruct->RTC_AlarmDateWeekDaySel = RTC_AlarmDateWeekDaySel_Date;
 8010640:	687b      	ldr	r3, [r7, #4]
 8010642:	2200      	movs	r2, #0
 8010644:	609a      	str	r2, [r3, #8]
  RTC_AlarmStruct->RTC_AlarmDateWeekDay = 1;
 8010646:	687b      	ldr	r3, [r7, #4]
 8010648:	2201      	movs	r2, #1
 801064a:	731a      	strb	r2, [r3, #12]

  /* Alarm Masks Settings : Mask =  all fields are not masked */
  RTC_AlarmStruct->RTC_AlarmMask = RTC_AlarmMask_None;
 801064c:	687b      	ldr	r3, [r7, #4]
 801064e:	2200      	movs	r2, #0
 8010650:	605a      	str	r2, [r3, #4]
}
 8010652:	bf00      	nop
 8010654:	370c      	adds	r7, #12
 8010656:	46bd      	mov	sp, r7
 8010658:	f85d 7b04 	ldr.w	r7, [sp], #4
 801065c:	4770      	bx	lr

0801065e <RTC_GetAlarm>:
  * @param  RTC_AlarmStruct: pointer to a RTC_AlarmTypeDef structure that will 
  *                          contains the output alarm configuration values.     
  * @retval None
  */
void RTC_GetAlarm(uint32_t RTC_Format, uint32_t RTC_Alarm, RTC_AlarmTypeDef* RTC_AlarmStruct)
{
 801065e:	b580      	push	{r7, lr}
 8010660:	b086      	sub	sp, #24
 8010662:	af00      	add	r7, sp, #0
 8010664:	60f8      	str	r0, [r7, #12]
 8010666:	60b9      	str	r1, [r7, #8]
 8010668:	607a      	str	r2, [r7, #4]
  uint32_t tmpreg = 0;
 801066a:	2300      	movs	r3, #0
 801066c:	617b      	str	r3, [r7, #20]
  /* Check the parameters */
  assert_param(IS_RTC_FORMAT(RTC_Format));
  assert_param(IS_RTC_ALARM(RTC_Alarm)); 

  /* Get the RTC_ALRMxR register */
  if (RTC_Alarm == RTC_Alarm_A)
 801066e:	68bb      	ldr	r3, [r7, #8]
 8010670:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 8010674:	d103      	bne.n	801067e <RTC_GetAlarm+0x20>
  {
    tmpreg = (uint32_t)(RTC->ALRMAR);
 8010676:	4b31      	ldr	r3, [pc, #196]	; (801073c <RTC_GetAlarm+0xde>)
 8010678:	69db      	ldr	r3, [r3, #28]
 801067a:	617b      	str	r3, [r7, #20]
 801067c:	e002      	b.n	8010684 <RTC_GetAlarm+0x26>
  }
  else
  {
    tmpreg = (uint32_t)(RTC->ALRMBR);
 801067e:	4b2f      	ldr	r3, [pc, #188]	; (801073c <RTC_GetAlarm+0xde>)
 8010680:	6a1b      	ldr	r3, [r3, #32]
 8010682:	617b      	str	r3, [r7, #20]
  }

  /* Fill the structure with the read parameters */
  RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours = (uint32_t)((tmpreg & (RTC_ALRMAR_HT | \
 8010684:	697b      	ldr	r3, [r7, #20]
 8010686:	0c1b      	lsrs	r3, r3, #16
 8010688:	b2db      	uxtb	r3, r3
 801068a:	f003 033f 	and.w	r3, r3, #63	; 0x3f
 801068e:	b2da      	uxtb	r2, r3
 8010690:	687b      	ldr	r3, [r7, #4]
 8010692:	701a      	strb	r2, [r3, #0]
                                                     RTC_ALRMAR_HU)) >> 16);
  RTC_AlarmStruct->RTC_AlarmTime.RTC_Minutes = (uint32_t)((tmpreg & (RTC_ALRMAR_MNT | \
 8010694:	697b      	ldr	r3, [r7, #20]
 8010696:	0a1b      	lsrs	r3, r3, #8
 8010698:	b2db      	uxtb	r3, r3
 801069a:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 801069e:	b2da      	uxtb	r2, r3
 80106a0:	687b      	ldr	r3, [r7, #4]
 80106a2:	705a      	strb	r2, [r3, #1]
                                                     RTC_ALRMAR_MNU)) >> 8);
  RTC_AlarmStruct->RTC_AlarmTime.RTC_Seconds = (uint32_t)(tmpreg & (RTC_ALRMAR_ST | \
 80106a4:	697b      	ldr	r3, [r7, #20]
 80106a6:	b2db      	uxtb	r3, r3
 80106a8:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 80106ac:	b2da      	uxtb	r2, r3
 80106ae:	687b      	ldr	r3, [r7, #4]
 80106b0:	709a      	strb	r2, [r3, #2]
                                                     RTC_ALRMAR_SU));
  RTC_AlarmStruct->RTC_AlarmTime.RTC_H12 = (uint32_t)((tmpreg & RTC_ALRMAR_PM) >> 16);
 80106b2:	697b      	ldr	r3, [r7, #20]
 80106b4:	0c1b      	lsrs	r3, r3, #16
 80106b6:	b2db      	uxtb	r3, r3
 80106b8:	f003 0340 	and.w	r3, r3, #64	; 0x40
 80106bc:	b2da      	uxtb	r2, r3
 80106be:	687b      	ldr	r3, [r7, #4]
 80106c0:	70da      	strb	r2, [r3, #3]
  RTC_AlarmStruct->RTC_AlarmDateWeekDay = (uint32_t)((tmpreg & (RTC_ALRMAR_DT | RTC_ALRMAR_DU)) >> 24);
 80106c2:	697b      	ldr	r3, [r7, #20]
 80106c4:	0e1b      	lsrs	r3, r3, #24
 80106c6:	b2db      	uxtb	r3, r3
 80106c8:	f003 033f 	and.w	r3, r3, #63	; 0x3f
 80106cc:	b2da      	uxtb	r2, r3
 80106ce:	687b      	ldr	r3, [r7, #4]
 80106d0:	731a      	strb	r2, [r3, #12]
  RTC_AlarmStruct->RTC_AlarmDateWeekDaySel = (uint32_t)(tmpreg & RTC_ALRMAR_WDSEL);
 80106d2:	697b      	ldr	r3, [r7, #20]
 80106d4:	f003 4280 	and.w	r2, r3, #1073741824	; 0x40000000
 80106d8:	687b      	ldr	r3, [r7, #4]
 80106da:	609a      	str	r2, [r3, #8]
  RTC_AlarmStruct->RTC_AlarmMask = (uint32_t)(tmpreg & RTC_AlarmMask_All);
 80106dc:	697b      	ldr	r3, [r7, #20]
 80106de:	f003 3280 	and.w	r2, r3, #2155905152	; 0x80808080
 80106e2:	687b      	ldr	r3, [r7, #4]
 80106e4:	605a      	str	r2, [r3, #4]

  if (RTC_Format == RTC_Format_BIN)
 80106e6:	68fb      	ldr	r3, [r7, #12]
 80106e8:	2b00      	cmp	r3, #0
 80106ea:	d123      	bne.n	8010734 <RTC_GetAlarm+0xd6>
  {
    RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours = RTC_Bcd2ToByte(RTC_AlarmStruct-> \
 80106ec:	687b      	ldr	r3, [r7, #4]
 80106ee:	781b      	ldrb	r3, [r3, #0]
 80106f0:	4618      	mov	r0, r3
 80106f2:	f000 fdc6 	bl	8011282 <RTC_Bcd2ToByte>
 80106f6:	4603      	mov	r3, r0
 80106f8:	461a      	mov	r2, r3
 80106fa:	687b      	ldr	r3, [r7, #4]
 80106fc:	701a      	strb	r2, [r3, #0]
                                                        RTC_AlarmTime.RTC_Hours);
    RTC_AlarmStruct->RTC_AlarmTime.RTC_Minutes = RTC_Bcd2ToByte(RTC_AlarmStruct-> \
 80106fe:	687b      	ldr	r3, [r7, #4]
 8010700:	785b      	ldrb	r3, [r3, #1]
 8010702:	4618      	mov	r0, r3
 8010704:	f000 fdbd 	bl	8011282 <RTC_Bcd2ToByte>
 8010708:	4603      	mov	r3, r0
 801070a:	461a      	mov	r2, r3
 801070c:	687b      	ldr	r3, [r7, #4]
 801070e:	705a      	strb	r2, [r3, #1]
                                                        RTC_AlarmTime.RTC_Minutes);
    RTC_AlarmStruct->RTC_AlarmTime.RTC_Seconds = RTC_Bcd2ToByte(RTC_AlarmStruct-> \
 8010710:	687b      	ldr	r3, [r7, #4]
 8010712:	789b      	ldrb	r3, [r3, #2]
 8010714:	4618      	mov	r0, r3
 8010716:	f000 fdb4 	bl	8011282 <RTC_Bcd2ToByte>
 801071a:	4603      	mov	r3, r0
 801071c:	461a      	mov	r2, r3
 801071e:	687b      	ldr	r3, [r7, #4]
 8010720:	709a      	strb	r2, [r3, #2]
                                                        RTC_AlarmTime.RTC_Seconds);
    RTC_AlarmStruct->RTC_AlarmDateWeekDay = RTC_Bcd2ToByte(RTC_AlarmStruct->RTC_AlarmDateWeekDay);
 8010722:	687b      	ldr	r3, [r7, #4]
 8010724:	7b1b      	ldrb	r3, [r3, #12]
 8010726:	4618      	mov	r0, r3
 8010728:	f000 fdab 	bl	8011282 <RTC_Bcd2ToByte>
 801072c:	4603      	mov	r3, r0
 801072e:	461a      	mov	r2, r3
 8010730:	687b      	ldr	r3, [r7, #4]
 8010732:	731a      	strb	r2, [r3, #12]
  }  
}
 8010734:	bf00      	nop
 8010736:	3718      	adds	r7, #24
 8010738:	46bd      	mov	sp, r7
 801073a:	bd80      	pop	{r7, pc}
 801073c:	40002800 	.word	0x40002800

08010740 <RTC_AlarmCmd>:
  * @retval An ErrorStatus enumeration value:
  *          - SUCCESS: RTC Alarm is enabled/disabled
  *          - ERROR: RTC Alarm is not enabled/disabled  
  */
ErrorStatus RTC_AlarmCmd(uint32_t RTC_Alarm, FunctionalState NewState)
{
 8010740:	b480      	push	{r7}
 8010742:	b087      	sub	sp, #28
 8010744:	af00      	add	r7, sp, #0
 8010746:	6078      	str	r0, [r7, #4]
 8010748:	460b      	mov	r3, r1
 801074a:	70fb      	strb	r3, [r7, #3]
  __IO uint32_t alarmcounter = 0x00;
 801074c:	2300      	movs	r3, #0
 801074e:	60fb      	str	r3, [r7, #12]
  uint32_t alarmstatus = 0x00;
 8010750:	2300      	movs	r3, #0
 8010752:	613b      	str	r3, [r7, #16]
  ErrorStatus status = ERROR;
 8010754:	2300      	movs	r3, #0
 8010756:	75fb      	strb	r3, [r7, #23]
  /* Check the parameters */
  assert_param(IS_RTC_CMD_ALARM(RTC_Alarm));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  /* Disable the write protection for RTC registers */
  RTC->WPR = 0xCA;
 8010758:	4b1f      	ldr	r3, [pc, #124]	; (80107d8 <RTC_AlarmCmd+0x98>)
 801075a:	22ca      	movs	r2, #202	; 0xca
 801075c:	625a      	str	r2, [r3, #36]	; 0x24
  RTC->WPR = 0x53;
 801075e:	4b1e      	ldr	r3, [pc, #120]	; (80107d8 <RTC_AlarmCmd+0x98>)
 8010760:	2253      	movs	r2, #83	; 0x53
 8010762:	625a      	str	r2, [r3, #36]	; 0x24

  /* Configure the Alarm state */
  if (NewState != DISABLE)
 8010764:	78fb      	ldrb	r3, [r7, #3]
 8010766:	2b00      	cmp	r3, #0
 8010768:	d008      	beq.n	801077c <RTC_AlarmCmd+0x3c>
  {
    RTC->CR |= (uint32_t)RTC_Alarm;
 801076a:	491b      	ldr	r1, [pc, #108]	; (80107d8 <RTC_AlarmCmd+0x98>)
 801076c:	4b1a      	ldr	r3, [pc, #104]	; (80107d8 <RTC_AlarmCmd+0x98>)
 801076e:	689a      	ldr	r2, [r3, #8]
 8010770:	687b      	ldr	r3, [r7, #4]
 8010772:	4313      	orrs	r3, r2
 8010774:	608b      	str	r3, [r1, #8]

    status = SUCCESS;    
 8010776:	2301      	movs	r3, #1
 8010778:	75fb      	strb	r3, [r7, #23]
 801077a:	e022      	b.n	80107c2 <RTC_AlarmCmd+0x82>
  }
  else
  { 
    /* Disable the Alarm in RTC_CR register */
    RTC->CR &= (uint32_t)~RTC_Alarm;
 801077c:	4916      	ldr	r1, [pc, #88]	; (80107d8 <RTC_AlarmCmd+0x98>)
 801077e:	4b16      	ldr	r3, [pc, #88]	; (80107d8 <RTC_AlarmCmd+0x98>)
 8010780:	689a      	ldr	r2, [r3, #8]
 8010782:	687b      	ldr	r3, [r7, #4]
 8010784:	43db      	mvns	r3, r3
 8010786:	4013      	ands	r3, r2
 8010788:	608b      	str	r3, [r1, #8]
   
    /* Wait till RTC ALRxWF flag is set and if Time out is reached exit */
    do
    {
      alarmstatus = RTC->ISR & (RTC_Alarm >> 8);
 801078a:	4b13      	ldr	r3, [pc, #76]	; (80107d8 <RTC_AlarmCmd+0x98>)
 801078c:	68da      	ldr	r2, [r3, #12]
 801078e:	687b      	ldr	r3, [r7, #4]
 8010790:	0a1b      	lsrs	r3, r3, #8
 8010792:	4013      	ands	r3, r2
 8010794:	613b      	str	r3, [r7, #16]
      alarmcounter++;  
 8010796:	68fb      	ldr	r3, [r7, #12]
 8010798:	3301      	adds	r3, #1
 801079a:	60fb      	str	r3, [r7, #12]
    } while((alarmcounter != INITMODE_TIMEOUT) && (alarmstatus == 0x00));
 801079c:	68fb      	ldr	r3, [r7, #12]
 801079e:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 80107a2:	d002      	beq.n	80107aa <RTC_AlarmCmd+0x6a>
 80107a4:	693b      	ldr	r3, [r7, #16]
 80107a6:	2b00      	cmp	r3, #0
 80107a8:	d0ef      	beq.n	801078a <RTC_AlarmCmd+0x4a>
    
    if ((RTC->ISR & (RTC_Alarm >> 8)) == RESET)
 80107aa:	4b0b      	ldr	r3, [pc, #44]	; (80107d8 <RTC_AlarmCmd+0x98>)
 80107ac:	68da      	ldr	r2, [r3, #12]
 80107ae:	687b      	ldr	r3, [r7, #4]
 80107b0:	0a1b      	lsrs	r3, r3, #8
 80107b2:	4013      	ands	r3, r2
 80107b4:	2b00      	cmp	r3, #0
 80107b6:	d102      	bne.n	80107be <RTC_AlarmCmd+0x7e>
    {
      status = ERROR;
 80107b8:	2300      	movs	r3, #0
 80107ba:	75fb      	strb	r3, [r7, #23]
 80107bc:	e001      	b.n	80107c2 <RTC_AlarmCmd+0x82>
    } 
    else
    {
      status = SUCCESS;
 80107be:	2301      	movs	r3, #1
 80107c0:	75fb      	strb	r3, [r7, #23]
    }        
  } 

  /* Enable the write protection for RTC registers */
  RTC->WPR = 0xFF; 
 80107c2:	4b05      	ldr	r3, [pc, #20]	; (80107d8 <RTC_AlarmCmd+0x98>)
 80107c4:	22ff      	movs	r2, #255	; 0xff
 80107c6:	625a      	str	r2, [r3, #36]	; 0x24
  
  return status;
 80107c8:	7dfb      	ldrb	r3, [r7, #23]
}
 80107ca:	4618      	mov	r0, r3
 80107cc:	371c      	adds	r7, #28
 80107ce:	46bd      	mov	sp, r7
 80107d0:	f85d 7b04 	ldr.w	r7, [sp], #4
 80107d4:	4770      	bx	lr
 80107d6:	bf00      	nop
 80107d8:	40002800 	.word	0x40002800

080107dc <RTC_AlarmSubSecondConfig>:
  *     @arg RTC_AlarmSubSecondMask_None   : SS[14:0] are compared and must match
  *                                          to activate alarm
  * @retval None
  */
void RTC_AlarmSubSecondConfig(uint32_t RTC_Alarm, uint32_t RTC_AlarmSubSecondValue, uint32_t RTC_AlarmSubSecondMask)
{
 80107dc:	b480      	push	{r7}
 80107de:	b087      	sub	sp, #28
 80107e0:	af00      	add	r7, sp, #0
 80107e2:	60f8      	str	r0, [r7, #12]
 80107e4:	60b9      	str	r1, [r7, #8]
 80107e6:	607a      	str	r2, [r7, #4]
  uint32_t tmpreg = 0;
 80107e8:	2300      	movs	r3, #0
 80107ea:	617b      	str	r3, [r7, #20]
  assert_param(IS_RTC_ALARM(RTC_Alarm));
  assert_param(IS_RTC_ALARM_SUB_SECOND_VALUE(RTC_AlarmSubSecondValue));
  assert_param(IS_RTC_ALARM_SUB_SECOND_MASK(RTC_AlarmSubSecondMask));
  
  /* Disable the write protection for RTC registers */
  RTC->WPR = 0xCA;
 80107ec:	4b0e      	ldr	r3, [pc, #56]	; (8010828 <RTC_AlarmSubSecondConfig+0x4c>)
 80107ee:	22ca      	movs	r2, #202	; 0xca
 80107f0:	625a      	str	r2, [r3, #36]	; 0x24
  RTC->WPR = 0x53;
 80107f2:	4b0d      	ldr	r3, [pc, #52]	; (8010828 <RTC_AlarmSubSecondConfig+0x4c>)
 80107f4:	2253      	movs	r2, #83	; 0x53
 80107f6:	625a      	str	r2, [r3, #36]	; 0x24
  
  /* Configure the Alarm A or Alarm B SubSecond registers */
  tmpreg = (uint32_t) (uint32_t)(RTC_AlarmSubSecondValue) | (uint32_t)(RTC_AlarmSubSecondMask);
 80107f8:	68ba      	ldr	r2, [r7, #8]
 80107fa:	687b      	ldr	r3, [r7, #4]
 80107fc:	4313      	orrs	r3, r2
 80107fe:	617b      	str	r3, [r7, #20]
  
  if (RTC_Alarm == RTC_Alarm_A)
 8010800:	68fb      	ldr	r3, [r7, #12]
 8010802:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 8010806:	d103      	bne.n	8010810 <RTC_AlarmSubSecondConfig+0x34>
  {
    /* Configure the AlarmA SubSecond register */
    RTC->ALRMASSR = tmpreg;
 8010808:	4a07      	ldr	r2, [pc, #28]	; (8010828 <RTC_AlarmSubSecondConfig+0x4c>)
 801080a:	697b      	ldr	r3, [r7, #20]
 801080c:	6453      	str	r3, [r2, #68]	; 0x44
 801080e:	e002      	b.n	8010816 <RTC_AlarmSubSecondConfig+0x3a>
  }
  else
  {
    /* Configure the Alarm B SubSecond register */
    RTC->ALRMBSSR = tmpreg;
 8010810:	4a05      	ldr	r2, [pc, #20]	; (8010828 <RTC_AlarmSubSecondConfig+0x4c>)
 8010812:	697b      	ldr	r3, [r7, #20]
 8010814:	6493      	str	r3, [r2, #72]	; 0x48
  }

  /* Enable the write protection for RTC registers */
  RTC->WPR = 0xFF;
 8010816:	4b04      	ldr	r3, [pc, #16]	; (8010828 <RTC_AlarmSubSecondConfig+0x4c>)
 8010818:	22ff      	movs	r2, #255	; 0xff
 801081a:	625a      	str	r2, [r3, #36]	; 0x24

}
 801081c:	bf00      	nop
 801081e:	371c      	adds	r7, #28
 8010820:	46bd      	mov	sp, r7
 8010822:	f85d 7b04 	ldr.w	r7, [sp], #4
 8010826:	4770      	bx	lr
 8010828:	40002800 	.word	0x40002800

0801082c <RTC_GetAlarmSubSecond>:
  *     @arg RTC_Alarm_B: to select Alarm B
  * @param  None
  * @retval RTC Alarm Subseconds value.
  */
uint32_t RTC_GetAlarmSubSecond(uint32_t RTC_Alarm)
{
 801082c:	b480      	push	{r7}
 801082e:	b085      	sub	sp, #20
 8010830:	af00      	add	r7, sp, #0
 8010832:	6078      	str	r0, [r7, #4]
  uint32_t tmpreg = 0;
 8010834:	2300      	movs	r3, #0
 8010836:	60fb      	str	r3, [r7, #12]
  
  /* Get the RTC_ALRMxR register */
  if (RTC_Alarm == RTC_Alarm_A)
 8010838:	687b      	ldr	r3, [r7, #4]
 801083a:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 801083e:	d105      	bne.n	801084c <RTC_GetAlarmSubSecond+0x20>
  {
    tmpreg = (uint32_t)((RTC->ALRMASSR) & RTC_ALRMASSR_SS);
 8010840:	4b08      	ldr	r3, [pc, #32]	; (8010864 <RTC_GetAlarmSubSecond+0x38>)
 8010842:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8010844:	f3c3 030e 	ubfx	r3, r3, #0, #15
 8010848:	60fb      	str	r3, [r7, #12]
 801084a:	e004      	b.n	8010856 <RTC_GetAlarmSubSecond+0x2a>
  }
  else
  {
    tmpreg = (uint32_t)((RTC->ALRMBSSR) & RTC_ALRMBSSR_SS);
 801084c:	4b05      	ldr	r3, [pc, #20]	; (8010864 <RTC_GetAlarmSubSecond+0x38>)
 801084e:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8010850:	f3c3 030e 	ubfx	r3, r3, #0, #15
 8010854:	60fb      	str	r3, [r7, #12]
  } 
  
  return (tmpreg);
 8010856:	68fb      	ldr	r3, [r7, #12]
}
 8010858:	4618      	mov	r0, r3
 801085a:	3714      	adds	r7, #20
 801085c:	46bd      	mov	sp, r7
 801085e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8010862:	4770      	bx	lr
 8010864:	40002800 	.word	0x40002800

08010868 <RTC_WakeUpClockConfig>:
  *            @arg RTC_WakeUpClock_CK_SPRE_16bits: RTC Wakeup Counter Clock = CK_SPRE
  *            @arg RTC_WakeUpClock_CK_SPRE_17bits: RTC Wakeup Counter Clock = CK_SPRE
  * @retval None
  */
void RTC_WakeUpClockConfig(uint32_t RTC_WakeUpClock)
{
 8010868:	b480      	push	{r7}
 801086a:	b083      	sub	sp, #12
 801086c:	af00      	add	r7, sp, #0
 801086e:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_RTC_WAKEUP_CLOCK(RTC_WakeUpClock));

  /* Disable the write protection for RTC registers */
  RTC->WPR = 0xCA;
 8010870:	4b0d      	ldr	r3, [pc, #52]	; (80108a8 <RTC_WakeUpClockConfig+0x40>)
 8010872:	22ca      	movs	r2, #202	; 0xca
 8010874:	625a      	str	r2, [r3, #36]	; 0x24
  RTC->WPR = 0x53;
 8010876:	4b0c      	ldr	r3, [pc, #48]	; (80108a8 <RTC_WakeUpClockConfig+0x40>)
 8010878:	2253      	movs	r2, #83	; 0x53
 801087a:	625a      	str	r2, [r3, #36]	; 0x24

  /* Clear the Wakeup Timer clock source bits in CR register */
  RTC->CR &= (uint32_t)~RTC_CR_WUCKSEL;
 801087c:	4a0a      	ldr	r2, [pc, #40]	; (80108a8 <RTC_WakeUpClockConfig+0x40>)
 801087e:	4b0a      	ldr	r3, [pc, #40]	; (80108a8 <RTC_WakeUpClockConfig+0x40>)
 8010880:	689b      	ldr	r3, [r3, #8]
 8010882:	f023 0307 	bic.w	r3, r3, #7
 8010886:	6093      	str	r3, [r2, #8]

  /* Configure the clock source */
  RTC->CR |= (uint32_t)RTC_WakeUpClock;
 8010888:	4907      	ldr	r1, [pc, #28]	; (80108a8 <RTC_WakeUpClockConfig+0x40>)
 801088a:	4b07      	ldr	r3, [pc, #28]	; (80108a8 <RTC_WakeUpClockConfig+0x40>)
 801088c:	689a      	ldr	r2, [r3, #8]
 801088e:	687b      	ldr	r3, [r7, #4]
 8010890:	4313      	orrs	r3, r2
 8010892:	608b      	str	r3, [r1, #8]
  
  /* Enable the write protection for RTC registers */
  RTC->WPR = 0xFF; 
 8010894:	4b04      	ldr	r3, [pc, #16]	; (80108a8 <RTC_WakeUpClockConfig+0x40>)
 8010896:	22ff      	movs	r2, #255	; 0xff
 8010898:	625a      	str	r2, [r3, #36]	; 0x24
}
 801089a:	bf00      	nop
 801089c:	370c      	adds	r7, #12
 801089e:	46bd      	mov	sp, r7
 80108a0:	f85d 7b04 	ldr.w	r7, [sp], #4
 80108a4:	4770      	bx	lr
 80108a6:	bf00      	nop
 80108a8:	40002800 	.word	0x40002800

080108ac <RTC_SetWakeUpCounter>:
  * @param  RTC_WakeUpCounter: specifies the WakeUp counter.
  *          This parameter can be a value from 0x0000 to 0xFFFF. 
  * @retval None
  */
void RTC_SetWakeUpCounter(uint32_t RTC_WakeUpCounter)
{
 80108ac:	b480      	push	{r7}
 80108ae:	b083      	sub	sp, #12
 80108b0:	af00      	add	r7, sp, #0
 80108b2:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_RTC_WAKEUP_COUNTER(RTC_WakeUpCounter));
  
  /* Disable the write protection for RTC registers */
  RTC->WPR = 0xCA;
 80108b4:	4b08      	ldr	r3, [pc, #32]	; (80108d8 <RTC_SetWakeUpCounter+0x2c>)
 80108b6:	22ca      	movs	r2, #202	; 0xca
 80108b8:	625a      	str	r2, [r3, #36]	; 0x24
  RTC->WPR = 0x53;
 80108ba:	4b07      	ldr	r3, [pc, #28]	; (80108d8 <RTC_SetWakeUpCounter+0x2c>)
 80108bc:	2253      	movs	r2, #83	; 0x53
 80108be:	625a      	str	r2, [r3, #36]	; 0x24
  
  /* Configure the Wakeup Timer counter */
  RTC->WUTR = (uint32_t)RTC_WakeUpCounter;
 80108c0:	4a05      	ldr	r2, [pc, #20]	; (80108d8 <RTC_SetWakeUpCounter+0x2c>)
 80108c2:	687b      	ldr	r3, [r7, #4]
 80108c4:	6153      	str	r3, [r2, #20]
  
  /* Enable the write protection for RTC registers */
  RTC->WPR = 0xFF; 
 80108c6:	4b04      	ldr	r3, [pc, #16]	; (80108d8 <RTC_SetWakeUpCounter+0x2c>)
 80108c8:	22ff      	movs	r2, #255	; 0xff
 80108ca:	625a      	str	r2, [r3, #36]	; 0x24
}
 80108cc:	bf00      	nop
 80108ce:	370c      	adds	r7, #12
 80108d0:	46bd      	mov	sp, r7
 80108d2:	f85d 7b04 	ldr.w	r7, [sp], #4
 80108d6:	4770      	bx	lr
 80108d8:	40002800 	.word	0x40002800

080108dc <RTC_GetWakeUpCounter>:
  * @brief  Returns the RTC WakeUp timer counter value.
  * @param  None
  * @retval The RTC WakeUp Counter value.
  */
uint32_t RTC_GetWakeUpCounter(void)
{
 80108dc:	b480      	push	{r7}
 80108de:	af00      	add	r7, sp, #0
  /* Get the counter value */
  return ((uint32_t)(RTC->WUTR & RTC_WUTR_WUT));
 80108e0:	4b03      	ldr	r3, [pc, #12]	; (80108f0 <RTC_GetWakeUpCounter+0x14>)
 80108e2:	695b      	ldr	r3, [r3, #20]
 80108e4:	b29b      	uxth	r3, r3
}
 80108e6:	4618      	mov	r0, r3
 80108e8:	46bd      	mov	sp, r7
 80108ea:	f85d 7b04 	ldr.w	r7, [sp], #4
 80108ee:	4770      	bx	lr
 80108f0:	40002800 	.word	0x40002800

080108f4 <RTC_WakeUpCmd>:
  * @param  NewState: new state of the WakeUp timer.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
ErrorStatus RTC_WakeUpCmd(FunctionalState NewState)
{
 80108f4:	b480      	push	{r7}
 80108f6:	b087      	sub	sp, #28
 80108f8:	af00      	add	r7, sp, #0
 80108fa:	4603      	mov	r3, r0
 80108fc:	71fb      	strb	r3, [r7, #7]
  __IO uint32_t wutcounter = 0x00;
 80108fe:	2300      	movs	r3, #0
 8010900:	60fb      	str	r3, [r7, #12]
  uint32_t wutwfstatus = 0x00;
 8010902:	2300      	movs	r3, #0
 8010904:	613b      	str	r3, [r7, #16]
  ErrorStatus status = ERROR;
 8010906:	2300      	movs	r3, #0
 8010908:	75fb      	strb	r3, [r7, #23]
  
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  /* Disable the write protection for RTC registers */
  RTC->WPR = 0xCA;
 801090a:	4b1e      	ldr	r3, [pc, #120]	; (8010984 <RTC_WakeUpCmd+0x90>)
 801090c:	22ca      	movs	r2, #202	; 0xca
 801090e:	625a      	str	r2, [r3, #36]	; 0x24
  RTC->WPR = 0x53;
 8010910:	4b1c      	ldr	r3, [pc, #112]	; (8010984 <RTC_WakeUpCmd+0x90>)
 8010912:	2253      	movs	r2, #83	; 0x53
 8010914:	625a      	str	r2, [r3, #36]	; 0x24

  if (NewState != DISABLE)
 8010916:	79fb      	ldrb	r3, [r7, #7]
 8010918:	2b00      	cmp	r3, #0
 801091a:	d008      	beq.n	801092e <RTC_WakeUpCmd+0x3a>
  {
    /* Enable the Wakeup Timer */
    RTC->CR |= (uint32_t)RTC_CR_WUTE;
 801091c:	4a19      	ldr	r2, [pc, #100]	; (8010984 <RTC_WakeUpCmd+0x90>)
 801091e:	4b19      	ldr	r3, [pc, #100]	; (8010984 <RTC_WakeUpCmd+0x90>)
 8010920:	689b      	ldr	r3, [r3, #8]
 8010922:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
 8010926:	6093      	str	r3, [r2, #8]
    status = SUCCESS;    
 8010928:	2301      	movs	r3, #1
 801092a:	75fb      	strb	r3, [r7, #23]
 801092c:	e01f      	b.n	801096e <RTC_WakeUpCmd+0x7a>
  }
  else
  {
    /* Disable the Wakeup Timer */
    RTC->CR &= (uint32_t)~RTC_CR_WUTE;
 801092e:	4a15      	ldr	r2, [pc, #84]	; (8010984 <RTC_WakeUpCmd+0x90>)
 8010930:	4b14      	ldr	r3, [pc, #80]	; (8010984 <RTC_WakeUpCmd+0x90>)
 8010932:	689b      	ldr	r3, [r3, #8]
 8010934:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 8010938:	6093      	str	r3, [r2, #8]
    /* Wait till RTC WUTWF flag is set and if Time out is reached exit */
    do
    {
      wutwfstatus = RTC->ISR & RTC_ISR_WUTWF;
 801093a:	4b12      	ldr	r3, [pc, #72]	; (8010984 <RTC_WakeUpCmd+0x90>)
 801093c:	68db      	ldr	r3, [r3, #12]
 801093e:	f003 0304 	and.w	r3, r3, #4
 8010942:	613b      	str	r3, [r7, #16]
      wutcounter++;  
 8010944:	68fb      	ldr	r3, [r7, #12]
 8010946:	3301      	adds	r3, #1
 8010948:	60fb      	str	r3, [r7, #12]
    } while((wutcounter != INITMODE_TIMEOUT) && (wutwfstatus == 0x00));
 801094a:	68fb      	ldr	r3, [r7, #12]
 801094c:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 8010950:	d002      	beq.n	8010958 <RTC_WakeUpCmd+0x64>
 8010952:	693b      	ldr	r3, [r7, #16]
 8010954:	2b00      	cmp	r3, #0
 8010956:	d0f0      	beq.n	801093a <RTC_WakeUpCmd+0x46>
    
    if ((RTC->ISR & RTC_ISR_WUTWF) == RESET)
 8010958:	4b0a      	ldr	r3, [pc, #40]	; (8010984 <RTC_WakeUpCmd+0x90>)
 801095a:	68db      	ldr	r3, [r3, #12]
 801095c:	f003 0304 	and.w	r3, r3, #4
 8010960:	2b00      	cmp	r3, #0
 8010962:	d102      	bne.n	801096a <RTC_WakeUpCmd+0x76>
    {
      status = ERROR;
 8010964:	2300      	movs	r3, #0
 8010966:	75fb      	strb	r3, [r7, #23]
 8010968:	e001      	b.n	801096e <RTC_WakeUpCmd+0x7a>
    }
    else
    {
      status = SUCCESS;
 801096a:	2301      	movs	r3, #1
 801096c:	75fb      	strb	r3, [r7, #23]
    }    
  }

  /* Enable the write protection for RTC registers */
  RTC->WPR = 0xFF; 
 801096e:	4b05      	ldr	r3, [pc, #20]	; (8010984 <RTC_WakeUpCmd+0x90>)
 8010970:	22ff      	movs	r2, #255	; 0xff
 8010972:	625a      	str	r2, [r3, #36]	; 0x24
  
  return status;
 8010974:	7dfb      	ldrb	r3, [r7, #23]
}
 8010976:	4618      	mov	r0, r3
 8010978:	371c      	adds	r7, #28
 801097a:	46bd      	mov	sp, r7
 801097c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8010980:	4770      	bx	lr
 8010982:	bf00      	nop
 8010984:	40002800 	.word	0x40002800

08010988 <RTC_DayLightSavingConfig>:
  *            @arg RTC_StoreOperation_Reset: BCK Bit Reset
  *            @arg RTC_StoreOperation_Set: BCK Bit Set
  * @retval None
  */
void RTC_DayLightSavingConfig(uint32_t RTC_DayLightSaving, uint32_t RTC_StoreOperation)
{
 8010988:	b480      	push	{r7}
 801098a:	b083      	sub	sp, #12
 801098c:	af00      	add	r7, sp, #0
 801098e:	6078      	str	r0, [r7, #4]
 8010990:	6039      	str	r1, [r7, #0]
  /* Check the parameters */
  assert_param(IS_RTC_DAYLIGHT_SAVING(RTC_DayLightSaving));
  assert_param(IS_RTC_STORE_OPERATION(RTC_StoreOperation));

  /* Disable the write protection for RTC registers */
  RTC->WPR = 0xCA;
 8010992:	4b0e      	ldr	r3, [pc, #56]	; (80109cc <RTC_DayLightSavingConfig+0x44>)
 8010994:	22ca      	movs	r2, #202	; 0xca
 8010996:	625a      	str	r2, [r3, #36]	; 0x24
  RTC->WPR = 0x53;
 8010998:	4b0c      	ldr	r3, [pc, #48]	; (80109cc <RTC_DayLightSavingConfig+0x44>)
 801099a:	2253      	movs	r2, #83	; 0x53
 801099c:	625a      	str	r2, [r3, #36]	; 0x24

  /* Clear the bits to be configured */
  RTC->CR &= (uint32_t)~(RTC_CR_BCK);
 801099e:	4a0b      	ldr	r2, [pc, #44]	; (80109cc <RTC_DayLightSavingConfig+0x44>)
 80109a0:	4b0a      	ldr	r3, [pc, #40]	; (80109cc <RTC_DayLightSavingConfig+0x44>)
 80109a2:	689b      	ldr	r3, [r3, #8]
 80109a4:	f423 2380 	bic.w	r3, r3, #262144	; 0x40000
 80109a8:	6093      	str	r3, [r2, #8]

  /* Configure the RTC_CR register */
  RTC->CR |= (uint32_t)(RTC_DayLightSaving | RTC_StoreOperation);
 80109aa:	4808      	ldr	r0, [pc, #32]	; (80109cc <RTC_DayLightSavingConfig+0x44>)
 80109ac:	4b07      	ldr	r3, [pc, #28]	; (80109cc <RTC_DayLightSavingConfig+0x44>)
 80109ae:	689a      	ldr	r2, [r3, #8]
 80109b0:	6879      	ldr	r1, [r7, #4]
 80109b2:	683b      	ldr	r3, [r7, #0]
 80109b4:	430b      	orrs	r3, r1
 80109b6:	4313      	orrs	r3, r2
 80109b8:	6083      	str	r3, [r0, #8]

  /* Enable the write protection for RTC registers */
  RTC->WPR = 0xFF; 
 80109ba:	4b04      	ldr	r3, [pc, #16]	; (80109cc <RTC_DayLightSavingConfig+0x44>)
 80109bc:	22ff      	movs	r2, #255	; 0xff
 80109be:	625a      	str	r2, [r3, #36]	; 0x24
}
 80109c0:	bf00      	nop
 80109c2:	370c      	adds	r7, #12
 80109c4:	46bd      	mov	sp, r7
 80109c6:	f85d 7b04 	ldr.w	r7, [sp], #4
 80109ca:	4770      	bx	lr
 80109cc:	40002800 	.word	0x40002800

080109d0 <RTC_GetStoreOperation>:
  * @retval RTC Day Light Saving stored operation.
  *          - RTC_StoreOperation_Reset
  *          - RTC_StoreOperation_Set       
  */
uint32_t RTC_GetStoreOperation(void)
{
 80109d0:	b480      	push	{r7}
 80109d2:	af00      	add	r7, sp, #0
  return (RTC->CR & RTC_CR_BCK);
 80109d4:	4b04      	ldr	r3, [pc, #16]	; (80109e8 <RTC_GetStoreOperation+0x18>)
 80109d6:	689b      	ldr	r3, [r3, #8]
 80109d8:	f403 2380 	and.w	r3, r3, #262144	; 0x40000
}
 80109dc:	4618      	mov	r0, r3
 80109de:	46bd      	mov	sp, r7
 80109e0:	f85d 7b04 	ldr.w	r7, [sp], #4
 80109e4:	4770      	bx	lr
 80109e6:	bf00      	nop
 80109e8:	40002800 	.word	0x40002800

080109ec <RTC_OutputConfig>:
  *            @arg RTC_OutputPolarity_Low: The output pin is low when the 
  *                                 ALRAF/ALRBF/WUTF is high (depending on OSEL)
  * @retval None
  */
void RTC_OutputConfig(uint32_t RTC_Output, uint32_t RTC_OutputPolarity)
{
 80109ec:	b480      	push	{r7}
 80109ee:	b083      	sub	sp, #12
 80109f0:	af00      	add	r7, sp, #0
 80109f2:	6078      	str	r0, [r7, #4]
 80109f4:	6039      	str	r1, [r7, #0]
  /* Check the parameters */
  assert_param(IS_RTC_OUTPUT(RTC_Output));
  assert_param(IS_RTC_OUTPUT_POL(RTC_OutputPolarity));

  /* Disable the write protection for RTC registers */
  RTC->WPR = 0xCA;
 80109f6:	4b0e      	ldr	r3, [pc, #56]	; (8010a30 <RTC_OutputConfig+0x44>)
 80109f8:	22ca      	movs	r2, #202	; 0xca
 80109fa:	625a      	str	r2, [r3, #36]	; 0x24
  RTC->WPR = 0x53;
 80109fc:	4b0c      	ldr	r3, [pc, #48]	; (8010a30 <RTC_OutputConfig+0x44>)
 80109fe:	2253      	movs	r2, #83	; 0x53
 8010a00:	625a      	str	r2, [r3, #36]	; 0x24

  /* Clear the bits to be configured */
  RTC->CR &= (uint32_t)~(RTC_CR_OSEL | RTC_CR_POL);
 8010a02:	4a0b      	ldr	r2, [pc, #44]	; (8010a30 <RTC_OutputConfig+0x44>)
 8010a04:	4b0a      	ldr	r3, [pc, #40]	; (8010a30 <RTC_OutputConfig+0x44>)
 8010a06:	689b      	ldr	r3, [r3, #8]
 8010a08:	f423 03e0 	bic.w	r3, r3, #7340032	; 0x700000
 8010a0c:	6093      	str	r3, [r2, #8]

  /* Configure the output selection and polarity */
  RTC->CR |= (uint32_t)(RTC_Output | RTC_OutputPolarity);
 8010a0e:	4808      	ldr	r0, [pc, #32]	; (8010a30 <RTC_OutputConfig+0x44>)
 8010a10:	4b07      	ldr	r3, [pc, #28]	; (8010a30 <RTC_OutputConfig+0x44>)
 8010a12:	689a      	ldr	r2, [r3, #8]
 8010a14:	6879      	ldr	r1, [r7, #4]
 8010a16:	683b      	ldr	r3, [r7, #0]
 8010a18:	430b      	orrs	r3, r1
 8010a1a:	4313      	orrs	r3, r2
 8010a1c:	6083      	str	r3, [r0, #8]

  /* Enable the write protection for RTC registers */
  RTC->WPR = 0xFF; 
 8010a1e:	4b04      	ldr	r3, [pc, #16]	; (8010a30 <RTC_OutputConfig+0x44>)
 8010a20:	22ff      	movs	r2, #255	; 0xff
 8010a22:	625a      	str	r2, [r3, #36]	; 0x24
}
 8010a24:	bf00      	nop
 8010a26:	370c      	adds	r7, #12
 8010a28:	46bd      	mov	sp, r7
 8010a2a:	f85d 7b04 	ldr.w	r7, [sp], #4
 8010a2e:	4770      	bx	lr
 8010a30:	40002800 	.word	0x40002800

08010a34 <RTC_CoarseCalibConfig>:
  * @retval An ErrorStatus enumeration value:
  *          - SUCCESS: RTC Coarse calibration are initialized
  *          - ERROR: RTC Coarse calibration are not initialized     
  */
ErrorStatus RTC_CoarseCalibConfig(uint32_t RTC_CalibSign, uint32_t Value)
{
 8010a34:	b580      	push	{r7, lr}
 8010a36:	b084      	sub	sp, #16
 8010a38:	af00      	add	r7, sp, #0
 8010a3a:	6078      	str	r0, [r7, #4]
 8010a3c:	6039      	str	r1, [r7, #0]
  ErrorStatus status = ERROR;
 8010a3e:	2300      	movs	r3, #0
 8010a40:	73fb      	strb	r3, [r7, #15]
  /* Check the parameters */
  assert_param(IS_RTC_CALIB_SIGN(RTC_CalibSign));
  assert_param(IS_RTC_CALIB_VALUE(Value)); 

  /* Disable the write protection for RTC registers */
  RTC->WPR = 0xCA;
 8010a42:	4b0f      	ldr	r3, [pc, #60]	; (8010a80 <RTC_CoarseCalibConfig+0x4c>)
 8010a44:	22ca      	movs	r2, #202	; 0xca
 8010a46:	625a      	str	r2, [r3, #36]	; 0x24
  RTC->WPR = 0x53;
 8010a48:	4b0d      	ldr	r3, [pc, #52]	; (8010a80 <RTC_CoarseCalibConfig+0x4c>)
 8010a4a:	2253      	movs	r2, #83	; 0x53
 8010a4c:	625a      	str	r2, [r3, #36]	; 0x24

  /* Set Initialization mode */
  if (RTC_EnterInitMode() == ERROR)
 8010a4e:	f7ff fa71 	bl	800ff34 <RTC_EnterInitMode>
 8010a52:	4603      	mov	r3, r0
 8010a54:	2b00      	cmp	r3, #0
 8010a56:	d102      	bne.n	8010a5e <RTC_CoarseCalibConfig+0x2a>
  {
    status = ERROR;
 8010a58:	2300      	movs	r3, #0
 8010a5a:	73fb      	strb	r3, [r7, #15]
 8010a5c:	e008      	b.n	8010a70 <RTC_CoarseCalibConfig+0x3c>
  } 
  else
  {
    /* Set the coarse calibration value */
    RTC->CALIBR = (uint32_t)(RTC_CalibSign | Value);
 8010a5e:	4908      	ldr	r1, [pc, #32]	; (8010a80 <RTC_CoarseCalibConfig+0x4c>)
 8010a60:	687a      	ldr	r2, [r7, #4]
 8010a62:	683b      	ldr	r3, [r7, #0]
 8010a64:	4313      	orrs	r3, r2
 8010a66:	618b      	str	r3, [r1, #24]
    /* Exit Initialization mode */
    RTC_ExitInitMode();
 8010a68:	f7ff fa9e 	bl	800ffa8 <RTC_ExitInitMode>
    
    status = SUCCESS;
 8010a6c:	2301      	movs	r3, #1
 8010a6e:	73fb      	strb	r3, [r7, #15]
  } 

  /* Enable the write protection for RTC registers */
  RTC->WPR = 0xFF; 
 8010a70:	4b03      	ldr	r3, [pc, #12]	; (8010a80 <RTC_CoarseCalibConfig+0x4c>)
 8010a72:	22ff      	movs	r2, #255	; 0xff
 8010a74:	625a      	str	r2, [r3, #36]	; 0x24
  
  return status;
 8010a76:	7bfb      	ldrb	r3, [r7, #15]
}
 8010a78:	4618      	mov	r0, r3
 8010a7a:	3710      	adds	r7, #16
 8010a7c:	46bd      	mov	sp, r7
 8010a7e:	bd80      	pop	{r7, pc}
 8010a80:	40002800 	.word	0x40002800

08010a84 <RTC_CoarseCalibCmd>:
  * @retval An ErrorStatus enumeration value:
  *          - SUCCESS: RTC Coarse calibration are enabled/disabled
  *          - ERROR: RTC Coarse calibration are not enabled/disabled    
  */
ErrorStatus RTC_CoarseCalibCmd(FunctionalState NewState)
{
 8010a84:	b580      	push	{r7, lr}
 8010a86:	b084      	sub	sp, #16
 8010a88:	af00      	add	r7, sp, #0
 8010a8a:	4603      	mov	r3, r0
 8010a8c:	71fb      	strb	r3, [r7, #7]
  ErrorStatus status = ERROR;
 8010a8e:	2300      	movs	r3, #0
 8010a90:	73fb      	strb	r3, [r7, #15]
  
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  /* Disable the write protection for RTC registers */
  RTC->WPR = 0xCA;
 8010a92:	4b15      	ldr	r3, [pc, #84]	; (8010ae8 <RTC_CoarseCalibCmd+0x64>)
 8010a94:	22ca      	movs	r2, #202	; 0xca
 8010a96:	625a      	str	r2, [r3, #36]	; 0x24
  RTC->WPR = 0x53;
 8010a98:	4b13      	ldr	r3, [pc, #76]	; (8010ae8 <RTC_CoarseCalibCmd+0x64>)
 8010a9a:	2253      	movs	r2, #83	; 0x53
 8010a9c:	625a      	str	r2, [r3, #36]	; 0x24
  
  /* Set Initialization mode */
  if (RTC_EnterInitMode() == ERROR)
 8010a9e:	f7ff fa49 	bl	800ff34 <RTC_EnterInitMode>
 8010aa2:	4603      	mov	r3, r0
 8010aa4:	2b00      	cmp	r3, #0
 8010aa6:	d102      	bne.n	8010aae <RTC_CoarseCalibCmd+0x2a>
  {
    status =  ERROR;
 8010aa8:	2300      	movs	r3, #0
 8010aaa:	73fb      	strb	r3, [r7, #15]
 8010aac:	e013      	b.n	8010ad6 <RTC_CoarseCalibCmd+0x52>
  }
  else
  {
    if (NewState != DISABLE)
 8010aae:	79fb      	ldrb	r3, [r7, #7]
 8010ab0:	2b00      	cmp	r3, #0
 8010ab2:	d006      	beq.n	8010ac2 <RTC_CoarseCalibCmd+0x3e>
    {
      /* Enable the Coarse Calibration */
      RTC->CR |= (uint32_t)RTC_CR_DCE;
 8010ab4:	4a0c      	ldr	r2, [pc, #48]	; (8010ae8 <RTC_CoarseCalibCmd+0x64>)
 8010ab6:	4b0c      	ldr	r3, [pc, #48]	; (8010ae8 <RTC_CoarseCalibCmd+0x64>)
 8010ab8:	689b      	ldr	r3, [r3, #8]
 8010aba:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8010abe:	6093      	str	r3, [r2, #8]
 8010ac0:	e005      	b.n	8010ace <RTC_CoarseCalibCmd+0x4a>
    }
    else
    { 
      /* Disable the Coarse Calibration */
      RTC->CR &= (uint32_t)~RTC_CR_DCE;
 8010ac2:	4a09      	ldr	r2, [pc, #36]	; (8010ae8 <RTC_CoarseCalibCmd+0x64>)
 8010ac4:	4b08      	ldr	r3, [pc, #32]	; (8010ae8 <RTC_CoarseCalibCmd+0x64>)
 8010ac6:	689b      	ldr	r3, [r3, #8]
 8010ac8:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 8010acc:	6093      	str	r3, [r2, #8]
    }
    /* Exit Initialization mode */
    RTC_ExitInitMode();
 8010ace:	f7ff fa6b 	bl	800ffa8 <RTC_ExitInitMode>
    
    status = SUCCESS;
 8010ad2:	2301      	movs	r3, #1
 8010ad4:	73fb      	strb	r3, [r7, #15]
  } 
  
  /* Enable the write protection for RTC registers */
  RTC->WPR = 0xFF; 
 8010ad6:	4b04      	ldr	r3, [pc, #16]	; (8010ae8 <RTC_CoarseCalibCmd+0x64>)
 8010ad8:	22ff      	movs	r2, #255	; 0xff
 8010ada:	625a      	str	r2, [r3, #36]	; 0x24
  
  return status;
 8010adc:	7bfb      	ldrb	r3, [r7, #15]
}
 8010ade:	4618      	mov	r0, r3
 8010ae0:	3710      	adds	r7, #16
 8010ae2:	46bd      	mov	sp, r7
 8010ae4:	bd80      	pop	{r7, pc}
 8010ae6:	bf00      	nop
 8010ae8:	40002800 	.word	0x40002800

08010aec <RTC_CalibOutputCmd>:
  * @param  NewState: new state of the digital calibration Output.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void RTC_CalibOutputCmd(FunctionalState NewState)
{
 8010aec:	b480      	push	{r7}
 8010aee:	b083      	sub	sp, #12
 8010af0:	af00      	add	r7, sp, #0
 8010af2:	4603      	mov	r3, r0
 8010af4:	71fb      	strb	r3, [r7, #7]
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  /* Disable the write protection for RTC registers */
  RTC->WPR = 0xCA;
 8010af6:	4b0f      	ldr	r3, [pc, #60]	; (8010b34 <RTC_CalibOutputCmd+0x48>)
 8010af8:	22ca      	movs	r2, #202	; 0xca
 8010afa:	625a      	str	r2, [r3, #36]	; 0x24
  RTC->WPR = 0x53;
 8010afc:	4b0d      	ldr	r3, [pc, #52]	; (8010b34 <RTC_CalibOutputCmd+0x48>)
 8010afe:	2253      	movs	r2, #83	; 0x53
 8010b00:	625a      	str	r2, [r3, #36]	; 0x24
  
  if (NewState != DISABLE)
 8010b02:	79fb      	ldrb	r3, [r7, #7]
 8010b04:	2b00      	cmp	r3, #0
 8010b06:	d006      	beq.n	8010b16 <RTC_CalibOutputCmd+0x2a>
  {
    /* Enable the RTC clock output */
    RTC->CR |= (uint32_t)RTC_CR_COE;
 8010b08:	4a0a      	ldr	r2, [pc, #40]	; (8010b34 <RTC_CalibOutputCmd+0x48>)
 8010b0a:	4b0a      	ldr	r3, [pc, #40]	; (8010b34 <RTC_CalibOutputCmd+0x48>)
 8010b0c:	689b      	ldr	r3, [r3, #8]
 8010b0e:	f443 0300 	orr.w	r3, r3, #8388608	; 0x800000
 8010b12:	6093      	str	r3, [r2, #8]
 8010b14:	e005      	b.n	8010b22 <RTC_CalibOutputCmd+0x36>
  }
  else
  { 
    /* Disable the RTC clock output */
    RTC->CR &= (uint32_t)~RTC_CR_COE;
 8010b16:	4a07      	ldr	r2, [pc, #28]	; (8010b34 <RTC_CalibOutputCmd+0x48>)
 8010b18:	4b06      	ldr	r3, [pc, #24]	; (8010b34 <RTC_CalibOutputCmd+0x48>)
 8010b1a:	689b      	ldr	r3, [r3, #8]
 8010b1c:	f423 0300 	bic.w	r3, r3, #8388608	; 0x800000
 8010b20:	6093      	str	r3, [r2, #8]
  }
  
  /* Enable the write protection for RTC registers */
  RTC->WPR = 0xFF; 
 8010b22:	4b04      	ldr	r3, [pc, #16]	; (8010b34 <RTC_CalibOutputCmd+0x48>)
 8010b24:	22ff      	movs	r2, #255	; 0xff
 8010b26:	625a      	str	r2, [r3, #36]	; 0x24
}
 8010b28:	bf00      	nop
 8010b2a:	370c      	adds	r7, #12
 8010b2c:	46bd      	mov	sp, r7
 8010b2e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8010b32:	4770      	bx	lr
 8010b34:	40002800 	.word	0x40002800

08010b38 <RTC_CalibOutputConfig>:
  *     @arg RTC_CalibOutput_512Hz: A signal has a regular waveform at 512Hz. 
  *     @arg RTC_CalibOutput_1Hz  : A signal has a regular waveform at 1Hz.
  * @retval None
*/
void RTC_CalibOutputConfig(uint32_t RTC_CalibOutput)
{
 8010b38:	b480      	push	{r7}
 8010b3a:	b083      	sub	sp, #12
 8010b3c:	af00      	add	r7, sp, #0
 8010b3e:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_RTC_CALIB_OUTPUT(RTC_CalibOutput));

  /* Disable the write protection for RTC registers */
  RTC->WPR = 0xCA;
 8010b40:	4b0d      	ldr	r3, [pc, #52]	; (8010b78 <RTC_CalibOutputConfig+0x40>)
 8010b42:	22ca      	movs	r2, #202	; 0xca
 8010b44:	625a      	str	r2, [r3, #36]	; 0x24
  RTC->WPR = 0x53;
 8010b46:	4b0c      	ldr	r3, [pc, #48]	; (8010b78 <RTC_CalibOutputConfig+0x40>)
 8010b48:	2253      	movs	r2, #83	; 0x53
 8010b4a:	625a      	str	r2, [r3, #36]	; 0x24
  
  /*clear flags before config*/
  RTC->CR &= (uint32_t)~(RTC_CR_COSEL);
 8010b4c:	4a0a      	ldr	r2, [pc, #40]	; (8010b78 <RTC_CalibOutputConfig+0x40>)
 8010b4e:	4b0a      	ldr	r3, [pc, #40]	; (8010b78 <RTC_CalibOutputConfig+0x40>)
 8010b50:	689b      	ldr	r3, [r3, #8]
 8010b52:	f423 2300 	bic.w	r3, r3, #524288	; 0x80000
 8010b56:	6093      	str	r3, [r2, #8]

  /* Configure the RTC_CR register */
  RTC->CR |= (uint32_t)RTC_CalibOutput;
 8010b58:	4907      	ldr	r1, [pc, #28]	; (8010b78 <RTC_CalibOutputConfig+0x40>)
 8010b5a:	4b07      	ldr	r3, [pc, #28]	; (8010b78 <RTC_CalibOutputConfig+0x40>)
 8010b5c:	689a      	ldr	r2, [r3, #8]
 8010b5e:	687b      	ldr	r3, [r7, #4]
 8010b60:	4313      	orrs	r3, r2
 8010b62:	608b      	str	r3, [r1, #8]

  /* Enable the write protection for RTC registers */
  RTC->WPR = 0xFF;
 8010b64:	4b04      	ldr	r3, [pc, #16]	; (8010b78 <RTC_CalibOutputConfig+0x40>)
 8010b66:	22ff      	movs	r2, #255	; 0xff
 8010b68:	625a      	str	r2, [r3, #36]	; 0x24
}
 8010b6a:	bf00      	nop
 8010b6c:	370c      	adds	r7, #12
 8010b6e:	46bd      	mov	sp, r7
 8010b70:	f85d 7b04 	ldr.w	r7, [sp], #4
 8010b74:	4770      	bx	lr
 8010b76:	bf00      	nop
 8010b78:	40002800 	.word	0x40002800

08010b7c <RTC_SmoothCalibConfig>:
  *          - ERROR: RTC Calib registers are not configured
*/
ErrorStatus RTC_SmoothCalibConfig(uint32_t RTC_SmoothCalibPeriod,
                                  uint32_t RTC_SmoothCalibPlusPulses,
                                  uint32_t RTC_SmouthCalibMinusPulsesValue)
{
 8010b7c:	b480      	push	{r7}
 8010b7e:	b087      	sub	sp, #28
 8010b80:	af00      	add	r7, sp, #0
 8010b82:	60f8      	str	r0, [r7, #12]
 8010b84:	60b9      	str	r1, [r7, #8]
 8010b86:	607a      	str	r2, [r7, #4]
  ErrorStatus status = ERROR;
 8010b88:	2300      	movs	r3, #0
 8010b8a:	75fb      	strb	r3, [r7, #23]
  uint32_t recalpfcount = 0;
 8010b8c:	2300      	movs	r3, #0
 8010b8e:	613b      	str	r3, [r7, #16]
  assert_param(IS_RTC_SMOOTH_CALIB_PERIOD(RTC_SmoothCalibPeriod));
  assert_param(IS_RTC_SMOOTH_CALIB_PLUS(RTC_SmoothCalibPlusPulses));
  assert_param(IS_RTC_SMOOTH_CALIB_MINUS(RTC_SmouthCalibMinusPulsesValue));

  /* Disable the write protection for RTC registers */
  RTC->WPR = 0xCA;
 8010b90:	4b1a      	ldr	r3, [pc, #104]	; (8010bfc <RTC_SmoothCalibConfig+0x80>)
 8010b92:	22ca      	movs	r2, #202	; 0xca
 8010b94:	625a      	str	r2, [r3, #36]	; 0x24
  RTC->WPR = 0x53;
 8010b96:	4b19      	ldr	r3, [pc, #100]	; (8010bfc <RTC_SmoothCalibConfig+0x80>)
 8010b98:	2253      	movs	r2, #83	; 0x53
 8010b9a:	625a      	str	r2, [r3, #36]	; 0x24
  
  /* check if a calibration is pending*/
  if ((RTC->ISR & RTC_ISR_RECALPF) != RESET)
 8010b9c:	4b17      	ldr	r3, [pc, #92]	; (8010bfc <RTC_SmoothCalibConfig+0x80>)
 8010b9e:	68db      	ldr	r3, [r3, #12]
 8010ba0:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
 8010ba4:	2b00      	cmp	r3, #0
 8010ba6:	d00d      	beq.n	8010bc4 <RTC_SmoothCalibConfig+0x48>
  {
    /* wait until the Calibration is completed*/
    while (((RTC->ISR & RTC_ISR_RECALPF) != RESET) && (recalpfcount != RECALPF_TIMEOUT))
 8010ba8:	e002      	b.n	8010bb0 <RTC_SmoothCalibConfig+0x34>
    {
      recalpfcount++;
 8010baa:	693b      	ldr	r3, [r7, #16]
 8010bac:	3301      	adds	r3, #1
 8010bae:	613b      	str	r3, [r7, #16]
    while (((RTC->ISR & RTC_ISR_RECALPF) != RESET) && (recalpfcount != RECALPF_TIMEOUT))
 8010bb0:	4b12      	ldr	r3, [pc, #72]	; (8010bfc <RTC_SmoothCalibConfig+0x80>)
 8010bb2:	68db      	ldr	r3, [r3, #12]
 8010bb4:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
 8010bb8:	2b00      	cmp	r3, #0
 8010bba:	d003      	beq.n	8010bc4 <RTC_SmoothCalibConfig+0x48>
 8010bbc:	693b      	ldr	r3, [r7, #16]
 8010bbe:	f5b3 3f00 	cmp.w	r3, #131072	; 0x20000
 8010bc2:	d1f2      	bne.n	8010baa <RTC_SmoothCalibConfig+0x2e>
    }
  }

  /* check if the calibration pending is completed or if there is no calibration operation at all*/
  if ((RTC->ISR & RTC_ISR_RECALPF) == RESET)
 8010bc4:	4b0d      	ldr	r3, [pc, #52]	; (8010bfc <RTC_SmoothCalibConfig+0x80>)
 8010bc6:	68db      	ldr	r3, [r3, #12]
 8010bc8:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
 8010bcc:	2b00      	cmp	r3, #0
 8010bce:	d109      	bne.n	8010be4 <RTC_SmoothCalibConfig+0x68>
  {
    /* Configure the Smooth calibration settings */
    RTC->CALR = (uint32_t)((uint32_t)RTC_SmoothCalibPeriod | (uint32_t)RTC_SmoothCalibPlusPulses | (uint32_t)RTC_SmouthCalibMinusPulsesValue);
 8010bd0:	490a      	ldr	r1, [pc, #40]	; (8010bfc <RTC_SmoothCalibConfig+0x80>)
 8010bd2:	68fa      	ldr	r2, [r7, #12]
 8010bd4:	68bb      	ldr	r3, [r7, #8]
 8010bd6:	431a      	orrs	r2, r3
 8010bd8:	687b      	ldr	r3, [r7, #4]
 8010bda:	4313      	orrs	r3, r2
 8010bdc:	63cb      	str	r3, [r1, #60]	; 0x3c

    status = SUCCESS;
 8010bde:	2301      	movs	r3, #1
 8010be0:	75fb      	strb	r3, [r7, #23]
 8010be2:	e001      	b.n	8010be8 <RTC_SmoothCalibConfig+0x6c>
  }
  else
  {
    status = ERROR;
 8010be4:	2300      	movs	r3, #0
 8010be6:	75fb      	strb	r3, [r7, #23]
  }

  /* Enable the write protection for RTC registers */
  RTC->WPR = 0xFF;
 8010be8:	4b04      	ldr	r3, [pc, #16]	; (8010bfc <RTC_SmoothCalibConfig+0x80>)
 8010bea:	22ff      	movs	r2, #255	; 0xff
 8010bec:	625a      	str	r2, [r3, #36]	; 0x24
  
  return (ErrorStatus)(status);
 8010bee:	7dfb      	ldrb	r3, [r7, #23]
}
 8010bf0:	4618      	mov	r0, r3
 8010bf2:	371c      	adds	r7, #28
 8010bf4:	46bd      	mov	sp, r7
 8010bf6:	f85d 7b04 	ldr.w	r7, [sp], #4
 8010bfa:	4770      	bx	lr
 8010bfc:	40002800 	.word	0x40002800

08010c00 <RTC_TimeStampCmd>:
  * @param  NewState: new state of the TimeStamp.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void RTC_TimeStampCmd(uint32_t RTC_TimeStampEdge, FunctionalState NewState)
{
 8010c00:	b480      	push	{r7}
 8010c02:	b085      	sub	sp, #20
 8010c04:	af00      	add	r7, sp, #0
 8010c06:	6078      	str	r0, [r7, #4]
 8010c08:	460b      	mov	r3, r1
 8010c0a:	70fb      	strb	r3, [r7, #3]
  uint32_t tmpreg = 0;
 8010c0c:	2300      	movs	r3, #0
 8010c0e:	60fb      	str	r3, [r7, #12]
  /* Check the parameters */
  assert_param(IS_RTC_TIMESTAMP_EDGE(RTC_TimeStampEdge));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  /* Get the RTC_CR register and clear the bits to be configured */
  tmpreg = (uint32_t)(RTC->CR & (uint32_t)~(RTC_CR_TSEDGE | RTC_CR_TSE));
 8010c10:	4b13      	ldr	r3, [pc, #76]	; (8010c60 <RTC_TimeStampCmd+0x60>)
 8010c12:	689b      	ldr	r3, [r3, #8]
 8010c14:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
 8010c18:	f023 0308 	bic.w	r3, r3, #8
 8010c1c:	60fb      	str	r3, [r7, #12]

  /* Get the new configuration */
  if (NewState != DISABLE)
 8010c1e:	78fb      	ldrb	r3, [r7, #3]
 8010c20:	2b00      	cmp	r3, #0
 8010c22:	d006      	beq.n	8010c32 <RTC_TimeStampCmd+0x32>
  {
    tmpreg |= (uint32_t)(RTC_TimeStampEdge | RTC_CR_TSE);
 8010c24:	687a      	ldr	r2, [r7, #4]
 8010c26:	68fb      	ldr	r3, [r7, #12]
 8010c28:	4313      	orrs	r3, r2
 8010c2a:	f443 6300 	orr.w	r3, r3, #2048	; 0x800
 8010c2e:	60fb      	str	r3, [r7, #12]
 8010c30:	e003      	b.n	8010c3a <RTC_TimeStampCmd+0x3a>
  }
  else
  {
    tmpreg |= (uint32_t)(RTC_TimeStampEdge);
 8010c32:	68fa      	ldr	r2, [r7, #12]
 8010c34:	687b      	ldr	r3, [r7, #4]
 8010c36:	4313      	orrs	r3, r2
 8010c38:	60fb      	str	r3, [r7, #12]
  }

  /* Disable the write protection for RTC registers */
  RTC->WPR = 0xCA;
 8010c3a:	4b09      	ldr	r3, [pc, #36]	; (8010c60 <RTC_TimeStampCmd+0x60>)
 8010c3c:	22ca      	movs	r2, #202	; 0xca
 8010c3e:	625a      	str	r2, [r3, #36]	; 0x24
  RTC->WPR = 0x53;
 8010c40:	4b07      	ldr	r3, [pc, #28]	; (8010c60 <RTC_TimeStampCmd+0x60>)
 8010c42:	2253      	movs	r2, #83	; 0x53
 8010c44:	625a      	str	r2, [r3, #36]	; 0x24

  /* Configure the Time Stamp TSEDGE and Enable bits */
  RTC->CR = (uint32_t)tmpreg;
 8010c46:	4a06      	ldr	r2, [pc, #24]	; (8010c60 <RTC_TimeStampCmd+0x60>)
 8010c48:	68fb      	ldr	r3, [r7, #12]
 8010c4a:	6093      	str	r3, [r2, #8]

  /* Enable the write protection for RTC registers */
  RTC->WPR = 0xFF; 
 8010c4c:	4b04      	ldr	r3, [pc, #16]	; (8010c60 <RTC_TimeStampCmd+0x60>)
 8010c4e:	22ff      	movs	r2, #255	; 0xff
 8010c50:	625a      	str	r2, [r3, #36]	; 0x24
}
 8010c52:	bf00      	nop
 8010c54:	3714      	adds	r7, #20
 8010c56:	46bd      	mov	sp, r7
 8010c58:	f85d 7b04 	ldr.w	r7, [sp], #4
 8010c5c:	4770      	bx	lr
 8010c5e:	bf00      	nop
 8010c60:	40002800 	.word	0x40002800

08010c64 <RTC_GetTimeStamp>:
  *                             contains the TimeStamp date values.     
  * @retval None
  */
void RTC_GetTimeStamp(uint32_t RTC_Format, RTC_TimeTypeDef* RTC_StampTimeStruct, 
                                      RTC_DateTypeDef* RTC_StampDateStruct)
{
 8010c64:	b580      	push	{r7, lr}
 8010c66:	b086      	sub	sp, #24
 8010c68:	af00      	add	r7, sp, #0
 8010c6a:	60f8      	str	r0, [r7, #12]
 8010c6c:	60b9      	str	r1, [r7, #8]
 8010c6e:	607a      	str	r2, [r7, #4]
  uint32_t tmptime = 0, tmpdate = 0;
 8010c70:	2300      	movs	r3, #0
 8010c72:	617b      	str	r3, [r7, #20]
 8010c74:	2300      	movs	r3, #0
 8010c76:	613b      	str	r3, [r7, #16]

  /* Check the parameters */
  assert_param(IS_RTC_FORMAT(RTC_Format));

  /* Get the TimeStamp time and date registers values */
  tmptime = (uint32_t)(RTC->TSTR & RTC_TR_RESERVED_MASK);
 8010c78:	4b41      	ldr	r3, [pc, #260]	; (8010d80 <RTC_GetTimeStamp+0x11c>)
 8010c7a:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8010c7c:	f003 337f 	and.w	r3, r3, #2139062143	; 0x7f7f7f7f
 8010c80:	f023 43fe 	bic.w	r3, r3, #2130706432	; 0x7f000000
 8010c84:	617b      	str	r3, [r7, #20]
  tmpdate = (uint32_t)(RTC->TSDR & RTC_DR_RESERVED_MASK);
 8010c86:	4b3e      	ldr	r3, [pc, #248]	; (8010d80 <RTC_GetTimeStamp+0x11c>)
 8010c88:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8010c8a:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
 8010c8e:	f023 03c0 	bic.w	r3, r3, #192	; 0xc0
 8010c92:	613b      	str	r3, [r7, #16]

  /* Fill the Time structure fields with the read parameters */
  RTC_StampTimeStruct->RTC_Hours = (uint8_t)((tmptime & (RTC_TR_HT | RTC_TR_HU)) >> 16);
 8010c94:	697b      	ldr	r3, [r7, #20]
 8010c96:	0c1b      	lsrs	r3, r3, #16
 8010c98:	b2db      	uxtb	r3, r3
 8010c9a:	f003 033f 	and.w	r3, r3, #63	; 0x3f
 8010c9e:	b2da      	uxtb	r2, r3
 8010ca0:	68bb      	ldr	r3, [r7, #8]
 8010ca2:	701a      	strb	r2, [r3, #0]
  RTC_StampTimeStruct->RTC_Minutes = (uint8_t)((tmptime & (RTC_TR_MNT | RTC_TR_MNU)) >> 8);
 8010ca4:	697b      	ldr	r3, [r7, #20]
 8010ca6:	0a1b      	lsrs	r3, r3, #8
 8010ca8:	b2db      	uxtb	r3, r3
 8010caa:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 8010cae:	b2da      	uxtb	r2, r3
 8010cb0:	68bb      	ldr	r3, [r7, #8]
 8010cb2:	705a      	strb	r2, [r3, #1]
  RTC_StampTimeStruct->RTC_Seconds = (uint8_t)(tmptime & (RTC_TR_ST | RTC_TR_SU));
 8010cb4:	697b      	ldr	r3, [r7, #20]
 8010cb6:	b2db      	uxtb	r3, r3
 8010cb8:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 8010cbc:	b2da      	uxtb	r2, r3
 8010cbe:	68bb      	ldr	r3, [r7, #8]
 8010cc0:	709a      	strb	r2, [r3, #2]
  RTC_StampTimeStruct->RTC_H12 = (uint8_t)((tmptime & (RTC_TR_PM)) >> 16);  
 8010cc2:	697b      	ldr	r3, [r7, #20]
 8010cc4:	0c1b      	lsrs	r3, r3, #16
 8010cc6:	b2db      	uxtb	r3, r3
 8010cc8:	f003 0340 	and.w	r3, r3, #64	; 0x40
 8010ccc:	b2da      	uxtb	r2, r3
 8010cce:	68bb      	ldr	r3, [r7, #8]
 8010cd0:	70da      	strb	r2, [r3, #3]

  /* Fill the Date structure fields with the read parameters */
  RTC_StampDateStruct->RTC_Year = 0;
 8010cd2:	687b      	ldr	r3, [r7, #4]
 8010cd4:	2200      	movs	r2, #0
 8010cd6:	70da      	strb	r2, [r3, #3]
  RTC_StampDateStruct->RTC_Month = (uint8_t)((tmpdate & (RTC_DR_MT | RTC_DR_MU)) >> 8);
 8010cd8:	693b      	ldr	r3, [r7, #16]
 8010cda:	0a1b      	lsrs	r3, r3, #8
 8010cdc:	b2db      	uxtb	r3, r3
 8010cde:	f003 031f 	and.w	r3, r3, #31
 8010ce2:	b2da      	uxtb	r2, r3
 8010ce4:	687b      	ldr	r3, [r7, #4]
 8010ce6:	705a      	strb	r2, [r3, #1]
  RTC_StampDateStruct->RTC_Date = (uint8_t)(tmpdate & (RTC_DR_DT | RTC_DR_DU));
 8010ce8:	693b      	ldr	r3, [r7, #16]
 8010cea:	b2db      	uxtb	r3, r3
 8010cec:	f003 033f 	and.w	r3, r3, #63	; 0x3f
 8010cf0:	b2da      	uxtb	r2, r3
 8010cf2:	687b      	ldr	r3, [r7, #4]
 8010cf4:	709a      	strb	r2, [r3, #2]
  RTC_StampDateStruct->RTC_WeekDay = (uint8_t)((tmpdate & (RTC_DR_WDU)) >> 13);
 8010cf6:	693b      	ldr	r3, [r7, #16]
 8010cf8:	0b5b      	lsrs	r3, r3, #13
 8010cfa:	b2db      	uxtb	r3, r3
 8010cfc:	f003 0307 	and.w	r3, r3, #7
 8010d00:	b2da      	uxtb	r2, r3
 8010d02:	687b      	ldr	r3, [r7, #4]
 8010d04:	701a      	strb	r2, [r3, #0]

  /* Check the input parameters format */
  if (RTC_Format == RTC_Format_BIN)
 8010d06:	68fb      	ldr	r3, [r7, #12]
 8010d08:	2b00      	cmp	r3, #0
 8010d0a:	d135      	bne.n	8010d78 <RTC_GetTimeStamp+0x114>
  {
    /* Convert the Time structure parameters to Binary format */
    RTC_StampTimeStruct->RTC_Hours = (uint8_t)RTC_Bcd2ToByte(RTC_StampTimeStruct->RTC_Hours);
 8010d0c:	68bb      	ldr	r3, [r7, #8]
 8010d0e:	781b      	ldrb	r3, [r3, #0]
 8010d10:	4618      	mov	r0, r3
 8010d12:	f000 fab6 	bl	8011282 <RTC_Bcd2ToByte>
 8010d16:	4603      	mov	r3, r0
 8010d18:	461a      	mov	r2, r3
 8010d1a:	68bb      	ldr	r3, [r7, #8]
 8010d1c:	701a      	strb	r2, [r3, #0]
    RTC_StampTimeStruct->RTC_Minutes = (uint8_t)RTC_Bcd2ToByte(RTC_StampTimeStruct->RTC_Minutes);
 8010d1e:	68bb      	ldr	r3, [r7, #8]
 8010d20:	785b      	ldrb	r3, [r3, #1]
 8010d22:	4618      	mov	r0, r3
 8010d24:	f000 faad 	bl	8011282 <RTC_Bcd2ToByte>
 8010d28:	4603      	mov	r3, r0
 8010d2a:	461a      	mov	r2, r3
 8010d2c:	68bb      	ldr	r3, [r7, #8]
 8010d2e:	705a      	strb	r2, [r3, #1]
    RTC_StampTimeStruct->RTC_Seconds = (uint8_t)RTC_Bcd2ToByte(RTC_StampTimeStruct->RTC_Seconds);
 8010d30:	68bb      	ldr	r3, [r7, #8]
 8010d32:	789b      	ldrb	r3, [r3, #2]
 8010d34:	4618      	mov	r0, r3
 8010d36:	f000 faa4 	bl	8011282 <RTC_Bcd2ToByte>
 8010d3a:	4603      	mov	r3, r0
 8010d3c:	461a      	mov	r2, r3
 8010d3e:	68bb      	ldr	r3, [r7, #8]
 8010d40:	709a      	strb	r2, [r3, #2]

    /* Convert the Date structure parameters to Binary format */
    RTC_StampDateStruct->RTC_Month = (uint8_t)RTC_Bcd2ToByte(RTC_StampDateStruct->RTC_Month);
 8010d42:	687b      	ldr	r3, [r7, #4]
 8010d44:	785b      	ldrb	r3, [r3, #1]
 8010d46:	4618      	mov	r0, r3
 8010d48:	f000 fa9b 	bl	8011282 <RTC_Bcd2ToByte>
 8010d4c:	4603      	mov	r3, r0
 8010d4e:	461a      	mov	r2, r3
 8010d50:	687b      	ldr	r3, [r7, #4]
 8010d52:	705a      	strb	r2, [r3, #1]
    RTC_StampDateStruct->RTC_Date = (uint8_t)RTC_Bcd2ToByte(RTC_StampDateStruct->RTC_Date);
 8010d54:	687b      	ldr	r3, [r7, #4]
 8010d56:	789b      	ldrb	r3, [r3, #2]
 8010d58:	4618      	mov	r0, r3
 8010d5a:	f000 fa92 	bl	8011282 <RTC_Bcd2ToByte>
 8010d5e:	4603      	mov	r3, r0
 8010d60:	461a      	mov	r2, r3
 8010d62:	687b      	ldr	r3, [r7, #4]
 8010d64:	709a      	strb	r2, [r3, #2]
    RTC_StampDateStruct->RTC_WeekDay = (uint8_t)RTC_Bcd2ToByte(RTC_StampDateStruct->RTC_WeekDay);
 8010d66:	687b      	ldr	r3, [r7, #4]
 8010d68:	781b      	ldrb	r3, [r3, #0]
 8010d6a:	4618      	mov	r0, r3
 8010d6c:	f000 fa89 	bl	8011282 <RTC_Bcd2ToByte>
 8010d70:	4603      	mov	r3, r0
 8010d72:	461a      	mov	r2, r3
 8010d74:	687b      	ldr	r3, [r7, #4]
 8010d76:	701a      	strb	r2, [r3, #0]
  }
}
 8010d78:	bf00      	nop
 8010d7a:	3718      	adds	r7, #24
 8010d7c:	46bd      	mov	sp, r7
 8010d7e:	bd80      	pop	{r7, pc}
 8010d80:	40002800 	.word	0x40002800

08010d84 <RTC_GetTimeStampSubSecond>:
  * @brief  Get the RTC timestamp Subseconds value.
  * @param  None
  * @retval RTC current timestamp Subseconds value.
  */
uint32_t RTC_GetTimeStampSubSecond(void)
{
 8010d84:	b480      	push	{r7}
 8010d86:	af00      	add	r7, sp, #0
  /* Get timestamp subseconds values from the correspondent registers */
  return (uint32_t)(RTC->TSSSR);
 8010d88:	4b03      	ldr	r3, [pc, #12]	; (8010d98 <RTC_GetTimeStampSubSecond+0x14>)
 8010d8a:	6b9b      	ldr	r3, [r3, #56]	; 0x38
}
 8010d8c:	4618      	mov	r0, r3
 8010d8e:	46bd      	mov	sp, r7
 8010d90:	f85d 7b04 	ldr.w	r7, [sp], #4
 8010d94:	4770      	bx	lr
 8010d96:	bf00      	nop
 8010d98:	40002800 	.word	0x40002800

08010d9c <RTC_TamperTriggerConfig>:
  *     @arg RTC_TamperTrigger_LowLevel: Low Level of the tamper pin causes tamper event.
  *     @arg RTC_TamperTrigger_HighLevel: High Level of the tamper pin causes tamper event.
  * @retval None
  */
void RTC_TamperTriggerConfig(uint32_t RTC_Tamper, uint32_t RTC_TamperTrigger)
{
 8010d9c:	b480      	push	{r7}
 8010d9e:	b083      	sub	sp, #12
 8010da0:	af00      	add	r7, sp, #0
 8010da2:	6078      	str	r0, [r7, #4]
 8010da4:	6039      	str	r1, [r7, #0]
  /* Check the parameters */
  assert_param(IS_RTC_TAMPER(RTC_Tamper)); 
  assert_param(IS_RTC_TAMPER_TRIGGER(RTC_TamperTrigger));
 
  if (RTC_TamperTrigger == RTC_TamperTrigger_RisingEdge)
 8010da6:	683b      	ldr	r3, [r7, #0]
 8010da8:	2b00      	cmp	r3, #0
 8010daa:	d108      	bne.n	8010dbe <RTC_TamperTriggerConfig+0x22>
  {  
    /* Configure the RTC_TAFCR register */
    RTC->TAFCR &= (uint32_t)((uint32_t)~(RTC_Tamper << 1));	
 8010dac:	490a      	ldr	r1, [pc, #40]	; (8010dd8 <RTC_TamperTriggerConfig+0x3c>)
 8010dae:	4b0a      	ldr	r3, [pc, #40]	; (8010dd8 <RTC_TamperTriggerConfig+0x3c>)
 8010db0:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 8010db2:	687b      	ldr	r3, [r7, #4]
 8010db4:	005b      	lsls	r3, r3, #1
 8010db6:	43db      	mvns	r3, r3
 8010db8:	4013      	ands	r3, r2
 8010dba:	640b      	str	r3, [r1, #64]	; 0x40
  else
  { 
    /* Configure the RTC_TAFCR register */
    RTC->TAFCR |= (uint32_t)(RTC_Tamper << 1);  
  }  
}
 8010dbc:	e006      	b.n	8010dcc <RTC_TamperTriggerConfig+0x30>
    RTC->TAFCR |= (uint32_t)(RTC_Tamper << 1);  
 8010dbe:	4906      	ldr	r1, [pc, #24]	; (8010dd8 <RTC_TamperTriggerConfig+0x3c>)
 8010dc0:	4b05      	ldr	r3, [pc, #20]	; (8010dd8 <RTC_TamperTriggerConfig+0x3c>)
 8010dc2:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 8010dc4:	687b      	ldr	r3, [r7, #4]
 8010dc6:	005b      	lsls	r3, r3, #1
 8010dc8:	4313      	orrs	r3, r2
 8010dca:	640b      	str	r3, [r1, #64]	; 0x40
}
 8010dcc:	bf00      	nop
 8010dce:	370c      	adds	r7, #12
 8010dd0:	46bd      	mov	sp, r7
 8010dd2:	f85d 7b04 	ldr.w	r7, [sp], #4
 8010dd6:	4770      	bx	lr
 8010dd8:	40002800 	.word	0x40002800

08010ddc <RTC_TamperCmd>:
  * @param  NewState: new state of the tamper pin.
  *          This parameter can be: ENABLE or DISABLE.                   
  * @retval None
  */
void RTC_TamperCmd(uint32_t RTC_Tamper, FunctionalState NewState)
{
 8010ddc:	b480      	push	{r7}
 8010dde:	b083      	sub	sp, #12
 8010de0:	af00      	add	r7, sp, #0
 8010de2:	6078      	str	r0, [r7, #4]
 8010de4:	460b      	mov	r3, r1
 8010de6:	70fb      	strb	r3, [r7, #3]
  /* Check the parameters */
  assert_param(IS_RTC_TAMPER(RTC_Tamper));  
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
 8010de8:	78fb      	ldrb	r3, [r7, #3]
 8010dea:	2b00      	cmp	r3, #0
 8010dec:	d006      	beq.n	8010dfc <RTC_TamperCmd+0x20>
  {
    /* Enable the selected Tamper pin */
    RTC->TAFCR |= (uint32_t)RTC_Tamper;
 8010dee:	490a      	ldr	r1, [pc, #40]	; (8010e18 <RTC_TamperCmd+0x3c>)
 8010df0:	4b09      	ldr	r3, [pc, #36]	; (8010e18 <RTC_TamperCmd+0x3c>)
 8010df2:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 8010df4:	687b      	ldr	r3, [r7, #4]
 8010df6:	4313      	orrs	r3, r2
 8010df8:	640b      	str	r3, [r1, #64]	; 0x40
  else
  {
    /* Disable the selected Tamper pin */
    RTC->TAFCR &= (uint32_t)~RTC_Tamper;    
  }  
}
 8010dfa:	e006      	b.n	8010e0a <RTC_TamperCmd+0x2e>
    RTC->TAFCR &= (uint32_t)~RTC_Tamper;    
 8010dfc:	4906      	ldr	r1, [pc, #24]	; (8010e18 <RTC_TamperCmd+0x3c>)
 8010dfe:	4b06      	ldr	r3, [pc, #24]	; (8010e18 <RTC_TamperCmd+0x3c>)
 8010e00:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 8010e02:	687b      	ldr	r3, [r7, #4]
 8010e04:	43db      	mvns	r3, r3
 8010e06:	4013      	ands	r3, r2
 8010e08:	640b      	str	r3, [r1, #64]	; 0x40
}
 8010e0a:	bf00      	nop
 8010e0c:	370c      	adds	r7, #12
 8010e0e:	46bd      	mov	sp, r7
 8010e10:	f85d 7b04 	ldr.w	r7, [sp], #4
 8010e14:	4770      	bx	lr
 8010e16:	bf00      	nop
 8010e18:	40002800 	.word	0x40002800

08010e1c <RTC_TamperFilterConfig>:
  *     @arg RTC_TamperFilter_8Sample: Tamper is activated after 8 consecutive 
  *                                    samples at the active level 
  * @retval None
  */
void RTC_TamperFilterConfig(uint32_t RTC_TamperFilter)
{
 8010e1c:	b480      	push	{r7}
 8010e1e:	b083      	sub	sp, #12
 8010e20:	af00      	add	r7, sp, #0
 8010e22:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_RTC_TAMPER_FILTER(RTC_TamperFilter));
   
  /* Clear TAMPFLT[1:0] bits in the RTC_TAFCR register */
  RTC->TAFCR &= (uint32_t)~(RTC_TAFCR_TAMPFLT);
 8010e24:	4a08      	ldr	r2, [pc, #32]	; (8010e48 <RTC_TamperFilterConfig+0x2c>)
 8010e26:	4b08      	ldr	r3, [pc, #32]	; (8010e48 <RTC_TamperFilterConfig+0x2c>)
 8010e28:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8010e2a:	f423 53c0 	bic.w	r3, r3, #6144	; 0x1800
 8010e2e:	6413      	str	r3, [r2, #64]	; 0x40

  /* Configure the RTC_TAFCR register */
  RTC->TAFCR |= (uint32_t)RTC_TamperFilter;
 8010e30:	4905      	ldr	r1, [pc, #20]	; (8010e48 <RTC_TamperFilterConfig+0x2c>)
 8010e32:	4b05      	ldr	r3, [pc, #20]	; (8010e48 <RTC_TamperFilterConfig+0x2c>)
 8010e34:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 8010e36:	687b      	ldr	r3, [r7, #4]
 8010e38:	4313      	orrs	r3, r2
 8010e3a:	640b      	str	r3, [r1, #64]	; 0x40
}
 8010e3c:	bf00      	nop
 8010e3e:	370c      	adds	r7, #12
 8010e40:	46bd      	mov	sp, r7
 8010e42:	f85d 7b04 	ldr.w	r7, [sp], #4
 8010e46:	4770      	bx	lr
 8010e48:	40002800 	.word	0x40002800

08010e4c <RTC_TamperSamplingFreqConfig>:
  *     @arg RTC_TamperSamplingFreq_RTCCLK_Div256: Each of the tamper inputs are sampled
  *                                           with a frequency =  RTCCLK / 256  
  * @retval None
  */
void RTC_TamperSamplingFreqConfig(uint32_t RTC_TamperSamplingFreq)
{
 8010e4c:	b480      	push	{r7}
 8010e4e:	b083      	sub	sp, #12
 8010e50:	af00      	add	r7, sp, #0
 8010e52:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_RTC_TAMPER_SAMPLING_FREQ(RTC_TamperSamplingFreq));
 
  /* Clear TAMPFREQ[2:0] bits in the RTC_TAFCR register */
  RTC->TAFCR &= (uint32_t)~(RTC_TAFCR_TAMPFREQ);
 8010e54:	4a08      	ldr	r2, [pc, #32]	; (8010e78 <RTC_TamperSamplingFreqConfig+0x2c>)
 8010e56:	4b08      	ldr	r3, [pc, #32]	; (8010e78 <RTC_TamperSamplingFreqConfig+0x2c>)
 8010e58:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8010e5a:	f423 63e0 	bic.w	r3, r3, #1792	; 0x700
 8010e5e:	6413      	str	r3, [r2, #64]	; 0x40

  /* Configure the RTC_TAFCR register */
  RTC->TAFCR |= (uint32_t)RTC_TamperSamplingFreq;
 8010e60:	4905      	ldr	r1, [pc, #20]	; (8010e78 <RTC_TamperSamplingFreqConfig+0x2c>)
 8010e62:	4b05      	ldr	r3, [pc, #20]	; (8010e78 <RTC_TamperSamplingFreqConfig+0x2c>)
 8010e64:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 8010e66:	687b      	ldr	r3, [r7, #4]
 8010e68:	4313      	orrs	r3, r2
 8010e6a:	640b      	str	r3, [r1, #64]	; 0x40
}
 8010e6c:	bf00      	nop
 8010e6e:	370c      	adds	r7, #12
 8010e70:	46bd      	mov	sp, r7
 8010e72:	f85d 7b04 	ldr.w	r7, [sp], #4
 8010e76:	4770      	bx	lr
 8010e78:	40002800 	.word	0x40002800

08010e7c <RTC_TamperPinsPrechargeDuration>:
  *     @arg RTC_TamperPrechargeDuration_4RTCCLK: Tamper pins are pre-charged before sampling during 4 RTCCLK cycle    
  *     @arg RTC_TamperPrechargeDuration_8RTCCLK: Tamper pins are pre-charged before sampling during 8 RTCCLK cycle
  * @retval None
  */
void RTC_TamperPinsPrechargeDuration(uint32_t RTC_TamperPrechargeDuration)
{
 8010e7c:	b480      	push	{r7}
 8010e7e:	b083      	sub	sp, #12
 8010e80:	af00      	add	r7, sp, #0
 8010e82:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_RTC_TAMPER_PRECHARGE_DURATION(RTC_TamperPrechargeDuration));
   
  /* Clear TAMPPRCH[1:0] bits in the RTC_TAFCR register */
  RTC->TAFCR &= (uint32_t)~(RTC_TAFCR_TAMPPRCH);
 8010e84:	4a08      	ldr	r2, [pc, #32]	; (8010ea8 <RTC_TamperPinsPrechargeDuration+0x2c>)
 8010e86:	4b08      	ldr	r3, [pc, #32]	; (8010ea8 <RTC_TamperPinsPrechargeDuration+0x2c>)
 8010e88:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8010e8a:	f423 43c0 	bic.w	r3, r3, #24576	; 0x6000
 8010e8e:	6413      	str	r3, [r2, #64]	; 0x40

  /* Configure the RTC_TAFCR register */
  RTC->TAFCR |= (uint32_t)RTC_TamperPrechargeDuration;
 8010e90:	4905      	ldr	r1, [pc, #20]	; (8010ea8 <RTC_TamperPinsPrechargeDuration+0x2c>)
 8010e92:	4b05      	ldr	r3, [pc, #20]	; (8010ea8 <RTC_TamperPinsPrechargeDuration+0x2c>)
 8010e94:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 8010e96:	687b      	ldr	r3, [r7, #4]
 8010e98:	4313      	orrs	r3, r2
 8010e9a:	640b      	str	r3, [r1, #64]	; 0x40
}
 8010e9c:	bf00      	nop
 8010e9e:	370c      	adds	r7, #12
 8010ea0:	46bd      	mov	sp, r7
 8010ea2:	f85d 7b04 	ldr.w	r7, [sp], #4
 8010ea6:	4770      	bx	lr
 8010ea8:	40002800 	.word	0x40002800

08010eac <RTC_TimeStampOnTamperDetectionCmd>:
  * @param  NewState: new state of the timestamp on tamper event.
  *         This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void RTC_TimeStampOnTamperDetectionCmd(FunctionalState NewState)
{
 8010eac:	b480      	push	{r7}
 8010eae:	b083      	sub	sp, #12
 8010eb0:	af00      	add	r7, sp, #0
 8010eb2:	4603      	mov	r3, r0
 8010eb4:	71fb      	strb	r3, [r7, #7]
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
   
  if (NewState != DISABLE)
 8010eb6:	79fb      	ldrb	r3, [r7, #7]
 8010eb8:	2b00      	cmp	r3, #0
 8010eba:	d006      	beq.n	8010eca <RTC_TimeStampOnTamperDetectionCmd+0x1e>
  {
    /* Save timestamp on tamper detection event */
    RTC->TAFCR |= (uint32_t)RTC_TAFCR_TAMPTS;
 8010ebc:	4a09      	ldr	r2, [pc, #36]	; (8010ee4 <RTC_TimeStampOnTamperDetectionCmd+0x38>)
 8010ebe:	4b09      	ldr	r3, [pc, #36]	; (8010ee4 <RTC_TimeStampOnTamperDetectionCmd+0x38>)
 8010ec0:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8010ec2:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8010ec6:	6413      	str	r3, [r2, #64]	; 0x40
  else
  {
    /* Tamper detection does not cause a timestamp to be saved */
    RTC->TAFCR &= (uint32_t)~RTC_TAFCR_TAMPTS;    
  }
}
 8010ec8:	e005      	b.n	8010ed6 <RTC_TimeStampOnTamperDetectionCmd+0x2a>
    RTC->TAFCR &= (uint32_t)~RTC_TAFCR_TAMPTS;    
 8010eca:	4a06      	ldr	r2, [pc, #24]	; (8010ee4 <RTC_TimeStampOnTamperDetectionCmd+0x38>)
 8010ecc:	4b05      	ldr	r3, [pc, #20]	; (8010ee4 <RTC_TimeStampOnTamperDetectionCmd+0x38>)
 8010ece:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8010ed0:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 8010ed4:	6413      	str	r3, [r2, #64]	; 0x40
}
 8010ed6:	bf00      	nop
 8010ed8:	370c      	adds	r7, #12
 8010eda:	46bd      	mov	sp, r7
 8010edc:	f85d 7b04 	ldr.w	r7, [sp], #4
 8010ee0:	4770      	bx	lr
 8010ee2:	bf00      	nop
 8010ee4:	40002800 	.word	0x40002800

08010ee8 <RTC_TamperPullUpCmd>:
  * @param  NewState: new state of tamper pull up.
  *   This parameter can be: ENABLE or DISABLE.                   
  * @retval None
  */
void RTC_TamperPullUpCmd(FunctionalState NewState)
{
 8010ee8:	b480      	push	{r7}
 8010eea:	b083      	sub	sp, #12
 8010eec:	af00      	add	r7, sp, #0
 8010eee:	4603      	mov	r3, r0
 8010ef0:	71fb      	strb	r3, [r7, #7]
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
 if (NewState != DISABLE)
 8010ef2:	79fb      	ldrb	r3, [r7, #7]
 8010ef4:	2b00      	cmp	r3, #0
 8010ef6:	d006      	beq.n	8010f06 <RTC_TamperPullUpCmd+0x1e>
  {
    /* Enable precharge of the selected Tamper pin */
    RTC->TAFCR &= (uint32_t)~RTC_TAFCR_TAMPPUDIS; 
 8010ef8:	4a09      	ldr	r2, [pc, #36]	; (8010f20 <RTC_TamperPullUpCmd+0x38>)
 8010efa:	4b09      	ldr	r3, [pc, #36]	; (8010f20 <RTC_TamperPullUpCmd+0x38>)
 8010efc:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8010efe:	f423 4300 	bic.w	r3, r3, #32768	; 0x8000
 8010f02:	6413      	str	r3, [r2, #64]	; 0x40
  else
  {
    /* Disable precharge of the selected Tamper pin */
    RTC->TAFCR |= (uint32_t)RTC_TAFCR_TAMPPUDIS;    
  } 
}
 8010f04:	e005      	b.n	8010f12 <RTC_TamperPullUpCmd+0x2a>
    RTC->TAFCR |= (uint32_t)RTC_TAFCR_TAMPPUDIS;    
 8010f06:	4a06      	ldr	r2, [pc, #24]	; (8010f20 <RTC_TamperPullUpCmd+0x38>)
 8010f08:	4b05      	ldr	r3, [pc, #20]	; (8010f20 <RTC_TamperPullUpCmd+0x38>)
 8010f0a:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8010f0c:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 8010f10:	6413      	str	r3, [r2, #64]	; 0x40
}
 8010f12:	bf00      	nop
 8010f14:	370c      	adds	r7, #12
 8010f16:	46bd      	mov	sp, r7
 8010f18:	f85d 7b04 	ldr.w	r7, [sp], #4
 8010f1c:	4770      	bx	lr
 8010f1e:	bf00      	nop
 8010f20:	40002800 	.word	0x40002800

08010f24 <RTC_WriteBackupRegister>:
  *                          specify the register.
  * @param  Data: Data to be written in the specified RTC Backup data register.                     
  * @retval None
  */
void RTC_WriteBackupRegister(uint32_t RTC_BKP_DR, uint32_t Data)
{
 8010f24:	b480      	push	{r7}
 8010f26:	b085      	sub	sp, #20
 8010f28:	af00      	add	r7, sp, #0
 8010f2a:	6078      	str	r0, [r7, #4]
 8010f2c:	6039      	str	r1, [r7, #0]
  __IO uint32_t tmp = 0;
 8010f2e:	2300      	movs	r3, #0
 8010f30:	60fb      	str	r3, [r7, #12]
  
  /* Check the parameters */
  assert_param(IS_RTC_BKP(RTC_BKP_DR));

  tmp = RTC_BASE + 0x50;
 8010f32:	4b08      	ldr	r3, [pc, #32]	; (8010f54 <RTC_WriteBackupRegister+0x30>)
 8010f34:	60fb      	str	r3, [r7, #12]
  tmp += (RTC_BKP_DR * 4);
 8010f36:	687b      	ldr	r3, [r7, #4]
 8010f38:	009a      	lsls	r2, r3, #2
 8010f3a:	68fb      	ldr	r3, [r7, #12]
 8010f3c:	4413      	add	r3, r2
 8010f3e:	60fb      	str	r3, [r7, #12]

  /* Write the specified register */
  *(__IO uint32_t *)tmp = (uint32_t)Data;
 8010f40:	68fb      	ldr	r3, [r7, #12]
 8010f42:	461a      	mov	r2, r3
 8010f44:	683b      	ldr	r3, [r7, #0]
 8010f46:	6013      	str	r3, [r2, #0]
}
 8010f48:	bf00      	nop
 8010f4a:	3714      	adds	r7, #20
 8010f4c:	46bd      	mov	sp, r7
 8010f4e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8010f52:	4770      	bx	lr
 8010f54:	40002850 	.word	0x40002850

08010f58 <RTC_ReadBackupRegister>:
  *          This parameter can be: RTC_BKP_DRx where x can be from 0 to 19 to 
  *                          specify the register.                   
  * @retval None
  */
uint32_t RTC_ReadBackupRegister(uint32_t RTC_BKP_DR)
{
 8010f58:	b480      	push	{r7}
 8010f5a:	b085      	sub	sp, #20
 8010f5c:	af00      	add	r7, sp, #0
 8010f5e:	6078      	str	r0, [r7, #4]
  __IO uint32_t tmp = 0;
 8010f60:	2300      	movs	r3, #0
 8010f62:	60fb      	str	r3, [r7, #12]
  
  /* Check the parameters */
  assert_param(IS_RTC_BKP(RTC_BKP_DR));

  tmp = RTC_BASE + 0x50;
 8010f64:	4b07      	ldr	r3, [pc, #28]	; (8010f84 <RTC_ReadBackupRegister+0x2c>)
 8010f66:	60fb      	str	r3, [r7, #12]
  tmp += (RTC_BKP_DR * 4);
 8010f68:	687b      	ldr	r3, [r7, #4]
 8010f6a:	009a      	lsls	r2, r3, #2
 8010f6c:	68fb      	ldr	r3, [r7, #12]
 8010f6e:	4413      	add	r3, r2
 8010f70:	60fb      	str	r3, [r7, #12]
  
  /* Read the specified register */
  return (*(__IO uint32_t *)tmp);
 8010f72:	68fb      	ldr	r3, [r7, #12]
 8010f74:	681b      	ldr	r3, [r3, #0]
}
 8010f76:	4618      	mov	r0, r3
 8010f78:	3714      	adds	r7, #20
 8010f7a:	46bd      	mov	sp, r7
 8010f7c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8010f80:	4770      	bx	lr
 8010f82:	bf00      	nop
 8010f84:	40002850 	.word	0x40002850

08010f88 <RTC_TamperPinSelection>:
  *            @arg RTC_TamperPin_PC13: PC13 is selected as RTC Tamper Pin.
  *            @arg RTC_TamperPin_PI8: PI8 is selected as RTC Tamper Pin.    
  * @retval None
  */
void RTC_TamperPinSelection(uint32_t RTC_TamperPin)
{
 8010f88:	b480      	push	{r7}
 8010f8a:	b083      	sub	sp, #12
 8010f8c:	af00      	add	r7, sp, #0
 8010f8e:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_RTC_TAMPER_PIN(RTC_TamperPin));
  
  RTC->TAFCR &= (uint32_t)~(RTC_TAFCR_TAMPINSEL);
 8010f90:	4a08      	ldr	r2, [pc, #32]	; (8010fb4 <RTC_TamperPinSelection+0x2c>)
 8010f92:	4b08      	ldr	r3, [pc, #32]	; (8010fb4 <RTC_TamperPinSelection+0x2c>)
 8010f94:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8010f96:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 8010f9a:	6413      	str	r3, [r2, #64]	; 0x40
  RTC->TAFCR |= (uint32_t)(RTC_TamperPin);  
 8010f9c:	4905      	ldr	r1, [pc, #20]	; (8010fb4 <RTC_TamperPinSelection+0x2c>)
 8010f9e:	4b05      	ldr	r3, [pc, #20]	; (8010fb4 <RTC_TamperPinSelection+0x2c>)
 8010fa0:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 8010fa2:	687b      	ldr	r3, [r7, #4]
 8010fa4:	4313      	orrs	r3, r2
 8010fa6:	640b      	str	r3, [r1, #64]	; 0x40
}
 8010fa8:	bf00      	nop
 8010faa:	370c      	adds	r7, #12
 8010fac:	46bd      	mov	sp, r7
 8010fae:	f85d 7b04 	ldr.w	r7, [sp], #4
 8010fb2:	4770      	bx	lr
 8010fb4:	40002800 	.word	0x40002800

08010fb8 <RTC_TimeStampPinSelection>:
  *            @arg RTC_TimeStampPin_PC13: PC13 is selected as RTC TimeStamp Pin.
  *            @arg RTC_TimeStampPin_PI8: PI8 is selected as RTC TimeStamp Pin.    
  * @retval None
  */
void RTC_TimeStampPinSelection(uint32_t RTC_TimeStampPin)
{
 8010fb8:	b480      	push	{r7}
 8010fba:	b083      	sub	sp, #12
 8010fbc:	af00      	add	r7, sp, #0
 8010fbe:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_RTC_TIMESTAMP_PIN(RTC_TimeStampPin));
  
  RTC->TAFCR &= (uint32_t)~(RTC_TAFCR_TSINSEL);
 8010fc0:	4a08      	ldr	r2, [pc, #32]	; (8010fe4 <RTC_TimeStampPinSelection+0x2c>)
 8010fc2:	4b08      	ldr	r3, [pc, #32]	; (8010fe4 <RTC_TimeStampPinSelection+0x2c>)
 8010fc4:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8010fc6:	f423 3300 	bic.w	r3, r3, #131072	; 0x20000
 8010fca:	6413      	str	r3, [r2, #64]	; 0x40
  RTC->TAFCR |= (uint32_t)(RTC_TimeStampPin);  
 8010fcc:	4905      	ldr	r1, [pc, #20]	; (8010fe4 <RTC_TimeStampPinSelection+0x2c>)
 8010fce:	4b05      	ldr	r3, [pc, #20]	; (8010fe4 <RTC_TimeStampPinSelection+0x2c>)
 8010fd0:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 8010fd2:	687b      	ldr	r3, [r7, #4]
 8010fd4:	4313      	orrs	r3, r2
 8010fd6:	640b      	str	r3, [r1, #64]	; 0x40
}
 8010fd8:	bf00      	nop
 8010fda:	370c      	adds	r7, #12
 8010fdc:	46bd      	mov	sp, r7
 8010fde:	f85d 7b04 	ldr.w	r7, [sp], #4
 8010fe2:	4770      	bx	lr
 8010fe4:	40002800 	.word	0x40002800

08010fe8 <RTC_OutputTypeConfig>:
  *            @arg RTC_OutputType_PushPull:  RTC Output (PC13) is configured in 
  *                                    Push Pull mode.    
  * @retval None
  */
void RTC_OutputTypeConfig(uint32_t RTC_OutputType)
{
 8010fe8:	b480      	push	{r7}
 8010fea:	b083      	sub	sp, #12
 8010fec:	af00      	add	r7, sp, #0
 8010fee:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_RTC_OUTPUT_TYPE(RTC_OutputType));
  
  RTC->TAFCR &= (uint32_t)~(RTC_TAFCR_ALARMOUTTYPE);
 8010ff0:	4a08      	ldr	r2, [pc, #32]	; (8011014 <RTC_OutputTypeConfig+0x2c>)
 8010ff2:	4b08      	ldr	r3, [pc, #32]	; (8011014 <RTC_OutputTypeConfig+0x2c>)
 8010ff4:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8010ff6:	f423 2380 	bic.w	r3, r3, #262144	; 0x40000
 8010ffa:	6413      	str	r3, [r2, #64]	; 0x40
  RTC->TAFCR |= (uint32_t)(RTC_OutputType);  
 8010ffc:	4905      	ldr	r1, [pc, #20]	; (8011014 <RTC_OutputTypeConfig+0x2c>)
 8010ffe:	4b05      	ldr	r3, [pc, #20]	; (8011014 <RTC_OutputTypeConfig+0x2c>)
 8011000:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 8011002:	687b      	ldr	r3, [r7, #4]
 8011004:	4313      	orrs	r3, r2
 8011006:	640b      	str	r3, [r1, #64]	; 0x40
}
 8011008:	bf00      	nop
 801100a:	370c      	adds	r7, #12
 801100c:	46bd      	mov	sp, r7
 801100e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8011012:	4770      	bx	lr
 8011014:	40002800 	.word	0x40002800

08011018 <RTC_SynchroShiftConfig>:
  * @retval An ErrorStatus enumeration value:
  *          - SUCCESS: RTC Shift registers are configured
  *          - ERROR: RTC Shift registers are not configured
*/
ErrorStatus RTC_SynchroShiftConfig(uint32_t RTC_ShiftAdd1S, uint32_t RTC_ShiftSubFS)
{
 8011018:	b580      	push	{r7, lr}
 801101a:	b084      	sub	sp, #16
 801101c:	af00      	add	r7, sp, #0
 801101e:	6078      	str	r0, [r7, #4]
 8011020:	6039      	str	r1, [r7, #0]
  ErrorStatus status = ERROR;
 8011022:	2300      	movs	r3, #0
 8011024:	73fb      	strb	r3, [r7, #15]
  uint32_t shpfcount = 0;
 8011026:	2300      	movs	r3, #0
 8011028:	60bb      	str	r3, [r7, #8]
  /* Check the parameters */
  assert_param(IS_RTC_SHIFT_ADD1S(RTC_ShiftAdd1S));
  assert_param(IS_RTC_SHIFT_SUBFS(RTC_ShiftSubFS));

  /* Disable the write protection for RTC registers */
  RTC->WPR = 0xCA;
 801102a:	4b21      	ldr	r3, [pc, #132]	; (80110b0 <RTC_SynchroShiftConfig+0x98>)
 801102c:	22ca      	movs	r2, #202	; 0xca
 801102e:	625a      	str	r2, [r3, #36]	; 0x24
  RTC->WPR = 0x53;
 8011030:	4b1f      	ldr	r3, [pc, #124]	; (80110b0 <RTC_SynchroShiftConfig+0x98>)
 8011032:	2253      	movs	r2, #83	; 0x53
 8011034:	625a      	str	r2, [r3, #36]	; 0x24
  
  /* Check if a Shift is pending*/
  if ((RTC->ISR & RTC_ISR_SHPF) != RESET)
 8011036:	4b1e      	ldr	r3, [pc, #120]	; (80110b0 <RTC_SynchroShiftConfig+0x98>)
 8011038:	68db      	ldr	r3, [r3, #12]
 801103a:	f003 0308 	and.w	r3, r3, #8
 801103e:	2b00      	cmp	r3, #0
 8011040:	d00d      	beq.n	801105e <RTC_SynchroShiftConfig+0x46>
  {
    /* Wait until the shift is completed*/
    while (((RTC->ISR & RTC_ISR_SHPF) != RESET) && (shpfcount != SHPF_TIMEOUT))
 8011042:	e002      	b.n	801104a <RTC_SynchroShiftConfig+0x32>
    {
      shpfcount++;
 8011044:	68bb      	ldr	r3, [r7, #8]
 8011046:	3301      	adds	r3, #1
 8011048:	60bb      	str	r3, [r7, #8]
    while (((RTC->ISR & RTC_ISR_SHPF) != RESET) && (shpfcount != SHPF_TIMEOUT))
 801104a:	4b19      	ldr	r3, [pc, #100]	; (80110b0 <RTC_SynchroShiftConfig+0x98>)
 801104c:	68db      	ldr	r3, [r3, #12]
 801104e:	f003 0308 	and.w	r3, r3, #8
 8011052:	2b00      	cmp	r3, #0
 8011054:	d003      	beq.n	801105e <RTC_SynchroShiftConfig+0x46>
 8011056:	68bb      	ldr	r3, [r7, #8]
 8011058:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
 801105c:	d1f2      	bne.n	8011044 <RTC_SynchroShiftConfig+0x2c>
    }
  }

  /* Check if the Shift pending is completed or if there is no Shift operation at all*/
  if ((RTC->ISR & RTC_ISR_SHPF) == RESET)
 801105e:	4b14      	ldr	r3, [pc, #80]	; (80110b0 <RTC_SynchroShiftConfig+0x98>)
 8011060:	68db      	ldr	r3, [r3, #12]
 8011062:	f003 0308 	and.w	r3, r3, #8
 8011066:	2b00      	cmp	r3, #0
 8011068:	d118      	bne.n	801109c <RTC_SynchroShiftConfig+0x84>
  {
    /* check if the reference clock detection is disabled */
    if((RTC->CR & RTC_CR_REFCKON) == RESET)
 801106a:	4b11      	ldr	r3, [pc, #68]	; (80110b0 <RTC_SynchroShiftConfig+0x98>)
 801106c:	689b      	ldr	r3, [r3, #8]
 801106e:	f003 0310 	and.w	r3, r3, #16
 8011072:	2b00      	cmp	r3, #0
 8011074:	d10f      	bne.n	8011096 <RTC_SynchroShiftConfig+0x7e>
    {
      /* Configure the Shift settings */
      RTC->SHIFTR = (uint32_t)(uint32_t)(RTC_ShiftSubFS) | (uint32_t)(RTC_ShiftAdd1S);
 8011076:	490e      	ldr	r1, [pc, #56]	; (80110b0 <RTC_SynchroShiftConfig+0x98>)
 8011078:	683a      	ldr	r2, [r7, #0]
 801107a:	687b      	ldr	r3, [r7, #4]
 801107c:	4313      	orrs	r3, r2
 801107e:	62cb      	str	r3, [r1, #44]	; 0x2c
    
      if(RTC_WaitForSynchro() == ERROR)
 8011080:	f7fe ffa2 	bl	800ffc8 <RTC_WaitForSynchro>
 8011084:	4603      	mov	r3, r0
 8011086:	2b00      	cmp	r3, #0
 8011088:	d102      	bne.n	8011090 <RTC_SynchroShiftConfig+0x78>
      {
        status = ERROR;
 801108a:	2300      	movs	r3, #0
 801108c:	73fb      	strb	r3, [r7, #15]
 801108e:	e007      	b.n	80110a0 <RTC_SynchroShiftConfig+0x88>
      }
      else
      {
        status = SUCCESS;
 8011090:	2301      	movs	r3, #1
 8011092:	73fb      	strb	r3, [r7, #15]
 8011094:	e004      	b.n	80110a0 <RTC_SynchroShiftConfig+0x88>
      }
    }
    else
    {
      status = ERROR;
 8011096:	2300      	movs	r3, #0
 8011098:	73fb      	strb	r3, [r7, #15]
 801109a:	e001      	b.n	80110a0 <RTC_SynchroShiftConfig+0x88>
    }
  }
  else
  {
    status = ERROR;
 801109c:	2300      	movs	r3, #0
 801109e:	73fb      	strb	r3, [r7, #15]
  }

  /* Enable the write protection for RTC registers */
  RTC->WPR = 0xFF;
 80110a0:	4b03      	ldr	r3, [pc, #12]	; (80110b0 <RTC_SynchroShiftConfig+0x98>)
 80110a2:	22ff      	movs	r2, #255	; 0xff
 80110a4:	625a      	str	r2, [r3, #36]	; 0x24
  
  return (ErrorStatus)(status);
 80110a6:	7bfb      	ldrb	r3, [r7, #15]
}
 80110a8:	4618      	mov	r0, r3
 80110aa:	3710      	adds	r7, #16
 80110ac:	46bd      	mov	sp, r7
 80110ae:	bd80      	pop	{r7, pc}
 80110b0:	40002800 	.word	0x40002800

080110b4 <RTC_ITConfig>:
  * @param  NewState: new state of the specified RTC interrupts.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void RTC_ITConfig(uint32_t RTC_IT, FunctionalState NewState)
{
 80110b4:	b480      	push	{r7}
 80110b6:	b083      	sub	sp, #12
 80110b8:	af00      	add	r7, sp, #0
 80110ba:	6078      	str	r0, [r7, #4]
 80110bc:	460b      	mov	r3, r1
 80110be:	70fb      	strb	r3, [r7, #3]
  /* Check the parameters */
  assert_param(IS_RTC_CONFIG_IT(RTC_IT));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  /* Disable the write protection for RTC registers */
  RTC->WPR = 0xCA;
 80110c0:	4b1a      	ldr	r3, [pc, #104]	; (801112c <RTC_ITConfig+0x78>)
 80110c2:	22ca      	movs	r2, #202	; 0xca
 80110c4:	625a      	str	r2, [r3, #36]	; 0x24
  RTC->WPR = 0x53;
 80110c6:	4b19      	ldr	r3, [pc, #100]	; (801112c <RTC_ITConfig+0x78>)
 80110c8:	2253      	movs	r2, #83	; 0x53
 80110ca:	625a      	str	r2, [r3, #36]	; 0x24

  if (NewState != DISABLE)
 80110cc:	78fb      	ldrb	r3, [r7, #3]
 80110ce:	2b00      	cmp	r3, #0
 80110d0:	d010      	beq.n	80110f4 <RTC_ITConfig+0x40>
  {
    /* Configure the Interrupts in the RTC_CR register */
    RTC->CR |= (uint32_t)(RTC_IT & ~RTC_TAFCR_TAMPIE);
 80110d2:	4916      	ldr	r1, [pc, #88]	; (801112c <RTC_ITConfig+0x78>)
 80110d4:	4b15      	ldr	r3, [pc, #84]	; (801112c <RTC_ITConfig+0x78>)
 80110d6:	689a      	ldr	r2, [r3, #8]
 80110d8:	687b      	ldr	r3, [r7, #4]
 80110da:	f023 0304 	bic.w	r3, r3, #4
 80110de:	4313      	orrs	r3, r2
 80110e0:	608b      	str	r3, [r1, #8]
    /* Configure the Tamper Interrupt in the RTC_TAFCR */
    RTC->TAFCR |= (uint32_t)(RTC_IT & RTC_TAFCR_TAMPIE);
 80110e2:	4912      	ldr	r1, [pc, #72]	; (801112c <RTC_ITConfig+0x78>)
 80110e4:	4b11      	ldr	r3, [pc, #68]	; (801112c <RTC_ITConfig+0x78>)
 80110e6:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 80110e8:	687b      	ldr	r3, [r7, #4]
 80110ea:	f003 0304 	and.w	r3, r3, #4
 80110ee:	4313      	orrs	r3, r2
 80110f0:	640b      	str	r3, [r1, #64]	; 0x40
 80110f2:	e011      	b.n	8011118 <RTC_ITConfig+0x64>
  }
  else
  {
    /* Configure the Interrupts in the RTC_CR register */
    RTC->CR &= (uint32_t)~(RTC_IT & (uint32_t)~RTC_TAFCR_TAMPIE);
 80110f4:	490d      	ldr	r1, [pc, #52]	; (801112c <RTC_ITConfig+0x78>)
 80110f6:	4b0d      	ldr	r3, [pc, #52]	; (801112c <RTC_ITConfig+0x78>)
 80110f8:	689a      	ldr	r2, [r3, #8]
 80110fa:	687b      	ldr	r3, [r7, #4]
 80110fc:	f023 0304 	bic.w	r3, r3, #4
 8011100:	43db      	mvns	r3, r3
 8011102:	4013      	ands	r3, r2
 8011104:	608b      	str	r3, [r1, #8]
    /* Configure the Tamper Interrupt in the RTC_TAFCR */
    RTC->TAFCR &= (uint32_t)~(RTC_IT & RTC_TAFCR_TAMPIE);
 8011106:	4909      	ldr	r1, [pc, #36]	; (801112c <RTC_ITConfig+0x78>)
 8011108:	4b08      	ldr	r3, [pc, #32]	; (801112c <RTC_ITConfig+0x78>)
 801110a:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 801110c:	687b      	ldr	r3, [r7, #4]
 801110e:	f003 0304 	and.w	r3, r3, #4
 8011112:	43db      	mvns	r3, r3
 8011114:	4013      	ands	r3, r2
 8011116:	640b      	str	r3, [r1, #64]	; 0x40
  }
  /* Enable the write protection for RTC registers */
  RTC->WPR = 0xFF; 
 8011118:	4b04      	ldr	r3, [pc, #16]	; (801112c <RTC_ITConfig+0x78>)
 801111a:	22ff      	movs	r2, #255	; 0xff
 801111c:	625a      	str	r2, [r3, #36]	; 0x24
}
 801111e:	bf00      	nop
 8011120:	370c      	adds	r7, #12
 8011122:	46bd      	mov	sp, r7
 8011124:	f85d 7b04 	ldr.w	r7, [sp], #4
 8011128:	4770      	bx	lr
 801112a:	bf00      	nop
 801112c:	40002800 	.word	0x40002800

08011130 <RTC_GetFlagStatus>:
  *            @arg RTC_FLAG_ALRBWF: Alarm B Write flag
  *            @arg RTC_FLAG_ALRAWF: Alarm A write flag
  * @retval The new state of RTC_FLAG (SET or RESET).
  */
FlagStatus RTC_GetFlagStatus(uint32_t RTC_FLAG)
{
 8011130:	b480      	push	{r7}
 8011132:	b085      	sub	sp, #20
 8011134:	af00      	add	r7, sp, #0
 8011136:	6078      	str	r0, [r7, #4]
  FlagStatus bitstatus = RESET;
 8011138:	2300      	movs	r3, #0
 801113a:	73fb      	strb	r3, [r7, #15]
  uint32_t tmpreg = 0;
 801113c:	2300      	movs	r3, #0
 801113e:	60bb      	str	r3, [r7, #8]
  
  /* Check the parameters */
  assert_param(IS_RTC_GET_FLAG(RTC_FLAG));
  
  /* Get all the flags */
  tmpreg = (uint32_t)(RTC->ISR & RTC_FLAGS_MASK);
 8011140:	4b0a      	ldr	r3, [pc, #40]	; (801116c <RTC_GetFlagStatus+0x3c>)
 8011142:	68da      	ldr	r2, [r3, #12]
 8011144:	4b0a      	ldr	r3, [pc, #40]	; (8011170 <RTC_GetFlagStatus+0x40>)
 8011146:	4013      	ands	r3, r2
 8011148:	60bb      	str	r3, [r7, #8]
  
  /* Return the status of the flag */
  if ((tmpreg & RTC_FLAG) != (uint32_t)RESET)
 801114a:	68ba      	ldr	r2, [r7, #8]
 801114c:	687b      	ldr	r3, [r7, #4]
 801114e:	4013      	ands	r3, r2
 8011150:	2b00      	cmp	r3, #0
 8011152:	d002      	beq.n	801115a <RTC_GetFlagStatus+0x2a>
  {
    bitstatus = SET;
 8011154:	2301      	movs	r3, #1
 8011156:	73fb      	strb	r3, [r7, #15]
 8011158:	e001      	b.n	801115e <RTC_GetFlagStatus+0x2e>
  }
  else
  {
    bitstatus = RESET;
 801115a:	2300      	movs	r3, #0
 801115c:	73fb      	strb	r3, [r7, #15]
  }
  return bitstatus;
 801115e:	7bfb      	ldrb	r3, [r7, #15]
}
 8011160:	4618      	mov	r0, r3
 8011162:	3714      	adds	r7, #20
 8011164:	46bd      	mov	sp, r7
 8011166:	f85d 7b04 	ldr.w	r7, [sp], #4
 801116a:	4770      	bx	lr
 801116c:	40002800 	.word	0x40002800
 8011170:	00013f7f 	.word	0x00013f7f

08011174 <RTC_ClearFlag>:
  *            @arg RTC_FLAG_ALRAF: Alarm A flag
  *            @arg RTC_FLAG_RSF: Registers Synchronized flag
  * @retval None
  */
void RTC_ClearFlag(uint32_t RTC_FLAG)
{
 8011174:	b480      	push	{r7}
 8011176:	b083      	sub	sp, #12
 8011178:	af00      	add	r7, sp, #0
 801117a:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_RTC_CLEAR_FLAG(RTC_FLAG));

  /* Clear the Flags in the RTC_ISR register */
  RTC->ISR = (uint32_t)((uint32_t)(~((RTC_FLAG | RTC_ISR_INIT)& 0x0000FFFF) | (uint32_t)(RTC->ISR & RTC_ISR_INIT)));  
 801117c:	4908      	ldr	r1, [pc, #32]	; (80111a0 <RTC_ClearFlag+0x2c>)
 801117e:	687b      	ldr	r3, [r7, #4]
 8011180:	b29b      	uxth	r3, r3
 8011182:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8011186:	43da      	mvns	r2, r3
 8011188:	4b05      	ldr	r3, [pc, #20]	; (80111a0 <RTC_ClearFlag+0x2c>)
 801118a:	68db      	ldr	r3, [r3, #12]
 801118c:	f003 0380 	and.w	r3, r3, #128	; 0x80
 8011190:	4313      	orrs	r3, r2
 8011192:	60cb      	str	r3, [r1, #12]
}
 8011194:	bf00      	nop
 8011196:	370c      	adds	r7, #12
 8011198:	46bd      	mov	sp, r7
 801119a:	f85d 7b04 	ldr.w	r7, [sp], #4
 801119e:	4770      	bx	lr
 80111a0:	40002800 	.word	0x40002800

080111a4 <RTC_GetITStatus>:
  *            @arg RTC_IT_ALRA: Alarm A interrupt 
  *            @arg RTC_IT_TAMP1: Tamper 1 event interrupt 
  * @retval The new state of RTC_IT (SET or RESET).
  */
ITStatus RTC_GetITStatus(uint32_t RTC_IT)
{
 80111a4:	b480      	push	{r7}
 80111a6:	b087      	sub	sp, #28
 80111a8:	af00      	add	r7, sp, #0
 80111aa:	6078      	str	r0, [r7, #4]
  ITStatus bitstatus = RESET;
 80111ac:	2300      	movs	r3, #0
 80111ae:	75fb      	strb	r3, [r7, #23]
  uint32_t tmpreg = 0, enablestatus = 0;
 80111b0:	2300      	movs	r3, #0
 80111b2:	613b      	str	r3, [r7, #16]
 80111b4:	2300      	movs	r3, #0
 80111b6:	60fb      	str	r3, [r7, #12]
 
  /* Check the parameters */
  assert_param(IS_RTC_GET_IT(RTC_IT));
  
  /* Get the TAMPER Interrupt enable bit and pending bit */
  tmpreg = (uint32_t)(RTC->TAFCR & (RTC_TAFCR_TAMPIE));
 80111b8:	4b13      	ldr	r3, [pc, #76]	; (8011208 <RTC_GetITStatus+0x64>)
 80111ba:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 80111bc:	f003 0304 	and.w	r3, r3, #4
 80111c0:	613b      	str	r3, [r7, #16]
 
  /* Get the Interrupt enable Status */
  enablestatus = (uint32_t)((RTC->CR & RTC_IT) | (tmpreg & (RTC_IT >> 15)));
 80111c2:	4b11      	ldr	r3, [pc, #68]	; (8011208 <RTC_GetITStatus+0x64>)
 80111c4:	689a      	ldr	r2, [r3, #8]
 80111c6:	687b      	ldr	r3, [r7, #4]
 80111c8:	401a      	ands	r2, r3
 80111ca:	687b      	ldr	r3, [r7, #4]
 80111cc:	0bd9      	lsrs	r1, r3, #15
 80111ce:	693b      	ldr	r3, [r7, #16]
 80111d0:	400b      	ands	r3, r1
 80111d2:	4313      	orrs	r3, r2
 80111d4:	60fb      	str	r3, [r7, #12]
  
  /* Get the Interrupt pending bit */
  tmpreg = (uint32_t)((RTC->ISR & (uint32_t)(RTC_IT >> 4)));
 80111d6:	4b0c      	ldr	r3, [pc, #48]	; (8011208 <RTC_GetITStatus+0x64>)
 80111d8:	68da      	ldr	r2, [r3, #12]
 80111da:	687b      	ldr	r3, [r7, #4]
 80111dc:	091b      	lsrs	r3, r3, #4
 80111de:	4013      	ands	r3, r2
 80111e0:	613b      	str	r3, [r7, #16]
  
  /* Get the status of the Interrupt */
  if ((enablestatus != (uint32_t)RESET) && ((tmpreg & 0x0000FFFF) != (uint32_t)RESET))
 80111e2:	68fb      	ldr	r3, [r7, #12]
 80111e4:	2b00      	cmp	r3, #0
 80111e6:	d006      	beq.n	80111f6 <RTC_GetITStatus+0x52>
 80111e8:	693b      	ldr	r3, [r7, #16]
 80111ea:	b29b      	uxth	r3, r3
 80111ec:	2b00      	cmp	r3, #0
 80111ee:	d002      	beq.n	80111f6 <RTC_GetITStatus+0x52>
  {
    bitstatus = SET;
 80111f0:	2301      	movs	r3, #1
 80111f2:	75fb      	strb	r3, [r7, #23]
 80111f4:	e001      	b.n	80111fa <RTC_GetITStatus+0x56>
  }
  else
  {
    bitstatus = RESET;
 80111f6:	2300      	movs	r3, #0
 80111f8:	75fb      	strb	r3, [r7, #23]
  }
  return bitstatus;
 80111fa:	7dfb      	ldrb	r3, [r7, #23]
}
 80111fc:	4618      	mov	r0, r3
 80111fe:	371c      	adds	r7, #28
 8011200:	46bd      	mov	sp, r7
 8011202:	f85d 7b04 	ldr.w	r7, [sp], #4
 8011206:	4770      	bx	lr
 8011208:	40002800 	.word	0x40002800

0801120c <RTC_ClearITPendingBit>:
  *            @arg RTC_IT_ALRA: Alarm A interrupt 
  *            @arg RTC_IT_TAMP1: Tamper 1 event interrupt 
  * @retval None
  */
void RTC_ClearITPendingBit(uint32_t RTC_IT)
{
 801120c:	b480      	push	{r7}
 801120e:	b085      	sub	sp, #20
 8011210:	af00      	add	r7, sp, #0
 8011212:	6078      	str	r0, [r7, #4]
  uint32_t tmpreg = 0;
 8011214:	2300      	movs	r3, #0
 8011216:	60fb      	str	r3, [r7, #12]

  /* Check the parameters */
  assert_param(IS_RTC_CLEAR_IT(RTC_IT));

  /* Get the RTC_ISR Interrupt pending bits mask */
  tmpreg = (uint32_t)(RTC_IT >> 4);
 8011218:	687b      	ldr	r3, [r7, #4]
 801121a:	091b      	lsrs	r3, r3, #4
 801121c:	60fb      	str	r3, [r7, #12]

  /* Clear the interrupt pending bits in the RTC_ISR register */
  RTC->ISR = (uint32_t)((uint32_t)(~((tmpreg | RTC_ISR_INIT)& 0x0000FFFF) | (uint32_t)(RTC->ISR & RTC_ISR_INIT))); 
 801121e:	4909      	ldr	r1, [pc, #36]	; (8011244 <RTC_ClearITPendingBit+0x38>)
 8011220:	68fb      	ldr	r3, [r7, #12]
 8011222:	b29b      	uxth	r3, r3
 8011224:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8011228:	43da      	mvns	r2, r3
 801122a:	4b06      	ldr	r3, [pc, #24]	; (8011244 <RTC_ClearITPendingBit+0x38>)
 801122c:	68db      	ldr	r3, [r3, #12]
 801122e:	f003 0380 	and.w	r3, r3, #128	; 0x80
 8011232:	4313      	orrs	r3, r2
 8011234:	60cb      	str	r3, [r1, #12]
}
 8011236:	bf00      	nop
 8011238:	3714      	adds	r7, #20
 801123a:	46bd      	mov	sp, r7
 801123c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8011240:	4770      	bx	lr
 8011242:	bf00      	nop
 8011244:	40002800 	.word	0x40002800

08011248 <RTC_ByteToBcd2>:
  * @brief  Converts a 2 digit decimal to BCD format.
  * @param  Value: Byte to be converted.
  * @retval Converted byte
  */
static uint8_t RTC_ByteToBcd2(uint8_t Value)
{
 8011248:	b480      	push	{r7}
 801124a:	b085      	sub	sp, #20
 801124c:	af00      	add	r7, sp, #0
 801124e:	4603      	mov	r3, r0
 8011250:	71fb      	strb	r3, [r7, #7]
  uint8_t bcdhigh = 0;
 8011252:	2300      	movs	r3, #0
 8011254:	73fb      	strb	r3, [r7, #15]
  
  while (Value >= 10)
 8011256:	e005      	b.n	8011264 <RTC_ByteToBcd2+0x1c>
  {
    bcdhigh++;
 8011258:	7bfb      	ldrb	r3, [r7, #15]
 801125a:	3301      	adds	r3, #1
 801125c:	73fb      	strb	r3, [r7, #15]
    Value -= 10;
 801125e:	79fb      	ldrb	r3, [r7, #7]
 8011260:	3b0a      	subs	r3, #10
 8011262:	71fb      	strb	r3, [r7, #7]
  while (Value >= 10)
 8011264:	79fb      	ldrb	r3, [r7, #7]
 8011266:	2b09      	cmp	r3, #9
 8011268:	d8f6      	bhi.n	8011258 <RTC_ByteToBcd2+0x10>
  }
  
  return  ((uint8_t)(bcdhigh << 4) | Value);
 801126a:	7bfb      	ldrb	r3, [r7, #15]
 801126c:	011b      	lsls	r3, r3, #4
 801126e:	b2da      	uxtb	r2, r3
 8011270:	79fb      	ldrb	r3, [r7, #7]
 8011272:	4313      	orrs	r3, r2
 8011274:	b2db      	uxtb	r3, r3
}
 8011276:	4618      	mov	r0, r3
 8011278:	3714      	adds	r7, #20
 801127a:	46bd      	mov	sp, r7
 801127c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8011280:	4770      	bx	lr

08011282 <RTC_Bcd2ToByte>:
  * @brief  Convert from 2 digit BCD to Binary.
  * @param  Value: BCD value to be converted.
  * @retval Converted word
  */
static uint8_t RTC_Bcd2ToByte(uint8_t Value)
{
 8011282:	b480      	push	{r7}
 8011284:	b085      	sub	sp, #20
 8011286:	af00      	add	r7, sp, #0
 8011288:	4603      	mov	r3, r0
 801128a:	71fb      	strb	r3, [r7, #7]
  uint8_t tmp = 0;
 801128c:	2300      	movs	r3, #0
 801128e:	73fb      	strb	r3, [r7, #15]
  tmp = ((uint8_t)(Value & (uint8_t)0xF0) >> (uint8_t)0x4) * 10;
 8011290:	79fb      	ldrb	r3, [r7, #7]
 8011292:	091b      	lsrs	r3, r3, #4
 8011294:	b2db      	uxtb	r3, r3
 8011296:	461a      	mov	r2, r3
 8011298:	0092      	lsls	r2, r2, #2
 801129a:	4413      	add	r3, r2
 801129c:	005b      	lsls	r3, r3, #1
 801129e:	73fb      	strb	r3, [r7, #15]
  return (tmp + (Value & (uint8_t)0x0F));
 80112a0:	79fb      	ldrb	r3, [r7, #7]
 80112a2:	f003 030f 	and.w	r3, r3, #15
 80112a6:	b2da      	uxtb	r2, r3
 80112a8:	7bfb      	ldrb	r3, [r7, #15]
 80112aa:	4413      	add	r3, r2
 80112ac:	b2db      	uxtb	r3, r3
}
 80112ae:	4618      	mov	r0, r3
 80112b0:	3714      	adds	r7, #20
 80112b2:	46bd      	mov	sp, r7
 80112b4:	f85d 7b04 	ldr.w	r7, [sp], #4
 80112b8:	4770      	bx	lr
 80112ba:	bf00      	nop

080112bc <SDIO_DeInit>:
  * @brief  Deinitializes the SDIO peripheral registers to their default reset values.
  * @param  None
  * @retval None
  */
void SDIO_DeInit(void)
{
 80112bc:	b580      	push	{r7, lr}
 80112be:	af00      	add	r7, sp, #0
  RCC_APB2PeriphResetCmd(RCC_APB2Periph_SDIO, ENABLE);
 80112c0:	2101      	movs	r1, #1
 80112c2:	f44f 6000 	mov.w	r0, #2048	; 0x800
 80112c6:	f7fe fb45 	bl	800f954 <RCC_APB2PeriphResetCmd>
  RCC_APB2PeriphResetCmd(RCC_APB2Periph_SDIO, DISABLE);
 80112ca:	2100      	movs	r1, #0
 80112cc:	f44f 6000 	mov.w	r0, #2048	; 0x800
 80112d0:	f7fe fb40 	bl	800f954 <RCC_APB2PeriphResetCmd>
}
 80112d4:	bf00      	nop
 80112d6:	bd80      	pop	{r7, pc}

080112d8 <SDIO_Init>:
  * @param  SDIO_InitStruct : pointer to a SDIO_InitTypeDef structure 
  *         that contains the configuration information for the SDIO peripheral.
  * @retval None
  */
void SDIO_Init(SDIO_InitTypeDef* SDIO_InitStruct)
{
 80112d8:	b480      	push	{r7}
 80112da:	b085      	sub	sp, #20
 80112dc:	af00      	add	r7, sp, #0
 80112de:	6078      	str	r0, [r7, #4]
  uint32_t tmpreg = 0;
 80112e0:	2300      	movs	r3, #0
 80112e2:	60fb      	str	r3, [r7, #12]
  assert_param(IS_SDIO_BUS_WIDE(SDIO_InitStruct->SDIO_BusWide));
  assert_param(IS_SDIO_HARDWARE_FLOW_CONTROL(SDIO_InitStruct->SDIO_HardwareFlowControl)); 
   
/*---------------------------- SDIO CLKCR Configuration ------------------------*/  
  /* Get the SDIO CLKCR value */
  tmpreg = SDIO->CLKCR;
 80112e4:	4b13      	ldr	r3, [pc, #76]	; (8011334 <SDIO_Init+0x5c>)
 80112e6:	685b      	ldr	r3, [r3, #4]
 80112e8:	60fb      	str	r3, [r7, #12]
  
  /* Clear CLKDIV, PWRSAV, BYPASS, WIDBUS, NEGEDGE, HWFC_EN bits */
  tmpreg &= CLKCR_CLEAR_MASK;
 80112ea:	68fb      	ldr	r3, [r7, #12]
 80112ec:	f423 43fd 	bic.w	r3, r3, #32384	; 0x7e80
 80112f0:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
 80112f4:	60fb      	str	r3, [r7, #12]
  /* Set PWRSAV bit according to SDIO_ClockPowerSave value */
  /* Set BYPASS bit according to SDIO_ClockBypass value */
  /* Set WIDBUS bits according to SDIO_BusWide value */
  /* Set NEGEDGE bits according to SDIO_ClockEdge value */
  /* Set HWFC_EN bits according to SDIO_HardwareFlowControl value */
  tmpreg |= (SDIO_InitStruct->SDIO_ClockDiv  | SDIO_InitStruct->SDIO_ClockPowerSave |
 80112f6:	687b      	ldr	r3, [r7, #4]
 80112f8:	7d1b      	ldrb	r3, [r3, #20]
 80112fa:	461a      	mov	r2, r3
 80112fc:	687b      	ldr	r3, [r7, #4]
 80112fe:	689b      	ldr	r3, [r3, #8]
 8011300:	431a      	orrs	r2, r3
             SDIO_InitStruct->SDIO_ClockBypass | SDIO_InitStruct->SDIO_BusWide |
 8011302:	687b      	ldr	r3, [r7, #4]
 8011304:	685b      	ldr	r3, [r3, #4]
  tmpreg |= (SDIO_InitStruct->SDIO_ClockDiv  | SDIO_InitStruct->SDIO_ClockPowerSave |
 8011306:	431a      	orrs	r2, r3
             SDIO_InitStruct->SDIO_ClockBypass | SDIO_InitStruct->SDIO_BusWide |
 8011308:	687b      	ldr	r3, [r7, #4]
 801130a:	68db      	ldr	r3, [r3, #12]
 801130c:	431a      	orrs	r2, r3
             SDIO_InitStruct->SDIO_ClockEdge | SDIO_InitStruct->SDIO_HardwareFlowControl); 
 801130e:	687b      	ldr	r3, [r7, #4]
 8011310:	681b      	ldr	r3, [r3, #0]
             SDIO_InitStruct->SDIO_ClockBypass | SDIO_InitStruct->SDIO_BusWide |
 8011312:	431a      	orrs	r2, r3
             SDIO_InitStruct->SDIO_ClockEdge | SDIO_InitStruct->SDIO_HardwareFlowControl); 
 8011314:	687b      	ldr	r3, [r7, #4]
 8011316:	691b      	ldr	r3, [r3, #16]
 8011318:	4313      	orrs	r3, r2
  tmpreg |= (SDIO_InitStruct->SDIO_ClockDiv  | SDIO_InitStruct->SDIO_ClockPowerSave |
 801131a:	68fa      	ldr	r2, [r7, #12]
 801131c:	4313      	orrs	r3, r2
 801131e:	60fb      	str	r3, [r7, #12]
  
  /* Write to SDIO CLKCR */
  SDIO->CLKCR = tmpreg;
 8011320:	4a04      	ldr	r2, [pc, #16]	; (8011334 <SDIO_Init+0x5c>)
 8011322:	68fb      	ldr	r3, [r7, #12]
 8011324:	6053      	str	r3, [r2, #4]
}
 8011326:	bf00      	nop
 8011328:	3714      	adds	r7, #20
 801132a:	46bd      	mov	sp, r7
 801132c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8011330:	4770      	bx	lr
 8011332:	bf00      	nop
 8011334:	40012c00 	.word	0x40012c00

08011338 <SDIO_StructInit>:
  * @param  SDIO_InitStruct: pointer to an SDIO_InitTypeDef structure which 
  *         will be initialized.
  * @retval None
  */
void SDIO_StructInit(SDIO_InitTypeDef* SDIO_InitStruct)
{
 8011338:	b480      	push	{r7}
 801133a:	b083      	sub	sp, #12
 801133c:	af00      	add	r7, sp, #0
 801133e:	6078      	str	r0, [r7, #4]
  /* SDIO_InitStruct members default value */
  SDIO_InitStruct->SDIO_ClockDiv = 0x00;
 8011340:	687b      	ldr	r3, [r7, #4]
 8011342:	2200      	movs	r2, #0
 8011344:	751a      	strb	r2, [r3, #20]
  SDIO_InitStruct->SDIO_ClockEdge = SDIO_ClockEdge_Rising;
 8011346:	687b      	ldr	r3, [r7, #4]
 8011348:	2200      	movs	r2, #0
 801134a:	601a      	str	r2, [r3, #0]
  SDIO_InitStruct->SDIO_ClockBypass = SDIO_ClockBypass_Disable;
 801134c:	687b      	ldr	r3, [r7, #4]
 801134e:	2200      	movs	r2, #0
 8011350:	605a      	str	r2, [r3, #4]
  SDIO_InitStruct->SDIO_ClockPowerSave = SDIO_ClockPowerSave_Disable;
 8011352:	687b      	ldr	r3, [r7, #4]
 8011354:	2200      	movs	r2, #0
 8011356:	609a      	str	r2, [r3, #8]
  SDIO_InitStruct->SDIO_BusWide = SDIO_BusWide_1b;
 8011358:	687b      	ldr	r3, [r7, #4]
 801135a:	2200      	movs	r2, #0
 801135c:	60da      	str	r2, [r3, #12]
  SDIO_InitStruct->SDIO_HardwareFlowControl = SDIO_HardwareFlowControl_Disable;
 801135e:	687b      	ldr	r3, [r7, #4]
 8011360:	2200      	movs	r2, #0
 8011362:	611a      	str	r2, [r3, #16]
}
 8011364:	bf00      	nop
 8011366:	370c      	adds	r7, #12
 8011368:	46bd      	mov	sp, r7
 801136a:	f85d 7b04 	ldr.w	r7, [sp], #4
 801136e:	4770      	bx	lr

08011370 <SDIO_ClockCmd>:
  * @param  NewState: new state of the SDIO Clock. 
  *         This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void SDIO_ClockCmd(FunctionalState NewState)
{
 8011370:	b480      	push	{r7}
 8011372:	b083      	sub	sp, #12
 8011374:	af00      	add	r7, sp, #0
 8011376:	4603      	mov	r3, r0
 8011378:	71fb      	strb	r3, [r7, #7]
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  *(__IO uint32_t *) CLKCR_CLKEN_BB = (uint32_t)NewState;
 801137a:	4a04      	ldr	r2, [pc, #16]	; (801138c <SDIO_ClockCmd+0x1c>)
 801137c:	79fb      	ldrb	r3, [r7, #7]
 801137e:	6013      	str	r3, [r2, #0]
}
 8011380:	bf00      	nop
 8011382:	370c      	adds	r7, #12
 8011384:	46bd      	mov	sp, r7
 8011386:	f85d 7b04 	ldr.w	r7, [sp], #4
 801138a:	4770      	bx	lr
 801138c:	422580a0 	.word	0x422580a0

08011390 <SDIO_SetPowerState>:
  *            @arg SDIO_PowerState_OFF: SDIO Power OFF
  *            @arg SDIO_PowerState_ON: SDIO Power ON
  * @retval None
  */
void SDIO_SetPowerState(uint32_t SDIO_PowerState)
{
 8011390:	b480      	push	{r7}
 8011392:	b083      	sub	sp, #12
 8011394:	af00      	add	r7, sp, #0
 8011396:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_SDIO_POWER_STATE(SDIO_PowerState));
  
  SDIO->POWER = SDIO_PowerState;
 8011398:	4a04      	ldr	r2, [pc, #16]	; (80113ac <SDIO_SetPowerState+0x1c>)
 801139a:	687b      	ldr	r3, [r7, #4]
 801139c:	6013      	str	r3, [r2, #0]
}
 801139e:	bf00      	nop
 80113a0:	370c      	adds	r7, #12
 80113a2:	46bd      	mov	sp, r7
 80113a4:	f85d 7b04 	ldr.w	r7, [sp], #4
 80113a8:	4770      	bx	lr
 80113aa:	bf00      	nop
 80113ac:	40012c00 	.word	0x40012c00

080113b0 <SDIO_GetPowerState>:
  *            - 0x00: Power OFF
  *            - 0x02: Power UP
  *            - 0x03: Power ON 
  */
uint32_t SDIO_GetPowerState(void)
{
 80113b0:	b480      	push	{r7}
 80113b2:	af00      	add	r7, sp, #0
  return (SDIO->POWER & (~PWR_PWRCTRL_MASK));
 80113b4:	4b04      	ldr	r3, [pc, #16]	; (80113c8 <SDIO_GetPowerState+0x18>)
 80113b6:	681b      	ldr	r3, [r3, #0]
 80113b8:	f003 0303 	and.w	r3, r3, #3
}
 80113bc:	4618      	mov	r0, r3
 80113be:	46bd      	mov	sp, r7
 80113c0:	f85d 7b04 	ldr.w	r7, [sp], #4
 80113c4:	4770      	bx	lr
 80113c6:	bf00      	nop
 80113c8:	40012c00 	.word	0x40012c00

080113cc <SDIO_SendCommand>:
  *         structure that contains the configuration information for the SDIO 
  *         command.
  * @retval None
  */
void SDIO_SendCommand(SDIO_CmdInitTypeDef *SDIO_CmdInitStruct)
{
 80113cc:	b480      	push	{r7}
 80113ce:	b085      	sub	sp, #20
 80113d0:	af00      	add	r7, sp, #0
 80113d2:	6078      	str	r0, [r7, #4]
  uint32_t tmpreg = 0;
 80113d4:	2300      	movs	r3, #0
 80113d6:	60fb      	str	r3, [r7, #12]
  assert_param(IS_SDIO_WAIT(SDIO_CmdInitStruct->SDIO_Wait));
  assert_param(IS_SDIO_CPSM(SDIO_CmdInitStruct->SDIO_CPSM));
  
/*---------------------------- SDIO ARG Configuration ------------------------*/
  /* Set the SDIO Argument value */
  SDIO->ARG = SDIO_CmdInitStruct->SDIO_Argument;
 80113d8:	4a11      	ldr	r2, [pc, #68]	; (8011420 <SDIO_SendCommand+0x54>)
 80113da:	687b      	ldr	r3, [r7, #4]
 80113dc:	681b      	ldr	r3, [r3, #0]
 80113de:	6093      	str	r3, [r2, #8]
  
/*---------------------------- SDIO CMD Configuration ------------------------*/  
  /* Get the SDIO CMD value */
  tmpreg = SDIO->CMD;
 80113e0:	4b0f      	ldr	r3, [pc, #60]	; (8011420 <SDIO_SendCommand+0x54>)
 80113e2:	68db      	ldr	r3, [r3, #12]
 80113e4:	60fb      	str	r3, [r7, #12]
  /* Clear CMDINDEX, WAITRESP, WAITINT, WAITPEND, CPSMEN bits */
  tmpreg &= CMD_CLEAR_MASK;
 80113e6:	68fb      	ldr	r3, [r7, #12]
 80113e8:	f423 63ff 	bic.w	r3, r3, #2040	; 0x7f8
 80113ec:	f023 0307 	bic.w	r3, r3, #7
 80113f0:	60fb      	str	r3, [r7, #12]
  /* Set CMDINDEX bits according to SDIO_CmdIndex value */
  /* Set WAITRESP bits according to SDIO_Response value */
  /* Set WAITINT and WAITPEND bits according to SDIO_Wait value */
  /* Set CPSMEN bits according to SDIO_CPSM value */
  tmpreg |= (uint32_t)SDIO_CmdInitStruct->SDIO_CmdIndex | SDIO_CmdInitStruct->SDIO_Response
 80113f2:	687b      	ldr	r3, [r7, #4]
 80113f4:	685a      	ldr	r2, [r3, #4]
 80113f6:	687b      	ldr	r3, [r7, #4]
 80113f8:	689b      	ldr	r3, [r3, #8]
 80113fa:	431a      	orrs	r2, r3
           | SDIO_CmdInitStruct->SDIO_Wait | SDIO_CmdInitStruct->SDIO_CPSM;
 80113fc:	687b      	ldr	r3, [r7, #4]
 80113fe:	68db      	ldr	r3, [r3, #12]
 8011400:	431a      	orrs	r2, r3
 8011402:	687b      	ldr	r3, [r7, #4]
 8011404:	691b      	ldr	r3, [r3, #16]
 8011406:	4313      	orrs	r3, r2
  tmpreg |= (uint32_t)SDIO_CmdInitStruct->SDIO_CmdIndex | SDIO_CmdInitStruct->SDIO_Response
 8011408:	68fa      	ldr	r2, [r7, #12]
 801140a:	4313      	orrs	r3, r2
 801140c:	60fb      	str	r3, [r7, #12]
  
  /* Write to SDIO CMD */
  SDIO->CMD = tmpreg;
 801140e:	4a04      	ldr	r2, [pc, #16]	; (8011420 <SDIO_SendCommand+0x54>)
 8011410:	68fb      	ldr	r3, [r7, #12]
 8011412:	60d3      	str	r3, [r2, #12]
}
 8011414:	bf00      	nop
 8011416:	3714      	adds	r7, #20
 8011418:	46bd      	mov	sp, r7
 801141a:	f85d 7b04 	ldr.w	r7, [sp], #4
 801141e:	4770      	bx	lr
 8011420:	40012c00 	.word	0x40012c00

08011424 <SDIO_CmdStructInit>:
  * @param  SDIO_CmdInitStruct: pointer to an SDIO_CmdInitTypeDef 
  *         structure which will be initialized.
  * @retval None
  */
void SDIO_CmdStructInit(SDIO_CmdInitTypeDef* SDIO_CmdInitStruct)
{
 8011424:	b480      	push	{r7}
 8011426:	b083      	sub	sp, #12
 8011428:	af00      	add	r7, sp, #0
 801142a:	6078      	str	r0, [r7, #4]
  /* SDIO_CmdInitStruct members default value */
  SDIO_CmdInitStruct->SDIO_Argument = 0x00;
 801142c:	687b      	ldr	r3, [r7, #4]
 801142e:	2200      	movs	r2, #0
 8011430:	601a      	str	r2, [r3, #0]
  SDIO_CmdInitStruct->SDIO_CmdIndex = 0x00;
 8011432:	687b      	ldr	r3, [r7, #4]
 8011434:	2200      	movs	r2, #0
 8011436:	605a      	str	r2, [r3, #4]
  SDIO_CmdInitStruct->SDIO_Response = SDIO_Response_No;
 8011438:	687b      	ldr	r3, [r7, #4]
 801143a:	2200      	movs	r2, #0
 801143c:	609a      	str	r2, [r3, #8]
  SDIO_CmdInitStruct->SDIO_Wait = SDIO_Wait_No;
 801143e:	687b      	ldr	r3, [r7, #4]
 8011440:	2200      	movs	r2, #0
 8011442:	60da      	str	r2, [r3, #12]
  SDIO_CmdInitStruct->SDIO_CPSM = SDIO_CPSM_Disable;
 8011444:	687b      	ldr	r3, [r7, #4]
 8011446:	2200      	movs	r2, #0
 8011448:	611a      	str	r2, [r3, #16]
}
 801144a:	bf00      	nop
 801144c:	370c      	adds	r7, #12
 801144e:	46bd      	mov	sp, r7
 8011450:	f85d 7b04 	ldr.w	r7, [sp], #4
 8011454:	4770      	bx	lr

08011456 <SDIO_GetCommandResponse>:
  * @brief  Returns command index of last command for which response received.
  * @param  None
  * @retval Returns the command index of the last command response received.
  */
uint8_t SDIO_GetCommandResponse(void)
{
 8011456:	b480      	push	{r7}
 8011458:	af00      	add	r7, sp, #0
  return (uint8_t)(SDIO->RESPCMD);
 801145a:	4b04      	ldr	r3, [pc, #16]	; (801146c <SDIO_GetCommandResponse+0x16>)
 801145c:	691b      	ldr	r3, [r3, #16]
 801145e:	b2db      	uxtb	r3, r3
}
 8011460:	4618      	mov	r0, r3
 8011462:	46bd      	mov	sp, r7
 8011464:	f85d 7b04 	ldr.w	r7, [sp], #4
 8011468:	4770      	bx	lr
 801146a:	bf00      	nop
 801146c:	40012c00 	.word	0x40012c00

08011470 <SDIO_GetResponse>:
  *            @arg SDIO_RESP3: Response Register 3
  *            @arg SDIO_RESP4: Response Register 4
  * @retval The Corresponding response register value.
  */
uint32_t SDIO_GetResponse(uint32_t SDIO_RESP)
{
 8011470:	b480      	push	{r7}
 8011472:	b085      	sub	sp, #20
 8011474:	af00      	add	r7, sp, #0
 8011476:	6078      	str	r0, [r7, #4]
  __IO uint32_t tmp = 0;
 8011478:	2300      	movs	r3, #0
 801147a:	60fb      	str	r3, [r7, #12]

  /* Check the parameters */
  assert_param(IS_SDIO_RESP(SDIO_RESP));

  tmp = SDIO_RESP_ADDR + SDIO_RESP;
 801147c:	687a      	ldr	r2, [r7, #4]
 801147e:	4b05      	ldr	r3, [pc, #20]	; (8011494 <SDIO_GetResponse+0x24>)
 8011480:	4413      	add	r3, r2
 8011482:	60fb      	str	r3, [r7, #12]
  
  return (*(__IO uint32_t *) tmp); 
 8011484:	68fb      	ldr	r3, [r7, #12]
 8011486:	681b      	ldr	r3, [r3, #0]
}
 8011488:	4618      	mov	r0, r3
 801148a:	3714      	adds	r7, #20
 801148c:	46bd      	mov	sp, r7
 801148e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8011492:	4770      	bx	lr
 8011494:	40012c14 	.word	0x40012c14

08011498 <SDIO_DataConfig>:
  * @param  SDIO_DataInitStruct : pointer to a SDIO_DataInitTypeDef structure 
  *         that contains the configuration information for the SDIO command.
  * @retval None
  */
void SDIO_DataConfig(SDIO_DataInitTypeDef* SDIO_DataInitStruct)
{
 8011498:	b480      	push	{r7}
 801149a:	b085      	sub	sp, #20
 801149c:	af00      	add	r7, sp, #0
 801149e:	6078      	str	r0, [r7, #4]
  uint32_t tmpreg = 0;
 80114a0:	2300      	movs	r3, #0
 80114a2:	60fb      	str	r3, [r7, #12]
  assert_param(IS_SDIO_TRANSFER_MODE(SDIO_DataInitStruct->SDIO_TransferMode));
  assert_param(IS_SDIO_DPSM(SDIO_DataInitStruct->SDIO_DPSM));

/*---------------------------- SDIO DTIMER Configuration ---------------------*/
  /* Set the SDIO Data TimeOut value */
  SDIO->DTIMER = SDIO_DataInitStruct->SDIO_DataTimeOut;
 80114a4:	4a12      	ldr	r2, [pc, #72]	; (80114f0 <SDIO_DataConfig+0x58>)
 80114a6:	687b      	ldr	r3, [r7, #4]
 80114a8:	681b      	ldr	r3, [r3, #0]
 80114aa:	6253      	str	r3, [r2, #36]	; 0x24

/*---------------------------- SDIO DLEN Configuration -----------------------*/
  /* Set the SDIO DataLength value */
  SDIO->DLEN = SDIO_DataInitStruct->SDIO_DataLength;
 80114ac:	4a10      	ldr	r2, [pc, #64]	; (80114f0 <SDIO_DataConfig+0x58>)
 80114ae:	687b      	ldr	r3, [r7, #4]
 80114b0:	685b      	ldr	r3, [r3, #4]
 80114b2:	6293      	str	r3, [r2, #40]	; 0x28

/*---------------------------- SDIO DCTRL Configuration ----------------------*/  
  /* Get the SDIO DCTRL value */
  tmpreg = SDIO->DCTRL;
 80114b4:	4b0e      	ldr	r3, [pc, #56]	; (80114f0 <SDIO_DataConfig+0x58>)
 80114b6:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80114b8:	60fb      	str	r3, [r7, #12]
  /* Clear DEN, DTMODE, DTDIR and DBCKSIZE bits */
  tmpreg &= DCTRL_CLEAR_MASK;
 80114ba:	68fb      	ldr	r3, [r7, #12]
 80114bc:	f023 03f7 	bic.w	r3, r3, #247	; 0xf7
 80114c0:	60fb      	str	r3, [r7, #12]
  /* Set DEN bit according to SDIO_DPSM value */
  /* Set DTMODE bit according to SDIO_TransferMode value */
  /* Set DTDIR bit according to SDIO_TransferDir value */
  /* Set DBCKSIZE bits according to SDIO_DataBlockSize value */
  tmpreg |= (uint32_t)SDIO_DataInitStruct->SDIO_DataBlockSize | SDIO_DataInitStruct->SDIO_TransferDir
 80114c2:	687b      	ldr	r3, [r7, #4]
 80114c4:	689a      	ldr	r2, [r3, #8]
 80114c6:	687b      	ldr	r3, [r7, #4]
 80114c8:	68db      	ldr	r3, [r3, #12]
 80114ca:	431a      	orrs	r2, r3
           | SDIO_DataInitStruct->SDIO_TransferMode | SDIO_DataInitStruct->SDIO_DPSM;
 80114cc:	687b      	ldr	r3, [r7, #4]
 80114ce:	691b      	ldr	r3, [r3, #16]
 80114d0:	431a      	orrs	r2, r3
 80114d2:	687b      	ldr	r3, [r7, #4]
 80114d4:	695b      	ldr	r3, [r3, #20]
 80114d6:	4313      	orrs	r3, r2
  tmpreg |= (uint32_t)SDIO_DataInitStruct->SDIO_DataBlockSize | SDIO_DataInitStruct->SDIO_TransferDir
 80114d8:	68fa      	ldr	r2, [r7, #12]
 80114da:	4313      	orrs	r3, r2
 80114dc:	60fb      	str	r3, [r7, #12]

  /* Write to SDIO DCTRL */
  SDIO->DCTRL = tmpreg;
 80114de:	4a04      	ldr	r2, [pc, #16]	; (80114f0 <SDIO_DataConfig+0x58>)
 80114e0:	68fb      	ldr	r3, [r7, #12]
 80114e2:	62d3      	str	r3, [r2, #44]	; 0x2c
}
 80114e4:	bf00      	nop
 80114e6:	3714      	adds	r7, #20
 80114e8:	46bd      	mov	sp, r7
 80114ea:	f85d 7b04 	ldr.w	r7, [sp], #4
 80114ee:	4770      	bx	lr
 80114f0:	40012c00 	.word	0x40012c00

080114f4 <SDIO_DataStructInit>:
  * @param  SDIO_DataInitStruct: pointer to an SDIO_DataInitTypeDef structure 
  *         which will be initialized.
  * @retval None
  */
void SDIO_DataStructInit(SDIO_DataInitTypeDef* SDIO_DataInitStruct)
{
 80114f4:	b480      	push	{r7}
 80114f6:	b083      	sub	sp, #12
 80114f8:	af00      	add	r7, sp, #0
 80114fa:	6078      	str	r0, [r7, #4]
  /* SDIO_DataInitStruct members default value */
  SDIO_DataInitStruct->SDIO_DataTimeOut = 0xFFFFFFFF;
 80114fc:	687b      	ldr	r3, [r7, #4]
 80114fe:	f04f 32ff 	mov.w	r2, #4294967295
 8011502:	601a      	str	r2, [r3, #0]
  SDIO_DataInitStruct->SDIO_DataLength = 0x00;
 8011504:	687b      	ldr	r3, [r7, #4]
 8011506:	2200      	movs	r2, #0
 8011508:	605a      	str	r2, [r3, #4]
  SDIO_DataInitStruct->SDIO_DataBlockSize = SDIO_DataBlockSize_1b;
 801150a:	687b      	ldr	r3, [r7, #4]
 801150c:	2200      	movs	r2, #0
 801150e:	609a      	str	r2, [r3, #8]
  SDIO_DataInitStruct->SDIO_TransferDir = SDIO_TransferDir_ToCard;
 8011510:	687b      	ldr	r3, [r7, #4]
 8011512:	2200      	movs	r2, #0
 8011514:	60da      	str	r2, [r3, #12]
  SDIO_DataInitStruct->SDIO_TransferMode = SDIO_TransferMode_Block;  
 8011516:	687b      	ldr	r3, [r7, #4]
 8011518:	2200      	movs	r2, #0
 801151a:	611a      	str	r2, [r3, #16]
  SDIO_DataInitStruct->SDIO_DPSM = SDIO_DPSM_Disable;
 801151c:	687b      	ldr	r3, [r7, #4]
 801151e:	2200      	movs	r2, #0
 8011520:	615a      	str	r2, [r3, #20]
}
 8011522:	bf00      	nop
 8011524:	370c      	adds	r7, #12
 8011526:	46bd      	mov	sp, r7
 8011528:	f85d 7b04 	ldr.w	r7, [sp], #4
 801152c:	4770      	bx	lr

0801152e <SDIO_GetDataCounter>:
  * @brief  Returns number of remaining data bytes to be transferred.
  * @param  None
  * @retval Number of remaining data bytes to be transferred
  */
uint32_t SDIO_GetDataCounter(void)
{ 
 801152e:	b480      	push	{r7}
 8011530:	af00      	add	r7, sp, #0
  return SDIO->DCOUNT;
 8011532:	4b03      	ldr	r3, [pc, #12]	; (8011540 <SDIO_GetDataCounter+0x12>)
 8011534:	6b1b      	ldr	r3, [r3, #48]	; 0x30
}
 8011536:	4618      	mov	r0, r3
 8011538:	46bd      	mov	sp, r7
 801153a:	f85d 7b04 	ldr.w	r7, [sp], #4
 801153e:	4770      	bx	lr
 8011540:	40012c00 	.word	0x40012c00

08011544 <SDIO_ReadData>:
  * @brief  Read one data word from Rx FIFO.
  * @param  None
  * @retval Data received
  */
uint32_t SDIO_ReadData(void)
{ 
 8011544:	b480      	push	{r7}
 8011546:	af00      	add	r7, sp, #0
  return SDIO->FIFO;
 8011548:	4b03      	ldr	r3, [pc, #12]	; (8011558 <SDIO_ReadData+0x14>)
 801154a:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
}
 801154e:	4618      	mov	r0, r3
 8011550:	46bd      	mov	sp, r7
 8011552:	f85d 7b04 	ldr.w	r7, [sp], #4
 8011556:	4770      	bx	lr
 8011558:	40012c00 	.word	0x40012c00

0801155c <SDIO_WriteData>:
  * @brief  Write one data word to Tx FIFO.
  * @param  Data: 32-bit data word to write.
  * @retval None
  */
void SDIO_WriteData(uint32_t Data)
{ 
 801155c:	b480      	push	{r7}
 801155e:	b083      	sub	sp, #12
 8011560:	af00      	add	r7, sp, #0
 8011562:	6078      	str	r0, [r7, #4]
  SDIO->FIFO = Data;
 8011564:	4a04      	ldr	r2, [pc, #16]	; (8011578 <SDIO_WriteData+0x1c>)
 8011566:	687b      	ldr	r3, [r7, #4]
 8011568:	f8c2 3080 	str.w	r3, [r2, #128]	; 0x80
}
 801156c:	bf00      	nop
 801156e:	370c      	adds	r7, #12
 8011570:	46bd      	mov	sp, r7
 8011572:	f85d 7b04 	ldr.w	r7, [sp], #4
 8011576:	4770      	bx	lr
 8011578:	40012c00 	.word	0x40012c00

0801157c <SDIO_GetFIFOCount>:
  * @brief  Returns the number of words left to be written to or read from FIFO.	
  * @param  None
  * @retval Remaining number of words.
  */
uint32_t SDIO_GetFIFOCount(void)
{ 
 801157c:	b480      	push	{r7}
 801157e:	af00      	add	r7, sp, #0
  return SDIO->FIFOCNT;
 8011580:	4b03      	ldr	r3, [pc, #12]	; (8011590 <SDIO_GetFIFOCount+0x14>)
 8011582:	6c9b      	ldr	r3, [r3, #72]	; 0x48
}
 8011584:	4618      	mov	r0, r3
 8011586:	46bd      	mov	sp, r7
 8011588:	f85d 7b04 	ldr.w	r7, [sp], #4
 801158c:	4770      	bx	lr
 801158e:	bf00      	nop
 8011590:	40012c00 	.word	0x40012c00

08011594 <SDIO_StartSDIOReadWait>:
  * @param  NewState: new state of the Start SDIO Read Wait operation. 
  *         This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void SDIO_StartSDIOReadWait(FunctionalState NewState)
{ 
 8011594:	b480      	push	{r7}
 8011596:	b083      	sub	sp, #12
 8011598:	af00      	add	r7, sp, #0
 801159a:	4603      	mov	r3, r0
 801159c:	71fb      	strb	r3, [r7, #7]
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  *(__IO uint32_t *) DCTRL_RWSTART_BB = (uint32_t) NewState;
 801159e:	4a04      	ldr	r2, [pc, #16]	; (80115b0 <SDIO_StartSDIOReadWait+0x1c>)
 80115a0:	79fb      	ldrb	r3, [r7, #7]
 80115a2:	6013      	str	r3, [r2, #0]
}
 80115a4:	bf00      	nop
 80115a6:	370c      	adds	r7, #12
 80115a8:	46bd      	mov	sp, r7
 80115aa:	f85d 7b04 	ldr.w	r7, [sp], #4
 80115ae:	4770      	bx	lr
 80115b0:	422585a0 	.word	0x422585a0

080115b4 <SDIO_StopSDIOReadWait>:
  * @param  NewState: new state of the Stop SDIO Read Wait operation. 
  *         This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void SDIO_StopSDIOReadWait(FunctionalState NewState)
{ 
 80115b4:	b480      	push	{r7}
 80115b6:	b083      	sub	sp, #12
 80115b8:	af00      	add	r7, sp, #0
 80115ba:	4603      	mov	r3, r0
 80115bc:	71fb      	strb	r3, [r7, #7]
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  *(__IO uint32_t *) DCTRL_RWSTOP_BB = (uint32_t) NewState;
 80115be:	4a04      	ldr	r2, [pc, #16]	; (80115d0 <SDIO_StopSDIOReadWait+0x1c>)
 80115c0:	79fb      	ldrb	r3, [r7, #7]
 80115c2:	6013      	str	r3, [r2, #0]
}
 80115c4:	bf00      	nop
 80115c6:	370c      	adds	r7, #12
 80115c8:	46bd      	mov	sp, r7
 80115ca:	f85d 7b04 	ldr.w	r7, [sp], #4
 80115ce:	4770      	bx	lr
 80115d0:	422585a4 	.word	0x422585a4

080115d4 <SDIO_SetSDIOReadWaitMode>:
  *            @arg SDIO_ReadWaitMode_CLK: Read Wait control by stopping SDIOCLK
  *            @arg SDIO_ReadWaitMode_DATA2: Read Wait control using SDIO_DATA2
  * @retval None
  */
void SDIO_SetSDIOReadWaitMode(uint32_t SDIO_ReadWaitMode)
{
 80115d4:	b480      	push	{r7}
 80115d6:	b083      	sub	sp, #12
 80115d8:	af00      	add	r7, sp, #0
 80115da:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_SDIO_READWAIT_MODE(SDIO_ReadWaitMode));
  
  *(__IO uint32_t *) DCTRL_RWMOD_BB = SDIO_ReadWaitMode;
 80115dc:	4a04      	ldr	r2, [pc, #16]	; (80115f0 <SDIO_SetSDIOReadWaitMode+0x1c>)
 80115de:	687b      	ldr	r3, [r7, #4]
 80115e0:	6013      	str	r3, [r2, #0]
}
 80115e2:	bf00      	nop
 80115e4:	370c      	adds	r7, #12
 80115e6:	46bd      	mov	sp, r7
 80115e8:	f85d 7b04 	ldr.w	r7, [sp], #4
 80115ec:	4770      	bx	lr
 80115ee:	bf00      	nop
 80115f0:	422585a8 	.word	0x422585a8

080115f4 <SDIO_SetSDIOOperation>:
  * @param  NewState: new state of SDIO specific operation. 
  *         This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void SDIO_SetSDIOOperation(FunctionalState NewState)
{ 
 80115f4:	b480      	push	{r7}
 80115f6:	b083      	sub	sp, #12
 80115f8:	af00      	add	r7, sp, #0
 80115fa:	4603      	mov	r3, r0
 80115fc:	71fb      	strb	r3, [r7, #7]
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  *(__IO uint32_t *) DCTRL_SDIOEN_BB = (uint32_t)NewState;
 80115fe:	4a04      	ldr	r2, [pc, #16]	; (8011610 <SDIO_SetSDIOOperation+0x1c>)
 8011600:	79fb      	ldrb	r3, [r7, #7]
 8011602:	6013      	str	r3, [r2, #0]
}
 8011604:	bf00      	nop
 8011606:	370c      	adds	r7, #12
 8011608:	46bd      	mov	sp, r7
 801160a:	f85d 7b04 	ldr.w	r7, [sp], #4
 801160e:	4770      	bx	lr
 8011610:	422585ac 	.word	0x422585ac

08011614 <SDIO_SendSDIOSuspendCmd>:
  * @param  NewState: new state of the SD I/O Mode suspend command.
  *         This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void SDIO_SendSDIOSuspendCmd(FunctionalState NewState)
{ 
 8011614:	b480      	push	{r7}
 8011616:	b083      	sub	sp, #12
 8011618:	af00      	add	r7, sp, #0
 801161a:	4603      	mov	r3, r0
 801161c:	71fb      	strb	r3, [r7, #7]
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  *(__IO uint32_t *) CMD_SDIOSUSPEND_BB = (uint32_t)NewState;
 801161e:	4a04      	ldr	r2, [pc, #16]	; (8011630 <SDIO_SendSDIOSuspendCmd+0x1c>)
 8011620:	79fb      	ldrb	r3, [r7, #7]
 8011622:	6013      	str	r3, [r2, #0]
}
 8011624:	bf00      	nop
 8011626:	370c      	adds	r7, #12
 8011628:	46bd      	mov	sp, r7
 801162a:	f85d 7b04 	ldr.w	r7, [sp], #4
 801162e:	4770      	bx	lr
 8011630:	422581ac 	.word	0x422581ac

08011634 <SDIO_CommandCompletionCmd>:
  * @param  NewState: new state of command completion signal. 
  *         This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void SDIO_CommandCompletionCmd(FunctionalState NewState)
{ 
 8011634:	b480      	push	{r7}
 8011636:	b083      	sub	sp, #12
 8011638:	af00      	add	r7, sp, #0
 801163a:	4603      	mov	r3, r0
 801163c:	71fb      	strb	r3, [r7, #7]
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  *(__IO uint32_t *) CMD_ENCMDCOMPL_BB = (uint32_t)NewState;
 801163e:	4a04      	ldr	r2, [pc, #16]	; (8011650 <SDIO_CommandCompletionCmd+0x1c>)
 8011640:	79fb      	ldrb	r3, [r7, #7]
 8011642:	6013      	str	r3, [r2, #0]
}
 8011644:	bf00      	nop
 8011646:	370c      	adds	r7, #12
 8011648:	46bd      	mov	sp, r7
 801164a:	f85d 7b04 	ldr.w	r7, [sp], #4
 801164e:	4770      	bx	lr
 8011650:	422581b0 	.word	0x422581b0

08011654 <SDIO_CEATAITCmd>:
  * @param  NewState: new state of CE-ATA interrupt. 
  *         This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void SDIO_CEATAITCmd(FunctionalState NewState)
{ 
 8011654:	b480      	push	{r7}
 8011656:	b083      	sub	sp, #12
 8011658:	af00      	add	r7, sp, #0
 801165a:	4603      	mov	r3, r0
 801165c:	71fb      	strb	r3, [r7, #7]
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  *(__IO uint32_t *) CMD_NIEN_BB = (uint32_t)((~((uint32_t)NewState)) & ((uint32_t)0x1));
 801165e:	4a08      	ldr	r2, [pc, #32]	; (8011680 <SDIO_CEATAITCmd+0x2c>)
 8011660:	79fb      	ldrb	r3, [r7, #7]
 8011662:	f003 0301 	and.w	r3, r3, #1
 8011666:	2b00      	cmp	r3, #0
 8011668:	bf0c      	ite	eq
 801166a:	2301      	moveq	r3, #1
 801166c:	2300      	movne	r3, #0
 801166e:	b2db      	uxtb	r3, r3
 8011670:	6013      	str	r3, [r2, #0]
}
 8011672:	bf00      	nop
 8011674:	370c      	adds	r7, #12
 8011676:	46bd      	mov	sp, r7
 8011678:	f85d 7b04 	ldr.w	r7, [sp], #4
 801167c:	4770      	bx	lr
 801167e:	bf00      	nop
 8011680:	422581b4 	.word	0x422581b4

08011684 <SDIO_SendCEATACmd>:
  * @param  NewState: new state of CE-ATA command. 
  *         This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void SDIO_SendCEATACmd(FunctionalState NewState)
{ 
 8011684:	b480      	push	{r7}
 8011686:	b083      	sub	sp, #12
 8011688:	af00      	add	r7, sp, #0
 801168a:	4603      	mov	r3, r0
 801168c:	71fb      	strb	r3, [r7, #7]
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  *(__IO uint32_t *) CMD_ATACMD_BB = (uint32_t)NewState;
 801168e:	4a04      	ldr	r2, [pc, #16]	; (80116a0 <SDIO_SendCEATACmd+0x1c>)
 8011690:	79fb      	ldrb	r3, [r7, #7]
 8011692:	6013      	str	r3, [r2, #0]
}
 8011694:	bf00      	nop
 8011696:	370c      	adds	r7, #12
 8011698:	46bd      	mov	sp, r7
 801169a:	f85d 7b04 	ldr.w	r7, [sp], #4
 801169e:	4770      	bx	lr
 80116a0:	422581b8 	.word	0x422581b8

080116a4 <SDIO_DMACmd>:
  * @param  NewState: new state of the selected SDIO DMA request.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void SDIO_DMACmd(FunctionalState NewState)
{
 80116a4:	b480      	push	{r7}
 80116a6:	b083      	sub	sp, #12
 80116a8:	af00      	add	r7, sp, #0
 80116aa:	4603      	mov	r3, r0
 80116ac:	71fb      	strb	r3, [r7, #7]
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  *(__IO uint32_t *) DCTRL_DMAEN_BB = (uint32_t)NewState;
 80116ae:	4a04      	ldr	r2, [pc, #16]	; (80116c0 <SDIO_DMACmd+0x1c>)
 80116b0:	79fb      	ldrb	r3, [r7, #7]
 80116b2:	6013      	str	r3, [r2, #0]
}
 80116b4:	bf00      	nop
 80116b6:	370c      	adds	r7, #12
 80116b8:	46bd      	mov	sp, r7
 80116ba:	f85d 7b04 	ldr.w	r7, [sp], #4
 80116be:	4770      	bx	lr
 80116c0:	4225858c 	.word	0x4225858c

080116c4 <SDIO_ITConfig>:
  * @param  NewState: new state of the specified SDIO interrupts.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None 
  */
void SDIO_ITConfig(uint32_t SDIO_IT, FunctionalState NewState)
{
 80116c4:	b480      	push	{r7}
 80116c6:	b083      	sub	sp, #12
 80116c8:	af00      	add	r7, sp, #0
 80116ca:	6078      	str	r0, [r7, #4]
 80116cc:	460b      	mov	r3, r1
 80116ce:	70fb      	strb	r3, [r7, #3]
  /* Check the parameters */
  assert_param(IS_SDIO_IT(SDIO_IT));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
 80116d0:	78fb      	ldrb	r3, [r7, #3]
 80116d2:	2b00      	cmp	r3, #0
 80116d4:	d006      	beq.n	80116e4 <SDIO_ITConfig+0x20>
  {
    /* Enable the SDIO interrupts */
    SDIO->MASK |= SDIO_IT;
 80116d6:	490a      	ldr	r1, [pc, #40]	; (8011700 <SDIO_ITConfig+0x3c>)
 80116d8:	4b09      	ldr	r3, [pc, #36]	; (8011700 <SDIO_ITConfig+0x3c>)
 80116da:	6bda      	ldr	r2, [r3, #60]	; 0x3c
 80116dc:	687b      	ldr	r3, [r7, #4]
 80116de:	4313      	orrs	r3, r2
 80116e0:	63cb      	str	r3, [r1, #60]	; 0x3c
  else
  {
    /* Disable the SDIO interrupts */
    SDIO->MASK &= ~SDIO_IT;
  } 
}
 80116e2:	e006      	b.n	80116f2 <SDIO_ITConfig+0x2e>
    SDIO->MASK &= ~SDIO_IT;
 80116e4:	4906      	ldr	r1, [pc, #24]	; (8011700 <SDIO_ITConfig+0x3c>)
 80116e6:	4b06      	ldr	r3, [pc, #24]	; (8011700 <SDIO_ITConfig+0x3c>)
 80116e8:	6bda      	ldr	r2, [r3, #60]	; 0x3c
 80116ea:	687b      	ldr	r3, [r7, #4]
 80116ec:	43db      	mvns	r3, r3
 80116ee:	4013      	ands	r3, r2
 80116f0:	63cb      	str	r3, [r1, #60]	; 0x3c
}
 80116f2:	bf00      	nop
 80116f4:	370c      	adds	r7, #12
 80116f6:	46bd      	mov	sp, r7
 80116f8:	f85d 7b04 	ldr.w	r7, [sp], #4
 80116fc:	4770      	bx	lr
 80116fe:	bf00      	nop
 8011700:	40012c00 	.word	0x40012c00

08011704 <SDIO_GetFlagStatus>:
  *            @arg SDIO_FLAG_SDIOIT:   SD I/O interrupt received
  *            @arg SDIO_FLAG_CEATAEND: CE-ATA command completion signal received for CMD61
  * @retval The new state of SDIO_FLAG (SET or RESET).
  */
FlagStatus SDIO_GetFlagStatus(uint32_t SDIO_FLAG)
{ 
 8011704:	b480      	push	{r7}
 8011706:	b085      	sub	sp, #20
 8011708:	af00      	add	r7, sp, #0
 801170a:	6078      	str	r0, [r7, #4]
  FlagStatus bitstatus = RESET;
 801170c:	2300      	movs	r3, #0
 801170e:	73fb      	strb	r3, [r7, #15]
  
  /* Check the parameters */
  assert_param(IS_SDIO_FLAG(SDIO_FLAG));
  
  if ((SDIO->STA & SDIO_FLAG) != (uint32_t)RESET)
 8011710:	4b08      	ldr	r3, [pc, #32]	; (8011734 <SDIO_GetFlagStatus+0x30>)
 8011712:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8011714:	687b      	ldr	r3, [r7, #4]
 8011716:	4013      	ands	r3, r2
 8011718:	2b00      	cmp	r3, #0
 801171a:	d002      	beq.n	8011722 <SDIO_GetFlagStatus+0x1e>
  {
    bitstatus = SET;
 801171c:	2301      	movs	r3, #1
 801171e:	73fb      	strb	r3, [r7, #15]
 8011720:	e001      	b.n	8011726 <SDIO_GetFlagStatus+0x22>
  }
  else
  {
    bitstatus = RESET;
 8011722:	2300      	movs	r3, #0
 8011724:	73fb      	strb	r3, [r7, #15]
  }
  return bitstatus;
 8011726:	7bfb      	ldrb	r3, [r7, #15]
}
 8011728:	4618      	mov	r0, r3
 801172a:	3714      	adds	r7, #20
 801172c:	46bd      	mov	sp, r7
 801172e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8011732:	4770      	bx	lr
 8011734:	40012c00 	.word	0x40012c00

08011738 <SDIO_ClearFlag>:
  *            @arg SDIO_FLAG_SDIOIT:   SD I/O interrupt received
  *            @arg SDIO_FLAG_CEATAEND: CE-ATA command completion signal received for CMD61
  * @retval None
  */
void SDIO_ClearFlag(uint32_t SDIO_FLAG)
{ 
 8011738:	b480      	push	{r7}
 801173a:	b083      	sub	sp, #12
 801173c:	af00      	add	r7, sp, #0
 801173e:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_SDIO_CLEAR_FLAG(SDIO_FLAG));
   
  SDIO->ICR = SDIO_FLAG;
 8011740:	4a04      	ldr	r2, [pc, #16]	; (8011754 <SDIO_ClearFlag+0x1c>)
 8011742:	687b      	ldr	r3, [r7, #4]
 8011744:	6393      	str	r3, [r2, #56]	; 0x38
}
 8011746:	bf00      	nop
 8011748:	370c      	adds	r7, #12
 801174a:	46bd      	mov	sp, r7
 801174c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8011750:	4770      	bx	lr
 8011752:	bf00      	nop
 8011754:	40012c00 	.word	0x40012c00

08011758 <SDIO_GetITStatus>:
  *            @arg SDIO_IT_SDIOIT:   SD I/O interrupt received interrupt
  *            @arg SDIO_IT_CEATAEND: CE-ATA command completion signal received for CMD61 interrupt
  * @retval The new state of SDIO_IT (SET or RESET).
  */
ITStatus SDIO_GetITStatus(uint32_t SDIO_IT)
{ 
 8011758:	b480      	push	{r7}
 801175a:	b085      	sub	sp, #20
 801175c:	af00      	add	r7, sp, #0
 801175e:	6078      	str	r0, [r7, #4]
  ITStatus bitstatus = RESET;
 8011760:	2300      	movs	r3, #0
 8011762:	73fb      	strb	r3, [r7, #15]
  
  /* Check the parameters */
  assert_param(IS_SDIO_GET_IT(SDIO_IT));
  if ((SDIO->STA & SDIO_IT) != (uint32_t)RESET)  
 8011764:	4b08      	ldr	r3, [pc, #32]	; (8011788 <SDIO_GetITStatus+0x30>)
 8011766:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8011768:	687b      	ldr	r3, [r7, #4]
 801176a:	4013      	ands	r3, r2
 801176c:	2b00      	cmp	r3, #0
 801176e:	d002      	beq.n	8011776 <SDIO_GetITStatus+0x1e>
  {
    bitstatus = SET;
 8011770:	2301      	movs	r3, #1
 8011772:	73fb      	strb	r3, [r7, #15]
 8011774:	e001      	b.n	801177a <SDIO_GetITStatus+0x22>
  }
  else
  {
    bitstatus = RESET;
 8011776:	2300      	movs	r3, #0
 8011778:	73fb      	strb	r3, [r7, #15]
  }
  return bitstatus;
 801177a:	7bfb      	ldrb	r3, [r7, #15]
}
 801177c:	4618      	mov	r0, r3
 801177e:	3714      	adds	r7, #20
 8011780:	46bd      	mov	sp, r7
 8011782:	f85d 7b04 	ldr.w	r7, [sp], #4
 8011786:	4770      	bx	lr
 8011788:	40012c00 	.word	0x40012c00

0801178c <SDIO_ClearITPendingBit>:
  *            @arg SDIO_IT_SDIOIT:   SD I/O interrupt received interrupt
  *            @arg SDIO_IT_CEATAEND: CE-ATA command completion signal received for CMD61
  * @retval None
  */
void SDIO_ClearITPendingBit(uint32_t SDIO_IT)
{ 
 801178c:	b480      	push	{r7}
 801178e:	b083      	sub	sp, #12
 8011790:	af00      	add	r7, sp, #0
 8011792:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_SDIO_CLEAR_IT(SDIO_IT));
   
  SDIO->ICR = SDIO_IT;
 8011794:	4a04      	ldr	r2, [pc, #16]	; (80117a8 <SDIO_ClearITPendingBit+0x1c>)
 8011796:	687b      	ldr	r3, [r7, #4]
 8011798:	6393      	str	r3, [r2, #56]	; 0x38
}
 801179a:	bf00      	nop
 801179c:	370c      	adds	r7, #12
 801179e:	46bd      	mov	sp, r7
 80117a0:	f85d 7b04 	ldr.w	r7, [sp], #4
 80117a4:	4770      	bx	lr
 80117a6:	bf00      	nop
 80117a8:	40012c00 	.word	0x40012c00

080117ac <SPI_I2S_DeInit>:
  *         is managed by the I2S peripheral clock).
  *             
  * @retval None
  */
void SPI_I2S_DeInit(SPI_TypeDef* SPIx)
{
 80117ac:	b580      	push	{r7, lr}
 80117ae:	b082      	sub	sp, #8
 80117b0:	af00      	add	r7, sp, #0
 80117b2:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_SPI_ALL_PERIPH(SPIx));

  if (SPIx == SPI1)
 80117b4:	687b      	ldr	r3, [r7, #4]
 80117b6:	4a17      	ldr	r2, [pc, #92]	; (8011814 <SPI_I2S_DeInit+0x68>)
 80117b8:	4293      	cmp	r3, r2
 80117ba:	d10a      	bne.n	80117d2 <SPI_I2S_DeInit+0x26>
  {
    /* Enable SPI1 reset state */
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_SPI1, ENABLE);
 80117bc:	2101      	movs	r1, #1
 80117be:	f44f 5080 	mov.w	r0, #4096	; 0x1000
 80117c2:	f7fe f8c7 	bl	800f954 <RCC_APB2PeriphResetCmd>
    /* Release SPI1 from reset state */
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_SPI1, DISABLE);
 80117c6:	2100      	movs	r1, #0
 80117c8:	f44f 5080 	mov.w	r0, #4096	; 0x1000
 80117cc:	f7fe f8c2 	bl	800f954 <RCC_APB2PeriphResetCmd>
      RCC_APB1PeriphResetCmd(RCC_APB1Periph_SPI3, ENABLE);
      /* Release SPI3 from reset state */
      RCC_APB1PeriphResetCmd(RCC_APB1Periph_SPI3, DISABLE);
    }
  }
}
 80117d0:	e01c      	b.n	801180c <SPI_I2S_DeInit+0x60>
  else if (SPIx == SPI2)
 80117d2:	687b      	ldr	r3, [r7, #4]
 80117d4:	4a10      	ldr	r2, [pc, #64]	; (8011818 <SPI_I2S_DeInit+0x6c>)
 80117d6:	4293      	cmp	r3, r2
 80117d8:	d10a      	bne.n	80117f0 <SPI_I2S_DeInit+0x44>
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_SPI2, ENABLE);
 80117da:	2101      	movs	r1, #1
 80117dc:	f44f 4080 	mov.w	r0, #16384	; 0x4000
 80117e0:	f7fe f898 	bl	800f914 <RCC_APB1PeriphResetCmd>
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_SPI2, DISABLE);
 80117e4:	2100      	movs	r1, #0
 80117e6:	f44f 4080 	mov.w	r0, #16384	; 0x4000
 80117ea:	f7fe f893 	bl	800f914 <RCC_APB1PeriphResetCmd>
}
 80117ee:	e00d      	b.n	801180c <SPI_I2S_DeInit+0x60>
    if (SPIx == SPI3)
 80117f0:	687b      	ldr	r3, [r7, #4]
 80117f2:	4a0a      	ldr	r2, [pc, #40]	; (801181c <SPI_I2S_DeInit+0x70>)
 80117f4:	4293      	cmp	r3, r2
 80117f6:	d109      	bne.n	801180c <SPI_I2S_DeInit+0x60>
      RCC_APB1PeriphResetCmd(RCC_APB1Periph_SPI3, ENABLE);
 80117f8:	2101      	movs	r1, #1
 80117fa:	f44f 4000 	mov.w	r0, #32768	; 0x8000
 80117fe:	f7fe f889 	bl	800f914 <RCC_APB1PeriphResetCmd>
      RCC_APB1PeriphResetCmd(RCC_APB1Periph_SPI3, DISABLE);
 8011802:	2100      	movs	r1, #0
 8011804:	f44f 4000 	mov.w	r0, #32768	; 0x8000
 8011808:	f7fe f884 	bl	800f914 <RCC_APB1PeriphResetCmd>
}
 801180c:	bf00      	nop
 801180e:	3708      	adds	r7, #8
 8011810:	46bd      	mov	sp, r7
 8011812:	bd80      	pop	{r7, pc}
 8011814:	40013000 	.word	0x40013000
 8011818:	40003800 	.word	0x40003800
 801181c:	40003c00 	.word	0x40003c00

08011820 <SPI_Init>:
  * @param  SPI_InitStruct: pointer to a SPI_InitTypeDef structure that
  *         contains the configuration information for the specified SPI peripheral.
  * @retval None
  */
void SPI_Init(SPI_TypeDef* SPIx, SPI_InitTypeDef* SPI_InitStruct)
{
 8011820:	b480      	push	{r7}
 8011822:	b085      	sub	sp, #20
 8011824:	af00      	add	r7, sp, #0
 8011826:	6078      	str	r0, [r7, #4]
 8011828:	6039      	str	r1, [r7, #0]
  uint16_t tmpreg = 0;
 801182a:	2300      	movs	r3, #0
 801182c:	81fb      	strh	r3, [r7, #14]
  assert_param(IS_SPI_FIRST_BIT(SPI_InitStruct->SPI_FirstBit));
  assert_param(IS_SPI_CRC_POLYNOMIAL(SPI_InitStruct->SPI_CRCPolynomial));

/*---------------------------- SPIx CR1 Configuration ------------------------*/
  /* Get the SPIx CR1 value */
  tmpreg = SPIx->CR1;
 801182e:	687b      	ldr	r3, [r7, #4]
 8011830:	881b      	ldrh	r3, [r3, #0]
 8011832:	81fb      	strh	r3, [r7, #14]
  /* Clear BIDIMode, BIDIOE, RxONLY, SSM, SSI, LSBFirst, BR, MSTR, CPOL and CPHA bits */
  tmpreg &= CR1_CLEAR_MASK;
 8011834:	89fb      	ldrh	r3, [r7, #14]
 8011836:	f403 5341 	and.w	r3, r3, #12352	; 0x3040
 801183a:	81fb      	strh	r3, [r7, #14]
  /* Set SSM, SSI and MSTR bits according to SPI_Mode and SPI_NSS values */
  /* Set LSBFirst bit according to SPI_FirstBit value */
  /* Set BR bits according to SPI_BaudRatePrescaler value */
  /* Set CPOL bit according to SPI_CPOL value */
  /* Set CPHA bit according to SPI_CPHA value */
  tmpreg |= (uint16_t)((uint32_t)SPI_InitStruct->SPI_Direction | SPI_InitStruct->SPI_Mode |
 801183c:	683b      	ldr	r3, [r7, #0]
 801183e:	881a      	ldrh	r2, [r3, #0]
 8011840:	683b      	ldr	r3, [r7, #0]
 8011842:	885b      	ldrh	r3, [r3, #2]
 8011844:	4313      	orrs	r3, r2
 8011846:	b29a      	uxth	r2, r3
                  SPI_InitStruct->SPI_DataSize | SPI_InitStruct->SPI_CPOL |  
 8011848:	683b      	ldr	r3, [r7, #0]
 801184a:	889b      	ldrh	r3, [r3, #4]
  tmpreg |= (uint16_t)((uint32_t)SPI_InitStruct->SPI_Direction | SPI_InitStruct->SPI_Mode |
 801184c:	4313      	orrs	r3, r2
 801184e:	b29a      	uxth	r2, r3
                  SPI_InitStruct->SPI_DataSize | SPI_InitStruct->SPI_CPOL |  
 8011850:	683b      	ldr	r3, [r7, #0]
 8011852:	88db      	ldrh	r3, [r3, #6]
  tmpreg |= (uint16_t)((uint32_t)SPI_InitStruct->SPI_Direction | SPI_InitStruct->SPI_Mode |
 8011854:	4313      	orrs	r3, r2
 8011856:	b29a      	uxth	r2, r3
                  SPI_InitStruct->SPI_CPHA | SPI_InitStruct->SPI_NSS |  
 8011858:	683b      	ldr	r3, [r7, #0]
 801185a:	891b      	ldrh	r3, [r3, #8]
  tmpreg |= (uint16_t)((uint32_t)SPI_InitStruct->SPI_Direction | SPI_InitStruct->SPI_Mode |
 801185c:	4313      	orrs	r3, r2
 801185e:	b29a      	uxth	r2, r3
                  SPI_InitStruct->SPI_CPHA | SPI_InitStruct->SPI_NSS |  
 8011860:	683b      	ldr	r3, [r7, #0]
 8011862:	895b      	ldrh	r3, [r3, #10]
  tmpreg |= (uint16_t)((uint32_t)SPI_InitStruct->SPI_Direction | SPI_InitStruct->SPI_Mode |
 8011864:	4313      	orrs	r3, r2
 8011866:	b29a      	uxth	r2, r3
                  SPI_InitStruct->SPI_BaudRatePrescaler | SPI_InitStruct->SPI_FirstBit);
 8011868:	683b      	ldr	r3, [r7, #0]
 801186a:	899b      	ldrh	r3, [r3, #12]
  tmpreg |= (uint16_t)((uint32_t)SPI_InitStruct->SPI_Direction | SPI_InitStruct->SPI_Mode |
 801186c:	4313      	orrs	r3, r2
 801186e:	b29a      	uxth	r2, r3
                  SPI_InitStruct->SPI_BaudRatePrescaler | SPI_InitStruct->SPI_FirstBit);
 8011870:	683b      	ldr	r3, [r7, #0]
 8011872:	89db      	ldrh	r3, [r3, #14]
  tmpreg |= (uint16_t)((uint32_t)SPI_InitStruct->SPI_Direction | SPI_InitStruct->SPI_Mode |
 8011874:	4313      	orrs	r3, r2
 8011876:	b29a      	uxth	r2, r3
 8011878:	89fb      	ldrh	r3, [r7, #14]
 801187a:	4313      	orrs	r3, r2
 801187c:	81fb      	strh	r3, [r7, #14]
  /* Write to SPIx CR1 */
  SPIx->CR1 = tmpreg;
 801187e:	687b      	ldr	r3, [r7, #4]
 8011880:	89fa      	ldrh	r2, [r7, #14]
 8011882:	801a      	strh	r2, [r3, #0]

  /* Activate the SPI mode (Reset I2SMOD bit in I2SCFGR register) */
  SPIx->I2SCFGR &= (uint16_t)~((uint16_t)SPI_I2SCFGR_I2SMOD);
 8011884:	687b      	ldr	r3, [r7, #4]
 8011886:	8b9b      	ldrh	r3, [r3, #28]
 8011888:	b29b      	uxth	r3, r3
 801188a:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
 801188e:	b29a      	uxth	r2, r3
 8011890:	687b      	ldr	r3, [r7, #4]
 8011892:	839a      	strh	r2, [r3, #28]
/*---------------------------- SPIx CRCPOLY Configuration --------------------*/
  /* Write to SPIx CRCPOLY */
  SPIx->CRCPR = SPI_InitStruct->SPI_CRCPolynomial;
 8011894:	683b      	ldr	r3, [r7, #0]
 8011896:	8a1a      	ldrh	r2, [r3, #16]
 8011898:	687b      	ldr	r3, [r7, #4]
 801189a:	821a      	strh	r2, [r3, #16]
}
 801189c:	bf00      	nop
 801189e:	3714      	adds	r7, #20
 80118a0:	46bd      	mov	sp, r7
 80118a2:	f85d 7b04 	ldr.w	r7, [sp], #4
 80118a6:	4770      	bx	lr

080118a8 <I2S_Init>:
  *         to the value of the the source clock frequency (in Hz).
  *  
  * @retval None
  */
void I2S_Init(SPI_TypeDef* SPIx, I2S_InitTypeDef* I2S_InitStruct)
{
 80118a8:	b480      	push	{r7}
 80118aa:	b08b      	sub	sp, #44	; 0x2c
 80118ac:	af00      	add	r7, sp, #0
 80118ae:	6078      	str	r0, [r7, #4]
 80118b0:	6039      	str	r1, [r7, #0]
  uint16_t tmpreg = 0, i2sdiv = 2, i2sodd = 0, packetlength = 1;
 80118b2:	2300      	movs	r3, #0
 80118b4:	837b      	strh	r3, [r7, #26]
 80118b6:	2302      	movs	r3, #2
 80118b8:	84fb      	strh	r3, [r7, #38]	; 0x26
 80118ba:	2300      	movs	r3, #0
 80118bc:	84bb      	strh	r3, [r7, #36]	; 0x24
 80118be:	2301      	movs	r3, #1
 80118c0:	847b      	strh	r3, [r7, #34]	; 0x22
  uint32_t tmp = 0, i2sclk = 0;
 80118c2:	2300      	movs	r3, #0
 80118c4:	61fb      	str	r3, [r7, #28]
 80118c6:	2300      	movs	r3, #0
 80118c8:	617b      	str	r3, [r7, #20]
#ifndef I2S_EXTERNAL_CLOCK_VAL
  uint32_t pllm = 0, plln = 0, pllr = 0;
 80118ca:	2300      	movs	r3, #0
 80118cc:	613b      	str	r3, [r7, #16]
 80118ce:	2300      	movs	r3, #0
 80118d0:	60fb      	str	r3, [r7, #12]
 80118d2:	2300      	movs	r3, #0
 80118d4:	60bb      	str	r3, [r7, #8]
  assert_param(IS_I2S_AUDIO_FREQ(I2S_InitStruct->I2S_AudioFreq));
  assert_param(IS_I2S_CPOL(I2S_InitStruct->I2S_CPOL));  

/*----------------------- SPIx I2SCFGR & I2SPR Configuration -----------------*/
  /* Clear I2SMOD, I2SE, I2SCFG, PCMSYNC, I2SSTD, CKPOL, DATLEN and CHLEN bits */
  SPIx->I2SCFGR &= I2SCFGR_CLEAR_MASK; 
 80118d6:	687b      	ldr	r3, [r7, #4]
 80118d8:	8b9b      	ldrh	r3, [r3, #28]
 80118da:	b29b      	uxth	r3, r3
 80118dc:	f423 637b 	bic.w	r3, r3, #4016	; 0xfb0
 80118e0:	f023 030f 	bic.w	r3, r3, #15
 80118e4:	b29a      	uxth	r2, r3
 80118e6:	687b      	ldr	r3, [r7, #4]
 80118e8:	839a      	strh	r2, [r3, #28]
  SPIx->I2SPR = 0x0002;
 80118ea:	687b      	ldr	r3, [r7, #4]
 80118ec:	2202      	movs	r2, #2
 80118ee:	841a      	strh	r2, [r3, #32]
  
  /* Get the I2SCFGR register value */
  tmpreg = SPIx->I2SCFGR;
 80118f0:	687b      	ldr	r3, [r7, #4]
 80118f2:	8b9b      	ldrh	r3, [r3, #28]
 80118f4:	837b      	strh	r3, [r7, #26]
  
  /* If the default value has to be written, reinitialize i2sdiv and i2sodd*/
  if(I2S_InitStruct->I2S_AudioFreq == I2S_AudioFreq_Default)
 80118f6:	683b      	ldr	r3, [r7, #0]
 80118f8:	689b      	ldr	r3, [r3, #8]
 80118fa:	2b02      	cmp	r3, #2
 80118fc:	d104      	bne.n	8011908 <I2S_Init+0x60>
  {
    i2sodd = (uint16_t)0;
 80118fe:	2300      	movs	r3, #0
 8011900:	84bb      	strh	r3, [r7, #36]	; 0x24
    i2sdiv = (uint16_t)2;   
 8011902:	2302      	movs	r3, #2
 8011904:	84fb      	strh	r3, [r7, #38]	; 0x26
 8011906:	e06d      	b.n	80119e4 <I2S_Init+0x13c>
  }
  /* If the requested audio frequency is not the default, compute the prescaler */
  else
  {
    /* Check the frame length (For the Prescaler computing) *******************/
    if(I2S_InitStruct->I2S_DataFormat == I2S_DataFormat_16b)
 8011908:	683b      	ldr	r3, [r7, #0]
 801190a:	889b      	ldrh	r3, [r3, #4]
 801190c:	2b00      	cmp	r3, #0
 801190e:	d102      	bne.n	8011916 <I2S_Init+0x6e>
    {
      /* Packet length is 16 bits */
      packetlength = 1;
 8011910:	2301      	movs	r3, #1
 8011912:	847b      	strh	r3, [r7, #34]	; 0x22
 8011914:	e001      	b.n	801191a <I2S_Init+0x72>
    }
    else
    {
      /* Packet length is 32 bits */
      packetlength = 2;
 8011916:	2302      	movs	r3, #2
 8011918:	847b      	strh	r3, [r7, #34]	; 0x22
    /* Set the I2S clock to the external clock  value */
    i2sclk = I2S_EXTERNAL_CLOCK_VAL;

  #else /* There is no define for External I2S clock source */
    /* Set PLLI2S as I2S clock source */
    if ((RCC->CFGR & RCC_CFGR_I2SSRC) != 0)
 801191a:	4b4b      	ldr	r3, [pc, #300]	; (8011a48 <I2S_Init+0x1a0>)
 801191c:	689b      	ldr	r3, [r3, #8]
 801191e:	f403 0300 	and.w	r3, r3, #8388608	; 0x800000
 8011922:	2b00      	cmp	r3, #0
 8011924:	d005      	beq.n	8011932 <I2S_Init+0x8a>
    {
      RCC->CFGR &= ~(uint32_t)RCC_CFGR_I2SSRC;
 8011926:	4a48      	ldr	r2, [pc, #288]	; (8011a48 <I2S_Init+0x1a0>)
 8011928:	4b47      	ldr	r3, [pc, #284]	; (8011a48 <I2S_Init+0x1a0>)
 801192a:	689b      	ldr	r3, [r3, #8]
 801192c:	f423 0300 	bic.w	r3, r3, #8388608	; 0x800000
 8011930:	6093      	str	r3, [r2, #8]
    }    
    
    /* Get the PLLI2SN value */
    plln = (uint32_t)(((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SN) >> 6) & \
 8011932:	4b45      	ldr	r3, [pc, #276]	; (8011a48 <I2S_Init+0x1a0>)
 8011934:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
 8011938:	099b      	lsrs	r3, r3, #6
 801193a:	f3c3 0308 	ubfx	r3, r3, #0, #9
 801193e:	60fb      	str	r3, [r7, #12]
                      (RCC_PLLI2SCFGR_PLLI2SN >> 6));
    
    /* Get the PLLI2SR value */
    pllr = (uint32_t)(((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SR) >> 28) & \
 8011940:	4b41      	ldr	r3, [pc, #260]	; (8011a48 <I2S_Init+0x1a0>)
 8011942:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
 8011946:	0f1b      	lsrs	r3, r3, #28
 8011948:	f003 0307 	and.w	r3, r3, #7
 801194c:	60bb      	str	r3, [r7, #8]
                      (RCC_PLLI2SCFGR_PLLI2SR >> 28));
    
    /* Get the PLLM value */
    pllm = (uint32_t)(RCC->PLLCFGR & RCC_PLLCFGR_PLLM);      
 801194e:	4b3e      	ldr	r3, [pc, #248]	; (8011a48 <I2S_Init+0x1a0>)
 8011950:	685b      	ldr	r3, [r3, #4]
 8011952:	f003 033f 	and.w	r3, r3, #63	; 0x3f
 8011956:	613b      	str	r3, [r7, #16]
    
    /* Get the I2S source clock value */
    i2sclk = (uint32_t)(((HSE_VALUE / pllm) * plln) / pllr);
 8011958:	4a3c      	ldr	r2, [pc, #240]	; (8011a4c <I2S_Init+0x1a4>)
 801195a:	693b      	ldr	r3, [r7, #16]
 801195c:	fbb2 f3f3 	udiv	r3, r2, r3
 8011960:	68fa      	ldr	r2, [r7, #12]
 8011962:	fb02 f203 	mul.w	r2, r2, r3
 8011966:	68bb      	ldr	r3, [r7, #8]
 8011968:	fbb2 f3f3 	udiv	r3, r2, r3
 801196c:	617b      	str	r3, [r7, #20]
  #endif /* I2S_EXTERNAL_CLOCK_VAL */
    
    /* Compute the Real divider depending on the MCLK output state, with a floating point */
    if(I2S_InitStruct->I2S_MCLKOutput == I2S_MCLKOutput_Enable)
 801196e:	683b      	ldr	r3, [r7, #0]
 8011970:	88db      	ldrh	r3, [r3, #6]
 8011972:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 8011976:	d10f      	bne.n	8011998 <I2S_Init+0xf0>
    {
      /* MCLK output is enabled */
      tmp = (uint16_t)(((((i2sclk / 256) * 10) / I2S_InitStruct->I2S_AudioFreq)) + 5);
 8011978:	697b      	ldr	r3, [r7, #20]
 801197a:	0a1a      	lsrs	r2, r3, #8
 801197c:	4613      	mov	r3, r2
 801197e:	009b      	lsls	r3, r3, #2
 8011980:	4413      	add	r3, r2
 8011982:	005b      	lsls	r3, r3, #1
 8011984:	461a      	mov	r2, r3
 8011986:	683b      	ldr	r3, [r7, #0]
 8011988:	689b      	ldr	r3, [r3, #8]
 801198a:	fbb2 f3f3 	udiv	r3, r2, r3
 801198e:	b29b      	uxth	r3, r3
 8011990:	3305      	adds	r3, #5
 8011992:	b29b      	uxth	r3, r3
 8011994:	61fb      	str	r3, [r7, #28]
 8011996:	e012      	b.n	80119be <I2S_Init+0x116>
    }
    else
    {
      /* MCLK output is disabled */
      tmp = (uint16_t)(((((i2sclk / (32 * packetlength)) *10 ) / I2S_InitStruct->I2S_AudioFreq)) + 5);
 8011998:	8c7b      	ldrh	r3, [r7, #34]	; 0x22
 801199a:	015b      	lsls	r3, r3, #5
 801199c:	461a      	mov	r2, r3
 801199e:	697b      	ldr	r3, [r7, #20]
 80119a0:	fbb3 f2f2 	udiv	r2, r3, r2
 80119a4:	4613      	mov	r3, r2
 80119a6:	009b      	lsls	r3, r3, #2
 80119a8:	4413      	add	r3, r2
 80119aa:	005b      	lsls	r3, r3, #1
 80119ac:	461a      	mov	r2, r3
 80119ae:	683b      	ldr	r3, [r7, #0]
 80119b0:	689b      	ldr	r3, [r3, #8]
 80119b2:	fbb2 f3f3 	udiv	r3, r2, r3
 80119b6:	b29b      	uxth	r3, r3
 80119b8:	3305      	adds	r3, #5
 80119ba:	b29b      	uxth	r3, r3
 80119bc:	61fb      	str	r3, [r7, #28]
    }
    
    /* Remove the flatting point */
    tmp = tmp / 10;  
 80119be:	69fb      	ldr	r3, [r7, #28]
 80119c0:	4a23      	ldr	r2, [pc, #140]	; (8011a50 <I2S_Init+0x1a8>)
 80119c2:	fba2 2303 	umull	r2, r3, r2, r3
 80119c6:	08db      	lsrs	r3, r3, #3
 80119c8:	61fb      	str	r3, [r7, #28]
      
    /* Check the parity of the divider */
    i2sodd = (uint16_t)(tmp & (uint16_t)0x0001);
 80119ca:	69fb      	ldr	r3, [r7, #28]
 80119cc:	b29b      	uxth	r3, r3
 80119ce:	f003 0301 	and.w	r3, r3, #1
 80119d2:	84bb      	strh	r3, [r7, #36]	; 0x24
   
    /* Compute the i2sdiv prescaler */
    i2sdiv = (uint16_t)((tmp - i2sodd) / 2);
 80119d4:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
 80119d6:	69fa      	ldr	r2, [r7, #28]
 80119d8:	1ad3      	subs	r3, r2, r3
 80119da:	085b      	lsrs	r3, r3, #1
 80119dc:	84fb      	strh	r3, [r7, #38]	; 0x26
   
    /* Get the Mask for the Odd bit (SPI_I2SPR[8]) register */
    i2sodd = (uint16_t) (i2sodd << 8);
 80119de:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
 80119e0:	021b      	lsls	r3, r3, #8
 80119e2:	84bb      	strh	r3, [r7, #36]	; 0x24
  }

  /* Test if the divider is 1 or 0 or greater than 0xFF */
  if ((i2sdiv < 2) || (i2sdiv > 0xFF))
 80119e4:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
 80119e6:	2b01      	cmp	r3, #1
 80119e8:	d902      	bls.n	80119f0 <I2S_Init+0x148>
 80119ea:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
 80119ec:	2bff      	cmp	r3, #255	; 0xff
 80119ee:	d903      	bls.n	80119f8 <I2S_Init+0x150>
  {
    /* Set the default values */
    i2sdiv = 2;
 80119f0:	2302      	movs	r3, #2
 80119f2:	84fb      	strh	r3, [r7, #38]	; 0x26
    i2sodd = 0;
 80119f4:	2300      	movs	r3, #0
 80119f6:	84bb      	strh	r3, [r7, #36]	; 0x24
  }

  /* Write to SPIx I2SPR register the computed value */
  SPIx->I2SPR = (uint16_t)((uint16_t)i2sdiv | (uint16_t)(i2sodd | (uint16_t)I2S_InitStruct->I2S_MCLKOutput));
 80119f8:	683b      	ldr	r3, [r7, #0]
 80119fa:	88da      	ldrh	r2, [r3, #6]
 80119fc:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
 80119fe:	4313      	orrs	r3, r2
 8011a00:	b29a      	uxth	r2, r3
 8011a02:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
 8011a04:	4313      	orrs	r3, r2
 8011a06:	b29a      	uxth	r2, r3
 8011a08:	687b      	ldr	r3, [r7, #4]
 8011a0a:	841a      	strh	r2, [r3, #32]
 
  /* Configure the I2S with the SPI_InitStruct values */
  tmpreg |= (uint16_t)((uint16_t)SPI_I2SCFGR_I2SMOD | (uint16_t)(I2S_InitStruct->I2S_Mode | \
 8011a0c:	683b      	ldr	r3, [r7, #0]
 8011a0e:	881a      	ldrh	r2, [r3, #0]
                  (uint16_t)(I2S_InitStruct->I2S_Standard | (uint16_t)(I2S_InitStruct->I2S_DataFormat | \
 8011a10:	683b      	ldr	r3, [r7, #0]
 8011a12:	8859      	ldrh	r1, [r3, #2]
 8011a14:	683b      	ldr	r3, [r7, #0]
 8011a16:	8898      	ldrh	r0, [r3, #4]
                  (uint16_t)I2S_InitStruct->I2S_CPOL))));
 8011a18:	683b      	ldr	r3, [r7, #0]
 8011a1a:	899b      	ldrh	r3, [r3, #12]
                  (uint16_t)(I2S_InitStruct->I2S_Standard | (uint16_t)(I2S_InitStruct->I2S_DataFormat | \
 8011a1c:	4303      	orrs	r3, r0
 8011a1e:	b29b      	uxth	r3, r3
 8011a20:	430b      	orrs	r3, r1
 8011a22:	b29b      	uxth	r3, r3
  tmpreg |= (uint16_t)((uint16_t)SPI_I2SCFGR_I2SMOD | (uint16_t)(I2S_InitStruct->I2S_Mode | \
 8011a24:	4313      	orrs	r3, r2
 8011a26:	b29a      	uxth	r2, r3
 8011a28:	8b7b      	ldrh	r3, [r7, #26]
 8011a2a:	4313      	orrs	r3, r2
 8011a2c:	b29b      	uxth	r3, r3
 8011a2e:	f443 6300 	orr.w	r3, r3, #2048	; 0x800
 8011a32:	837b      	strh	r3, [r7, #26]
 
  /* Write to SPIx I2SCFGR */  
  SPIx->I2SCFGR = tmpreg;
 8011a34:	687b      	ldr	r3, [r7, #4]
 8011a36:	8b7a      	ldrh	r2, [r7, #26]
 8011a38:	839a      	strh	r2, [r3, #28]
}
 8011a3a:	bf00      	nop
 8011a3c:	372c      	adds	r7, #44	; 0x2c
 8011a3e:	46bd      	mov	sp, r7
 8011a40:	f85d 7b04 	ldr.w	r7, [sp], #4
 8011a44:	4770      	bx	lr
 8011a46:	bf00      	nop
 8011a48:	40023800 	.word	0x40023800
 8011a4c:	017d7840 	.word	0x017d7840
 8011a50:	cccccccd 	.word	0xcccccccd

08011a54 <SPI_StructInit>:
  * @brief  Fills each SPI_InitStruct member with its default value.
  * @param  SPI_InitStruct: pointer to a SPI_InitTypeDef structure which will be initialized.
  * @retval None
  */
void SPI_StructInit(SPI_InitTypeDef* SPI_InitStruct)
{
 8011a54:	b480      	push	{r7}
 8011a56:	b083      	sub	sp, #12
 8011a58:	af00      	add	r7, sp, #0
 8011a5a:	6078      	str	r0, [r7, #4]
/*--------------- Reset SPI init structure parameters values -----------------*/
  /* Initialize the SPI_Direction member */
  SPI_InitStruct->SPI_Direction = SPI_Direction_2Lines_FullDuplex;
 8011a5c:	687b      	ldr	r3, [r7, #4]
 8011a5e:	2200      	movs	r2, #0
 8011a60:	801a      	strh	r2, [r3, #0]
  /* initialize the SPI_Mode member */
  SPI_InitStruct->SPI_Mode = SPI_Mode_Slave;
 8011a62:	687b      	ldr	r3, [r7, #4]
 8011a64:	2200      	movs	r2, #0
 8011a66:	805a      	strh	r2, [r3, #2]
  /* initialize the SPI_DataSize member */
  SPI_InitStruct->SPI_DataSize = SPI_DataSize_8b;
 8011a68:	687b      	ldr	r3, [r7, #4]
 8011a6a:	2200      	movs	r2, #0
 8011a6c:	809a      	strh	r2, [r3, #4]
  /* Initialize the SPI_CPOL member */
  SPI_InitStruct->SPI_CPOL = SPI_CPOL_Low;
 8011a6e:	687b      	ldr	r3, [r7, #4]
 8011a70:	2200      	movs	r2, #0
 8011a72:	80da      	strh	r2, [r3, #6]
  /* Initialize the SPI_CPHA member */
  SPI_InitStruct->SPI_CPHA = SPI_CPHA_1Edge;
 8011a74:	687b      	ldr	r3, [r7, #4]
 8011a76:	2200      	movs	r2, #0
 8011a78:	811a      	strh	r2, [r3, #8]
  /* Initialize the SPI_NSS member */
  SPI_InitStruct->SPI_NSS = SPI_NSS_Hard;
 8011a7a:	687b      	ldr	r3, [r7, #4]
 8011a7c:	2200      	movs	r2, #0
 8011a7e:	815a      	strh	r2, [r3, #10]
  /* Initialize the SPI_BaudRatePrescaler member */
  SPI_InitStruct->SPI_BaudRatePrescaler = SPI_BaudRatePrescaler_2;
 8011a80:	687b      	ldr	r3, [r7, #4]
 8011a82:	2200      	movs	r2, #0
 8011a84:	819a      	strh	r2, [r3, #12]
  /* Initialize the SPI_FirstBit member */
  SPI_InitStruct->SPI_FirstBit = SPI_FirstBit_MSB;
 8011a86:	687b      	ldr	r3, [r7, #4]
 8011a88:	2200      	movs	r2, #0
 8011a8a:	81da      	strh	r2, [r3, #14]
  /* Initialize the SPI_CRCPolynomial member */
  SPI_InitStruct->SPI_CRCPolynomial = 7;
 8011a8c:	687b      	ldr	r3, [r7, #4]
 8011a8e:	2207      	movs	r2, #7
 8011a90:	821a      	strh	r2, [r3, #16]
}
 8011a92:	bf00      	nop
 8011a94:	370c      	adds	r7, #12
 8011a96:	46bd      	mov	sp, r7
 8011a98:	f85d 7b04 	ldr.w	r7, [sp], #4
 8011a9c:	4770      	bx	lr

08011a9e <I2S_StructInit>:
  * @brief  Fills each I2S_InitStruct member with its default value.
  * @param  I2S_InitStruct: pointer to a I2S_InitTypeDef structure which will be initialized.
  * @retval None
  */
void I2S_StructInit(I2S_InitTypeDef* I2S_InitStruct)
{
 8011a9e:	b480      	push	{r7}
 8011aa0:	b083      	sub	sp, #12
 8011aa2:	af00      	add	r7, sp, #0
 8011aa4:	6078      	str	r0, [r7, #4]
/*--------------- Reset I2S init structure parameters values -----------------*/
  /* Initialize the I2S_Mode member */
  I2S_InitStruct->I2S_Mode = I2S_Mode_SlaveTx;
 8011aa6:	687b      	ldr	r3, [r7, #4]
 8011aa8:	2200      	movs	r2, #0
 8011aaa:	801a      	strh	r2, [r3, #0]
  
  /* Initialize the I2S_Standard member */
  I2S_InitStruct->I2S_Standard = I2S_Standard_Phillips;
 8011aac:	687b      	ldr	r3, [r7, #4]
 8011aae:	2200      	movs	r2, #0
 8011ab0:	805a      	strh	r2, [r3, #2]
  
  /* Initialize the I2S_DataFormat member */
  I2S_InitStruct->I2S_DataFormat = I2S_DataFormat_16b;
 8011ab2:	687b      	ldr	r3, [r7, #4]
 8011ab4:	2200      	movs	r2, #0
 8011ab6:	809a      	strh	r2, [r3, #4]
  
  /* Initialize the I2S_MCLKOutput member */
  I2S_InitStruct->I2S_MCLKOutput = I2S_MCLKOutput_Disable;
 8011ab8:	687b      	ldr	r3, [r7, #4]
 8011aba:	2200      	movs	r2, #0
 8011abc:	80da      	strh	r2, [r3, #6]
  
  /* Initialize the I2S_AudioFreq member */
  I2S_InitStruct->I2S_AudioFreq = I2S_AudioFreq_Default;
 8011abe:	687b      	ldr	r3, [r7, #4]
 8011ac0:	2202      	movs	r2, #2
 8011ac2:	609a      	str	r2, [r3, #8]
  
  /* Initialize the I2S_CPOL member */
  I2S_InitStruct->I2S_CPOL = I2S_CPOL_Low;
 8011ac4:	687b      	ldr	r3, [r7, #4]
 8011ac6:	2200      	movs	r2, #0
 8011ac8:	819a      	strh	r2, [r3, #12]
}
 8011aca:	bf00      	nop
 8011acc:	370c      	adds	r7, #12
 8011ace:	46bd      	mov	sp, r7
 8011ad0:	f85d 7b04 	ldr.w	r7, [sp], #4
 8011ad4:	4770      	bx	lr

08011ad6 <SPI_Cmd>:
  * @param  NewState: new state of the SPIx peripheral. 
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void SPI_Cmd(SPI_TypeDef* SPIx, FunctionalState NewState)
{
 8011ad6:	b480      	push	{r7}
 8011ad8:	b083      	sub	sp, #12
 8011ada:	af00      	add	r7, sp, #0
 8011adc:	6078      	str	r0, [r7, #4]
 8011ade:	460b      	mov	r3, r1
 8011ae0:	70fb      	strb	r3, [r7, #3]
  /* Check the parameters */
  assert_param(IS_SPI_ALL_PERIPH(SPIx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 8011ae2:	78fb      	ldrb	r3, [r7, #3]
 8011ae4:	2b00      	cmp	r3, #0
 8011ae6:	d008      	beq.n	8011afa <SPI_Cmd+0x24>
  {
    /* Enable the selected SPI peripheral */
    SPIx->CR1 |= SPI_CR1_SPE;
 8011ae8:	687b      	ldr	r3, [r7, #4]
 8011aea:	881b      	ldrh	r3, [r3, #0]
 8011aec:	b29b      	uxth	r3, r3
 8011aee:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8011af2:	b29a      	uxth	r2, r3
 8011af4:	687b      	ldr	r3, [r7, #4]
 8011af6:	801a      	strh	r2, [r3, #0]
  else
  {
    /* Disable the selected SPI peripheral */
    SPIx->CR1 &= (uint16_t)~((uint16_t)SPI_CR1_SPE);
  }
}
 8011af8:	e007      	b.n	8011b0a <SPI_Cmd+0x34>
    SPIx->CR1 &= (uint16_t)~((uint16_t)SPI_CR1_SPE);
 8011afa:	687b      	ldr	r3, [r7, #4]
 8011afc:	881b      	ldrh	r3, [r3, #0]
 8011afe:	b29b      	uxth	r3, r3
 8011b00:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 8011b04:	b29a      	uxth	r2, r3
 8011b06:	687b      	ldr	r3, [r7, #4]
 8011b08:	801a      	strh	r2, [r3, #0]
}
 8011b0a:	bf00      	nop
 8011b0c:	370c      	adds	r7, #12
 8011b0e:	46bd      	mov	sp, r7
 8011b10:	f85d 7b04 	ldr.w	r7, [sp], #4
 8011b14:	4770      	bx	lr

08011b16 <I2S_Cmd>:
  * @param  NewState: new state of the SPIx peripheral. 
  *         This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void I2S_Cmd(SPI_TypeDef* SPIx, FunctionalState NewState)
{
 8011b16:	b480      	push	{r7}
 8011b18:	b083      	sub	sp, #12
 8011b1a:	af00      	add	r7, sp, #0
 8011b1c:	6078      	str	r0, [r7, #4]
 8011b1e:	460b      	mov	r3, r1
 8011b20:	70fb      	strb	r3, [r7, #3]
  /* Check the parameters */
  assert_param(IS_SPI_23_PERIPH_EXT(SPIx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
 8011b22:	78fb      	ldrb	r3, [r7, #3]
 8011b24:	2b00      	cmp	r3, #0
 8011b26:	d008      	beq.n	8011b3a <I2S_Cmd+0x24>
  {
    /* Enable the selected SPI peripheral (in I2S mode) */
    SPIx->I2SCFGR |= SPI_I2SCFGR_I2SE;
 8011b28:	687b      	ldr	r3, [r7, #4]
 8011b2a:	8b9b      	ldrh	r3, [r3, #28]
 8011b2c:	b29b      	uxth	r3, r3
 8011b2e:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
 8011b32:	b29a      	uxth	r2, r3
 8011b34:	687b      	ldr	r3, [r7, #4]
 8011b36:	839a      	strh	r2, [r3, #28]
  else
  {
    /* Disable the selected SPI peripheral in I2S mode */
    SPIx->I2SCFGR &= (uint16_t)~((uint16_t)SPI_I2SCFGR_I2SE);
  }
}
 8011b38:	e007      	b.n	8011b4a <I2S_Cmd+0x34>
    SPIx->I2SCFGR &= (uint16_t)~((uint16_t)SPI_I2SCFGR_I2SE);
 8011b3a:	687b      	ldr	r3, [r7, #4]
 8011b3c:	8b9b      	ldrh	r3, [r3, #28]
 8011b3e:	b29b      	uxth	r3, r3
 8011b40:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 8011b44:	b29a      	uxth	r2, r3
 8011b46:	687b      	ldr	r3, [r7, #4]
 8011b48:	839a      	strh	r2, [r3, #28]
}
 8011b4a:	bf00      	nop
 8011b4c:	370c      	adds	r7, #12
 8011b4e:	46bd      	mov	sp, r7
 8011b50:	f85d 7b04 	ldr.w	r7, [sp], #4
 8011b54:	4770      	bx	lr

08011b56 <SPI_DataSizeConfig>:
  *            @arg SPI_DataSize_16b: Set data frame format to 16bit
  *            @arg SPI_DataSize_8b: Set data frame format to 8bit
  * @retval None
  */
void SPI_DataSizeConfig(SPI_TypeDef* SPIx, uint16_t SPI_DataSize)
{
 8011b56:	b480      	push	{r7}
 8011b58:	b083      	sub	sp, #12
 8011b5a:	af00      	add	r7, sp, #0
 8011b5c:	6078      	str	r0, [r7, #4]
 8011b5e:	460b      	mov	r3, r1
 8011b60:	807b      	strh	r3, [r7, #2]
  /* Check the parameters */
  assert_param(IS_SPI_ALL_PERIPH(SPIx));
  assert_param(IS_SPI_DATASIZE(SPI_DataSize));
  /* Clear DFF bit */
  SPIx->CR1 &= (uint16_t)~SPI_DataSize_16b;
 8011b62:	687b      	ldr	r3, [r7, #4]
 8011b64:	881b      	ldrh	r3, [r3, #0]
 8011b66:	b29b      	uxth	r3, r3
 8011b68:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
 8011b6c:	b29a      	uxth	r2, r3
 8011b6e:	687b      	ldr	r3, [r7, #4]
 8011b70:	801a      	strh	r2, [r3, #0]
  /* Set new DFF bit value */
  SPIx->CR1 |= SPI_DataSize;
 8011b72:	687b      	ldr	r3, [r7, #4]
 8011b74:	881b      	ldrh	r3, [r3, #0]
 8011b76:	b29a      	uxth	r2, r3
 8011b78:	887b      	ldrh	r3, [r7, #2]
 8011b7a:	4313      	orrs	r3, r2
 8011b7c:	b29a      	uxth	r2, r3
 8011b7e:	687b      	ldr	r3, [r7, #4]
 8011b80:	801a      	strh	r2, [r3, #0]
}
 8011b82:	bf00      	nop
 8011b84:	370c      	adds	r7, #12
 8011b86:	46bd      	mov	sp, r7
 8011b88:	f85d 7b04 	ldr.w	r7, [sp], #4
 8011b8c:	4770      	bx	lr

08011b8e <SPI_BiDirectionalLineConfig>:
  *            @arg SPI_Direction_Tx: Selects Tx transmission direction
  *            @arg SPI_Direction_Rx: Selects Rx receive direction
  * @retval None
  */
void SPI_BiDirectionalLineConfig(SPI_TypeDef* SPIx, uint16_t SPI_Direction)
{
 8011b8e:	b480      	push	{r7}
 8011b90:	b083      	sub	sp, #12
 8011b92:	af00      	add	r7, sp, #0
 8011b94:	6078      	str	r0, [r7, #4]
 8011b96:	460b      	mov	r3, r1
 8011b98:	807b      	strh	r3, [r7, #2]
  /* Check the parameters */
  assert_param(IS_SPI_ALL_PERIPH(SPIx));
  assert_param(IS_SPI_DIRECTION(SPI_Direction));
  if (SPI_Direction == SPI_Direction_Tx)
 8011b9a:	887b      	ldrh	r3, [r7, #2]
 8011b9c:	f5b3 4f80 	cmp.w	r3, #16384	; 0x4000
 8011ba0:	d108      	bne.n	8011bb4 <SPI_BiDirectionalLineConfig+0x26>
  {
    /* Set the Tx only mode */
    SPIx->CR1 |= SPI_Direction_Tx;
 8011ba2:	687b      	ldr	r3, [r7, #4]
 8011ba4:	881b      	ldrh	r3, [r3, #0]
 8011ba6:	b29b      	uxth	r3, r3
 8011ba8:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 8011bac:	b29a      	uxth	r2, r3
 8011bae:	687b      	ldr	r3, [r7, #4]
 8011bb0:	801a      	strh	r2, [r3, #0]
  else
  {
    /* Set the Rx only mode */
    SPIx->CR1 &= SPI_Direction_Rx;
  }
}
 8011bb2:	e007      	b.n	8011bc4 <SPI_BiDirectionalLineConfig+0x36>
    SPIx->CR1 &= SPI_Direction_Rx;
 8011bb4:	687b      	ldr	r3, [r7, #4]
 8011bb6:	881b      	ldrh	r3, [r3, #0]
 8011bb8:	b29b      	uxth	r3, r3
 8011bba:	f423 4380 	bic.w	r3, r3, #16384	; 0x4000
 8011bbe:	b29a      	uxth	r2, r3
 8011bc0:	687b      	ldr	r3, [r7, #4]
 8011bc2:	801a      	strh	r2, [r3, #0]
}
 8011bc4:	bf00      	nop
 8011bc6:	370c      	adds	r7, #12
 8011bc8:	46bd      	mov	sp, r7
 8011bca:	f85d 7b04 	ldr.w	r7, [sp], #4
 8011bce:	4770      	bx	lr

08011bd0 <SPI_NSSInternalSoftwareConfig>:
  *            @arg SPI_NSSInternalSoft_Set: Set NSS pin internally
  *            @arg SPI_NSSInternalSoft_Reset: Reset NSS pin internally
  * @retval None
  */
void SPI_NSSInternalSoftwareConfig(SPI_TypeDef* SPIx, uint16_t SPI_NSSInternalSoft)
{
 8011bd0:	b480      	push	{r7}
 8011bd2:	b083      	sub	sp, #12
 8011bd4:	af00      	add	r7, sp, #0
 8011bd6:	6078      	str	r0, [r7, #4]
 8011bd8:	460b      	mov	r3, r1
 8011bda:	807b      	strh	r3, [r7, #2]
  /* Check the parameters */
  assert_param(IS_SPI_ALL_PERIPH(SPIx));
  assert_param(IS_SPI_NSS_INTERNAL(SPI_NSSInternalSoft));
  if (SPI_NSSInternalSoft != SPI_NSSInternalSoft_Reset)
 8011bdc:	887b      	ldrh	r3, [r7, #2]
 8011bde:	f64f 62ff 	movw	r2, #65279	; 0xfeff
 8011be2:	4293      	cmp	r3, r2
 8011be4:	d008      	beq.n	8011bf8 <SPI_NSSInternalSoftwareConfig+0x28>
  {
    /* Set NSS pin internally by software */
    SPIx->CR1 |= SPI_NSSInternalSoft_Set;
 8011be6:	687b      	ldr	r3, [r7, #4]
 8011be8:	881b      	ldrh	r3, [r3, #0]
 8011bea:	b29b      	uxth	r3, r3
 8011bec:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 8011bf0:	b29a      	uxth	r2, r3
 8011bf2:	687b      	ldr	r3, [r7, #4]
 8011bf4:	801a      	strh	r2, [r3, #0]
  else
  {
    /* Reset NSS pin internally by software */
    SPIx->CR1 &= SPI_NSSInternalSoft_Reset;
  }
}
 8011bf6:	e007      	b.n	8011c08 <SPI_NSSInternalSoftwareConfig+0x38>
    SPIx->CR1 &= SPI_NSSInternalSoft_Reset;
 8011bf8:	687b      	ldr	r3, [r7, #4]
 8011bfa:	881b      	ldrh	r3, [r3, #0]
 8011bfc:	b29b      	uxth	r3, r3
 8011bfe:	f423 7380 	bic.w	r3, r3, #256	; 0x100
 8011c02:	b29a      	uxth	r2, r3
 8011c04:	687b      	ldr	r3, [r7, #4]
 8011c06:	801a      	strh	r2, [r3, #0]
}
 8011c08:	bf00      	nop
 8011c0a:	370c      	adds	r7, #12
 8011c0c:	46bd      	mov	sp, r7
 8011c0e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8011c12:	4770      	bx	lr

08011c14 <SPI_SSOutputCmd>:
  * @param  NewState: new state of the SPIx SS output. 
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void SPI_SSOutputCmd(SPI_TypeDef* SPIx, FunctionalState NewState)
{
 8011c14:	b480      	push	{r7}
 8011c16:	b083      	sub	sp, #12
 8011c18:	af00      	add	r7, sp, #0
 8011c1a:	6078      	str	r0, [r7, #4]
 8011c1c:	460b      	mov	r3, r1
 8011c1e:	70fb      	strb	r3, [r7, #3]
  /* Check the parameters */
  assert_param(IS_SPI_ALL_PERIPH(SPIx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 8011c20:	78fb      	ldrb	r3, [r7, #3]
 8011c22:	2b00      	cmp	r3, #0
 8011c24:	d008      	beq.n	8011c38 <SPI_SSOutputCmd+0x24>
  {
    /* Enable the selected SPI SS output */
    SPIx->CR2 |= (uint16_t)SPI_CR2_SSOE;
 8011c26:	687b      	ldr	r3, [r7, #4]
 8011c28:	889b      	ldrh	r3, [r3, #4]
 8011c2a:	b29b      	uxth	r3, r3
 8011c2c:	f043 0304 	orr.w	r3, r3, #4
 8011c30:	b29a      	uxth	r2, r3
 8011c32:	687b      	ldr	r3, [r7, #4]
 8011c34:	809a      	strh	r2, [r3, #4]
  else
  {
    /* Disable the selected SPI SS output */
    SPIx->CR2 &= (uint16_t)~((uint16_t)SPI_CR2_SSOE);
  }
}
 8011c36:	e007      	b.n	8011c48 <SPI_SSOutputCmd+0x34>
    SPIx->CR2 &= (uint16_t)~((uint16_t)SPI_CR2_SSOE);
 8011c38:	687b      	ldr	r3, [r7, #4]
 8011c3a:	889b      	ldrh	r3, [r3, #4]
 8011c3c:	b29b      	uxth	r3, r3
 8011c3e:	f023 0304 	bic.w	r3, r3, #4
 8011c42:	b29a      	uxth	r2, r3
 8011c44:	687b      	ldr	r3, [r7, #4]
 8011c46:	809a      	strh	r2, [r3, #4]
}
 8011c48:	bf00      	nop
 8011c4a:	370c      	adds	r7, #12
 8011c4c:	46bd      	mov	sp, r7
 8011c4e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8011c52:	4770      	bx	lr

08011c54 <SPI_TIModeCmd>:
  * @param  NewState: new state of the selected SPI TI communication mode.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void SPI_TIModeCmd(SPI_TypeDef* SPIx, FunctionalState NewState)
{
 8011c54:	b480      	push	{r7}
 8011c56:	b083      	sub	sp, #12
 8011c58:	af00      	add	r7, sp, #0
 8011c5a:	6078      	str	r0, [r7, #4]
 8011c5c:	460b      	mov	r3, r1
 8011c5e:	70fb      	strb	r3, [r7, #3]
  /* Check the parameters */
  assert_param(IS_SPI_ALL_PERIPH(SPIx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 8011c60:	78fb      	ldrb	r3, [r7, #3]
 8011c62:	2b00      	cmp	r3, #0
 8011c64:	d008      	beq.n	8011c78 <SPI_TIModeCmd+0x24>
  {
    /* Enable the TI mode for the selected SPI peripheral */
    SPIx->CR2 |= SPI_CR2_FRF;
 8011c66:	687b      	ldr	r3, [r7, #4]
 8011c68:	889b      	ldrh	r3, [r3, #4]
 8011c6a:	b29b      	uxth	r3, r3
 8011c6c:	f043 0310 	orr.w	r3, r3, #16
 8011c70:	b29a      	uxth	r2, r3
 8011c72:	687b      	ldr	r3, [r7, #4]
 8011c74:	809a      	strh	r2, [r3, #4]
  else
  {
    /* Disable the TI mode for the selected SPI peripheral */
    SPIx->CR2 &= (uint16_t)~SPI_CR2_FRF;
  }
}
 8011c76:	e007      	b.n	8011c88 <SPI_TIModeCmd+0x34>
    SPIx->CR2 &= (uint16_t)~SPI_CR2_FRF;
 8011c78:	687b      	ldr	r3, [r7, #4]
 8011c7a:	889b      	ldrh	r3, [r3, #4]
 8011c7c:	b29b      	uxth	r3, r3
 8011c7e:	f023 0310 	bic.w	r3, r3, #16
 8011c82:	b29a      	uxth	r2, r3
 8011c84:	687b      	ldr	r3, [r7, #4]
 8011c86:	809a      	strh	r2, [r3, #4]
}
 8011c88:	bf00      	nop
 8011c8a:	370c      	adds	r7, #12
 8011c8c:	46bd      	mov	sp, r7
 8011c8e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8011c92:	4770      	bx	lr

08011c94 <I2S_FullDuplexConfig>:
  * @note   The I2S full duplex extension can be configured in slave mode only.    
  *  
  * @retval None
  */
void I2S_FullDuplexConfig(SPI_TypeDef* I2Sxext, I2S_InitTypeDef* I2S_InitStruct)
{
 8011c94:	b480      	push	{r7}
 8011c96:	b085      	sub	sp, #20
 8011c98:	af00      	add	r7, sp, #0
 8011c9a:	6078      	str	r0, [r7, #4]
 8011c9c:	6039      	str	r1, [r7, #0]
  uint16_t tmpreg = 0, tmp = 0;
 8011c9e:	2300      	movs	r3, #0
 8011ca0:	81bb      	strh	r3, [r7, #12]
 8011ca2:	2300      	movs	r3, #0
 8011ca4:	81fb      	strh	r3, [r7, #14]
  assert_param(IS_I2S_DATA_FORMAT(I2S_InitStruct->I2S_DataFormat));
  assert_param(IS_I2S_CPOL(I2S_InitStruct->I2S_CPOL));  

/*----------------------- SPIx I2SCFGR & I2SPR Configuration -----------------*/
  /* Clear I2SMOD, I2SE, I2SCFG, PCMSYNC, I2SSTD, CKPOL, DATLEN and CHLEN bits */
  I2Sxext->I2SCFGR &= I2SCFGR_CLEAR_MASK; 
 8011ca6:	687b      	ldr	r3, [r7, #4]
 8011ca8:	8b9b      	ldrh	r3, [r3, #28]
 8011caa:	b29b      	uxth	r3, r3
 8011cac:	f423 637b 	bic.w	r3, r3, #4016	; 0xfb0
 8011cb0:	f023 030f 	bic.w	r3, r3, #15
 8011cb4:	b29a      	uxth	r2, r3
 8011cb6:	687b      	ldr	r3, [r7, #4]
 8011cb8:	839a      	strh	r2, [r3, #28]
  I2Sxext->I2SPR = 0x0002;
 8011cba:	687b      	ldr	r3, [r7, #4]
 8011cbc:	2202      	movs	r2, #2
 8011cbe:	841a      	strh	r2, [r3, #32]
  
  /* Get the I2SCFGR register value */
  tmpreg = I2Sxext->I2SCFGR;
 8011cc0:	687b      	ldr	r3, [r7, #4]
 8011cc2:	8b9b      	ldrh	r3, [r3, #28]
 8011cc4:	81bb      	strh	r3, [r7, #12]
  
  /* Get the mode to be configured for the extended I2S */
  if ((I2S_InitStruct->I2S_Mode == I2S_Mode_MasterTx) || (I2S_InitStruct->I2S_Mode == I2S_Mode_SlaveTx))
 8011cc6:	683b      	ldr	r3, [r7, #0]
 8011cc8:	881b      	ldrh	r3, [r3, #0]
 8011cca:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 8011cce:	d003      	beq.n	8011cd8 <I2S_FullDuplexConfig+0x44>
 8011cd0:	683b      	ldr	r3, [r7, #0]
 8011cd2:	881b      	ldrh	r3, [r3, #0]
 8011cd4:	2b00      	cmp	r3, #0
 8011cd6:	d103      	bne.n	8011ce0 <I2S_FullDuplexConfig+0x4c>
  {
    tmp = I2S_Mode_SlaveRx;
 8011cd8:	f44f 7380 	mov.w	r3, #256	; 0x100
 8011cdc:	81fb      	strh	r3, [r7, #14]
 8011cde:	e00b      	b.n	8011cf8 <I2S_FullDuplexConfig+0x64>
  }
  else
  {
    if ((I2S_InitStruct->I2S_Mode == I2S_Mode_MasterRx) || (I2S_InitStruct->I2S_Mode == I2S_Mode_SlaveRx))
 8011ce0:	683b      	ldr	r3, [r7, #0]
 8011ce2:	881b      	ldrh	r3, [r3, #0]
 8011ce4:	f5b3 7f40 	cmp.w	r3, #768	; 0x300
 8011ce8:	d004      	beq.n	8011cf4 <I2S_FullDuplexConfig+0x60>
 8011cea:	683b      	ldr	r3, [r7, #0]
 8011cec:	881b      	ldrh	r3, [r3, #0]
 8011cee:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 8011cf2:	d101      	bne.n	8011cf8 <I2S_FullDuplexConfig+0x64>
    {
      tmp = I2S_Mode_SlaveTx;
 8011cf4:	2300      	movs	r3, #0
 8011cf6:	81fb      	strh	r3, [r7, #14]
  }

 
  /* Configure the I2S with the SPI_InitStruct values */
  tmpreg |= (uint16_t)((uint16_t)SPI_I2SCFGR_I2SMOD | (uint16_t)(tmp | \
                  (uint16_t)(I2S_InitStruct->I2S_Standard | (uint16_t)(I2S_InitStruct->I2S_DataFormat | \
 8011cf8:	683b      	ldr	r3, [r7, #0]
 8011cfa:	885a      	ldrh	r2, [r3, #2]
 8011cfc:	683b      	ldr	r3, [r7, #0]
 8011cfe:	8899      	ldrh	r1, [r3, #4]
                  (uint16_t)I2S_InitStruct->I2S_CPOL))));
 8011d00:	683b      	ldr	r3, [r7, #0]
 8011d02:	899b      	ldrh	r3, [r3, #12]
                  (uint16_t)(I2S_InitStruct->I2S_Standard | (uint16_t)(I2S_InitStruct->I2S_DataFormat | \
 8011d04:	430b      	orrs	r3, r1
 8011d06:	b29b      	uxth	r3, r3
 8011d08:	4313      	orrs	r3, r2
 8011d0a:	b29a      	uxth	r2, r3
  tmpreg |= (uint16_t)((uint16_t)SPI_I2SCFGR_I2SMOD | (uint16_t)(tmp | \
 8011d0c:	89fb      	ldrh	r3, [r7, #14]
 8011d0e:	4313      	orrs	r3, r2
 8011d10:	b29a      	uxth	r2, r3
 8011d12:	89bb      	ldrh	r3, [r7, #12]
 8011d14:	4313      	orrs	r3, r2
 8011d16:	b29b      	uxth	r3, r3
 8011d18:	f443 6300 	orr.w	r3, r3, #2048	; 0x800
 8011d1c:	81bb      	strh	r3, [r7, #12]
 
  /* Write to SPIx I2SCFGR */  
  I2Sxext->I2SCFGR = tmpreg;
 8011d1e:	687b      	ldr	r3, [r7, #4]
 8011d20:	89ba      	ldrh	r2, [r7, #12]
 8011d22:	839a      	strh	r2, [r3, #28]
}
 8011d24:	bf00      	nop
 8011d26:	3714      	adds	r7, #20
 8011d28:	46bd      	mov	sp, r7
 8011d2a:	f85d 7b04 	ldr.w	r7, [sp], #4
 8011d2e:	4770      	bx	lr

08011d30 <SPI_I2S_ReceiveData>:
  * @param  SPIx: To select the SPIx/I2Sx peripheral, where x can be: 1, 2 or 3 
  *         in SPI mode or 2 or 3 in I2S mode or I2Sxext for I2S full duplex mode. 
  * @retval The value of the received data.
  */
uint16_t SPI_I2S_ReceiveData(SPI_TypeDef* SPIx)
{
 8011d30:	b480      	push	{r7}
 8011d32:	b083      	sub	sp, #12
 8011d34:	af00      	add	r7, sp, #0
 8011d36:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_SPI_ALL_PERIPH_EXT(SPIx));
  
  /* Return the data in the DR register */
  return SPIx->DR;
 8011d38:	687b      	ldr	r3, [r7, #4]
 8011d3a:	899b      	ldrh	r3, [r3, #12]
 8011d3c:	b29b      	uxth	r3, r3
}
 8011d3e:	4618      	mov	r0, r3
 8011d40:	370c      	adds	r7, #12
 8011d42:	46bd      	mov	sp, r7
 8011d44:	f85d 7b04 	ldr.w	r7, [sp], #4
 8011d48:	4770      	bx	lr

08011d4a <SPI_I2S_SendData>:
  *         in SPI mode or 2 or 3 in I2S mode or I2Sxext for I2S full duplex mode.     
  * @param  Data: Data to be transmitted.
  * @retval None
  */
void SPI_I2S_SendData(SPI_TypeDef* SPIx, uint16_t Data)
{
 8011d4a:	b480      	push	{r7}
 8011d4c:	b083      	sub	sp, #12
 8011d4e:	af00      	add	r7, sp, #0
 8011d50:	6078      	str	r0, [r7, #4]
 8011d52:	460b      	mov	r3, r1
 8011d54:	807b      	strh	r3, [r7, #2]
  /* Check the parameters */
  assert_param(IS_SPI_ALL_PERIPH_EXT(SPIx));
  
  /* Write in the DR register the data to be sent */
  SPIx->DR = Data;
 8011d56:	687b      	ldr	r3, [r7, #4]
 8011d58:	887a      	ldrh	r2, [r7, #2]
 8011d5a:	819a      	strh	r2, [r3, #12]
}
 8011d5c:	bf00      	nop
 8011d5e:	370c      	adds	r7, #12
 8011d60:	46bd      	mov	sp, r7
 8011d62:	f85d 7b04 	ldr.w	r7, [sp], #4
 8011d66:	4770      	bx	lr

08011d68 <SPI_CalculateCRC>:
  * @param  NewState: new state of the SPIx CRC value calculation.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void SPI_CalculateCRC(SPI_TypeDef* SPIx, FunctionalState NewState)
{
 8011d68:	b480      	push	{r7}
 8011d6a:	b083      	sub	sp, #12
 8011d6c:	af00      	add	r7, sp, #0
 8011d6e:	6078      	str	r0, [r7, #4]
 8011d70:	460b      	mov	r3, r1
 8011d72:	70fb      	strb	r3, [r7, #3]
  /* Check the parameters */
  assert_param(IS_SPI_ALL_PERIPH(SPIx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 8011d74:	78fb      	ldrb	r3, [r7, #3]
 8011d76:	2b00      	cmp	r3, #0
 8011d78:	d008      	beq.n	8011d8c <SPI_CalculateCRC+0x24>
  {
    /* Enable the selected SPI CRC calculation */
    SPIx->CR1 |= SPI_CR1_CRCEN;
 8011d7a:	687b      	ldr	r3, [r7, #4]
 8011d7c:	881b      	ldrh	r3, [r3, #0]
 8011d7e:	b29b      	uxth	r3, r3
 8011d80:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
 8011d84:	b29a      	uxth	r2, r3
 8011d86:	687b      	ldr	r3, [r7, #4]
 8011d88:	801a      	strh	r2, [r3, #0]
  else
  {
    /* Disable the selected SPI CRC calculation */
    SPIx->CR1 &= (uint16_t)~((uint16_t)SPI_CR1_CRCEN);
  }
}
 8011d8a:	e007      	b.n	8011d9c <SPI_CalculateCRC+0x34>
    SPIx->CR1 &= (uint16_t)~((uint16_t)SPI_CR1_CRCEN);
 8011d8c:	687b      	ldr	r3, [r7, #4]
 8011d8e:	881b      	ldrh	r3, [r3, #0]
 8011d90:	b29b      	uxth	r3, r3
 8011d92:	f423 5300 	bic.w	r3, r3, #8192	; 0x2000
 8011d96:	b29a      	uxth	r2, r3
 8011d98:	687b      	ldr	r3, [r7, #4]
 8011d9a:	801a      	strh	r2, [r3, #0]
}
 8011d9c:	bf00      	nop
 8011d9e:	370c      	adds	r7, #12
 8011da0:	46bd      	mov	sp, r7
 8011da2:	f85d 7b04 	ldr.w	r7, [sp], #4
 8011da6:	4770      	bx	lr

08011da8 <SPI_TransmitCRC>:
  * @brief  Transmit the SPIx CRC value.
  * @param  SPIx: where x can be 1, 2 or 3 to select the SPI peripheral.
  * @retval None
  */
void SPI_TransmitCRC(SPI_TypeDef* SPIx)
{
 8011da8:	b480      	push	{r7}
 8011daa:	b083      	sub	sp, #12
 8011dac:	af00      	add	r7, sp, #0
 8011dae:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_SPI_ALL_PERIPH(SPIx));
  
  /* Enable the selected SPI CRC transmission */
  SPIx->CR1 |= SPI_CR1_CRCNEXT;
 8011db0:	687b      	ldr	r3, [r7, #4]
 8011db2:	881b      	ldrh	r3, [r3, #0]
 8011db4:	b29b      	uxth	r3, r3
 8011db6:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
 8011dba:	b29a      	uxth	r2, r3
 8011dbc:	687b      	ldr	r3, [r7, #4]
 8011dbe:	801a      	strh	r2, [r3, #0]
}
 8011dc0:	bf00      	nop
 8011dc2:	370c      	adds	r7, #12
 8011dc4:	46bd      	mov	sp, r7
 8011dc6:	f85d 7b04 	ldr.w	r7, [sp], #4
 8011dca:	4770      	bx	lr

08011dcc <SPI_GetCRC>:
  *            @arg SPI_CRC_Tx: Selects Tx CRC register
  *            @arg SPI_CRC_Rx: Selects Rx CRC register
  * @retval The selected CRC register value..
  */
uint16_t SPI_GetCRC(SPI_TypeDef* SPIx, uint8_t SPI_CRC)
{
 8011dcc:	b480      	push	{r7}
 8011dce:	b085      	sub	sp, #20
 8011dd0:	af00      	add	r7, sp, #0
 8011dd2:	6078      	str	r0, [r7, #4]
 8011dd4:	460b      	mov	r3, r1
 8011dd6:	70fb      	strb	r3, [r7, #3]
  uint16_t crcreg = 0;
 8011dd8:	2300      	movs	r3, #0
 8011dda:	81fb      	strh	r3, [r7, #14]
  /* Check the parameters */
  assert_param(IS_SPI_ALL_PERIPH(SPIx));
  assert_param(IS_SPI_CRC(SPI_CRC));
  if (SPI_CRC != SPI_CRC_Rx)
 8011ddc:	78fb      	ldrb	r3, [r7, #3]
 8011dde:	2b01      	cmp	r3, #1
 8011de0:	d003      	beq.n	8011dea <SPI_GetCRC+0x1e>
  {
    /* Get the Tx CRC register */
    crcreg = SPIx->TXCRCR;
 8011de2:	687b      	ldr	r3, [r7, #4]
 8011de4:	8b1b      	ldrh	r3, [r3, #24]
 8011de6:	81fb      	strh	r3, [r7, #14]
 8011de8:	e002      	b.n	8011df0 <SPI_GetCRC+0x24>
  }
  else
  {
    /* Get the Rx CRC register */
    crcreg = SPIx->RXCRCR;
 8011dea:	687b      	ldr	r3, [r7, #4]
 8011dec:	8a9b      	ldrh	r3, [r3, #20]
 8011dee:	81fb      	strh	r3, [r7, #14]
  }
  /* Return the selected CRC register */
  return crcreg;
 8011df0:	89fb      	ldrh	r3, [r7, #14]
}
 8011df2:	4618      	mov	r0, r3
 8011df4:	3714      	adds	r7, #20
 8011df6:	46bd      	mov	sp, r7
 8011df8:	f85d 7b04 	ldr.w	r7, [sp], #4
 8011dfc:	4770      	bx	lr

08011dfe <SPI_GetCRCPolynomial>:
  * @brief  Returns the CRC Polynomial register value for the specified SPI.
  * @param  SPIx: where x can be 1, 2 or 3 to select the SPI peripheral.
  * @retval The CRC Polynomial register value.
  */
uint16_t SPI_GetCRCPolynomial(SPI_TypeDef* SPIx)
{
 8011dfe:	b480      	push	{r7}
 8011e00:	b083      	sub	sp, #12
 8011e02:	af00      	add	r7, sp, #0
 8011e04:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_SPI_ALL_PERIPH(SPIx));
  
  /* Return the CRC polynomial register */
  return SPIx->CRCPR;
 8011e06:	687b      	ldr	r3, [r7, #4]
 8011e08:	8a1b      	ldrh	r3, [r3, #16]
 8011e0a:	b29b      	uxth	r3, r3
}
 8011e0c:	4618      	mov	r0, r3
 8011e0e:	370c      	adds	r7, #12
 8011e10:	46bd      	mov	sp, r7
 8011e12:	f85d 7b04 	ldr.w	r7, [sp], #4
 8011e16:	4770      	bx	lr

08011e18 <SPI_I2S_DMACmd>:
  * @param  NewState: new state of the selected SPI DMA transfer request.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void SPI_I2S_DMACmd(SPI_TypeDef* SPIx, uint16_t SPI_I2S_DMAReq, FunctionalState NewState)
{
 8011e18:	b480      	push	{r7}
 8011e1a:	b083      	sub	sp, #12
 8011e1c:	af00      	add	r7, sp, #0
 8011e1e:	6078      	str	r0, [r7, #4]
 8011e20:	460b      	mov	r3, r1
 8011e22:	807b      	strh	r3, [r7, #2]
 8011e24:	4613      	mov	r3, r2
 8011e26:	707b      	strb	r3, [r7, #1]
  /* Check the parameters */
  assert_param(IS_SPI_ALL_PERIPH_EXT(SPIx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  assert_param(IS_SPI_I2S_DMAREQ(SPI_I2S_DMAReq));

  if (NewState != DISABLE)
 8011e28:	787b      	ldrb	r3, [r7, #1]
 8011e2a:	2b00      	cmp	r3, #0
 8011e2c:	d008      	beq.n	8011e40 <SPI_I2S_DMACmd+0x28>
  {
    /* Enable the selected SPI DMA requests */
    SPIx->CR2 |= SPI_I2S_DMAReq;
 8011e2e:	687b      	ldr	r3, [r7, #4]
 8011e30:	889b      	ldrh	r3, [r3, #4]
 8011e32:	b29a      	uxth	r2, r3
 8011e34:	887b      	ldrh	r3, [r7, #2]
 8011e36:	4313      	orrs	r3, r2
 8011e38:	b29a      	uxth	r2, r3
 8011e3a:	687b      	ldr	r3, [r7, #4]
 8011e3c:	809a      	strh	r2, [r3, #4]
  else
  {
    /* Disable the selected SPI DMA requests */
    SPIx->CR2 &= (uint16_t)~SPI_I2S_DMAReq;
  }
}
 8011e3e:	e009      	b.n	8011e54 <SPI_I2S_DMACmd+0x3c>
    SPIx->CR2 &= (uint16_t)~SPI_I2S_DMAReq;
 8011e40:	687b      	ldr	r3, [r7, #4]
 8011e42:	889b      	ldrh	r3, [r3, #4]
 8011e44:	b29a      	uxth	r2, r3
 8011e46:	887b      	ldrh	r3, [r7, #2]
 8011e48:	43db      	mvns	r3, r3
 8011e4a:	b29b      	uxth	r3, r3
 8011e4c:	4013      	ands	r3, r2
 8011e4e:	b29a      	uxth	r2, r3
 8011e50:	687b      	ldr	r3, [r7, #4]
 8011e52:	809a      	strh	r2, [r3, #4]
}
 8011e54:	bf00      	nop
 8011e56:	370c      	adds	r7, #12
 8011e58:	46bd      	mov	sp, r7
 8011e5a:	f85d 7b04 	ldr.w	r7, [sp], #4
 8011e5e:	4770      	bx	lr

08011e60 <SPI_I2S_ITConfig>:
  * @param  NewState: new state of the specified SPI interrupt.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void SPI_I2S_ITConfig(SPI_TypeDef* SPIx, uint8_t SPI_I2S_IT, FunctionalState NewState)
{
 8011e60:	b480      	push	{r7}
 8011e62:	b085      	sub	sp, #20
 8011e64:	af00      	add	r7, sp, #0
 8011e66:	6078      	str	r0, [r7, #4]
 8011e68:	460b      	mov	r3, r1
 8011e6a:	70fb      	strb	r3, [r7, #3]
 8011e6c:	4613      	mov	r3, r2
 8011e6e:	70bb      	strb	r3, [r7, #2]
  uint16_t itpos = 0, itmask = 0 ;
 8011e70:	2300      	movs	r3, #0
 8011e72:	81fb      	strh	r3, [r7, #14]
 8011e74:	2300      	movs	r3, #0
 8011e76:	81bb      	strh	r3, [r7, #12]
  assert_param(IS_SPI_ALL_PERIPH_EXT(SPIx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  assert_param(IS_SPI_I2S_CONFIG_IT(SPI_I2S_IT));

  /* Get the SPI IT index */
  itpos = SPI_I2S_IT >> 4;
 8011e78:	78fb      	ldrb	r3, [r7, #3]
 8011e7a:	091b      	lsrs	r3, r3, #4
 8011e7c:	b2db      	uxtb	r3, r3
 8011e7e:	81fb      	strh	r3, [r7, #14]

  /* Set the IT mask */
  itmask = (uint16_t)1 << (uint16_t)itpos;
 8011e80:	89fb      	ldrh	r3, [r7, #14]
 8011e82:	2201      	movs	r2, #1
 8011e84:	fa02 f303 	lsl.w	r3, r2, r3
 8011e88:	81bb      	strh	r3, [r7, #12]

  if (NewState != DISABLE)
 8011e8a:	78bb      	ldrb	r3, [r7, #2]
 8011e8c:	2b00      	cmp	r3, #0
 8011e8e:	d008      	beq.n	8011ea2 <SPI_I2S_ITConfig+0x42>
  {
    /* Enable the selected SPI interrupt */
    SPIx->CR2 |= itmask;
 8011e90:	687b      	ldr	r3, [r7, #4]
 8011e92:	889b      	ldrh	r3, [r3, #4]
 8011e94:	b29a      	uxth	r2, r3
 8011e96:	89bb      	ldrh	r3, [r7, #12]
 8011e98:	4313      	orrs	r3, r2
 8011e9a:	b29a      	uxth	r2, r3
 8011e9c:	687b      	ldr	r3, [r7, #4]
 8011e9e:	809a      	strh	r2, [r3, #4]
  else
  {
    /* Disable the selected SPI interrupt */
    SPIx->CR2 &= (uint16_t)~itmask;
  }
}
 8011ea0:	e009      	b.n	8011eb6 <SPI_I2S_ITConfig+0x56>
    SPIx->CR2 &= (uint16_t)~itmask;
 8011ea2:	687b      	ldr	r3, [r7, #4]
 8011ea4:	889b      	ldrh	r3, [r3, #4]
 8011ea6:	b29a      	uxth	r2, r3
 8011ea8:	89bb      	ldrh	r3, [r7, #12]
 8011eaa:	43db      	mvns	r3, r3
 8011eac:	b29b      	uxth	r3, r3
 8011eae:	4013      	ands	r3, r2
 8011eb0:	b29a      	uxth	r2, r3
 8011eb2:	687b      	ldr	r3, [r7, #4]
 8011eb4:	809a      	strh	r2, [r3, #4]
}
 8011eb6:	bf00      	nop
 8011eb8:	3714      	adds	r7, #20
 8011eba:	46bd      	mov	sp, r7
 8011ebc:	f85d 7b04 	ldr.w	r7, [sp], #4
 8011ec0:	4770      	bx	lr

08011ec2 <SPI_I2S_GetFlagStatus>:
  *            @arg I2S_FLAG_UDR: Underrun Error flag.
  *            @arg I2S_FLAG_CHSIDE: Channel Side flag.  
  * @retval The new state of SPI_I2S_FLAG (SET or RESET).
  */
FlagStatus SPI_I2S_GetFlagStatus(SPI_TypeDef* SPIx, uint16_t SPI_I2S_FLAG)
{
 8011ec2:	b480      	push	{r7}
 8011ec4:	b085      	sub	sp, #20
 8011ec6:	af00      	add	r7, sp, #0
 8011ec8:	6078      	str	r0, [r7, #4]
 8011eca:	460b      	mov	r3, r1
 8011ecc:	807b      	strh	r3, [r7, #2]
  FlagStatus bitstatus = RESET;
 8011ece:	2300      	movs	r3, #0
 8011ed0:	73fb      	strb	r3, [r7, #15]
  /* Check the parameters */
  assert_param(IS_SPI_ALL_PERIPH_EXT(SPIx));
  assert_param(IS_SPI_I2S_GET_FLAG(SPI_I2S_FLAG));
  
  /* Check the status of the specified SPI flag */
  if ((SPIx->SR & SPI_I2S_FLAG) != (uint16_t)RESET)
 8011ed2:	687b      	ldr	r3, [r7, #4]
 8011ed4:	891b      	ldrh	r3, [r3, #8]
 8011ed6:	b29a      	uxth	r2, r3
 8011ed8:	887b      	ldrh	r3, [r7, #2]
 8011eda:	4013      	ands	r3, r2
 8011edc:	b29b      	uxth	r3, r3
 8011ede:	2b00      	cmp	r3, #0
 8011ee0:	d002      	beq.n	8011ee8 <SPI_I2S_GetFlagStatus+0x26>
  {
    /* SPI_I2S_FLAG is set */
    bitstatus = SET;
 8011ee2:	2301      	movs	r3, #1
 8011ee4:	73fb      	strb	r3, [r7, #15]
 8011ee6:	e001      	b.n	8011eec <SPI_I2S_GetFlagStatus+0x2a>
  }
  else
  {
    /* SPI_I2S_FLAG is reset */
    bitstatus = RESET;
 8011ee8:	2300      	movs	r3, #0
 8011eea:	73fb      	strb	r3, [r7, #15]
  }
  /* Return the SPI_I2S_FLAG status */
  return  bitstatus;
 8011eec:	7bfb      	ldrb	r3, [r7, #15]
}
 8011eee:	4618      	mov	r0, r3
 8011ef0:	3714      	adds	r7, #20
 8011ef2:	46bd      	mov	sp, r7
 8011ef4:	f85d 7b04 	ldr.w	r7, [sp], #4
 8011ef8:	4770      	bx	lr

08011efa <SPI_I2S_ClearFlag>:
  *          write operation to SPI_CR1 register (SPI_Cmd() to enable the SPI).
  *  
  * @retval None
  */
void SPI_I2S_ClearFlag(SPI_TypeDef* SPIx, uint16_t SPI_I2S_FLAG)
{
 8011efa:	b480      	push	{r7}
 8011efc:	b083      	sub	sp, #12
 8011efe:	af00      	add	r7, sp, #0
 8011f00:	6078      	str	r0, [r7, #4]
 8011f02:	460b      	mov	r3, r1
 8011f04:	807b      	strh	r3, [r7, #2]
  /* Check the parameters */
  assert_param(IS_SPI_ALL_PERIPH_EXT(SPIx));
  assert_param(IS_SPI_I2S_CLEAR_FLAG(SPI_I2S_FLAG));
    
  /* Clear the selected SPI CRC Error (CRCERR) flag */
  SPIx->SR = (uint16_t)~SPI_I2S_FLAG;
 8011f06:	887b      	ldrh	r3, [r7, #2]
 8011f08:	43db      	mvns	r3, r3
 8011f0a:	b29a      	uxth	r2, r3
 8011f0c:	687b      	ldr	r3, [r7, #4]
 8011f0e:	811a      	strh	r2, [r3, #8]
}
 8011f10:	bf00      	nop
 8011f12:	370c      	adds	r7, #12
 8011f14:	46bd      	mov	sp, r7
 8011f16:	f85d 7b04 	ldr.w	r7, [sp], #4
 8011f1a:	4770      	bx	lr

08011f1c <SPI_I2S_GetITStatus>:
  *            @arg I2S_IT_UDR: Underrun interrupt.  
  *            @arg SPI_I2S_IT_TIFRFE: Format Error interrupt.  
  * @retval The new state of SPI_I2S_IT (SET or RESET).
  */
ITStatus SPI_I2S_GetITStatus(SPI_TypeDef* SPIx, uint8_t SPI_I2S_IT)
{
 8011f1c:	b480      	push	{r7}
 8011f1e:	b085      	sub	sp, #20
 8011f20:	af00      	add	r7, sp, #0
 8011f22:	6078      	str	r0, [r7, #4]
 8011f24:	460b      	mov	r3, r1
 8011f26:	70fb      	strb	r3, [r7, #3]
  ITStatus bitstatus = RESET;
 8011f28:	2300      	movs	r3, #0
 8011f2a:	73fb      	strb	r3, [r7, #15]
  uint16_t itpos = 0, itmask = 0, enablestatus = 0;
 8011f2c:	2300      	movs	r3, #0
 8011f2e:	81bb      	strh	r3, [r7, #12]
 8011f30:	2300      	movs	r3, #0
 8011f32:	817b      	strh	r3, [r7, #10]
 8011f34:	2300      	movs	r3, #0
 8011f36:	813b      	strh	r3, [r7, #8]
  /* Check the parameters */
  assert_param(IS_SPI_ALL_PERIPH_EXT(SPIx));
  assert_param(IS_SPI_I2S_GET_IT(SPI_I2S_IT));

  /* Get the SPI_I2S_IT index */
  itpos = 0x01 << (SPI_I2S_IT & 0x0F);
 8011f38:	78fb      	ldrb	r3, [r7, #3]
 8011f3a:	f003 030f 	and.w	r3, r3, #15
 8011f3e:	2201      	movs	r2, #1
 8011f40:	fa02 f303 	lsl.w	r3, r2, r3
 8011f44:	81bb      	strh	r3, [r7, #12]

  /* Get the SPI_I2S_IT IT mask */
  itmask = SPI_I2S_IT >> 4;
 8011f46:	78fb      	ldrb	r3, [r7, #3]
 8011f48:	091b      	lsrs	r3, r3, #4
 8011f4a:	b2db      	uxtb	r3, r3
 8011f4c:	817b      	strh	r3, [r7, #10]

  /* Set the IT mask */
  itmask = 0x01 << itmask;
 8011f4e:	897b      	ldrh	r3, [r7, #10]
 8011f50:	2201      	movs	r2, #1
 8011f52:	fa02 f303 	lsl.w	r3, r2, r3
 8011f56:	817b      	strh	r3, [r7, #10]

  /* Get the SPI_I2S_IT enable bit status */
  enablestatus = (SPIx->CR2 & itmask) ;
 8011f58:	687b      	ldr	r3, [r7, #4]
 8011f5a:	889b      	ldrh	r3, [r3, #4]
 8011f5c:	b29a      	uxth	r2, r3
 8011f5e:	897b      	ldrh	r3, [r7, #10]
 8011f60:	4013      	ands	r3, r2
 8011f62:	813b      	strh	r3, [r7, #8]

  /* Check the status of the specified SPI interrupt */
  if (((SPIx->SR & itpos) != (uint16_t)RESET) && enablestatus)
 8011f64:	687b      	ldr	r3, [r7, #4]
 8011f66:	891b      	ldrh	r3, [r3, #8]
 8011f68:	b29a      	uxth	r2, r3
 8011f6a:	89bb      	ldrh	r3, [r7, #12]
 8011f6c:	4013      	ands	r3, r2
 8011f6e:	b29b      	uxth	r3, r3
 8011f70:	2b00      	cmp	r3, #0
 8011f72:	d005      	beq.n	8011f80 <SPI_I2S_GetITStatus+0x64>
 8011f74:	893b      	ldrh	r3, [r7, #8]
 8011f76:	2b00      	cmp	r3, #0
 8011f78:	d002      	beq.n	8011f80 <SPI_I2S_GetITStatus+0x64>
  {
    /* SPI_I2S_IT is set */
    bitstatus = SET;
 8011f7a:	2301      	movs	r3, #1
 8011f7c:	73fb      	strb	r3, [r7, #15]
 8011f7e:	e001      	b.n	8011f84 <SPI_I2S_GetITStatus+0x68>
  }
  else
  {
    /* SPI_I2S_IT is reset */
    bitstatus = RESET;
 8011f80:	2300      	movs	r3, #0
 8011f82:	73fb      	strb	r3, [r7, #15]
  }
  /* Return the SPI_I2S_IT status */
  return bitstatus;
 8011f84:	7bfb      	ldrb	r3, [r7, #15]
}
 8011f86:	4618      	mov	r0, r3
 8011f88:	3714      	adds	r7, #20
 8011f8a:	46bd      	mov	sp, r7
 8011f8c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8011f90:	4770      	bx	lr

08011f92 <SPI_I2S_ClearITPendingBit>:
  *          followed by a write operation to SPI_CR1 register (SPI_Cmd() to enable 
  *          the SPI).
  * @retval None
  */
void SPI_I2S_ClearITPendingBit(SPI_TypeDef* SPIx, uint8_t SPI_I2S_IT)
{
 8011f92:	b480      	push	{r7}
 8011f94:	b085      	sub	sp, #20
 8011f96:	af00      	add	r7, sp, #0
 8011f98:	6078      	str	r0, [r7, #4]
 8011f9a:	460b      	mov	r3, r1
 8011f9c:	70fb      	strb	r3, [r7, #3]
  uint16_t itpos = 0;
 8011f9e:	2300      	movs	r3, #0
 8011fa0:	81fb      	strh	r3, [r7, #14]
  /* Check the parameters */
  assert_param(IS_SPI_ALL_PERIPH_EXT(SPIx));
  assert_param(IS_SPI_I2S_CLEAR_IT(SPI_I2S_IT));

  /* Get the SPI_I2S IT index */
  itpos = 0x01 << (SPI_I2S_IT & 0x0F);
 8011fa2:	78fb      	ldrb	r3, [r7, #3]
 8011fa4:	f003 030f 	and.w	r3, r3, #15
 8011fa8:	2201      	movs	r2, #1
 8011faa:	fa02 f303 	lsl.w	r3, r2, r3
 8011fae:	81fb      	strh	r3, [r7, #14]

  /* Clear the selected SPI CRC Error (CRCERR) interrupt pending bit */
  SPIx->SR = (uint16_t)~itpos;
 8011fb0:	89fb      	ldrh	r3, [r7, #14]
 8011fb2:	43db      	mvns	r3, r3
 8011fb4:	b29a      	uxth	r2, r3
 8011fb6:	687b      	ldr	r3, [r7, #4]
 8011fb8:	811a      	strh	r2, [r3, #8]
}
 8011fba:	bf00      	nop
 8011fbc:	3714      	adds	r7, #20
 8011fbe:	46bd      	mov	sp, r7
 8011fc0:	f85d 7b04 	ldr.w	r7, [sp], #4
 8011fc4:	4770      	bx	lr
 8011fc6:	bf00      	nop

08011fc8 <SYSCFG_DeInit>:
  *   registers to their default reset values.
  * @param  None
  * @retval None
  */
void SYSCFG_DeInit(void)
{
 8011fc8:	b580      	push	{r7, lr}
 8011fca:	af00      	add	r7, sp, #0
   RCC_APB2PeriphResetCmd(RCC_APB2Periph_SYSCFG, ENABLE);
 8011fcc:	2101      	movs	r1, #1
 8011fce:	f44f 4080 	mov.w	r0, #16384	; 0x4000
 8011fd2:	f7fd fcbf 	bl	800f954 <RCC_APB2PeriphResetCmd>
   RCC_APB2PeriphResetCmd(RCC_APB2Periph_SYSCFG, DISABLE);
 8011fd6:	2100      	movs	r1, #0
 8011fd8:	f44f 4080 	mov.w	r0, #16384	; 0x4000
 8011fdc:	f7fd fcba 	bl	800f954 <RCC_APB2PeriphResetCmd>
}
 8011fe0:	bf00      	nop
 8011fe2:	bd80      	pop	{r7, pc}

08011fe4 <SYSCFG_MemoryRemapConfig>:
  *            @arg SYSCFG_MemoryRemap_FSMC:        FSMC (Bank1 (NOR/PSRAM 1 and 2) mapped at 0x00000000
  *            @arg SYSCFG_MemoryRemap_SRAM:        Embedded SRAM (112kB) mapped at 0x00000000
  * @retval None
  */
void SYSCFG_MemoryRemapConfig(uint8_t SYSCFG_MemoryRemap)
{
 8011fe4:	b480      	push	{r7}
 8011fe6:	b083      	sub	sp, #12
 8011fe8:	af00      	add	r7, sp, #0
 8011fea:	4603      	mov	r3, r0
 8011fec:	71fb      	strb	r3, [r7, #7]
  /* Check the parameters */
  assert_param(IS_SYSCFG_MEMORY_REMAP_CONFING(SYSCFG_MemoryRemap));

  SYSCFG->MEMRMP = SYSCFG_MemoryRemap;
 8011fee:	4a04      	ldr	r2, [pc, #16]	; (8012000 <SYSCFG_MemoryRemapConfig+0x1c>)
 8011ff0:	79fb      	ldrb	r3, [r7, #7]
 8011ff2:	6013      	str	r3, [r2, #0]
}
 8011ff4:	bf00      	nop
 8011ff6:	370c      	adds	r7, #12
 8011ff8:	46bd      	mov	sp, r7
 8011ffa:	f85d 7b04 	ldr.w	r7, [sp], #4
 8011ffe:	4770      	bx	lr
 8012000:	40013800 	.word	0x40013800

08012004 <SYSCFG_EXTILineConfig>:
  *           This parameter can be EXTI_PinSourcex where x can be (0..15, except
  *           for EXTI_PortSourceGPIOI x can be (0..11).
  * @retval None
  */
void SYSCFG_EXTILineConfig(uint8_t EXTI_PortSourceGPIOx, uint8_t EXTI_PinSourcex)
{
 8012004:	b490      	push	{r4, r7}
 8012006:	b084      	sub	sp, #16
 8012008:	af00      	add	r7, sp, #0
 801200a:	4603      	mov	r3, r0
 801200c:	460a      	mov	r2, r1
 801200e:	71fb      	strb	r3, [r7, #7]
 8012010:	4613      	mov	r3, r2
 8012012:	71bb      	strb	r3, [r7, #6]
  uint32_t tmp = 0x00;
 8012014:	2300      	movs	r3, #0
 8012016:	60fb      	str	r3, [r7, #12]

  /* Check the parameters */
  assert_param(IS_EXTI_PORT_SOURCE(EXTI_PortSourceGPIOx));
  assert_param(IS_EXTI_PIN_SOURCE(EXTI_PinSourcex));

  tmp = ((uint32_t)0x0F) << (0x04 * (EXTI_PinSourcex & (uint8_t)0x03));
 8012018:	79bb      	ldrb	r3, [r7, #6]
 801201a:	f003 0303 	and.w	r3, r3, #3
 801201e:	009b      	lsls	r3, r3, #2
 8012020:	220f      	movs	r2, #15
 8012022:	fa02 f303 	lsl.w	r3, r2, r3
 8012026:	60fb      	str	r3, [r7, #12]
  SYSCFG->EXTICR[EXTI_PinSourcex >> 0x02] &= ~tmp;
 8012028:	4916      	ldr	r1, [pc, #88]	; (8012084 <SYSCFG_EXTILineConfig+0x80>)
 801202a:	79bb      	ldrb	r3, [r7, #6]
 801202c:	089b      	lsrs	r3, r3, #2
 801202e:	b2db      	uxtb	r3, r3
 8012030:	4618      	mov	r0, r3
 8012032:	4a14      	ldr	r2, [pc, #80]	; (8012084 <SYSCFG_EXTILineConfig+0x80>)
 8012034:	79bb      	ldrb	r3, [r7, #6]
 8012036:	089b      	lsrs	r3, r3, #2
 8012038:	b2db      	uxtb	r3, r3
 801203a:	3302      	adds	r3, #2
 801203c:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
 8012040:	68fb      	ldr	r3, [r7, #12]
 8012042:	43db      	mvns	r3, r3
 8012044:	401a      	ands	r2, r3
 8012046:	1c83      	adds	r3, r0, #2
 8012048:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
  SYSCFG->EXTICR[EXTI_PinSourcex >> 0x02] |= (((uint32_t)EXTI_PortSourceGPIOx) << (0x04 * (EXTI_PinSourcex & (uint8_t)0x03)));
 801204c:	480d      	ldr	r0, [pc, #52]	; (8012084 <SYSCFG_EXTILineConfig+0x80>)
 801204e:	79bb      	ldrb	r3, [r7, #6]
 8012050:	089b      	lsrs	r3, r3, #2
 8012052:	b2db      	uxtb	r3, r3
 8012054:	461c      	mov	r4, r3
 8012056:	4a0b      	ldr	r2, [pc, #44]	; (8012084 <SYSCFG_EXTILineConfig+0x80>)
 8012058:	79bb      	ldrb	r3, [r7, #6]
 801205a:	089b      	lsrs	r3, r3, #2
 801205c:	b2db      	uxtb	r3, r3
 801205e:	3302      	adds	r3, #2
 8012060:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
 8012064:	79f9      	ldrb	r1, [r7, #7]
 8012066:	79bb      	ldrb	r3, [r7, #6]
 8012068:	f003 0303 	and.w	r3, r3, #3
 801206c:	009b      	lsls	r3, r3, #2
 801206e:	fa01 f303 	lsl.w	r3, r1, r3
 8012072:	431a      	orrs	r2, r3
 8012074:	1ca3      	adds	r3, r4, #2
 8012076:	f840 2023 	str.w	r2, [r0, r3, lsl #2]
}
 801207a:	bf00      	nop
 801207c:	3710      	adds	r7, #16
 801207e:	46bd      	mov	sp, r7
 8012080:	bc90      	pop	{r4, r7}
 8012082:	4770      	bx	lr
 8012084:	40013800 	.word	0x40013800

08012088 <SYSCFG_ETH_MediaInterfaceConfig>:
  *            @arg SYSCFG_ETH_MediaInterface_MII: MII mode selected
  *            @arg SYSCFG_ETH_MediaInterface_RMII: RMII mode selected 
  * @retval None 
  */
void SYSCFG_ETH_MediaInterfaceConfig(uint32_t SYSCFG_ETH_MediaInterface) 
{ 
 8012088:	b480      	push	{r7}
 801208a:	b083      	sub	sp, #12
 801208c:	af00      	add	r7, sp, #0
 801208e:	6078      	str	r0, [r7, #4]
  assert_param(IS_SYSCFG_ETH_MEDIA_INTERFACE(SYSCFG_ETH_MediaInterface)); 
  /* Configure MII_RMII selection bit */ 
  *(__IO uint32_t *) PMC_MII_RMII_SEL_BB = SYSCFG_ETH_MediaInterface; 
 8012090:	4a04      	ldr	r2, [pc, #16]	; (80120a4 <SYSCFG_ETH_MediaInterfaceConfig+0x1c>)
 8012092:	687b      	ldr	r3, [r7, #4]
 8012094:	6013      	str	r3, [r2, #0]
}
 8012096:	bf00      	nop
 8012098:	370c      	adds	r7, #12
 801209a:	46bd      	mov	sp, r7
 801209c:	f85d 7b04 	ldr.w	r7, [sp], #4
 80120a0:	4770      	bx	lr
 80120a2:	bf00      	nop
 80120a4:	422700dc 	.word	0x422700dc

080120a8 <SYSCFG_CompensationCellCmd>:
  *            @arg ENABLE: I/O compensation cell enabled  
  *            @arg DISABLE: I/O compensation cell power-down mode  
  * @retval None
  */
void SYSCFG_CompensationCellCmd(FunctionalState NewState)
{
 80120a8:	b480      	push	{r7}
 80120aa:	b083      	sub	sp, #12
 80120ac:	af00      	add	r7, sp, #0
 80120ae:	4603      	mov	r3, r0
 80120b0:	71fb      	strb	r3, [r7, #7]
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  *(__IO uint32_t *) CMPCR_CMP_PD_BB = (uint32_t)NewState;
 80120b2:	4a04      	ldr	r2, [pc, #16]	; (80120c4 <SYSCFG_CompensationCellCmd+0x1c>)
 80120b4:	79fb      	ldrb	r3, [r7, #7]
 80120b6:	6013      	str	r3, [r2, #0]
}
 80120b8:	bf00      	nop
 80120ba:	370c      	adds	r7, #12
 80120bc:	46bd      	mov	sp, r7
 80120be:	f85d 7b04 	ldr.w	r7, [sp], #4
 80120c2:	4770      	bx	lr
 80120c4:	42270400 	.word	0x42270400

080120c8 <SYSCFG_GetCompensationCellStatus>:
  * @brief  Checks whether the I/O Compensation Cell ready flag is set or not.
  * @param  None
  * @retval The new state of the I/O Compensation Cell ready flag (SET or RESET)
  */
FlagStatus SYSCFG_GetCompensationCellStatus(void)
{
 80120c8:	b480      	push	{r7}
 80120ca:	b083      	sub	sp, #12
 80120cc:	af00      	add	r7, sp, #0
  FlagStatus bitstatus = RESET;
 80120ce:	2300      	movs	r3, #0
 80120d0:	71fb      	strb	r3, [r7, #7]
    
  if ((SYSCFG->CMPCR & SYSCFG_CMPCR_READY ) != (uint32_t)RESET)
 80120d2:	4b09      	ldr	r3, [pc, #36]	; (80120f8 <SYSCFG_GetCompensationCellStatus+0x30>)
 80120d4:	6a1b      	ldr	r3, [r3, #32]
 80120d6:	f403 7380 	and.w	r3, r3, #256	; 0x100
 80120da:	2b00      	cmp	r3, #0
 80120dc:	d002      	beq.n	80120e4 <SYSCFG_GetCompensationCellStatus+0x1c>
  {
    bitstatus = SET;
 80120de:	2301      	movs	r3, #1
 80120e0:	71fb      	strb	r3, [r7, #7]
 80120e2:	e001      	b.n	80120e8 <SYSCFG_GetCompensationCellStatus+0x20>
  }
  else
  {
    bitstatus = RESET;
 80120e4:	2300      	movs	r3, #0
 80120e6:	71fb      	strb	r3, [r7, #7]
  }
  return bitstatus;
 80120e8:	79fb      	ldrb	r3, [r7, #7]
}
 80120ea:	4618      	mov	r0, r3
 80120ec:	370c      	adds	r7, #12
 80120ee:	46bd      	mov	sp, r7
 80120f0:	f85d 7b04 	ldr.w	r7, [sp], #4
 80120f4:	4770      	bx	lr
 80120f6:	bf00      	nop
 80120f8:	40013800 	.word	0x40013800

080120fc <TIM_DeInit>:
  * @param  TIMx: where x can be 1 to 14 to select the TIM peripheral.
  * @retval None

  */
void TIM_DeInit(TIM_TypeDef* TIMx)
{
 80120fc:	b580      	push	{r7, lr}
 80120fe:	b082      	sub	sp, #8
 8012100:	af00      	add	r7, sp, #0
 8012102:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_TIM_ALL_PERIPH(TIMx)); 
 
  if (TIMx == TIM1)
 8012104:	687b      	ldr	r3, [r7, #4]
 8012106:	4a60      	ldr	r2, [pc, #384]	; (8012288 <TIM_DeInit+0x18c>)
 8012108:	4293      	cmp	r3, r2
 801210a:	d108      	bne.n	801211e <TIM_DeInit+0x22>
  {
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM1, ENABLE);
 801210c:	2101      	movs	r1, #1
 801210e:	2001      	movs	r0, #1
 8012110:	f7fd fc20 	bl	800f954 <RCC_APB2PeriphResetCmd>
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM1, DISABLE);  
 8012114:	2100      	movs	r1, #0
 8012116:	2001      	movs	r0, #1
 8012118:	f7fd fc1c 	bl	800f954 <RCC_APB2PeriphResetCmd>
    {     
      RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM14, ENABLE);
      RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM14, DISABLE); 
    }   
  }
}
 801211c:	e0af      	b.n	801227e <TIM_DeInit+0x182>
  else if (TIMx == TIM2) 
 801211e:	687b      	ldr	r3, [r7, #4]
 8012120:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
 8012124:	d108      	bne.n	8012138 <TIM_DeInit+0x3c>
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM2, ENABLE);
 8012126:	2101      	movs	r1, #1
 8012128:	2001      	movs	r0, #1
 801212a:	f7fd fbf3 	bl	800f914 <RCC_APB1PeriphResetCmd>
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM2, DISABLE);
 801212e:	2100      	movs	r1, #0
 8012130:	2001      	movs	r0, #1
 8012132:	f7fd fbef 	bl	800f914 <RCC_APB1PeriphResetCmd>
}
 8012136:	e0a2      	b.n	801227e <TIM_DeInit+0x182>
  else if (TIMx == TIM3)
 8012138:	687b      	ldr	r3, [r7, #4]
 801213a:	4a54      	ldr	r2, [pc, #336]	; (801228c <TIM_DeInit+0x190>)
 801213c:	4293      	cmp	r3, r2
 801213e:	d108      	bne.n	8012152 <TIM_DeInit+0x56>
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM3, ENABLE);
 8012140:	2101      	movs	r1, #1
 8012142:	2002      	movs	r0, #2
 8012144:	f7fd fbe6 	bl	800f914 <RCC_APB1PeriphResetCmd>
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM3, DISABLE);
 8012148:	2100      	movs	r1, #0
 801214a:	2002      	movs	r0, #2
 801214c:	f7fd fbe2 	bl	800f914 <RCC_APB1PeriphResetCmd>
}
 8012150:	e095      	b.n	801227e <TIM_DeInit+0x182>
  else if (TIMx == TIM4)
 8012152:	687b      	ldr	r3, [r7, #4]
 8012154:	4a4e      	ldr	r2, [pc, #312]	; (8012290 <TIM_DeInit+0x194>)
 8012156:	4293      	cmp	r3, r2
 8012158:	d108      	bne.n	801216c <TIM_DeInit+0x70>
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM4, ENABLE);
 801215a:	2101      	movs	r1, #1
 801215c:	2004      	movs	r0, #4
 801215e:	f7fd fbd9 	bl	800f914 <RCC_APB1PeriphResetCmd>
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM4, DISABLE);
 8012162:	2100      	movs	r1, #0
 8012164:	2004      	movs	r0, #4
 8012166:	f7fd fbd5 	bl	800f914 <RCC_APB1PeriphResetCmd>
}
 801216a:	e088      	b.n	801227e <TIM_DeInit+0x182>
  else if (TIMx == TIM5)
 801216c:	687b      	ldr	r3, [r7, #4]
 801216e:	4a49      	ldr	r2, [pc, #292]	; (8012294 <TIM_DeInit+0x198>)
 8012170:	4293      	cmp	r3, r2
 8012172:	d108      	bne.n	8012186 <TIM_DeInit+0x8a>
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM5, ENABLE);
 8012174:	2101      	movs	r1, #1
 8012176:	2008      	movs	r0, #8
 8012178:	f7fd fbcc 	bl	800f914 <RCC_APB1PeriphResetCmd>
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM5, DISABLE);
 801217c:	2100      	movs	r1, #0
 801217e:	2008      	movs	r0, #8
 8012180:	f7fd fbc8 	bl	800f914 <RCC_APB1PeriphResetCmd>
}
 8012184:	e07b      	b.n	801227e <TIM_DeInit+0x182>
  else if (TIMx == TIM6)  
 8012186:	687b      	ldr	r3, [r7, #4]
 8012188:	4a43      	ldr	r2, [pc, #268]	; (8012298 <TIM_DeInit+0x19c>)
 801218a:	4293      	cmp	r3, r2
 801218c:	d108      	bne.n	80121a0 <TIM_DeInit+0xa4>
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM6, ENABLE);
 801218e:	2101      	movs	r1, #1
 8012190:	2010      	movs	r0, #16
 8012192:	f7fd fbbf 	bl	800f914 <RCC_APB1PeriphResetCmd>
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM6, DISABLE);
 8012196:	2100      	movs	r1, #0
 8012198:	2010      	movs	r0, #16
 801219a:	f7fd fbbb 	bl	800f914 <RCC_APB1PeriphResetCmd>
}
 801219e:	e06e      	b.n	801227e <TIM_DeInit+0x182>
  else if (TIMx == TIM7)
 80121a0:	687b      	ldr	r3, [r7, #4]
 80121a2:	4a3e      	ldr	r2, [pc, #248]	; (801229c <TIM_DeInit+0x1a0>)
 80121a4:	4293      	cmp	r3, r2
 80121a6:	d108      	bne.n	80121ba <TIM_DeInit+0xbe>
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM7, ENABLE);
 80121a8:	2101      	movs	r1, #1
 80121aa:	2020      	movs	r0, #32
 80121ac:	f7fd fbb2 	bl	800f914 <RCC_APB1PeriphResetCmd>
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM7, DISABLE);
 80121b0:	2100      	movs	r1, #0
 80121b2:	2020      	movs	r0, #32
 80121b4:	f7fd fbae 	bl	800f914 <RCC_APB1PeriphResetCmd>
}
 80121b8:	e061      	b.n	801227e <TIM_DeInit+0x182>
  else if (TIMx == TIM8)
 80121ba:	687b      	ldr	r3, [r7, #4]
 80121bc:	4a38      	ldr	r2, [pc, #224]	; (80122a0 <TIM_DeInit+0x1a4>)
 80121be:	4293      	cmp	r3, r2
 80121c0:	d108      	bne.n	80121d4 <TIM_DeInit+0xd8>
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM8, ENABLE);
 80121c2:	2101      	movs	r1, #1
 80121c4:	2002      	movs	r0, #2
 80121c6:	f7fd fbc5 	bl	800f954 <RCC_APB2PeriphResetCmd>
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM8, DISABLE);  
 80121ca:	2100      	movs	r1, #0
 80121cc:	2002      	movs	r0, #2
 80121ce:	f7fd fbc1 	bl	800f954 <RCC_APB2PeriphResetCmd>
}
 80121d2:	e054      	b.n	801227e <TIM_DeInit+0x182>
  else if (TIMx == TIM9)
 80121d4:	687b      	ldr	r3, [r7, #4]
 80121d6:	4a33      	ldr	r2, [pc, #204]	; (80122a4 <TIM_DeInit+0x1a8>)
 80121d8:	4293      	cmp	r3, r2
 80121da:	d10a      	bne.n	80121f2 <TIM_DeInit+0xf6>
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM9, ENABLE);
 80121dc:	2101      	movs	r1, #1
 80121de:	f44f 3080 	mov.w	r0, #65536	; 0x10000
 80121e2:	f7fd fbb7 	bl	800f954 <RCC_APB2PeriphResetCmd>
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM9, DISABLE);  
 80121e6:	2100      	movs	r1, #0
 80121e8:	f44f 3080 	mov.w	r0, #65536	; 0x10000
 80121ec:	f7fd fbb2 	bl	800f954 <RCC_APB2PeriphResetCmd>
}
 80121f0:	e045      	b.n	801227e <TIM_DeInit+0x182>
  else if (TIMx == TIM10)
 80121f2:	687b      	ldr	r3, [r7, #4]
 80121f4:	4a2c      	ldr	r2, [pc, #176]	; (80122a8 <TIM_DeInit+0x1ac>)
 80121f6:	4293      	cmp	r3, r2
 80121f8:	d10a      	bne.n	8012210 <TIM_DeInit+0x114>
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM10, ENABLE);
 80121fa:	2101      	movs	r1, #1
 80121fc:	f44f 3000 	mov.w	r0, #131072	; 0x20000
 8012200:	f7fd fba8 	bl	800f954 <RCC_APB2PeriphResetCmd>
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM10, DISABLE);  
 8012204:	2100      	movs	r1, #0
 8012206:	f44f 3000 	mov.w	r0, #131072	; 0x20000
 801220a:	f7fd fba3 	bl	800f954 <RCC_APB2PeriphResetCmd>
}
 801220e:	e036      	b.n	801227e <TIM_DeInit+0x182>
  else if (TIMx == TIM11) 
 8012210:	687b      	ldr	r3, [r7, #4]
 8012212:	4a26      	ldr	r2, [pc, #152]	; (80122ac <TIM_DeInit+0x1b0>)
 8012214:	4293      	cmp	r3, r2
 8012216:	d10a      	bne.n	801222e <TIM_DeInit+0x132>
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM11, ENABLE);
 8012218:	2101      	movs	r1, #1
 801221a:	f44f 2080 	mov.w	r0, #262144	; 0x40000
 801221e:	f7fd fb99 	bl	800f954 <RCC_APB2PeriphResetCmd>
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM11, DISABLE);  
 8012222:	2100      	movs	r1, #0
 8012224:	f44f 2080 	mov.w	r0, #262144	; 0x40000
 8012228:	f7fd fb94 	bl	800f954 <RCC_APB2PeriphResetCmd>
}
 801222c:	e027      	b.n	801227e <TIM_DeInit+0x182>
  else if (TIMx == TIM12)
 801222e:	687b      	ldr	r3, [r7, #4]
 8012230:	4a1f      	ldr	r2, [pc, #124]	; (80122b0 <TIM_DeInit+0x1b4>)
 8012232:	4293      	cmp	r3, r2
 8012234:	d108      	bne.n	8012248 <TIM_DeInit+0x14c>
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM12, ENABLE);
 8012236:	2101      	movs	r1, #1
 8012238:	2040      	movs	r0, #64	; 0x40
 801223a:	f7fd fb6b 	bl	800f914 <RCC_APB1PeriphResetCmd>
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM12, DISABLE);  
 801223e:	2100      	movs	r1, #0
 8012240:	2040      	movs	r0, #64	; 0x40
 8012242:	f7fd fb67 	bl	800f914 <RCC_APB1PeriphResetCmd>
}
 8012246:	e01a      	b.n	801227e <TIM_DeInit+0x182>
  else if (TIMx == TIM13) 
 8012248:	687b      	ldr	r3, [r7, #4]
 801224a:	4a1a      	ldr	r2, [pc, #104]	; (80122b4 <TIM_DeInit+0x1b8>)
 801224c:	4293      	cmp	r3, r2
 801224e:	d108      	bne.n	8012262 <TIM_DeInit+0x166>
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM13, ENABLE);
 8012250:	2101      	movs	r1, #1
 8012252:	2080      	movs	r0, #128	; 0x80
 8012254:	f7fd fb5e 	bl	800f914 <RCC_APB1PeriphResetCmd>
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM13, DISABLE);  
 8012258:	2100      	movs	r1, #0
 801225a:	2080      	movs	r0, #128	; 0x80
 801225c:	f7fd fb5a 	bl	800f914 <RCC_APB1PeriphResetCmd>
}
 8012260:	e00d      	b.n	801227e <TIM_DeInit+0x182>
    if (TIMx == TIM14) 
 8012262:	687b      	ldr	r3, [r7, #4]
 8012264:	4a14      	ldr	r2, [pc, #80]	; (80122b8 <TIM_DeInit+0x1bc>)
 8012266:	4293      	cmp	r3, r2
 8012268:	d109      	bne.n	801227e <TIM_DeInit+0x182>
      RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM14, ENABLE);
 801226a:	2101      	movs	r1, #1
 801226c:	f44f 7080 	mov.w	r0, #256	; 0x100
 8012270:	f7fd fb50 	bl	800f914 <RCC_APB1PeriphResetCmd>
      RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM14, DISABLE); 
 8012274:	2100      	movs	r1, #0
 8012276:	f44f 7080 	mov.w	r0, #256	; 0x100
 801227a:	f7fd fb4b 	bl	800f914 <RCC_APB1PeriphResetCmd>
}
 801227e:	bf00      	nop
 8012280:	3708      	adds	r7, #8
 8012282:	46bd      	mov	sp, r7
 8012284:	bd80      	pop	{r7, pc}
 8012286:	bf00      	nop
 8012288:	40010000 	.word	0x40010000
 801228c:	40000400 	.word	0x40000400
 8012290:	40000800 	.word	0x40000800
 8012294:	40000c00 	.word	0x40000c00
 8012298:	40001000 	.word	0x40001000
 801229c:	40001400 	.word	0x40001400
 80122a0:	40010400 	.word	0x40010400
 80122a4:	40014000 	.word	0x40014000
 80122a8:	40014400 	.word	0x40014400
 80122ac:	40014800 	.word	0x40014800
 80122b0:	40001800 	.word	0x40001800
 80122b4:	40001c00 	.word	0x40001c00
 80122b8:	40002000 	.word	0x40002000

080122bc <TIM_TimeBaseInit>:
  * @param  TIM_TimeBaseInitStruct: pointer to a TIM_TimeBaseInitTypeDef structure
  *         that contains the configuration information for the specified TIM peripheral.
  * @retval None
  */
void TIM_TimeBaseInit(TIM_TypeDef* TIMx, TIM_TimeBaseInitTypeDef* TIM_TimeBaseInitStruct)
{
 80122bc:	b480      	push	{r7}
 80122be:	b085      	sub	sp, #20
 80122c0:	af00      	add	r7, sp, #0
 80122c2:	6078      	str	r0, [r7, #4]
 80122c4:	6039      	str	r1, [r7, #0]
  uint16_t tmpcr1 = 0;
 80122c6:	2300      	movs	r3, #0
 80122c8:	81fb      	strh	r3, [r7, #14]
  /* Check the parameters */
  assert_param(IS_TIM_ALL_PERIPH(TIMx)); 
  assert_param(IS_TIM_COUNTER_MODE(TIM_TimeBaseInitStruct->TIM_CounterMode));
  assert_param(IS_TIM_CKD_DIV(TIM_TimeBaseInitStruct->TIM_ClockDivision));

  tmpcr1 = TIMx->CR1;  
 80122ca:	687b      	ldr	r3, [r7, #4]
 80122cc:	881b      	ldrh	r3, [r3, #0]
 80122ce:	81fb      	strh	r3, [r7, #14]

  if((TIMx == TIM1) || (TIMx == TIM8)||
 80122d0:	687b      	ldr	r3, [r7, #4]
 80122d2:	4a29      	ldr	r2, [pc, #164]	; (8012378 <TIM_TimeBaseInit+0xbc>)
 80122d4:	4293      	cmp	r3, r2
 80122d6:	d013      	beq.n	8012300 <TIM_TimeBaseInit+0x44>
 80122d8:	687b      	ldr	r3, [r7, #4]
 80122da:	4a28      	ldr	r2, [pc, #160]	; (801237c <TIM_TimeBaseInit+0xc0>)
 80122dc:	4293      	cmp	r3, r2
 80122de:	d00f      	beq.n	8012300 <TIM_TimeBaseInit+0x44>
 80122e0:	687b      	ldr	r3, [r7, #4]
 80122e2:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
 80122e6:	d00b      	beq.n	8012300 <TIM_TimeBaseInit+0x44>
     (TIMx == TIM2) || (TIMx == TIM3)||
 80122e8:	687b      	ldr	r3, [r7, #4]
 80122ea:	4a25      	ldr	r2, [pc, #148]	; (8012380 <TIM_TimeBaseInit+0xc4>)
 80122ec:	4293      	cmp	r3, r2
 80122ee:	d007      	beq.n	8012300 <TIM_TimeBaseInit+0x44>
 80122f0:	687b      	ldr	r3, [r7, #4]
 80122f2:	4a24      	ldr	r2, [pc, #144]	; (8012384 <TIM_TimeBaseInit+0xc8>)
 80122f4:	4293      	cmp	r3, r2
 80122f6:	d003      	beq.n	8012300 <TIM_TimeBaseInit+0x44>
     (TIMx == TIM4) || (TIMx == TIM5)) 
 80122f8:	687b      	ldr	r3, [r7, #4]
 80122fa:	4a23      	ldr	r2, [pc, #140]	; (8012388 <TIM_TimeBaseInit+0xcc>)
 80122fc:	4293      	cmp	r3, r2
 80122fe:	d108      	bne.n	8012312 <TIM_TimeBaseInit+0x56>
  {
    /* Select the Counter Mode */
    tmpcr1 &= (uint16_t)(~(TIM_CR1_DIR | TIM_CR1_CMS));
 8012300:	89fb      	ldrh	r3, [r7, #14]
 8012302:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 8012306:	81fb      	strh	r3, [r7, #14]
    tmpcr1 |= (uint32_t)TIM_TimeBaseInitStruct->TIM_CounterMode;
 8012308:	683b      	ldr	r3, [r7, #0]
 801230a:	885a      	ldrh	r2, [r3, #2]
 801230c:	89fb      	ldrh	r3, [r7, #14]
 801230e:	4313      	orrs	r3, r2
 8012310:	81fb      	strh	r3, [r7, #14]
  }
 
  if((TIMx != TIM6) && (TIMx != TIM7))
 8012312:	687b      	ldr	r3, [r7, #4]
 8012314:	4a1d      	ldr	r2, [pc, #116]	; (801238c <TIM_TimeBaseInit+0xd0>)
 8012316:	4293      	cmp	r3, r2
 8012318:	d00c      	beq.n	8012334 <TIM_TimeBaseInit+0x78>
 801231a:	687b      	ldr	r3, [r7, #4]
 801231c:	4a1c      	ldr	r2, [pc, #112]	; (8012390 <TIM_TimeBaseInit+0xd4>)
 801231e:	4293      	cmp	r3, r2
 8012320:	d008      	beq.n	8012334 <TIM_TimeBaseInit+0x78>
  {
    /* Set the clock division */
    tmpcr1 &=  (uint16_t)(~TIM_CR1_CKD);
 8012322:	89fb      	ldrh	r3, [r7, #14]
 8012324:	f423 7340 	bic.w	r3, r3, #768	; 0x300
 8012328:	81fb      	strh	r3, [r7, #14]
    tmpcr1 |= (uint32_t)TIM_TimeBaseInitStruct->TIM_ClockDivision;
 801232a:	683b      	ldr	r3, [r7, #0]
 801232c:	891a      	ldrh	r2, [r3, #8]
 801232e:	89fb      	ldrh	r3, [r7, #14]
 8012330:	4313      	orrs	r3, r2
 8012332:	81fb      	strh	r3, [r7, #14]
  }

  TIMx->CR1 = tmpcr1;
 8012334:	687b      	ldr	r3, [r7, #4]
 8012336:	89fa      	ldrh	r2, [r7, #14]
 8012338:	801a      	strh	r2, [r3, #0]

  /* Set the Autoreload value */
  TIMx->ARR = TIM_TimeBaseInitStruct->TIM_Period ;
 801233a:	683b      	ldr	r3, [r7, #0]
 801233c:	685a      	ldr	r2, [r3, #4]
 801233e:	687b      	ldr	r3, [r7, #4]
 8012340:	62da      	str	r2, [r3, #44]	; 0x2c
 
  /* Set the Prescaler value */
  TIMx->PSC = TIM_TimeBaseInitStruct->TIM_Prescaler;
 8012342:	683b      	ldr	r3, [r7, #0]
 8012344:	881a      	ldrh	r2, [r3, #0]
 8012346:	687b      	ldr	r3, [r7, #4]
 8012348:	851a      	strh	r2, [r3, #40]	; 0x28
    
  if ((TIMx == TIM1) || (TIMx == TIM8))  
 801234a:	687b      	ldr	r3, [r7, #4]
 801234c:	4a0a      	ldr	r2, [pc, #40]	; (8012378 <TIM_TimeBaseInit+0xbc>)
 801234e:	4293      	cmp	r3, r2
 8012350:	d003      	beq.n	801235a <TIM_TimeBaseInit+0x9e>
 8012352:	687b      	ldr	r3, [r7, #4]
 8012354:	4a09      	ldr	r2, [pc, #36]	; (801237c <TIM_TimeBaseInit+0xc0>)
 8012356:	4293      	cmp	r3, r2
 8012358:	d104      	bne.n	8012364 <TIM_TimeBaseInit+0xa8>
  {
    /* Set the Repetition Counter value */
    TIMx->RCR = TIM_TimeBaseInitStruct->TIM_RepetitionCounter;
 801235a:	683b      	ldr	r3, [r7, #0]
 801235c:	7a9b      	ldrb	r3, [r3, #10]
 801235e:	b29a      	uxth	r2, r3
 8012360:	687b      	ldr	r3, [r7, #4]
 8012362:	861a      	strh	r2, [r3, #48]	; 0x30
  }

  /* Generate an update event to reload the Prescaler 
     and the repetition counter(only for TIM1 and TIM8) value immediatly */
  TIMx->EGR = TIM_PSCReloadMode_Immediate;          
 8012364:	687b      	ldr	r3, [r7, #4]
 8012366:	2201      	movs	r2, #1
 8012368:	829a      	strh	r2, [r3, #20]
}
 801236a:	bf00      	nop
 801236c:	3714      	adds	r7, #20
 801236e:	46bd      	mov	sp, r7
 8012370:	f85d 7b04 	ldr.w	r7, [sp], #4
 8012374:	4770      	bx	lr
 8012376:	bf00      	nop
 8012378:	40010000 	.word	0x40010000
 801237c:	40010400 	.word	0x40010400
 8012380:	40000400 	.word	0x40000400
 8012384:	40000800 	.word	0x40000800
 8012388:	40000c00 	.word	0x40000c00
 801238c:	40001000 	.word	0x40001000
 8012390:	40001400 	.word	0x40001400

08012394 <TIM_TimeBaseStructInit>:
  * @param  TIM_TimeBaseInitStruct : pointer to a TIM_TimeBaseInitTypeDef
  *         structure which will be initialized.
  * @retval None
  */
void TIM_TimeBaseStructInit(TIM_TimeBaseInitTypeDef* TIM_TimeBaseInitStruct)
{
 8012394:	b480      	push	{r7}
 8012396:	b083      	sub	sp, #12
 8012398:	af00      	add	r7, sp, #0
 801239a:	6078      	str	r0, [r7, #4]
  /* Set the default configuration */
  TIM_TimeBaseInitStruct->TIM_Period = 0xFFFFFFFF;
 801239c:	687b      	ldr	r3, [r7, #4]
 801239e:	f04f 32ff 	mov.w	r2, #4294967295
 80123a2:	605a      	str	r2, [r3, #4]
  TIM_TimeBaseInitStruct->TIM_Prescaler = 0x0000;
 80123a4:	687b      	ldr	r3, [r7, #4]
 80123a6:	2200      	movs	r2, #0
 80123a8:	801a      	strh	r2, [r3, #0]
  TIM_TimeBaseInitStruct->TIM_ClockDivision = TIM_CKD_DIV1;
 80123aa:	687b      	ldr	r3, [r7, #4]
 80123ac:	2200      	movs	r2, #0
 80123ae:	811a      	strh	r2, [r3, #8]
  TIM_TimeBaseInitStruct->TIM_CounterMode = TIM_CounterMode_Up;
 80123b0:	687b      	ldr	r3, [r7, #4]
 80123b2:	2200      	movs	r2, #0
 80123b4:	805a      	strh	r2, [r3, #2]
  TIM_TimeBaseInitStruct->TIM_RepetitionCounter = 0x0000;
 80123b6:	687b      	ldr	r3, [r7, #4]
 80123b8:	2200      	movs	r2, #0
 80123ba:	729a      	strb	r2, [r3, #10]
}
 80123bc:	bf00      	nop
 80123be:	370c      	adds	r7, #12
 80123c0:	46bd      	mov	sp, r7
 80123c2:	f85d 7b04 	ldr.w	r7, [sp], #4
 80123c6:	4770      	bx	lr

080123c8 <TIM_PrescalerConfig>:
  *            @arg TIM_PSCReloadMode_Update: The Prescaler is loaded at the update event.
  *            @arg TIM_PSCReloadMode_Immediate: The Prescaler is loaded immediatly.
  * @retval None
  */
void TIM_PrescalerConfig(TIM_TypeDef* TIMx, uint16_t Prescaler, uint16_t TIM_PSCReloadMode)
{
 80123c8:	b480      	push	{r7}
 80123ca:	b083      	sub	sp, #12
 80123cc:	af00      	add	r7, sp, #0
 80123ce:	6078      	str	r0, [r7, #4]
 80123d0:	460b      	mov	r3, r1
 80123d2:	807b      	strh	r3, [r7, #2]
 80123d4:	4613      	mov	r3, r2
 80123d6:	803b      	strh	r3, [r7, #0]
  /* Check the parameters */
  assert_param(IS_TIM_ALL_PERIPH(TIMx));
  assert_param(IS_TIM_PRESCALER_RELOAD(TIM_PSCReloadMode));
  /* Set the Prescaler value */
  TIMx->PSC = Prescaler;
 80123d8:	687b      	ldr	r3, [r7, #4]
 80123da:	887a      	ldrh	r2, [r7, #2]
 80123dc:	851a      	strh	r2, [r3, #40]	; 0x28
  /* Set or reset the UG Bit */
  TIMx->EGR = TIM_PSCReloadMode;
 80123de:	687b      	ldr	r3, [r7, #4]
 80123e0:	883a      	ldrh	r2, [r7, #0]
 80123e2:	829a      	strh	r2, [r3, #20]
}
 80123e4:	bf00      	nop
 80123e6:	370c      	adds	r7, #12
 80123e8:	46bd      	mov	sp, r7
 80123ea:	f85d 7b04 	ldr.w	r7, [sp], #4
 80123ee:	4770      	bx	lr

080123f0 <TIM_CounterModeConfig>:
  *            @arg TIM_CounterMode_CenterAligned2: TIM Center Aligned Mode2
  *            @arg TIM_CounterMode_CenterAligned3: TIM Center Aligned Mode3
  * @retval None
  */
void TIM_CounterModeConfig(TIM_TypeDef* TIMx, uint16_t TIM_CounterMode)
{
 80123f0:	b480      	push	{r7}
 80123f2:	b085      	sub	sp, #20
 80123f4:	af00      	add	r7, sp, #0
 80123f6:	6078      	str	r0, [r7, #4]
 80123f8:	460b      	mov	r3, r1
 80123fa:	807b      	strh	r3, [r7, #2]
  uint16_t tmpcr1 = 0;
 80123fc:	2300      	movs	r3, #0
 80123fe:	81fb      	strh	r3, [r7, #14]

  /* Check the parameters */
  assert_param(IS_TIM_LIST3_PERIPH(TIMx));
  assert_param(IS_TIM_COUNTER_MODE(TIM_CounterMode));

  tmpcr1 = TIMx->CR1;
 8012400:	687b      	ldr	r3, [r7, #4]
 8012402:	881b      	ldrh	r3, [r3, #0]
 8012404:	81fb      	strh	r3, [r7, #14]

  /* Reset the CMS and DIR Bits */
  tmpcr1 &= (uint16_t)~(TIM_CR1_DIR | TIM_CR1_CMS);
 8012406:	89fb      	ldrh	r3, [r7, #14]
 8012408:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 801240c:	81fb      	strh	r3, [r7, #14]

  /* Set the Counter Mode */
  tmpcr1 |= TIM_CounterMode;
 801240e:	89fa      	ldrh	r2, [r7, #14]
 8012410:	887b      	ldrh	r3, [r7, #2]
 8012412:	4313      	orrs	r3, r2
 8012414:	81fb      	strh	r3, [r7, #14]

  /* Write to TIMx CR1 register */
  TIMx->CR1 = tmpcr1;
 8012416:	687b      	ldr	r3, [r7, #4]
 8012418:	89fa      	ldrh	r2, [r7, #14]
 801241a:	801a      	strh	r2, [r3, #0]
}
 801241c:	bf00      	nop
 801241e:	3714      	adds	r7, #20
 8012420:	46bd      	mov	sp, r7
 8012422:	f85d 7b04 	ldr.w	r7, [sp], #4
 8012426:	4770      	bx	lr

08012428 <TIM_SetCounter>:
  * @param  TIMx: where x can be 1 to 14 to select the TIM peripheral.
  * @param  Counter: specifies the Counter register new value.
  * @retval None
  */
void TIM_SetCounter(TIM_TypeDef* TIMx, uint32_t Counter)
{
 8012428:	b480      	push	{r7}
 801242a:	b083      	sub	sp, #12
 801242c:	af00      	add	r7, sp, #0
 801242e:	6078      	str	r0, [r7, #4]
 8012430:	6039      	str	r1, [r7, #0]
  /* Check the parameters */
   assert_param(IS_TIM_ALL_PERIPH(TIMx));

  /* Set the Counter Register value */
  TIMx->CNT = Counter;
 8012432:	687b      	ldr	r3, [r7, #4]
 8012434:	683a      	ldr	r2, [r7, #0]
 8012436:	625a      	str	r2, [r3, #36]	; 0x24
}
 8012438:	bf00      	nop
 801243a:	370c      	adds	r7, #12
 801243c:	46bd      	mov	sp, r7
 801243e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8012442:	4770      	bx	lr

08012444 <TIM_SetAutoreload>:
  * @param  TIMx: where x can be 1 to 14 to select the TIM peripheral.
  * @param  Autoreload: specifies the Autoreload register new value.
  * @retval None
  */
void TIM_SetAutoreload(TIM_TypeDef* TIMx, uint32_t Autoreload)
{
 8012444:	b480      	push	{r7}
 8012446:	b083      	sub	sp, #12
 8012448:	af00      	add	r7, sp, #0
 801244a:	6078      	str	r0, [r7, #4]
 801244c:	6039      	str	r1, [r7, #0]
  /* Check the parameters */
  assert_param(IS_TIM_ALL_PERIPH(TIMx));
  
  /* Set the Autoreload Register value */
  TIMx->ARR = Autoreload;
 801244e:	687b      	ldr	r3, [r7, #4]
 8012450:	683a      	ldr	r2, [r7, #0]
 8012452:	62da      	str	r2, [r3, #44]	; 0x2c
}
 8012454:	bf00      	nop
 8012456:	370c      	adds	r7, #12
 8012458:	46bd      	mov	sp, r7
 801245a:	f85d 7b04 	ldr.w	r7, [sp], #4
 801245e:	4770      	bx	lr

08012460 <TIM_GetCounter>:
  * @brief  Gets the TIMx Counter value.
  * @param  TIMx: where x can be 1 to 14 to select the TIM peripheral.
  * @retval Counter Register value
  */
uint32_t TIM_GetCounter(TIM_TypeDef* TIMx)
{
 8012460:	b480      	push	{r7}
 8012462:	b083      	sub	sp, #12
 8012464:	af00      	add	r7, sp, #0
 8012466:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_TIM_ALL_PERIPH(TIMx));

  /* Get the Counter Register value */
  return TIMx->CNT;
 8012468:	687b      	ldr	r3, [r7, #4]
 801246a:	6a5b      	ldr	r3, [r3, #36]	; 0x24
}
 801246c:	4618      	mov	r0, r3
 801246e:	370c      	adds	r7, #12
 8012470:	46bd      	mov	sp, r7
 8012472:	f85d 7b04 	ldr.w	r7, [sp], #4
 8012476:	4770      	bx	lr

08012478 <TIM_GetPrescaler>:
  * @brief  Gets the TIMx Prescaler value.
  * @param  TIMx: where x can be 1 to 14 to select the TIM peripheral.
  * @retval Prescaler Register value.
  */
uint16_t TIM_GetPrescaler(TIM_TypeDef* TIMx)
{
 8012478:	b480      	push	{r7}
 801247a:	b083      	sub	sp, #12
 801247c:	af00      	add	r7, sp, #0
 801247e:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_TIM_ALL_PERIPH(TIMx));

  /* Get the Prescaler Register value */
  return TIMx->PSC;
 8012480:	687b      	ldr	r3, [r7, #4]
 8012482:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
 8012484:	b29b      	uxth	r3, r3
}
 8012486:	4618      	mov	r0, r3
 8012488:	370c      	adds	r7, #12
 801248a:	46bd      	mov	sp, r7
 801248c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8012490:	4770      	bx	lr

08012492 <TIM_UpdateDisableConfig>:
  * @param  NewState: new state of the TIMx UDIS bit
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void TIM_UpdateDisableConfig(TIM_TypeDef* TIMx, FunctionalState NewState)
{
 8012492:	b480      	push	{r7}
 8012494:	b083      	sub	sp, #12
 8012496:	af00      	add	r7, sp, #0
 8012498:	6078      	str	r0, [r7, #4]
 801249a:	460b      	mov	r3, r1
 801249c:	70fb      	strb	r3, [r7, #3]
  /* Check the parameters */
  assert_param(IS_TIM_ALL_PERIPH(TIMx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 801249e:	78fb      	ldrb	r3, [r7, #3]
 80124a0:	2b00      	cmp	r3, #0
 80124a2:	d008      	beq.n	80124b6 <TIM_UpdateDisableConfig+0x24>
  {
    /* Set the Update Disable Bit */
    TIMx->CR1 |= TIM_CR1_UDIS;
 80124a4:	687b      	ldr	r3, [r7, #4]
 80124a6:	881b      	ldrh	r3, [r3, #0]
 80124a8:	b29b      	uxth	r3, r3
 80124aa:	f043 0302 	orr.w	r3, r3, #2
 80124ae:	b29a      	uxth	r2, r3
 80124b0:	687b      	ldr	r3, [r7, #4]
 80124b2:	801a      	strh	r2, [r3, #0]
  else
  {
    /* Reset the Update Disable Bit */
    TIMx->CR1 &= (uint16_t)~TIM_CR1_UDIS;
  }
}
 80124b4:	e007      	b.n	80124c6 <TIM_UpdateDisableConfig+0x34>
    TIMx->CR1 &= (uint16_t)~TIM_CR1_UDIS;
 80124b6:	687b      	ldr	r3, [r7, #4]
 80124b8:	881b      	ldrh	r3, [r3, #0]
 80124ba:	b29b      	uxth	r3, r3
 80124bc:	f023 0302 	bic.w	r3, r3, #2
 80124c0:	b29a      	uxth	r2, r3
 80124c2:	687b      	ldr	r3, [r7, #4]
 80124c4:	801a      	strh	r2, [r3, #0]
}
 80124c6:	bf00      	nop
 80124c8:	370c      	adds	r7, #12
 80124ca:	46bd      	mov	sp, r7
 80124cc:	f85d 7b04 	ldr.w	r7, [sp], #4
 80124d0:	4770      	bx	lr

080124d2 <TIM_UpdateRequestConfig>:
  *                 generation through the slave mode controller.
  *            @arg TIM_UpdateSource_Regular: Source of update is counter overflow/underflow.
  * @retval None
  */
void TIM_UpdateRequestConfig(TIM_TypeDef* TIMx, uint16_t TIM_UpdateSource)
{
 80124d2:	b480      	push	{r7}
 80124d4:	b083      	sub	sp, #12
 80124d6:	af00      	add	r7, sp, #0
 80124d8:	6078      	str	r0, [r7, #4]
 80124da:	460b      	mov	r3, r1
 80124dc:	807b      	strh	r3, [r7, #2]
  /* Check the parameters */
  assert_param(IS_TIM_ALL_PERIPH(TIMx));
  assert_param(IS_TIM_UPDATE_SOURCE(TIM_UpdateSource));

  if (TIM_UpdateSource != TIM_UpdateSource_Global)
 80124de:	887b      	ldrh	r3, [r7, #2]
 80124e0:	2b00      	cmp	r3, #0
 80124e2:	d008      	beq.n	80124f6 <TIM_UpdateRequestConfig+0x24>
  {
    /* Set the URS Bit */
    TIMx->CR1 |= TIM_CR1_URS;
 80124e4:	687b      	ldr	r3, [r7, #4]
 80124e6:	881b      	ldrh	r3, [r3, #0]
 80124e8:	b29b      	uxth	r3, r3
 80124ea:	f043 0304 	orr.w	r3, r3, #4
 80124ee:	b29a      	uxth	r2, r3
 80124f0:	687b      	ldr	r3, [r7, #4]
 80124f2:	801a      	strh	r2, [r3, #0]
  else
  {
    /* Reset the URS Bit */
    TIMx->CR1 &= (uint16_t)~TIM_CR1_URS;
  }
}
 80124f4:	e007      	b.n	8012506 <TIM_UpdateRequestConfig+0x34>
    TIMx->CR1 &= (uint16_t)~TIM_CR1_URS;
 80124f6:	687b      	ldr	r3, [r7, #4]
 80124f8:	881b      	ldrh	r3, [r3, #0]
 80124fa:	b29b      	uxth	r3, r3
 80124fc:	f023 0304 	bic.w	r3, r3, #4
 8012500:	b29a      	uxth	r2, r3
 8012502:	687b      	ldr	r3, [r7, #4]
 8012504:	801a      	strh	r2, [r3, #0]
}
 8012506:	bf00      	nop
 8012508:	370c      	adds	r7, #12
 801250a:	46bd      	mov	sp, r7
 801250c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8012510:	4770      	bx	lr

08012512 <TIM_ARRPreloadConfig>:
  * @param  NewState: new state of the TIMx peripheral Preload register
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void TIM_ARRPreloadConfig(TIM_TypeDef* TIMx, FunctionalState NewState)
{
 8012512:	b480      	push	{r7}
 8012514:	b083      	sub	sp, #12
 8012516:	af00      	add	r7, sp, #0
 8012518:	6078      	str	r0, [r7, #4]
 801251a:	460b      	mov	r3, r1
 801251c:	70fb      	strb	r3, [r7, #3]
  /* Check the parameters */
  assert_param(IS_TIM_ALL_PERIPH(TIMx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 801251e:	78fb      	ldrb	r3, [r7, #3]
 8012520:	2b00      	cmp	r3, #0
 8012522:	d008      	beq.n	8012536 <TIM_ARRPreloadConfig+0x24>
  {
    /* Set the ARR Preload Bit */
    TIMx->CR1 |= TIM_CR1_ARPE;
 8012524:	687b      	ldr	r3, [r7, #4]
 8012526:	881b      	ldrh	r3, [r3, #0]
 8012528:	b29b      	uxth	r3, r3
 801252a:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 801252e:	b29a      	uxth	r2, r3
 8012530:	687b      	ldr	r3, [r7, #4]
 8012532:	801a      	strh	r2, [r3, #0]
  else
  {
    /* Reset the ARR Preload Bit */
    TIMx->CR1 &= (uint16_t)~TIM_CR1_ARPE;
  }
}
 8012534:	e007      	b.n	8012546 <TIM_ARRPreloadConfig+0x34>
    TIMx->CR1 &= (uint16_t)~TIM_CR1_ARPE;
 8012536:	687b      	ldr	r3, [r7, #4]
 8012538:	881b      	ldrh	r3, [r3, #0]
 801253a:	b29b      	uxth	r3, r3
 801253c:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 8012540:	b29a      	uxth	r2, r3
 8012542:	687b      	ldr	r3, [r7, #4]
 8012544:	801a      	strh	r2, [r3, #0]
}
 8012546:	bf00      	nop
 8012548:	370c      	adds	r7, #12
 801254a:	46bd      	mov	sp, r7
 801254c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8012550:	4770      	bx	lr

08012552 <TIM_SelectOnePulseMode>:
  *            @arg TIM_OPMode_Single
  *            @arg TIM_OPMode_Repetitive
  * @retval None
  */
void TIM_SelectOnePulseMode(TIM_TypeDef* TIMx, uint16_t TIM_OPMode)
{
 8012552:	b480      	push	{r7}
 8012554:	b083      	sub	sp, #12
 8012556:	af00      	add	r7, sp, #0
 8012558:	6078      	str	r0, [r7, #4]
 801255a:	460b      	mov	r3, r1
 801255c:	807b      	strh	r3, [r7, #2]
  /* Check the parameters */
  assert_param(IS_TIM_ALL_PERIPH(TIMx));
  assert_param(IS_TIM_OPM_MODE(TIM_OPMode));

  /* Reset the OPM Bit */
  TIMx->CR1 &= (uint16_t)~TIM_CR1_OPM;
 801255e:	687b      	ldr	r3, [r7, #4]
 8012560:	881b      	ldrh	r3, [r3, #0]
 8012562:	b29b      	uxth	r3, r3
 8012564:	f023 0308 	bic.w	r3, r3, #8
 8012568:	b29a      	uxth	r2, r3
 801256a:	687b      	ldr	r3, [r7, #4]
 801256c:	801a      	strh	r2, [r3, #0]

  /* Configure the OPM Mode */
  TIMx->CR1 |= TIM_OPMode;
 801256e:	687b      	ldr	r3, [r7, #4]
 8012570:	881b      	ldrh	r3, [r3, #0]
 8012572:	b29a      	uxth	r2, r3
 8012574:	887b      	ldrh	r3, [r7, #2]
 8012576:	4313      	orrs	r3, r2
 8012578:	b29a      	uxth	r2, r3
 801257a:	687b      	ldr	r3, [r7, #4]
 801257c:	801a      	strh	r2, [r3, #0]
}
 801257e:	bf00      	nop
 8012580:	370c      	adds	r7, #12
 8012582:	46bd      	mov	sp, r7
 8012584:	f85d 7b04 	ldr.w	r7, [sp], #4
 8012588:	4770      	bx	lr

0801258a <TIM_SetClockDivision>:
  *            @arg TIM_CKD_DIV2: TDTS = 2*Tck_tim
  *            @arg TIM_CKD_DIV4: TDTS = 4*Tck_tim
  * @retval None
  */
void TIM_SetClockDivision(TIM_TypeDef* TIMx, uint16_t TIM_CKD)
{
 801258a:	b480      	push	{r7}
 801258c:	b083      	sub	sp, #12
 801258e:	af00      	add	r7, sp, #0
 8012590:	6078      	str	r0, [r7, #4]
 8012592:	460b      	mov	r3, r1
 8012594:	807b      	strh	r3, [r7, #2]
  /* Check the parameters */
  assert_param(IS_TIM_LIST1_PERIPH(TIMx));
  assert_param(IS_TIM_CKD_DIV(TIM_CKD));

  /* Reset the CKD Bits */
  TIMx->CR1 &= (uint16_t)(~TIM_CR1_CKD);
 8012596:	687b      	ldr	r3, [r7, #4]
 8012598:	881b      	ldrh	r3, [r3, #0]
 801259a:	b29b      	uxth	r3, r3
 801259c:	f423 7340 	bic.w	r3, r3, #768	; 0x300
 80125a0:	b29a      	uxth	r2, r3
 80125a2:	687b      	ldr	r3, [r7, #4]
 80125a4:	801a      	strh	r2, [r3, #0]

  /* Set the CKD value */
  TIMx->CR1 |= TIM_CKD;
 80125a6:	687b      	ldr	r3, [r7, #4]
 80125a8:	881b      	ldrh	r3, [r3, #0]
 80125aa:	b29a      	uxth	r2, r3
 80125ac:	887b      	ldrh	r3, [r7, #2]
 80125ae:	4313      	orrs	r3, r2
 80125b0:	b29a      	uxth	r2, r3
 80125b2:	687b      	ldr	r3, [r7, #4]
 80125b4:	801a      	strh	r2, [r3, #0]
}
 80125b6:	bf00      	nop
 80125b8:	370c      	adds	r7, #12
 80125ba:	46bd      	mov	sp, r7
 80125bc:	f85d 7b04 	ldr.w	r7, [sp], #4
 80125c0:	4770      	bx	lr

080125c2 <TIM_Cmd>:
  * @param  NewState: new state of the TIMx peripheral.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void TIM_Cmd(TIM_TypeDef* TIMx, FunctionalState NewState)
{
 80125c2:	b480      	push	{r7}
 80125c4:	b083      	sub	sp, #12
 80125c6:	af00      	add	r7, sp, #0
 80125c8:	6078      	str	r0, [r7, #4]
 80125ca:	460b      	mov	r3, r1
 80125cc:	70fb      	strb	r3, [r7, #3]
  /* Check the parameters */
  assert_param(IS_TIM_ALL_PERIPH(TIMx)); 
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
 80125ce:	78fb      	ldrb	r3, [r7, #3]
 80125d0:	2b00      	cmp	r3, #0
 80125d2:	d008      	beq.n	80125e6 <TIM_Cmd+0x24>
  {
    /* Enable the TIM Counter */
    TIMx->CR1 |= TIM_CR1_CEN;
 80125d4:	687b      	ldr	r3, [r7, #4]
 80125d6:	881b      	ldrh	r3, [r3, #0]
 80125d8:	b29b      	uxth	r3, r3
 80125da:	f043 0301 	orr.w	r3, r3, #1
 80125de:	b29a      	uxth	r2, r3
 80125e0:	687b      	ldr	r3, [r7, #4]
 80125e2:	801a      	strh	r2, [r3, #0]
  else
  {
    /* Disable the TIM Counter */
    TIMx->CR1 &= (uint16_t)~TIM_CR1_CEN;
  }
}
 80125e4:	e007      	b.n	80125f6 <TIM_Cmd+0x34>
    TIMx->CR1 &= (uint16_t)~TIM_CR1_CEN;
 80125e6:	687b      	ldr	r3, [r7, #4]
 80125e8:	881b      	ldrh	r3, [r3, #0]
 80125ea:	b29b      	uxth	r3, r3
 80125ec:	f023 0301 	bic.w	r3, r3, #1
 80125f0:	b29a      	uxth	r2, r3
 80125f2:	687b      	ldr	r3, [r7, #4]
 80125f4:	801a      	strh	r2, [r3, #0]
}
 80125f6:	bf00      	nop
 80125f8:	370c      	adds	r7, #12
 80125fa:	46bd      	mov	sp, r7
 80125fc:	f85d 7b04 	ldr.w	r7, [sp], #4
 8012600:	4770      	bx	lr

08012602 <TIM_OC1Init>:
  * @param  TIM_OCInitStruct: pointer to a TIM_OCInitTypeDef structure that contains
  *         the configuration information for the specified TIM peripheral.
  * @retval None
  */
void TIM_OC1Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)
{
 8012602:	b480      	push	{r7}
 8012604:	b085      	sub	sp, #20
 8012606:	af00      	add	r7, sp, #0
 8012608:	6078      	str	r0, [r7, #4]
 801260a:	6039      	str	r1, [r7, #0]
  uint16_t tmpccmrx = 0, tmpccer = 0, tmpcr2 = 0;
 801260c:	2300      	movs	r3, #0
 801260e:	817b      	strh	r3, [r7, #10]
 8012610:	2300      	movs	r3, #0
 8012612:	81fb      	strh	r3, [r7, #14]
 8012614:	2300      	movs	r3, #0
 8012616:	81bb      	strh	r3, [r7, #12]
  assert_param(IS_TIM_OC_MODE(TIM_OCInitStruct->TIM_OCMode));
  assert_param(IS_TIM_OUTPUT_STATE(TIM_OCInitStruct->TIM_OutputState));
  assert_param(IS_TIM_OC_POLARITY(TIM_OCInitStruct->TIM_OCPolarity));   

  /* Disable the Channel 1: Reset the CC1E Bit */
  TIMx->CCER &= (uint16_t)~TIM_CCER_CC1E;
 8012618:	687b      	ldr	r3, [r7, #4]
 801261a:	8c1b      	ldrh	r3, [r3, #32]
 801261c:	b29b      	uxth	r3, r3
 801261e:	f023 0301 	bic.w	r3, r3, #1
 8012622:	b29a      	uxth	r2, r3
 8012624:	687b      	ldr	r3, [r7, #4]
 8012626:	841a      	strh	r2, [r3, #32]
  
  /* Get the TIMx CCER register value */
  tmpccer = TIMx->CCER;
 8012628:	687b      	ldr	r3, [r7, #4]
 801262a:	8c1b      	ldrh	r3, [r3, #32]
 801262c:	81fb      	strh	r3, [r7, #14]
  /* Get the TIMx CR2 register value */
  tmpcr2 =  TIMx->CR2;
 801262e:	687b      	ldr	r3, [r7, #4]
 8012630:	889b      	ldrh	r3, [r3, #4]
 8012632:	81bb      	strh	r3, [r7, #12]
  
  /* Get the TIMx CCMR1 register value */
  tmpccmrx = TIMx->CCMR1;
 8012634:	687b      	ldr	r3, [r7, #4]
 8012636:	8b1b      	ldrh	r3, [r3, #24]
 8012638:	817b      	strh	r3, [r7, #10]
    
  /* Reset the Output Compare Mode Bits */
  tmpccmrx &= (uint16_t)~TIM_CCMR1_OC1M;
 801263a:	897b      	ldrh	r3, [r7, #10]
 801263c:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 8012640:	817b      	strh	r3, [r7, #10]
  tmpccmrx &= (uint16_t)~TIM_CCMR1_CC1S;
 8012642:	897b      	ldrh	r3, [r7, #10]
 8012644:	f023 0303 	bic.w	r3, r3, #3
 8012648:	817b      	strh	r3, [r7, #10]
  /* Select the Output Compare Mode */
  tmpccmrx |= TIM_OCInitStruct->TIM_OCMode;
 801264a:	683b      	ldr	r3, [r7, #0]
 801264c:	881a      	ldrh	r2, [r3, #0]
 801264e:	897b      	ldrh	r3, [r7, #10]
 8012650:	4313      	orrs	r3, r2
 8012652:	817b      	strh	r3, [r7, #10]
  
  /* Reset the Output Polarity level */
  tmpccer &= (uint16_t)~TIM_CCER_CC1P;
 8012654:	89fb      	ldrh	r3, [r7, #14]
 8012656:	f023 0302 	bic.w	r3, r3, #2
 801265a:	81fb      	strh	r3, [r7, #14]
  /* Set the Output Compare Polarity */
  tmpccer |= TIM_OCInitStruct->TIM_OCPolarity;
 801265c:	683b      	ldr	r3, [r7, #0]
 801265e:	899a      	ldrh	r2, [r3, #12]
 8012660:	89fb      	ldrh	r3, [r7, #14]
 8012662:	4313      	orrs	r3, r2
 8012664:	81fb      	strh	r3, [r7, #14]
  
  /* Set the Output State */
  tmpccer |= TIM_OCInitStruct->TIM_OutputState;
 8012666:	683b      	ldr	r3, [r7, #0]
 8012668:	885a      	ldrh	r2, [r3, #2]
 801266a:	89fb      	ldrh	r3, [r7, #14]
 801266c:	4313      	orrs	r3, r2
 801266e:	81fb      	strh	r3, [r7, #14]
    
  if((TIMx == TIM1) || (TIMx == TIM8))
 8012670:	687b      	ldr	r3, [r7, #4]
 8012672:	4a1f      	ldr	r2, [pc, #124]	; (80126f0 <TIM_OC1Init+0xee>)
 8012674:	4293      	cmp	r3, r2
 8012676:	d003      	beq.n	8012680 <TIM_OC1Init+0x7e>
 8012678:	687b      	ldr	r3, [r7, #4]
 801267a:	4a1e      	ldr	r2, [pc, #120]	; (80126f4 <TIM_OC1Init+0xf2>)
 801267c:	4293      	cmp	r3, r2
 801267e:	d123      	bne.n	80126c8 <TIM_OC1Init+0xc6>
    assert_param(IS_TIM_OCN_POLARITY(TIM_OCInitStruct->TIM_OCNPolarity));
    assert_param(IS_TIM_OCNIDLE_STATE(TIM_OCInitStruct->TIM_OCNIdleState));
    assert_param(IS_TIM_OCIDLE_STATE(TIM_OCInitStruct->TIM_OCIdleState));
    
    /* Reset the Output N Polarity level */
    tmpccer &= (uint16_t)~TIM_CCER_CC1NP;
 8012680:	89fb      	ldrh	r3, [r7, #14]
 8012682:	f023 0308 	bic.w	r3, r3, #8
 8012686:	81fb      	strh	r3, [r7, #14]
    /* Set the Output N Polarity */
    tmpccer |= TIM_OCInitStruct->TIM_OCNPolarity;
 8012688:	683b      	ldr	r3, [r7, #0]
 801268a:	89da      	ldrh	r2, [r3, #14]
 801268c:	89fb      	ldrh	r3, [r7, #14]
 801268e:	4313      	orrs	r3, r2
 8012690:	81fb      	strh	r3, [r7, #14]
    /* Reset the Output N State */
    tmpccer &= (uint16_t)~TIM_CCER_CC1NE;
 8012692:	89fb      	ldrh	r3, [r7, #14]
 8012694:	f023 0304 	bic.w	r3, r3, #4
 8012698:	81fb      	strh	r3, [r7, #14]
    
    /* Set the Output N State */
    tmpccer |= TIM_OCInitStruct->TIM_OutputNState;
 801269a:	683b      	ldr	r3, [r7, #0]
 801269c:	889a      	ldrh	r2, [r3, #4]
 801269e:	89fb      	ldrh	r3, [r7, #14]
 80126a0:	4313      	orrs	r3, r2
 80126a2:	81fb      	strh	r3, [r7, #14]
    /* Reset the Output Compare and Output Compare N IDLE State */
    tmpcr2 &= (uint16_t)~TIM_CR2_OIS1;
 80126a4:	89bb      	ldrh	r3, [r7, #12]
 80126a6:	f423 7380 	bic.w	r3, r3, #256	; 0x100
 80126aa:	81bb      	strh	r3, [r7, #12]
    tmpcr2 &= (uint16_t)~TIM_CR2_OIS1N;
 80126ac:	89bb      	ldrh	r3, [r7, #12]
 80126ae:	f423 7300 	bic.w	r3, r3, #512	; 0x200
 80126b2:	81bb      	strh	r3, [r7, #12]
    /* Set the Output Idle state */
    tmpcr2 |= TIM_OCInitStruct->TIM_OCIdleState;
 80126b4:	683b      	ldr	r3, [r7, #0]
 80126b6:	8a1a      	ldrh	r2, [r3, #16]
 80126b8:	89bb      	ldrh	r3, [r7, #12]
 80126ba:	4313      	orrs	r3, r2
 80126bc:	81bb      	strh	r3, [r7, #12]
    /* Set the Output N Idle state */
    tmpcr2 |= TIM_OCInitStruct->TIM_OCNIdleState;
 80126be:	683b      	ldr	r3, [r7, #0]
 80126c0:	8a5a      	ldrh	r2, [r3, #18]
 80126c2:	89bb      	ldrh	r3, [r7, #12]
 80126c4:	4313      	orrs	r3, r2
 80126c6:	81bb      	strh	r3, [r7, #12]
  }
  /* Write to TIMx CR2 */
  TIMx->CR2 = tmpcr2;
 80126c8:	687b      	ldr	r3, [r7, #4]
 80126ca:	89ba      	ldrh	r2, [r7, #12]
 80126cc:	809a      	strh	r2, [r3, #4]
  
  /* Write to TIMx CCMR1 */
  TIMx->CCMR1 = tmpccmrx;
 80126ce:	687b      	ldr	r3, [r7, #4]
 80126d0:	897a      	ldrh	r2, [r7, #10]
 80126d2:	831a      	strh	r2, [r3, #24]
  
  /* Set the Capture Compare Register value */
  TIMx->CCR1 = TIM_OCInitStruct->TIM_Pulse;
 80126d4:	683b      	ldr	r3, [r7, #0]
 80126d6:	689a      	ldr	r2, [r3, #8]
 80126d8:	687b      	ldr	r3, [r7, #4]
 80126da:	635a      	str	r2, [r3, #52]	; 0x34
  
  /* Write to TIMx CCER */
  TIMx->CCER = tmpccer;
 80126dc:	687b      	ldr	r3, [r7, #4]
 80126de:	89fa      	ldrh	r2, [r7, #14]
 80126e0:	841a      	strh	r2, [r3, #32]
}
 80126e2:	bf00      	nop
 80126e4:	3714      	adds	r7, #20
 80126e6:	46bd      	mov	sp, r7
 80126e8:	f85d 7b04 	ldr.w	r7, [sp], #4
 80126ec:	4770      	bx	lr
 80126ee:	bf00      	nop
 80126f0:	40010000 	.word	0x40010000
 80126f4:	40010400 	.word	0x40010400

080126f8 <TIM_OC2Init>:
  * @param  TIM_OCInitStruct: pointer to a TIM_OCInitTypeDef structure that contains
  *         the configuration information for the specified TIM peripheral.
  * @retval None
  */
void TIM_OC2Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)
{
 80126f8:	b480      	push	{r7}
 80126fa:	b085      	sub	sp, #20
 80126fc:	af00      	add	r7, sp, #0
 80126fe:	6078      	str	r0, [r7, #4]
 8012700:	6039      	str	r1, [r7, #0]
  uint16_t tmpccmrx = 0, tmpccer = 0, tmpcr2 = 0;
 8012702:	2300      	movs	r3, #0
 8012704:	817b      	strh	r3, [r7, #10]
 8012706:	2300      	movs	r3, #0
 8012708:	81fb      	strh	r3, [r7, #14]
 801270a:	2300      	movs	r3, #0
 801270c:	81bb      	strh	r3, [r7, #12]
  assert_param(IS_TIM_OC_MODE(TIM_OCInitStruct->TIM_OCMode));
  assert_param(IS_TIM_OUTPUT_STATE(TIM_OCInitStruct->TIM_OutputState));
  assert_param(IS_TIM_OC_POLARITY(TIM_OCInitStruct->TIM_OCPolarity));   

  /* Disable the Channel 2: Reset the CC2E Bit */
  TIMx->CCER &= (uint16_t)~TIM_CCER_CC2E;
 801270e:	687b      	ldr	r3, [r7, #4]
 8012710:	8c1b      	ldrh	r3, [r3, #32]
 8012712:	b29b      	uxth	r3, r3
 8012714:	f023 0310 	bic.w	r3, r3, #16
 8012718:	b29a      	uxth	r2, r3
 801271a:	687b      	ldr	r3, [r7, #4]
 801271c:	841a      	strh	r2, [r3, #32]
  
  /* Get the TIMx CCER register value */  
  tmpccer = TIMx->CCER;
 801271e:	687b      	ldr	r3, [r7, #4]
 8012720:	8c1b      	ldrh	r3, [r3, #32]
 8012722:	81fb      	strh	r3, [r7, #14]
  /* Get the TIMx CR2 register value */
  tmpcr2 =  TIMx->CR2;
 8012724:	687b      	ldr	r3, [r7, #4]
 8012726:	889b      	ldrh	r3, [r3, #4]
 8012728:	81bb      	strh	r3, [r7, #12]
  
  /* Get the TIMx CCMR1 register value */
  tmpccmrx = TIMx->CCMR1;
 801272a:	687b      	ldr	r3, [r7, #4]
 801272c:	8b1b      	ldrh	r3, [r3, #24]
 801272e:	817b      	strh	r3, [r7, #10]
    
  /* Reset the Output Compare mode and Capture/Compare selection Bits */
  tmpccmrx &= (uint16_t)~TIM_CCMR1_OC2M;
 8012730:	897b      	ldrh	r3, [r7, #10]
 8012732:	f423 43e0 	bic.w	r3, r3, #28672	; 0x7000
 8012736:	817b      	strh	r3, [r7, #10]
  tmpccmrx &= (uint16_t)~TIM_CCMR1_CC2S;
 8012738:	897b      	ldrh	r3, [r7, #10]
 801273a:	f423 7340 	bic.w	r3, r3, #768	; 0x300
 801273e:	817b      	strh	r3, [r7, #10]
  
  /* Select the Output Compare Mode */
  tmpccmrx |= (uint16_t)(TIM_OCInitStruct->TIM_OCMode << 8);
 8012740:	683b      	ldr	r3, [r7, #0]
 8012742:	881b      	ldrh	r3, [r3, #0]
 8012744:	021b      	lsls	r3, r3, #8
 8012746:	b29a      	uxth	r2, r3
 8012748:	897b      	ldrh	r3, [r7, #10]
 801274a:	4313      	orrs	r3, r2
 801274c:	817b      	strh	r3, [r7, #10]
  
  /* Reset the Output Polarity level */
  tmpccer &= (uint16_t)~TIM_CCER_CC2P;
 801274e:	89fb      	ldrh	r3, [r7, #14]
 8012750:	f023 0320 	bic.w	r3, r3, #32
 8012754:	81fb      	strh	r3, [r7, #14]
  /* Set the Output Compare Polarity */
  tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCPolarity << 4);
 8012756:	683b      	ldr	r3, [r7, #0]
 8012758:	899b      	ldrh	r3, [r3, #12]
 801275a:	011b      	lsls	r3, r3, #4
 801275c:	b29a      	uxth	r2, r3
 801275e:	89fb      	ldrh	r3, [r7, #14]
 8012760:	4313      	orrs	r3, r2
 8012762:	81fb      	strh	r3, [r7, #14]
  
  /* Set the Output State */
  tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OutputState << 4);
 8012764:	683b      	ldr	r3, [r7, #0]
 8012766:	885b      	ldrh	r3, [r3, #2]
 8012768:	011b      	lsls	r3, r3, #4
 801276a:	b29a      	uxth	r2, r3
 801276c:	89fb      	ldrh	r3, [r7, #14]
 801276e:	4313      	orrs	r3, r2
 8012770:	81fb      	strh	r3, [r7, #14]
    
  if((TIMx == TIM1) || (TIMx == TIM8))
 8012772:	687b      	ldr	r3, [r7, #4]
 8012774:	4a22      	ldr	r2, [pc, #136]	; (8012800 <TIM_OC2Init+0x108>)
 8012776:	4293      	cmp	r3, r2
 8012778:	d003      	beq.n	8012782 <TIM_OC2Init+0x8a>
 801277a:	687b      	ldr	r3, [r7, #4]
 801277c:	4a21      	ldr	r2, [pc, #132]	; (8012804 <TIM_OC2Init+0x10c>)
 801277e:	4293      	cmp	r3, r2
 8012780:	d12b      	bne.n	80127da <TIM_OC2Init+0xe2>
    assert_param(IS_TIM_OCN_POLARITY(TIM_OCInitStruct->TIM_OCNPolarity));
    assert_param(IS_TIM_OCNIDLE_STATE(TIM_OCInitStruct->TIM_OCNIdleState));
    assert_param(IS_TIM_OCIDLE_STATE(TIM_OCInitStruct->TIM_OCIdleState));
    
    /* Reset the Output N Polarity level */
    tmpccer &= (uint16_t)~TIM_CCER_CC2NP;
 8012782:	89fb      	ldrh	r3, [r7, #14]
 8012784:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 8012788:	81fb      	strh	r3, [r7, #14]
    /* Set the Output N Polarity */
    tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCNPolarity << 4);
 801278a:	683b      	ldr	r3, [r7, #0]
 801278c:	89db      	ldrh	r3, [r3, #14]
 801278e:	011b      	lsls	r3, r3, #4
 8012790:	b29a      	uxth	r2, r3
 8012792:	89fb      	ldrh	r3, [r7, #14]
 8012794:	4313      	orrs	r3, r2
 8012796:	81fb      	strh	r3, [r7, #14]
    /* Reset the Output N State */
    tmpccer &= (uint16_t)~TIM_CCER_CC2NE;
 8012798:	89fb      	ldrh	r3, [r7, #14]
 801279a:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 801279e:	81fb      	strh	r3, [r7, #14]
    
    /* Set the Output N State */
    tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OutputNState << 4);
 80127a0:	683b      	ldr	r3, [r7, #0]
 80127a2:	889b      	ldrh	r3, [r3, #4]
 80127a4:	011b      	lsls	r3, r3, #4
 80127a6:	b29a      	uxth	r2, r3
 80127a8:	89fb      	ldrh	r3, [r7, #14]
 80127aa:	4313      	orrs	r3, r2
 80127ac:	81fb      	strh	r3, [r7, #14]
    /* Reset the Output Compare and Output Compare N IDLE State */
    tmpcr2 &= (uint16_t)~TIM_CR2_OIS2;
 80127ae:	89bb      	ldrh	r3, [r7, #12]
 80127b0:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 80127b4:	81bb      	strh	r3, [r7, #12]
    tmpcr2 &= (uint16_t)~TIM_CR2_OIS2N;
 80127b6:	89bb      	ldrh	r3, [r7, #12]
 80127b8:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
 80127bc:	81bb      	strh	r3, [r7, #12]
    /* Set the Output Idle state */
    tmpcr2 |= (uint16_t)(TIM_OCInitStruct->TIM_OCIdleState << 2);
 80127be:	683b      	ldr	r3, [r7, #0]
 80127c0:	8a1b      	ldrh	r3, [r3, #16]
 80127c2:	009b      	lsls	r3, r3, #2
 80127c4:	b29a      	uxth	r2, r3
 80127c6:	89bb      	ldrh	r3, [r7, #12]
 80127c8:	4313      	orrs	r3, r2
 80127ca:	81bb      	strh	r3, [r7, #12]
    /* Set the Output N Idle state */
    tmpcr2 |= (uint16_t)(TIM_OCInitStruct->TIM_OCNIdleState << 2);
 80127cc:	683b      	ldr	r3, [r7, #0]
 80127ce:	8a5b      	ldrh	r3, [r3, #18]
 80127d0:	009b      	lsls	r3, r3, #2
 80127d2:	b29a      	uxth	r2, r3
 80127d4:	89bb      	ldrh	r3, [r7, #12]
 80127d6:	4313      	orrs	r3, r2
 80127d8:	81bb      	strh	r3, [r7, #12]
  }
  /* Write to TIMx CR2 */
  TIMx->CR2 = tmpcr2;
 80127da:	687b      	ldr	r3, [r7, #4]
 80127dc:	89ba      	ldrh	r2, [r7, #12]
 80127de:	809a      	strh	r2, [r3, #4]
  
  /* Write to TIMx CCMR1 */
  TIMx->CCMR1 = tmpccmrx;
 80127e0:	687b      	ldr	r3, [r7, #4]
 80127e2:	897a      	ldrh	r2, [r7, #10]
 80127e4:	831a      	strh	r2, [r3, #24]
  
  /* Set the Capture Compare Register value */
  TIMx->CCR2 = TIM_OCInitStruct->TIM_Pulse;
 80127e6:	683b      	ldr	r3, [r7, #0]
 80127e8:	689a      	ldr	r2, [r3, #8]
 80127ea:	687b      	ldr	r3, [r7, #4]
 80127ec:	639a      	str	r2, [r3, #56]	; 0x38
  
  /* Write to TIMx CCER */
  TIMx->CCER = tmpccer;
 80127ee:	687b      	ldr	r3, [r7, #4]
 80127f0:	89fa      	ldrh	r2, [r7, #14]
 80127f2:	841a      	strh	r2, [r3, #32]
}
 80127f4:	bf00      	nop
 80127f6:	3714      	adds	r7, #20
 80127f8:	46bd      	mov	sp, r7
 80127fa:	f85d 7b04 	ldr.w	r7, [sp], #4
 80127fe:	4770      	bx	lr
 8012800:	40010000 	.word	0x40010000
 8012804:	40010400 	.word	0x40010400

08012808 <TIM_OC3Init>:
  * @param  TIM_OCInitStruct: pointer to a TIM_OCInitTypeDef structure that contains
  *         the configuration information for the specified TIM peripheral.
  * @retval None
  */
void TIM_OC3Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)
{
 8012808:	b480      	push	{r7}
 801280a:	b085      	sub	sp, #20
 801280c:	af00      	add	r7, sp, #0
 801280e:	6078      	str	r0, [r7, #4]
 8012810:	6039      	str	r1, [r7, #0]
  uint16_t tmpccmrx = 0, tmpccer = 0, tmpcr2 = 0;
 8012812:	2300      	movs	r3, #0
 8012814:	817b      	strh	r3, [r7, #10]
 8012816:	2300      	movs	r3, #0
 8012818:	81fb      	strh	r3, [r7, #14]
 801281a:	2300      	movs	r3, #0
 801281c:	81bb      	strh	r3, [r7, #12]
  assert_param(IS_TIM_OC_MODE(TIM_OCInitStruct->TIM_OCMode));
  assert_param(IS_TIM_OUTPUT_STATE(TIM_OCInitStruct->TIM_OutputState));
  assert_param(IS_TIM_OC_POLARITY(TIM_OCInitStruct->TIM_OCPolarity));   

  /* Disable the Channel 3: Reset the CC2E Bit */
  TIMx->CCER &= (uint16_t)~TIM_CCER_CC3E;
 801281e:	687b      	ldr	r3, [r7, #4]
 8012820:	8c1b      	ldrh	r3, [r3, #32]
 8012822:	b29b      	uxth	r3, r3
 8012824:	f423 7380 	bic.w	r3, r3, #256	; 0x100
 8012828:	b29a      	uxth	r2, r3
 801282a:	687b      	ldr	r3, [r7, #4]
 801282c:	841a      	strh	r2, [r3, #32]
  
  /* Get the TIMx CCER register value */
  tmpccer = TIMx->CCER;
 801282e:	687b      	ldr	r3, [r7, #4]
 8012830:	8c1b      	ldrh	r3, [r3, #32]
 8012832:	81fb      	strh	r3, [r7, #14]
  /* Get the TIMx CR2 register value */
  tmpcr2 =  TIMx->CR2;
 8012834:	687b      	ldr	r3, [r7, #4]
 8012836:	889b      	ldrh	r3, [r3, #4]
 8012838:	81bb      	strh	r3, [r7, #12]
  
  /* Get the TIMx CCMR2 register value */
  tmpccmrx = TIMx->CCMR2;
 801283a:	687b      	ldr	r3, [r7, #4]
 801283c:	8b9b      	ldrh	r3, [r3, #28]
 801283e:	817b      	strh	r3, [r7, #10]
    
  /* Reset the Output Compare mode and Capture/Compare selection Bits */
  tmpccmrx &= (uint16_t)~TIM_CCMR2_OC3M;
 8012840:	897b      	ldrh	r3, [r7, #10]
 8012842:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 8012846:	817b      	strh	r3, [r7, #10]
  tmpccmrx &= (uint16_t)~TIM_CCMR2_CC3S;  
 8012848:	897b      	ldrh	r3, [r7, #10]
 801284a:	f023 0303 	bic.w	r3, r3, #3
 801284e:	817b      	strh	r3, [r7, #10]
  /* Select the Output Compare Mode */
  tmpccmrx |= TIM_OCInitStruct->TIM_OCMode;
 8012850:	683b      	ldr	r3, [r7, #0]
 8012852:	881a      	ldrh	r2, [r3, #0]
 8012854:	897b      	ldrh	r3, [r7, #10]
 8012856:	4313      	orrs	r3, r2
 8012858:	817b      	strh	r3, [r7, #10]
  
  /* Reset the Output Polarity level */
  tmpccer &= (uint16_t)~TIM_CCER_CC3P;
 801285a:	89fb      	ldrh	r3, [r7, #14]
 801285c:	f423 7300 	bic.w	r3, r3, #512	; 0x200
 8012860:	81fb      	strh	r3, [r7, #14]
  /* Set the Output Compare Polarity */
  tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCPolarity << 8);
 8012862:	683b      	ldr	r3, [r7, #0]
 8012864:	899b      	ldrh	r3, [r3, #12]
 8012866:	021b      	lsls	r3, r3, #8
 8012868:	b29a      	uxth	r2, r3
 801286a:	89fb      	ldrh	r3, [r7, #14]
 801286c:	4313      	orrs	r3, r2
 801286e:	81fb      	strh	r3, [r7, #14]
  
  /* Set the Output State */
  tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OutputState << 8);
 8012870:	683b      	ldr	r3, [r7, #0]
 8012872:	885b      	ldrh	r3, [r3, #2]
 8012874:	021b      	lsls	r3, r3, #8
 8012876:	b29a      	uxth	r2, r3
 8012878:	89fb      	ldrh	r3, [r7, #14]
 801287a:	4313      	orrs	r3, r2
 801287c:	81fb      	strh	r3, [r7, #14]
    
  if((TIMx == TIM1) || (TIMx == TIM8))
 801287e:	687b      	ldr	r3, [r7, #4]
 8012880:	4a22      	ldr	r2, [pc, #136]	; (801290c <TIM_OC3Init+0x104>)
 8012882:	4293      	cmp	r3, r2
 8012884:	d003      	beq.n	801288e <TIM_OC3Init+0x86>
 8012886:	687b      	ldr	r3, [r7, #4]
 8012888:	4a21      	ldr	r2, [pc, #132]	; (8012910 <TIM_OC3Init+0x108>)
 801288a:	4293      	cmp	r3, r2
 801288c:	d12b      	bne.n	80128e6 <TIM_OC3Init+0xde>
    assert_param(IS_TIM_OCN_POLARITY(TIM_OCInitStruct->TIM_OCNPolarity));
    assert_param(IS_TIM_OCNIDLE_STATE(TIM_OCInitStruct->TIM_OCNIdleState));
    assert_param(IS_TIM_OCIDLE_STATE(TIM_OCInitStruct->TIM_OCIdleState));
    
    /* Reset the Output N Polarity level */
    tmpccer &= (uint16_t)~TIM_CCER_CC3NP;
 801288e:	89fb      	ldrh	r3, [r7, #14]
 8012890:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
 8012894:	81fb      	strh	r3, [r7, #14]
    /* Set the Output N Polarity */
    tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCNPolarity << 8);
 8012896:	683b      	ldr	r3, [r7, #0]
 8012898:	89db      	ldrh	r3, [r3, #14]
 801289a:	021b      	lsls	r3, r3, #8
 801289c:	b29a      	uxth	r2, r3
 801289e:	89fb      	ldrh	r3, [r7, #14]
 80128a0:	4313      	orrs	r3, r2
 80128a2:	81fb      	strh	r3, [r7, #14]
    /* Reset the Output N State */
    tmpccer &= (uint16_t)~TIM_CCER_CC3NE;
 80128a4:	89fb      	ldrh	r3, [r7, #14]
 80128a6:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 80128aa:	81fb      	strh	r3, [r7, #14]
    
    /* Set the Output N State */
    tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OutputNState << 8);
 80128ac:	683b      	ldr	r3, [r7, #0]
 80128ae:	889b      	ldrh	r3, [r3, #4]
 80128b0:	021b      	lsls	r3, r3, #8
 80128b2:	b29a      	uxth	r2, r3
 80128b4:	89fb      	ldrh	r3, [r7, #14]
 80128b6:	4313      	orrs	r3, r2
 80128b8:	81fb      	strh	r3, [r7, #14]
    /* Reset the Output Compare and Output Compare N IDLE State */
    tmpcr2 &= (uint16_t)~TIM_CR2_OIS3;
 80128ba:	89bb      	ldrh	r3, [r7, #12]
 80128bc:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
 80128c0:	81bb      	strh	r3, [r7, #12]
    tmpcr2 &= (uint16_t)~TIM_CR2_OIS3N;
 80128c2:	89bb      	ldrh	r3, [r7, #12]
 80128c4:	f423 5300 	bic.w	r3, r3, #8192	; 0x2000
 80128c8:	81bb      	strh	r3, [r7, #12]
    /* Set the Output Idle state */
    tmpcr2 |= (uint16_t)(TIM_OCInitStruct->TIM_OCIdleState << 4);
 80128ca:	683b      	ldr	r3, [r7, #0]
 80128cc:	8a1b      	ldrh	r3, [r3, #16]
 80128ce:	011b      	lsls	r3, r3, #4
 80128d0:	b29a      	uxth	r2, r3
 80128d2:	89bb      	ldrh	r3, [r7, #12]
 80128d4:	4313      	orrs	r3, r2
 80128d6:	81bb      	strh	r3, [r7, #12]
    /* Set the Output N Idle state */
    tmpcr2 |= (uint16_t)(TIM_OCInitStruct->TIM_OCNIdleState << 4);
 80128d8:	683b      	ldr	r3, [r7, #0]
 80128da:	8a5b      	ldrh	r3, [r3, #18]
 80128dc:	011b      	lsls	r3, r3, #4
 80128de:	b29a      	uxth	r2, r3
 80128e0:	89bb      	ldrh	r3, [r7, #12]
 80128e2:	4313      	orrs	r3, r2
 80128e4:	81bb      	strh	r3, [r7, #12]
  }
  /* Write to TIMx CR2 */
  TIMx->CR2 = tmpcr2;
 80128e6:	687b      	ldr	r3, [r7, #4]
 80128e8:	89ba      	ldrh	r2, [r7, #12]
 80128ea:	809a      	strh	r2, [r3, #4]
  
  /* Write to TIMx CCMR2 */
  TIMx->CCMR2 = tmpccmrx;
 80128ec:	687b      	ldr	r3, [r7, #4]
 80128ee:	897a      	ldrh	r2, [r7, #10]
 80128f0:	839a      	strh	r2, [r3, #28]
  
  /* Set the Capture Compare Register value */
  TIMx->CCR3 = TIM_OCInitStruct->TIM_Pulse;
 80128f2:	683b      	ldr	r3, [r7, #0]
 80128f4:	689a      	ldr	r2, [r3, #8]
 80128f6:	687b      	ldr	r3, [r7, #4]
 80128f8:	63da      	str	r2, [r3, #60]	; 0x3c
  
  /* Write to TIMx CCER */
  TIMx->CCER = tmpccer;
 80128fa:	687b      	ldr	r3, [r7, #4]
 80128fc:	89fa      	ldrh	r2, [r7, #14]
 80128fe:	841a      	strh	r2, [r3, #32]
}
 8012900:	bf00      	nop
 8012902:	3714      	adds	r7, #20
 8012904:	46bd      	mov	sp, r7
 8012906:	f85d 7b04 	ldr.w	r7, [sp], #4
 801290a:	4770      	bx	lr
 801290c:	40010000 	.word	0x40010000
 8012910:	40010400 	.word	0x40010400

08012914 <TIM_OC4Init>:
  * @param  TIM_OCInitStruct: pointer to a TIM_OCInitTypeDef structure that contains
  *         the configuration information for the specified TIM peripheral.
  * @retval None
  */
void TIM_OC4Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)
{
 8012914:	b480      	push	{r7}
 8012916:	b085      	sub	sp, #20
 8012918:	af00      	add	r7, sp, #0
 801291a:	6078      	str	r0, [r7, #4]
 801291c:	6039      	str	r1, [r7, #0]
  uint16_t tmpccmrx = 0, tmpccer = 0, tmpcr2 = 0;
 801291e:	2300      	movs	r3, #0
 8012920:	81bb      	strh	r3, [r7, #12]
 8012922:	2300      	movs	r3, #0
 8012924:	817b      	strh	r3, [r7, #10]
 8012926:	2300      	movs	r3, #0
 8012928:	81fb      	strh	r3, [r7, #14]
  assert_param(IS_TIM_OC_MODE(TIM_OCInitStruct->TIM_OCMode));
  assert_param(IS_TIM_OUTPUT_STATE(TIM_OCInitStruct->TIM_OutputState));
  assert_param(IS_TIM_OC_POLARITY(TIM_OCInitStruct->TIM_OCPolarity));   

  /* Disable the Channel 4: Reset the CC4E Bit */
  TIMx->CCER &= (uint16_t)~TIM_CCER_CC4E;
 801292a:	687b      	ldr	r3, [r7, #4]
 801292c:	8c1b      	ldrh	r3, [r3, #32]
 801292e:	b29b      	uxth	r3, r3
 8012930:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
 8012934:	b29a      	uxth	r2, r3
 8012936:	687b      	ldr	r3, [r7, #4]
 8012938:	841a      	strh	r2, [r3, #32]
  
  /* Get the TIMx CCER register value */
  tmpccer = TIMx->CCER;
 801293a:	687b      	ldr	r3, [r7, #4]
 801293c:	8c1b      	ldrh	r3, [r3, #32]
 801293e:	817b      	strh	r3, [r7, #10]
  /* Get the TIMx CR2 register value */
  tmpcr2 =  TIMx->CR2;
 8012940:	687b      	ldr	r3, [r7, #4]
 8012942:	889b      	ldrh	r3, [r3, #4]
 8012944:	81fb      	strh	r3, [r7, #14]
  
  /* Get the TIMx CCMR2 register value */
  tmpccmrx = TIMx->CCMR2;
 8012946:	687b      	ldr	r3, [r7, #4]
 8012948:	8b9b      	ldrh	r3, [r3, #28]
 801294a:	81bb      	strh	r3, [r7, #12]
    
  /* Reset the Output Compare mode and Capture/Compare selection Bits */
  tmpccmrx &= (uint16_t)~TIM_CCMR2_OC4M;
 801294c:	89bb      	ldrh	r3, [r7, #12]
 801294e:	f423 43e0 	bic.w	r3, r3, #28672	; 0x7000
 8012952:	81bb      	strh	r3, [r7, #12]
  tmpccmrx &= (uint16_t)~TIM_CCMR2_CC4S;
 8012954:	89bb      	ldrh	r3, [r7, #12]
 8012956:	f423 7340 	bic.w	r3, r3, #768	; 0x300
 801295a:	81bb      	strh	r3, [r7, #12]
  
  /* Select the Output Compare Mode */
  tmpccmrx |= (uint16_t)(TIM_OCInitStruct->TIM_OCMode << 8);
 801295c:	683b      	ldr	r3, [r7, #0]
 801295e:	881b      	ldrh	r3, [r3, #0]
 8012960:	021b      	lsls	r3, r3, #8
 8012962:	b29a      	uxth	r2, r3
 8012964:	89bb      	ldrh	r3, [r7, #12]
 8012966:	4313      	orrs	r3, r2
 8012968:	81bb      	strh	r3, [r7, #12]
  
  /* Reset the Output Polarity level */
  tmpccer &= (uint16_t)~TIM_CCER_CC4P;
 801296a:	897b      	ldrh	r3, [r7, #10]
 801296c:	f423 5300 	bic.w	r3, r3, #8192	; 0x2000
 8012970:	817b      	strh	r3, [r7, #10]
  /* Set the Output Compare Polarity */
  tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCPolarity << 12);
 8012972:	683b      	ldr	r3, [r7, #0]
 8012974:	899b      	ldrh	r3, [r3, #12]
 8012976:	031b      	lsls	r3, r3, #12
 8012978:	b29a      	uxth	r2, r3
 801297a:	897b      	ldrh	r3, [r7, #10]
 801297c:	4313      	orrs	r3, r2
 801297e:	817b      	strh	r3, [r7, #10]
  
  /* Set the Output State */
  tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OutputState << 12);
 8012980:	683b      	ldr	r3, [r7, #0]
 8012982:	885b      	ldrh	r3, [r3, #2]
 8012984:	031b      	lsls	r3, r3, #12
 8012986:	b29a      	uxth	r2, r3
 8012988:	897b      	ldrh	r3, [r7, #10]
 801298a:	4313      	orrs	r3, r2
 801298c:	817b      	strh	r3, [r7, #10]
  
  if((TIMx == TIM1) || (TIMx == TIM8))
 801298e:	687b      	ldr	r3, [r7, #4]
 8012990:	4a12      	ldr	r2, [pc, #72]	; (80129dc <TIM_OC4Init+0xc8>)
 8012992:	4293      	cmp	r3, r2
 8012994:	d003      	beq.n	801299e <TIM_OC4Init+0x8a>
 8012996:	687b      	ldr	r3, [r7, #4]
 8012998:	4a11      	ldr	r2, [pc, #68]	; (80129e0 <TIM_OC4Init+0xcc>)
 801299a:	4293      	cmp	r3, r2
 801299c:	d10a      	bne.n	80129b4 <TIM_OC4Init+0xa0>
  {
    assert_param(IS_TIM_OCIDLE_STATE(TIM_OCInitStruct->TIM_OCIdleState));
    /* Reset the Output Compare IDLE State */
    tmpcr2 &=(uint16_t) ~TIM_CR2_OIS4;
 801299e:	89fb      	ldrh	r3, [r7, #14]
 80129a0:	f423 4380 	bic.w	r3, r3, #16384	; 0x4000
 80129a4:	81fb      	strh	r3, [r7, #14]
    /* Set the Output Idle state */
    tmpcr2 |= (uint16_t)(TIM_OCInitStruct->TIM_OCIdleState << 6);
 80129a6:	683b      	ldr	r3, [r7, #0]
 80129a8:	8a1b      	ldrh	r3, [r3, #16]
 80129aa:	019b      	lsls	r3, r3, #6
 80129ac:	b29a      	uxth	r2, r3
 80129ae:	89fb      	ldrh	r3, [r7, #14]
 80129b0:	4313      	orrs	r3, r2
 80129b2:	81fb      	strh	r3, [r7, #14]
  }
  /* Write to TIMx CR2 */
  TIMx->CR2 = tmpcr2;
 80129b4:	687b      	ldr	r3, [r7, #4]
 80129b6:	89fa      	ldrh	r2, [r7, #14]
 80129b8:	809a      	strh	r2, [r3, #4]
  
  /* Write to TIMx CCMR2 */  
  TIMx->CCMR2 = tmpccmrx;
 80129ba:	687b      	ldr	r3, [r7, #4]
 80129bc:	89ba      	ldrh	r2, [r7, #12]
 80129be:	839a      	strh	r2, [r3, #28]
    
  /* Set the Capture Compare Register value */
  TIMx->CCR4 = TIM_OCInitStruct->TIM_Pulse;
 80129c0:	683b      	ldr	r3, [r7, #0]
 80129c2:	689a      	ldr	r2, [r3, #8]
 80129c4:	687b      	ldr	r3, [r7, #4]
 80129c6:	641a      	str	r2, [r3, #64]	; 0x40
  
  /* Write to TIMx CCER */
  TIMx->CCER = tmpccer;
 80129c8:	687b      	ldr	r3, [r7, #4]
 80129ca:	897a      	ldrh	r2, [r7, #10]
 80129cc:	841a      	strh	r2, [r3, #32]
}
 80129ce:	bf00      	nop
 80129d0:	3714      	adds	r7, #20
 80129d2:	46bd      	mov	sp, r7
 80129d4:	f85d 7b04 	ldr.w	r7, [sp], #4
 80129d8:	4770      	bx	lr
 80129da:	bf00      	nop
 80129dc:	40010000 	.word	0x40010000
 80129e0:	40010400 	.word	0x40010400

080129e4 <TIM_OCStructInit>:
  * @param  TIM_OCInitStruct: pointer to a TIM_OCInitTypeDef structure which will
  *         be initialized.
  * @retval None
  */
void TIM_OCStructInit(TIM_OCInitTypeDef* TIM_OCInitStruct)
{
 80129e4:	b480      	push	{r7}
 80129e6:	b083      	sub	sp, #12
 80129e8:	af00      	add	r7, sp, #0
 80129ea:	6078      	str	r0, [r7, #4]
  /* Set the default configuration */
  TIM_OCInitStruct->TIM_OCMode = TIM_OCMode_Timing;
 80129ec:	687b      	ldr	r3, [r7, #4]
 80129ee:	2200      	movs	r2, #0
 80129f0:	801a      	strh	r2, [r3, #0]
  TIM_OCInitStruct->TIM_OutputState = TIM_OutputState_Disable;
 80129f2:	687b      	ldr	r3, [r7, #4]
 80129f4:	2200      	movs	r2, #0
 80129f6:	805a      	strh	r2, [r3, #2]
  TIM_OCInitStruct->TIM_OutputNState = TIM_OutputNState_Disable;
 80129f8:	687b      	ldr	r3, [r7, #4]
 80129fa:	2200      	movs	r2, #0
 80129fc:	809a      	strh	r2, [r3, #4]
  TIM_OCInitStruct->TIM_Pulse = 0x00000000;
 80129fe:	687b      	ldr	r3, [r7, #4]
 8012a00:	2200      	movs	r2, #0
 8012a02:	609a      	str	r2, [r3, #8]
  TIM_OCInitStruct->TIM_OCPolarity = TIM_OCPolarity_High;
 8012a04:	687b      	ldr	r3, [r7, #4]
 8012a06:	2200      	movs	r2, #0
 8012a08:	819a      	strh	r2, [r3, #12]
  TIM_OCInitStruct->TIM_OCNPolarity = TIM_OCPolarity_High;
 8012a0a:	687b      	ldr	r3, [r7, #4]
 8012a0c:	2200      	movs	r2, #0
 8012a0e:	81da      	strh	r2, [r3, #14]
  TIM_OCInitStruct->TIM_OCIdleState = TIM_OCIdleState_Reset;
 8012a10:	687b      	ldr	r3, [r7, #4]
 8012a12:	2200      	movs	r2, #0
 8012a14:	821a      	strh	r2, [r3, #16]
  TIM_OCInitStruct->TIM_OCNIdleState = TIM_OCNIdleState_Reset;
 8012a16:	687b      	ldr	r3, [r7, #4]
 8012a18:	2200      	movs	r2, #0
 8012a1a:	825a      	strh	r2, [r3, #18]
}
 8012a1c:	bf00      	nop
 8012a1e:	370c      	adds	r7, #12
 8012a20:	46bd      	mov	sp, r7
 8012a22:	f85d 7b04 	ldr.w	r7, [sp], #4
 8012a26:	4770      	bx	lr

08012a28 <TIM_SelectOCxM>:
  *            @arg TIM_ForcedAction_Active
  *            @arg TIM_ForcedAction_InActive
  * @retval None
  */
void TIM_SelectOCxM(TIM_TypeDef* TIMx, uint16_t TIM_Channel, uint16_t TIM_OCMode)
{
 8012a28:	b480      	push	{r7}
 8012a2a:	b085      	sub	sp, #20
 8012a2c:	af00      	add	r7, sp, #0
 8012a2e:	6078      	str	r0, [r7, #4]
 8012a30:	460b      	mov	r3, r1
 8012a32:	807b      	strh	r3, [r7, #2]
 8012a34:	4613      	mov	r3, r2
 8012a36:	803b      	strh	r3, [r7, #0]
  uint32_t tmp = 0;
 8012a38:	2300      	movs	r3, #0
 8012a3a:	60fb      	str	r3, [r7, #12]
  uint16_t tmp1 = 0;
 8012a3c:	2300      	movs	r3, #0
 8012a3e:	817b      	strh	r3, [r7, #10]
  /* Check the parameters */
  assert_param(IS_TIM_LIST1_PERIPH(TIMx));
  assert_param(IS_TIM_CHANNEL(TIM_Channel));
  assert_param(IS_TIM_OCM(TIM_OCMode));

  tmp = (uint32_t) TIMx;
 8012a40:	687b      	ldr	r3, [r7, #4]
 8012a42:	60fb      	str	r3, [r7, #12]
  tmp += CCMR_OFFSET;
 8012a44:	68fb      	ldr	r3, [r7, #12]
 8012a46:	3318      	adds	r3, #24
 8012a48:	60fb      	str	r3, [r7, #12]

  tmp1 = CCER_CCE_SET << (uint16_t)TIM_Channel;
 8012a4a:	887b      	ldrh	r3, [r7, #2]
 8012a4c:	2201      	movs	r2, #1
 8012a4e:	fa02 f303 	lsl.w	r3, r2, r3
 8012a52:	817b      	strh	r3, [r7, #10]

  /* Disable the Channel: Reset the CCxE Bit */
  TIMx->CCER &= (uint16_t) ~tmp1;
 8012a54:	687b      	ldr	r3, [r7, #4]
 8012a56:	8c1b      	ldrh	r3, [r3, #32]
 8012a58:	b29a      	uxth	r2, r3
 8012a5a:	897b      	ldrh	r3, [r7, #10]
 8012a5c:	43db      	mvns	r3, r3
 8012a5e:	b29b      	uxth	r3, r3
 8012a60:	4013      	ands	r3, r2
 8012a62:	b29a      	uxth	r2, r3
 8012a64:	687b      	ldr	r3, [r7, #4]
 8012a66:	841a      	strh	r2, [r3, #32]

  if((TIM_Channel == TIM_Channel_1) ||(TIM_Channel == TIM_Channel_3))
 8012a68:	887b      	ldrh	r3, [r7, #2]
 8012a6a:	2b00      	cmp	r3, #0
 8012a6c:	d002      	beq.n	8012a74 <TIM_SelectOCxM+0x4c>
 8012a6e:	887b      	ldrh	r3, [r7, #2]
 8012a70:	2b08      	cmp	r3, #8
 8012a72:	d114      	bne.n	8012a9e <TIM_SelectOCxM+0x76>
  {
    tmp += (TIM_Channel>>1);
 8012a74:	887b      	ldrh	r3, [r7, #2]
 8012a76:	085b      	lsrs	r3, r3, #1
 8012a78:	b29b      	uxth	r3, r3
 8012a7a:	461a      	mov	r2, r3
 8012a7c:	68fb      	ldr	r3, [r7, #12]
 8012a7e:	4413      	add	r3, r2
 8012a80:	60fb      	str	r3, [r7, #12]

    /* Reset the OCxM bits in the CCMRx register */
    *(__IO uint32_t *) tmp &= CCMR_OC13M_MASK;
 8012a82:	68fa      	ldr	r2, [r7, #12]
 8012a84:	68fb      	ldr	r3, [r7, #12]
 8012a86:	6819      	ldr	r1, [r3, #0]
 8012a88:	f64f 738f 	movw	r3, #65423	; 0xff8f
 8012a8c:	400b      	ands	r3, r1
 8012a8e:	6013      	str	r3, [r2, #0]
   
    /* Configure the OCxM bits in the CCMRx register */
    *(__IO uint32_t *) tmp |= TIM_OCMode;
 8012a90:	68fb      	ldr	r3, [r7, #12]
 8012a92:	68fa      	ldr	r2, [r7, #12]
 8012a94:	6811      	ldr	r1, [r2, #0]
 8012a96:	883a      	ldrh	r2, [r7, #0]
 8012a98:	430a      	orrs	r2, r1
 8012a9a:	601a      	str	r2, [r3, #0]
 8012a9c:	e017      	b.n	8012ace <TIM_SelectOCxM+0xa6>
  }
  else
  {
    tmp += (uint16_t)(TIM_Channel - (uint16_t)4)>> (uint16_t)1;
 8012a9e:	887b      	ldrh	r3, [r7, #2]
 8012aa0:	3b04      	subs	r3, #4
 8012aa2:	b29b      	uxth	r3, r3
 8012aa4:	085b      	lsrs	r3, r3, #1
 8012aa6:	b29b      	uxth	r3, r3
 8012aa8:	461a      	mov	r2, r3
 8012aaa:	68fb      	ldr	r3, [r7, #12]
 8012aac:	4413      	add	r3, r2
 8012aae:	60fb      	str	r3, [r7, #12]

    /* Reset the OCxM bits in the CCMRx register */
    *(__IO uint32_t *) tmp &= CCMR_OC24M_MASK;
 8012ab0:	68fa      	ldr	r2, [r7, #12]
 8012ab2:	68fb      	ldr	r3, [r7, #12]
 8012ab4:	6819      	ldr	r1, [r3, #0]
 8012ab6:	f648 73ff 	movw	r3, #36863	; 0x8fff
 8012aba:	400b      	ands	r3, r1
 8012abc:	6013      	str	r3, [r2, #0]
    
    /* Configure the OCxM bits in the CCMRx register */
    *(__IO uint32_t *) tmp |= (uint16_t)(TIM_OCMode << 8);
 8012abe:	68fb      	ldr	r3, [r7, #12]
 8012ac0:	68fa      	ldr	r2, [r7, #12]
 8012ac2:	6812      	ldr	r2, [r2, #0]
 8012ac4:	8839      	ldrh	r1, [r7, #0]
 8012ac6:	0209      	lsls	r1, r1, #8
 8012ac8:	b289      	uxth	r1, r1
 8012aca:	430a      	orrs	r2, r1
 8012acc:	601a      	str	r2, [r3, #0]
  }
}
 8012ace:	bf00      	nop
 8012ad0:	3714      	adds	r7, #20
 8012ad2:	46bd      	mov	sp, r7
 8012ad4:	f85d 7b04 	ldr.w	r7, [sp], #4
 8012ad8:	4770      	bx	lr

08012ada <TIM_SetCompare1>:
  * @param  TIMx: where x can be 1 to 14 except 6 and 7, to select the TIM peripheral.
  * @param  Compare1: specifies the Capture Compare1 register new value.
  * @retval None
  */
void TIM_SetCompare1(TIM_TypeDef* TIMx, uint32_t Compare1)
{
 8012ada:	b480      	push	{r7}
 8012adc:	b083      	sub	sp, #12
 8012ade:	af00      	add	r7, sp, #0
 8012ae0:	6078      	str	r0, [r7, #4]
 8012ae2:	6039      	str	r1, [r7, #0]
  /* Check the parameters */
  assert_param(IS_TIM_LIST1_PERIPH(TIMx));

  /* Set the Capture Compare1 Register value */
  TIMx->CCR1 = Compare1;
 8012ae4:	687b      	ldr	r3, [r7, #4]
 8012ae6:	683a      	ldr	r2, [r7, #0]
 8012ae8:	635a      	str	r2, [r3, #52]	; 0x34
}
 8012aea:	bf00      	nop
 8012aec:	370c      	adds	r7, #12
 8012aee:	46bd      	mov	sp, r7
 8012af0:	f85d 7b04 	ldr.w	r7, [sp], #4
 8012af4:	4770      	bx	lr

08012af6 <TIM_SetCompare2>:
  *         peripheral.
  * @param  Compare2: specifies the Capture Compare2 register new value.
  * @retval None
  */
void TIM_SetCompare2(TIM_TypeDef* TIMx, uint32_t Compare2)
{
 8012af6:	b480      	push	{r7}
 8012af8:	b083      	sub	sp, #12
 8012afa:	af00      	add	r7, sp, #0
 8012afc:	6078      	str	r0, [r7, #4]
 8012afe:	6039      	str	r1, [r7, #0]
  /* Check the parameters */
  assert_param(IS_TIM_LIST2_PERIPH(TIMx));

  /* Set the Capture Compare2 Register value */
  TIMx->CCR2 = Compare2;
 8012b00:	687b      	ldr	r3, [r7, #4]
 8012b02:	683a      	ldr	r2, [r7, #0]
 8012b04:	639a      	str	r2, [r3, #56]	; 0x38
}
 8012b06:	bf00      	nop
 8012b08:	370c      	adds	r7, #12
 8012b0a:	46bd      	mov	sp, r7
 8012b0c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8012b10:	4770      	bx	lr

08012b12 <TIM_SetCompare3>:
  * @param  TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
  * @param  Compare3: specifies the Capture Compare3 register new value.
  * @retval None
  */
void TIM_SetCompare3(TIM_TypeDef* TIMx, uint32_t Compare3)
{
 8012b12:	b480      	push	{r7}
 8012b14:	b083      	sub	sp, #12
 8012b16:	af00      	add	r7, sp, #0
 8012b18:	6078      	str	r0, [r7, #4]
 8012b1a:	6039      	str	r1, [r7, #0]
  /* Check the parameters */
  assert_param(IS_TIM_LIST3_PERIPH(TIMx));

  /* Set the Capture Compare3 Register value */
  TIMx->CCR3 = Compare3;
 8012b1c:	687b      	ldr	r3, [r7, #4]
 8012b1e:	683a      	ldr	r2, [r7, #0]
 8012b20:	63da      	str	r2, [r3, #60]	; 0x3c
}
 8012b22:	bf00      	nop
 8012b24:	370c      	adds	r7, #12
 8012b26:	46bd      	mov	sp, r7
 8012b28:	f85d 7b04 	ldr.w	r7, [sp], #4
 8012b2c:	4770      	bx	lr

08012b2e <TIM_SetCompare4>:
  * @param  TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
  * @param  Compare4: specifies the Capture Compare4 register new value.
  * @retval None
  */
void TIM_SetCompare4(TIM_TypeDef* TIMx, uint32_t Compare4)
{
 8012b2e:	b480      	push	{r7}
 8012b30:	b083      	sub	sp, #12
 8012b32:	af00      	add	r7, sp, #0
 8012b34:	6078      	str	r0, [r7, #4]
 8012b36:	6039      	str	r1, [r7, #0]
  /* Check the parameters */
  assert_param(IS_TIM_LIST3_PERIPH(TIMx));

  /* Set the Capture Compare4 Register value */
  TIMx->CCR4 = Compare4;
 8012b38:	687b      	ldr	r3, [r7, #4]
 8012b3a:	683a      	ldr	r2, [r7, #0]
 8012b3c:	641a      	str	r2, [r3, #64]	; 0x40
}
 8012b3e:	bf00      	nop
 8012b40:	370c      	adds	r7, #12
 8012b42:	46bd      	mov	sp, r7
 8012b44:	f85d 7b04 	ldr.w	r7, [sp], #4
 8012b48:	4770      	bx	lr

08012b4a <TIM_ForcedOC1Config>:
  *            @arg TIM_ForcedAction_Active: Force active level on OC1REF
  *            @arg TIM_ForcedAction_InActive: Force inactive level on OC1REF.
  * @retval None
  */
void TIM_ForcedOC1Config(TIM_TypeDef* TIMx, uint16_t TIM_ForcedAction)
{
 8012b4a:	b480      	push	{r7}
 8012b4c:	b085      	sub	sp, #20
 8012b4e:	af00      	add	r7, sp, #0
 8012b50:	6078      	str	r0, [r7, #4]
 8012b52:	460b      	mov	r3, r1
 8012b54:	807b      	strh	r3, [r7, #2]
  uint16_t tmpccmr1 = 0;
 8012b56:	2300      	movs	r3, #0
 8012b58:	81fb      	strh	r3, [r7, #14]

  /* Check the parameters */
  assert_param(IS_TIM_LIST1_PERIPH(TIMx));
  assert_param(IS_TIM_FORCED_ACTION(TIM_ForcedAction));
  tmpccmr1 = TIMx->CCMR1;
 8012b5a:	687b      	ldr	r3, [r7, #4]
 8012b5c:	8b1b      	ldrh	r3, [r3, #24]
 8012b5e:	81fb      	strh	r3, [r7, #14]

  /* Reset the OC1M Bits */
  tmpccmr1 &= (uint16_t)~TIM_CCMR1_OC1M;
 8012b60:	89fb      	ldrh	r3, [r7, #14]
 8012b62:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 8012b66:	81fb      	strh	r3, [r7, #14]

  /* Configure The Forced output Mode */
  tmpccmr1 |= TIM_ForcedAction;
 8012b68:	89fa      	ldrh	r2, [r7, #14]
 8012b6a:	887b      	ldrh	r3, [r7, #2]
 8012b6c:	4313      	orrs	r3, r2
 8012b6e:	81fb      	strh	r3, [r7, #14]

  /* Write to TIMx CCMR1 register */
  TIMx->CCMR1 = tmpccmr1;
 8012b70:	687b      	ldr	r3, [r7, #4]
 8012b72:	89fa      	ldrh	r2, [r7, #14]
 8012b74:	831a      	strh	r2, [r3, #24]
}
 8012b76:	bf00      	nop
 8012b78:	3714      	adds	r7, #20
 8012b7a:	46bd      	mov	sp, r7
 8012b7c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8012b80:	4770      	bx	lr

08012b82 <TIM_ForcedOC2Config>:
  *            @arg TIM_ForcedAction_Active: Force active level on OC2REF
  *            @arg TIM_ForcedAction_InActive: Force inactive level on OC2REF.
  * @retval None
  */
void TIM_ForcedOC2Config(TIM_TypeDef* TIMx, uint16_t TIM_ForcedAction)
{
 8012b82:	b480      	push	{r7}
 8012b84:	b085      	sub	sp, #20
 8012b86:	af00      	add	r7, sp, #0
 8012b88:	6078      	str	r0, [r7, #4]
 8012b8a:	460b      	mov	r3, r1
 8012b8c:	807b      	strh	r3, [r7, #2]
  uint16_t tmpccmr1 = 0;
 8012b8e:	2300      	movs	r3, #0
 8012b90:	81fb      	strh	r3, [r7, #14]

  /* Check the parameters */
  assert_param(IS_TIM_LIST2_PERIPH(TIMx));
  assert_param(IS_TIM_FORCED_ACTION(TIM_ForcedAction));
  tmpccmr1 = TIMx->CCMR1;
 8012b92:	687b      	ldr	r3, [r7, #4]
 8012b94:	8b1b      	ldrh	r3, [r3, #24]
 8012b96:	81fb      	strh	r3, [r7, #14]

  /* Reset the OC2M Bits */
  tmpccmr1 &= (uint16_t)~TIM_CCMR1_OC2M;
 8012b98:	89fb      	ldrh	r3, [r7, #14]
 8012b9a:	f423 43e0 	bic.w	r3, r3, #28672	; 0x7000
 8012b9e:	81fb      	strh	r3, [r7, #14]

  /* Configure The Forced output Mode */
  tmpccmr1 |= (uint16_t)(TIM_ForcedAction << 8);
 8012ba0:	887b      	ldrh	r3, [r7, #2]
 8012ba2:	021b      	lsls	r3, r3, #8
 8012ba4:	b29a      	uxth	r2, r3
 8012ba6:	89fb      	ldrh	r3, [r7, #14]
 8012ba8:	4313      	orrs	r3, r2
 8012baa:	81fb      	strh	r3, [r7, #14]

  /* Write to TIMx CCMR1 register */
  TIMx->CCMR1 = tmpccmr1;
 8012bac:	687b      	ldr	r3, [r7, #4]
 8012bae:	89fa      	ldrh	r2, [r7, #14]
 8012bb0:	831a      	strh	r2, [r3, #24]
}
 8012bb2:	bf00      	nop
 8012bb4:	3714      	adds	r7, #20
 8012bb6:	46bd      	mov	sp, r7
 8012bb8:	f85d 7b04 	ldr.w	r7, [sp], #4
 8012bbc:	4770      	bx	lr

08012bbe <TIM_ForcedOC3Config>:
  *            @arg TIM_ForcedAction_Active: Force active level on OC3REF
  *            @arg TIM_ForcedAction_InActive: Force inactive level on OC3REF.
  * @retval None
  */
void TIM_ForcedOC3Config(TIM_TypeDef* TIMx, uint16_t TIM_ForcedAction)
{
 8012bbe:	b480      	push	{r7}
 8012bc0:	b085      	sub	sp, #20
 8012bc2:	af00      	add	r7, sp, #0
 8012bc4:	6078      	str	r0, [r7, #4]
 8012bc6:	460b      	mov	r3, r1
 8012bc8:	807b      	strh	r3, [r7, #2]
  uint16_t tmpccmr2 = 0;
 8012bca:	2300      	movs	r3, #0
 8012bcc:	81fb      	strh	r3, [r7, #14]

  /* Check the parameters */
  assert_param(IS_TIM_LIST3_PERIPH(TIMx));
  assert_param(IS_TIM_FORCED_ACTION(TIM_ForcedAction));

  tmpccmr2 = TIMx->CCMR2;
 8012bce:	687b      	ldr	r3, [r7, #4]
 8012bd0:	8b9b      	ldrh	r3, [r3, #28]
 8012bd2:	81fb      	strh	r3, [r7, #14]

  /* Reset the OC1M Bits */
  tmpccmr2 &= (uint16_t)~TIM_CCMR2_OC3M;
 8012bd4:	89fb      	ldrh	r3, [r7, #14]
 8012bd6:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 8012bda:	81fb      	strh	r3, [r7, #14]

  /* Configure The Forced output Mode */
  tmpccmr2 |= TIM_ForcedAction;
 8012bdc:	89fa      	ldrh	r2, [r7, #14]
 8012bde:	887b      	ldrh	r3, [r7, #2]
 8012be0:	4313      	orrs	r3, r2
 8012be2:	81fb      	strh	r3, [r7, #14]

  /* Write to TIMx CCMR2 register */
  TIMx->CCMR2 = tmpccmr2;
 8012be4:	687b      	ldr	r3, [r7, #4]
 8012be6:	89fa      	ldrh	r2, [r7, #14]
 8012be8:	839a      	strh	r2, [r3, #28]
}
 8012bea:	bf00      	nop
 8012bec:	3714      	adds	r7, #20
 8012bee:	46bd      	mov	sp, r7
 8012bf0:	f85d 7b04 	ldr.w	r7, [sp], #4
 8012bf4:	4770      	bx	lr

08012bf6 <TIM_ForcedOC4Config>:
  *            @arg TIM_ForcedAction_Active: Force active level on OC4REF
  *            @arg TIM_ForcedAction_InActive: Force inactive level on OC4REF.
  * @retval None
  */
void TIM_ForcedOC4Config(TIM_TypeDef* TIMx, uint16_t TIM_ForcedAction)
{
 8012bf6:	b480      	push	{r7}
 8012bf8:	b085      	sub	sp, #20
 8012bfa:	af00      	add	r7, sp, #0
 8012bfc:	6078      	str	r0, [r7, #4]
 8012bfe:	460b      	mov	r3, r1
 8012c00:	807b      	strh	r3, [r7, #2]
  uint16_t tmpccmr2 = 0;
 8012c02:	2300      	movs	r3, #0
 8012c04:	81fb      	strh	r3, [r7, #14]

  /* Check the parameters */
  assert_param(IS_TIM_LIST3_PERIPH(TIMx));
  assert_param(IS_TIM_FORCED_ACTION(TIM_ForcedAction));
  tmpccmr2 = TIMx->CCMR2;
 8012c06:	687b      	ldr	r3, [r7, #4]
 8012c08:	8b9b      	ldrh	r3, [r3, #28]
 8012c0a:	81fb      	strh	r3, [r7, #14]

  /* Reset the OC2M Bits */
  tmpccmr2 &= (uint16_t)~TIM_CCMR2_OC4M;
 8012c0c:	89fb      	ldrh	r3, [r7, #14]
 8012c0e:	f423 43e0 	bic.w	r3, r3, #28672	; 0x7000
 8012c12:	81fb      	strh	r3, [r7, #14]

  /* Configure The Forced output Mode */
  tmpccmr2 |= (uint16_t)(TIM_ForcedAction << 8);
 8012c14:	887b      	ldrh	r3, [r7, #2]
 8012c16:	021b      	lsls	r3, r3, #8
 8012c18:	b29a      	uxth	r2, r3
 8012c1a:	89fb      	ldrh	r3, [r7, #14]
 8012c1c:	4313      	orrs	r3, r2
 8012c1e:	81fb      	strh	r3, [r7, #14]

  /* Write to TIMx CCMR2 register */
  TIMx->CCMR2 = tmpccmr2;
 8012c20:	687b      	ldr	r3, [r7, #4]
 8012c22:	89fa      	ldrh	r2, [r7, #14]
 8012c24:	839a      	strh	r2, [r3, #28]
}
 8012c26:	bf00      	nop
 8012c28:	3714      	adds	r7, #20
 8012c2a:	46bd      	mov	sp, r7
 8012c2c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8012c30:	4770      	bx	lr

08012c32 <TIM_OC1PreloadConfig>:
  *            @arg TIM_OCPreload_Enable
  *            @arg TIM_OCPreload_Disable
  * @retval None
  */
void TIM_OC1PreloadConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPreload)
{
 8012c32:	b480      	push	{r7}
 8012c34:	b085      	sub	sp, #20
 8012c36:	af00      	add	r7, sp, #0
 8012c38:	6078      	str	r0, [r7, #4]
 8012c3a:	460b      	mov	r3, r1
 8012c3c:	807b      	strh	r3, [r7, #2]
  uint16_t tmpccmr1 = 0;
 8012c3e:	2300      	movs	r3, #0
 8012c40:	81fb      	strh	r3, [r7, #14]

  /* Check the parameters */
  assert_param(IS_TIM_LIST1_PERIPH(TIMx));
  assert_param(IS_TIM_OCPRELOAD_STATE(TIM_OCPreload));

  tmpccmr1 = TIMx->CCMR1;
 8012c42:	687b      	ldr	r3, [r7, #4]
 8012c44:	8b1b      	ldrh	r3, [r3, #24]
 8012c46:	81fb      	strh	r3, [r7, #14]

  /* Reset the OC1PE Bit */
  tmpccmr1 &= (uint16_t)(~TIM_CCMR1_OC1PE);
 8012c48:	89fb      	ldrh	r3, [r7, #14]
 8012c4a:	f023 0308 	bic.w	r3, r3, #8
 8012c4e:	81fb      	strh	r3, [r7, #14]

  /* Enable or Disable the Output Compare Preload feature */
  tmpccmr1 |= TIM_OCPreload;
 8012c50:	89fa      	ldrh	r2, [r7, #14]
 8012c52:	887b      	ldrh	r3, [r7, #2]
 8012c54:	4313      	orrs	r3, r2
 8012c56:	81fb      	strh	r3, [r7, #14]

  /* Write to TIMx CCMR1 register */
  TIMx->CCMR1 = tmpccmr1;
 8012c58:	687b      	ldr	r3, [r7, #4]
 8012c5a:	89fa      	ldrh	r2, [r7, #14]
 8012c5c:	831a      	strh	r2, [r3, #24]
}
 8012c5e:	bf00      	nop
 8012c60:	3714      	adds	r7, #20
 8012c62:	46bd      	mov	sp, r7
 8012c64:	f85d 7b04 	ldr.w	r7, [sp], #4
 8012c68:	4770      	bx	lr

08012c6a <TIM_OC2PreloadConfig>:
  *            @arg TIM_OCPreload_Enable
  *            @arg TIM_OCPreload_Disable
  * @retval None
  */
void TIM_OC2PreloadConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPreload)
{
 8012c6a:	b480      	push	{r7}
 8012c6c:	b085      	sub	sp, #20
 8012c6e:	af00      	add	r7, sp, #0
 8012c70:	6078      	str	r0, [r7, #4]
 8012c72:	460b      	mov	r3, r1
 8012c74:	807b      	strh	r3, [r7, #2]
  uint16_t tmpccmr1 = 0;
 8012c76:	2300      	movs	r3, #0
 8012c78:	81fb      	strh	r3, [r7, #14]

  /* Check the parameters */
  assert_param(IS_TIM_LIST2_PERIPH(TIMx));
  assert_param(IS_TIM_OCPRELOAD_STATE(TIM_OCPreload));

  tmpccmr1 = TIMx->CCMR1;
 8012c7a:	687b      	ldr	r3, [r7, #4]
 8012c7c:	8b1b      	ldrh	r3, [r3, #24]
 8012c7e:	81fb      	strh	r3, [r7, #14]

  /* Reset the OC2PE Bit */
  tmpccmr1 &= (uint16_t)(~TIM_CCMR1_OC2PE);
 8012c80:	89fb      	ldrh	r3, [r7, #14]
 8012c82:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
 8012c86:	81fb      	strh	r3, [r7, #14]

  /* Enable or Disable the Output Compare Preload feature */
  tmpccmr1 |= (uint16_t)(TIM_OCPreload << 8);
 8012c88:	887b      	ldrh	r3, [r7, #2]
 8012c8a:	021b      	lsls	r3, r3, #8
 8012c8c:	b29a      	uxth	r2, r3
 8012c8e:	89fb      	ldrh	r3, [r7, #14]
 8012c90:	4313      	orrs	r3, r2
 8012c92:	81fb      	strh	r3, [r7, #14]

  /* Write to TIMx CCMR1 register */
  TIMx->CCMR1 = tmpccmr1;
 8012c94:	687b      	ldr	r3, [r7, #4]
 8012c96:	89fa      	ldrh	r2, [r7, #14]
 8012c98:	831a      	strh	r2, [r3, #24]
}
 8012c9a:	bf00      	nop
 8012c9c:	3714      	adds	r7, #20
 8012c9e:	46bd      	mov	sp, r7
 8012ca0:	f85d 7b04 	ldr.w	r7, [sp], #4
 8012ca4:	4770      	bx	lr

08012ca6 <TIM_OC3PreloadConfig>:
  *            @arg TIM_OCPreload_Enable
  *            @arg TIM_OCPreload_Disable
  * @retval None
  */
void TIM_OC3PreloadConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPreload)
{
 8012ca6:	b480      	push	{r7}
 8012ca8:	b085      	sub	sp, #20
 8012caa:	af00      	add	r7, sp, #0
 8012cac:	6078      	str	r0, [r7, #4]
 8012cae:	460b      	mov	r3, r1
 8012cb0:	807b      	strh	r3, [r7, #2]
  uint16_t tmpccmr2 = 0;
 8012cb2:	2300      	movs	r3, #0
 8012cb4:	81fb      	strh	r3, [r7, #14]

  /* Check the parameters */
  assert_param(IS_TIM_LIST3_PERIPH(TIMx));
  assert_param(IS_TIM_OCPRELOAD_STATE(TIM_OCPreload));

  tmpccmr2 = TIMx->CCMR2;
 8012cb6:	687b      	ldr	r3, [r7, #4]
 8012cb8:	8b9b      	ldrh	r3, [r3, #28]
 8012cba:	81fb      	strh	r3, [r7, #14]

  /* Reset the OC3PE Bit */
  tmpccmr2 &= (uint16_t)(~TIM_CCMR2_OC3PE);
 8012cbc:	89fb      	ldrh	r3, [r7, #14]
 8012cbe:	f023 0308 	bic.w	r3, r3, #8
 8012cc2:	81fb      	strh	r3, [r7, #14]

  /* Enable or Disable the Output Compare Preload feature */
  tmpccmr2 |= TIM_OCPreload;
 8012cc4:	89fa      	ldrh	r2, [r7, #14]
 8012cc6:	887b      	ldrh	r3, [r7, #2]
 8012cc8:	4313      	orrs	r3, r2
 8012cca:	81fb      	strh	r3, [r7, #14]

  /* Write to TIMx CCMR2 register */
  TIMx->CCMR2 = tmpccmr2;
 8012ccc:	687b      	ldr	r3, [r7, #4]
 8012cce:	89fa      	ldrh	r2, [r7, #14]
 8012cd0:	839a      	strh	r2, [r3, #28]
}
 8012cd2:	bf00      	nop
 8012cd4:	3714      	adds	r7, #20
 8012cd6:	46bd      	mov	sp, r7
 8012cd8:	f85d 7b04 	ldr.w	r7, [sp], #4
 8012cdc:	4770      	bx	lr

08012cde <TIM_OC4PreloadConfig>:
  *            @arg TIM_OCPreload_Enable
  *            @arg TIM_OCPreload_Disable
  * @retval None
  */
void TIM_OC4PreloadConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPreload)
{
 8012cde:	b480      	push	{r7}
 8012ce0:	b085      	sub	sp, #20
 8012ce2:	af00      	add	r7, sp, #0
 8012ce4:	6078      	str	r0, [r7, #4]
 8012ce6:	460b      	mov	r3, r1
 8012ce8:	807b      	strh	r3, [r7, #2]
  uint16_t tmpccmr2 = 0;
 8012cea:	2300      	movs	r3, #0
 8012cec:	81fb      	strh	r3, [r7, #14]

  /* Check the parameters */
  assert_param(IS_TIM_LIST3_PERIPH(TIMx));
  assert_param(IS_TIM_OCPRELOAD_STATE(TIM_OCPreload));

  tmpccmr2 = TIMx->CCMR2;
 8012cee:	687b      	ldr	r3, [r7, #4]
 8012cf0:	8b9b      	ldrh	r3, [r3, #28]
 8012cf2:	81fb      	strh	r3, [r7, #14]

  /* Reset the OC4PE Bit */
  tmpccmr2 &= (uint16_t)(~TIM_CCMR2_OC4PE);
 8012cf4:	89fb      	ldrh	r3, [r7, #14]
 8012cf6:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
 8012cfa:	81fb      	strh	r3, [r7, #14]

  /* Enable or Disable the Output Compare Preload feature */
  tmpccmr2 |= (uint16_t)(TIM_OCPreload << 8);
 8012cfc:	887b      	ldrh	r3, [r7, #2]
 8012cfe:	021b      	lsls	r3, r3, #8
 8012d00:	b29a      	uxth	r2, r3
 8012d02:	89fb      	ldrh	r3, [r7, #14]
 8012d04:	4313      	orrs	r3, r2
 8012d06:	81fb      	strh	r3, [r7, #14]

  /* Write to TIMx CCMR2 register */
  TIMx->CCMR2 = tmpccmr2;
 8012d08:	687b      	ldr	r3, [r7, #4]
 8012d0a:	89fa      	ldrh	r2, [r7, #14]
 8012d0c:	839a      	strh	r2, [r3, #28]
}
 8012d0e:	bf00      	nop
 8012d10:	3714      	adds	r7, #20
 8012d12:	46bd      	mov	sp, r7
 8012d14:	f85d 7b04 	ldr.w	r7, [sp], #4
 8012d18:	4770      	bx	lr

08012d1a <TIM_OC1FastConfig>:
  *            @arg TIM_OCFast_Enable: TIM output compare fast enable
  *            @arg TIM_OCFast_Disable: TIM output compare fast disable
  * @retval None
  */
void TIM_OC1FastConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCFast)
{
 8012d1a:	b480      	push	{r7}
 8012d1c:	b085      	sub	sp, #20
 8012d1e:	af00      	add	r7, sp, #0
 8012d20:	6078      	str	r0, [r7, #4]
 8012d22:	460b      	mov	r3, r1
 8012d24:	807b      	strh	r3, [r7, #2]
  uint16_t tmpccmr1 = 0;
 8012d26:	2300      	movs	r3, #0
 8012d28:	81fb      	strh	r3, [r7, #14]
  /* Check the parameters */
  assert_param(IS_TIM_LIST1_PERIPH(TIMx));
  assert_param(IS_TIM_OCFAST_STATE(TIM_OCFast));

  /* Get the TIMx CCMR1 register value */
  tmpccmr1 = TIMx->CCMR1;
 8012d2a:	687b      	ldr	r3, [r7, #4]
 8012d2c:	8b1b      	ldrh	r3, [r3, #24]
 8012d2e:	81fb      	strh	r3, [r7, #14]

  /* Reset the OC1FE Bit */
  tmpccmr1 &= (uint16_t)~TIM_CCMR1_OC1FE;
 8012d30:	89fb      	ldrh	r3, [r7, #14]
 8012d32:	f023 0304 	bic.w	r3, r3, #4
 8012d36:	81fb      	strh	r3, [r7, #14]

  /* Enable or Disable the Output Compare Fast Bit */
  tmpccmr1 |= TIM_OCFast;
 8012d38:	89fa      	ldrh	r2, [r7, #14]
 8012d3a:	887b      	ldrh	r3, [r7, #2]
 8012d3c:	4313      	orrs	r3, r2
 8012d3e:	81fb      	strh	r3, [r7, #14]

  /* Write to TIMx CCMR1 */
  TIMx->CCMR1 = tmpccmr1;
 8012d40:	687b      	ldr	r3, [r7, #4]
 8012d42:	89fa      	ldrh	r2, [r7, #14]
 8012d44:	831a      	strh	r2, [r3, #24]
}
 8012d46:	bf00      	nop
 8012d48:	3714      	adds	r7, #20
 8012d4a:	46bd      	mov	sp, r7
 8012d4c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8012d50:	4770      	bx	lr

08012d52 <TIM_OC2FastConfig>:
  *            @arg TIM_OCFast_Enable: TIM output compare fast enable
  *            @arg TIM_OCFast_Disable: TIM output compare fast disable
  * @retval None
  */
void TIM_OC2FastConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCFast)
{
 8012d52:	b480      	push	{r7}
 8012d54:	b085      	sub	sp, #20
 8012d56:	af00      	add	r7, sp, #0
 8012d58:	6078      	str	r0, [r7, #4]
 8012d5a:	460b      	mov	r3, r1
 8012d5c:	807b      	strh	r3, [r7, #2]
  uint16_t tmpccmr1 = 0;
 8012d5e:	2300      	movs	r3, #0
 8012d60:	81fb      	strh	r3, [r7, #14]
  /* Check the parameters */
  assert_param(IS_TIM_LIST2_PERIPH(TIMx));
  assert_param(IS_TIM_OCFAST_STATE(TIM_OCFast));

  /* Get the TIMx CCMR1 register value */
  tmpccmr1 = TIMx->CCMR1;
 8012d62:	687b      	ldr	r3, [r7, #4]
 8012d64:	8b1b      	ldrh	r3, [r3, #24]
 8012d66:	81fb      	strh	r3, [r7, #14]

  /* Reset the OC2FE Bit */
  tmpccmr1 &= (uint16_t)(~TIM_CCMR1_OC2FE);
 8012d68:	89fb      	ldrh	r3, [r7, #14]
 8012d6a:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 8012d6e:	81fb      	strh	r3, [r7, #14]

  /* Enable or Disable the Output Compare Fast Bit */
  tmpccmr1 |= (uint16_t)(TIM_OCFast << 8);
 8012d70:	887b      	ldrh	r3, [r7, #2]
 8012d72:	021b      	lsls	r3, r3, #8
 8012d74:	b29a      	uxth	r2, r3
 8012d76:	89fb      	ldrh	r3, [r7, #14]
 8012d78:	4313      	orrs	r3, r2
 8012d7a:	81fb      	strh	r3, [r7, #14]

  /* Write to TIMx CCMR1 */
  TIMx->CCMR1 = tmpccmr1;
 8012d7c:	687b      	ldr	r3, [r7, #4]
 8012d7e:	89fa      	ldrh	r2, [r7, #14]
 8012d80:	831a      	strh	r2, [r3, #24]
}
 8012d82:	bf00      	nop
 8012d84:	3714      	adds	r7, #20
 8012d86:	46bd      	mov	sp, r7
 8012d88:	f85d 7b04 	ldr.w	r7, [sp], #4
 8012d8c:	4770      	bx	lr

08012d8e <TIM_OC3FastConfig>:
  *            @arg TIM_OCFast_Enable: TIM output compare fast enable
  *            @arg TIM_OCFast_Disable: TIM output compare fast disable
  * @retval None
  */
void TIM_OC3FastConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCFast)
{
 8012d8e:	b480      	push	{r7}
 8012d90:	b085      	sub	sp, #20
 8012d92:	af00      	add	r7, sp, #0
 8012d94:	6078      	str	r0, [r7, #4]
 8012d96:	460b      	mov	r3, r1
 8012d98:	807b      	strh	r3, [r7, #2]
  uint16_t tmpccmr2 = 0;
 8012d9a:	2300      	movs	r3, #0
 8012d9c:	81fb      	strh	r3, [r7, #14]
  /* Check the parameters */
  assert_param(IS_TIM_LIST3_PERIPH(TIMx));
  assert_param(IS_TIM_OCFAST_STATE(TIM_OCFast));

  /* Get the TIMx CCMR2 register value */
  tmpccmr2 = TIMx->CCMR2;
 8012d9e:	687b      	ldr	r3, [r7, #4]
 8012da0:	8b9b      	ldrh	r3, [r3, #28]
 8012da2:	81fb      	strh	r3, [r7, #14]

  /* Reset the OC3FE Bit */
  tmpccmr2 &= (uint16_t)~TIM_CCMR2_OC3FE;
 8012da4:	89fb      	ldrh	r3, [r7, #14]
 8012da6:	f023 0304 	bic.w	r3, r3, #4
 8012daa:	81fb      	strh	r3, [r7, #14]

  /* Enable or Disable the Output Compare Fast Bit */
  tmpccmr2 |= TIM_OCFast;
 8012dac:	89fa      	ldrh	r2, [r7, #14]
 8012dae:	887b      	ldrh	r3, [r7, #2]
 8012db0:	4313      	orrs	r3, r2
 8012db2:	81fb      	strh	r3, [r7, #14]

  /* Write to TIMx CCMR2 */
  TIMx->CCMR2 = tmpccmr2;
 8012db4:	687b      	ldr	r3, [r7, #4]
 8012db6:	89fa      	ldrh	r2, [r7, #14]
 8012db8:	839a      	strh	r2, [r3, #28]
}
 8012dba:	bf00      	nop
 8012dbc:	3714      	adds	r7, #20
 8012dbe:	46bd      	mov	sp, r7
 8012dc0:	f85d 7b04 	ldr.w	r7, [sp], #4
 8012dc4:	4770      	bx	lr

08012dc6 <TIM_OC4FastConfig>:
  *            @arg TIM_OCFast_Enable: TIM output compare fast enable
  *            @arg TIM_OCFast_Disable: TIM output compare fast disable
  * @retval None
  */
void TIM_OC4FastConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCFast)
{
 8012dc6:	b480      	push	{r7}
 8012dc8:	b085      	sub	sp, #20
 8012dca:	af00      	add	r7, sp, #0
 8012dcc:	6078      	str	r0, [r7, #4]
 8012dce:	460b      	mov	r3, r1
 8012dd0:	807b      	strh	r3, [r7, #2]
  uint16_t tmpccmr2 = 0;
 8012dd2:	2300      	movs	r3, #0
 8012dd4:	81fb      	strh	r3, [r7, #14]
  /* Check the parameters */
  assert_param(IS_TIM_LIST3_PERIPH(TIMx));
  assert_param(IS_TIM_OCFAST_STATE(TIM_OCFast));

  /* Get the TIMx CCMR2 register value */
  tmpccmr2 = TIMx->CCMR2;
 8012dd6:	687b      	ldr	r3, [r7, #4]
 8012dd8:	8b9b      	ldrh	r3, [r3, #28]
 8012dda:	81fb      	strh	r3, [r7, #14]

  /* Reset the OC4FE Bit */
  tmpccmr2 &= (uint16_t)(~TIM_CCMR2_OC4FE);
 8012ddc:	89fb      	ldrh	r3, [r7, #14]
 8012dde:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 8012de2:	81fb      	strh	r3, [r7, #14]

  /* Enable or Disable the Output Compare Fast Bit */
  tmpccmr2 |= (uint16_t)(TIM_OCFast << 8);
 8012de4:	887b      	ldrh	r3, [r7, #2]
 8012de6:	021b      	lsls	r3, r3, #8
 8012de8:	b29a      	uxth	r2, r3
 8012dea:	89fb      	ldrh	r3, [r7, #14]
 8012dec:	4313      	orrs	r3, r2
 8012dee:	81fb      	strh	r3, [r7, #14]

  /* Write to TIMx CCMR2 */
  TIMx->CCMR2 = tmpccmr2;
 8012df0:	687b      	ldr	r3, [r7, #4]
 8012df2:	89fa      	ldrh	r2, [r7, #14]
 8012df4:	839a      	strh	r2, [r3, #28]
}
 8012df6:	bf00      	nop
 8012df8:	3714      	adds	r7, #20
 8012dfa:	46bd      	mov	sp, r7
 8012dfc:	f85d 7b04 	ldr.w	r7, [sp], #4
 8012e00:	4770      	bx	lr

08012e02 <TIM_ClearOC1Ref>:
  *            @arg TIM_OCClear_Enable: TIM Output clear enable
  *            @arg TIM_OCClear_Disable: TIM Output clear disable
  * @retval None
  */
void TIM_ClearOC1Ref(TIM_TypeDef* TIMx, uint16_t TIM_OCClear)
{
 8012e02:	b480      	push	{r7}
 8012e04:	b085      	sub	sp, #20
 8012e06:	af00      	add	r7, sp, #0
 8012e08:	6078      	str	r0, [r7, #4]
 8012e0a:	460b      	mov	r3, r1
 8012e0c:	807b      	strh	r3, [r7, #2]
  uint16_t tmpccmr1 = 0;
 8012e0e:	2300      	movs	r3, #0
 8012e10:	81fb      	strh	r3, [r7, #14]

  /* Check the parameters */
  assert_param(IS_TIM_LIST1_PERIPH(TIMx));
  assert_param(IS_TIM_OCCLEAR_STATE(TIM_OCClear));

  tmpccmr1 = TIMx->CCMR1;
 8012e12:	687b      	ldr	r3, [r7, #4]
 8012e14:	8b1b      	ldrh	r3, [r3, #24]
 8012e16:	81fb      	strh	r3, [r7, #14]

  /* Reset the OC1CE Bit */
  tmpccmr1 &= (uint16_t)~TIM_CCMR1_OC1CE;
 8012e18:	89fb      	ldrh	r3, [r7, #14]
 8012e1a:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 8012e1e:	81fb      	strh	r3, [r7, #14]

  /* Enable or Disable the Output Compare Clear Bit */
  tmpccmr1 |= TIM_OCClear;
 8012e20:	89fa      	ldrh	r2, [r7, #14]
 8012e22:	887b      	ldrh	r3, [r7, #2]
 8012e24:	4313      	orrs	r3, r2
 8012e26:	81fb      	strh	r3, [r7, #14]

  /* Write to TIMx CCMR1 register */
  TIMx->CCMR1 = tmpccmr1;
 8012e28:	687b      	ldr	r3, [r7, #4]
 8012e2a:	89fa      	ldrh	r2, [r7, #14]
 8012e2c:	831a      	strh	r2, [r3, #24]
}
 8012e2e:	bf00      	nop
 8012e30:	3714      	adds	r7, #20
 8012e32:	46bd      	mov	sp, r7
 8012e34:	f85d 7b04 	ldr.w	r7, [sp], #4
 8012e38:	4770      	bx	lr

08012e3a <TIM_ClearOC2Ref>:
  *            @arg TIM_OCClear_Enable: TIM Output clear enable
  *            @arg TIM_OCClear_Disable: TIM Output clear disable
  * @retval None
  */
void TIM_ClearOC2Ref(TIM_TypeDef* TIMx, uint16_t TIM_OCClear)
{
 8012e3a:	b480      	push	{r7}
 8012e3c:	b085      	sub	sp, #20
 8012e3e:	af00      	add	r7, sp, #0
 8012e40:	6078      	str	r0, [r7, #4]
 8012e42:	460b      	mov	r3, r1
 8012e44:	807b      	strh	r3, [r7, #2]
  uint16_t tmpccmr1 = 0;
 8012e46:	2300      	movs	r3, #0
 8012e48:	81fb      	strh	r3, [r7, #14]

  /* Check the parameters */
  assert_param(IS_TIM_LIST2_PERIPH(TIMx));
  assert_param(IS_TIM_OCCLEAR_STATE(TIM_OCClear));

  tmpccmr1 = TIMx->CCMR1;
 8012e4a:	687b      	ldr	r3, [r7, #4]
 8012e4c:	8b1b      	ldrh	r3, [r3, #24]
 8012e4e:	81fb      	strh	r3, [r7, #14]

  /* Reset the OC2CE Bit */
  tmpccmr1 &= (uint16_t)~TIM_CCMR1_OC2CE;
 8012e50:	89fb      	ldrh	r3, [r7, #14]
 8012e52:	f3c3 030e 	ubfx	r3, r3, #0, #15
 8012e56:	81fb      	strh	r3, [r7, #14]

  /* Enable or Disable the Output Compare Clear Bit */
  tmpccmr1 |= (uint16_t)(TIM_OCClear << 8);
 8012e58:	887b      	ldrh	r3, [r7, #2]
 8012e5a:	021b      	lsls	r3, r3, #8
 8012e5c:	b29a      	uxth	r2, r3
 8012e5e:	89fb      	ldrh	r3, [r7, #14]
 8012e60:	4313      	orrs	r3, r2
 8012e62:	81fb      	strh	r3, [r7, #14]

  /* Write to TIMx CCMR1 register */
  TIMx->CCMR1 = tmpccmr1;
 8012e64:	687b      	ldr	r3, [r7, #4]
 8012e66:	89fa      	ldrh	r2, [r7, #14]
 8012e68:	831a      	strh	r2, [r3, #24]
}
 8012e6a:	bf00      	nop
 8012e6c:	3714      	adds	r7, #20
 8012e6e:	46bd      	mov	sp, r7
 8012e70:	f85d 7b04 	ldr.w	r7, [sp], #4
 8012e74:	4770      	bx	lr

08012e76 <TIM_ClearOC3Ref>:
  *            @arg TIM_OCClear_Enable: TIM Output clear enable
  *            @arg TIM_OCClear_Disable: TIM Output clear disable
  * @retval None
  */
void TIM_ClearOC3Ref(TIM_TypeDef* TIMx, uint16_t TIM_OCClear)
{
 8012e76:	b480      	push	{r7}
 8012e78:	b085      	sub	sp, #20
 8012e7a:	af00      	add	r7, sp, #0
 8012e7c:	6078      	str	r0, [r7, #4]
 8012e7e:	460b      	mov	r3, r1
 8012e80:	807b      	strh	r3, [r7, #2]
  uint16_t tmpccmr2 = 0;
 8012e82:	2300      	movs	r3, #0
 8012e84:	81fb      	strh	r3, [r7, #14]

  /* Check the parameters */
  assert_param(IS_TIM_LIST3_PERIPH(TIMx));
  assert_param(IS_TIM_OCCLEAR_STATE(TIM_OCClear));

  tmpccmr2 = TIMx->CCMR2;
 8012e86:	687b      	ldr	r3, [r7, #4]
 8012e88:	8b9b      	ldrh	r3, [r3, #28]
 8012e8a:	81fb      	strh	r3, [r7, #14]

  /* Reset the OC3CE Bit */
  tmpccmr2 &= (uint16_t)~TIM_CCMR2_OC3CE;
 8012e8c:	89fb      	ldrh	r3, [r7, #14]
 8012e8e:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 8012e92:	81fb      	strh	r3, [r7, #14]

  /* Enable or Disable the Output Compare Clear Bit */
  tmpccmr2 |= TIM_OCClear;
 8012e94:	89fa      	ldrh	r2, [r7, #14]
 8012e96:	887b      	ldrh	r3, [r7, #2]
 8012e98:	4313      	orrs	r3, r2
 8012e9a:	81fb      	strh	r3, [r7, #14]

  /* Write to TIMx CCMR2 register */
  TIMx->CCMR2 = tmpccmr2;
 8012e9c:	687b      	ldr	r3, [r7, #4]
 8012e9e:	89fa      	ldrh	r2, [r7, #14]
 8012ea0:	839a      	strh	r2, [r3, #28]
}
 8012ea2:	bf00      	nop
 8012ea4:	3714      	adds	r7, #20
 8012ea6:	46bd      	mov	sp, r7
 8012ea8:	f85d 7b04 	ldr.w	r7, [sp], #4
 8012eac:	4770      	bx	lr

08012eae <TIM_ClearOC4Ref>:
  *            @arg TIM_OCClear_Enable: TIM Output clear enable
  *            @arg TIM_OCClear_Disable: TIM Output clear disable
  * @retval None
  */
void TIM_ClearOC4Ref(TIM_TypeDef* TIMx, uint16_t TIM_OCClear)
{
 8012eae:	b480      	push	{r7}
 8012eb0:	b085      	sub	sp, #20
 8012eb2:	af00      	add	r7, sp, #0
 8012eb4:	6078      	str	r0, [r7, #4]
 8012eb6:	460b      	mov	r3, r1
 8012eb8:	807b      	strh	r3, [r7, #2]
  uint16_t tmpccmr2 = 0;
 8012eba:	2300      	movs	r3, #0
 8012ebc:	81fb      	strh	r3, [r7, #14]

  /* Check the parameters */
  assert_param(IS_TIM_LIST3_PERIPH(TIMx));
  assert_param(IS_TIM_OCCLEAR_STATE(TIM_OCClear));

  tmpccmr2 = TIMx->CCMR2;
 8012ebe:	687b      	ldr	r3, [r7, #4]
 8012ec0:	8b9b      	ldrh	r3, [r3, #28]
 8012ec2:	81fb      	strh	r3, [r7, #14]

  /* Reset the OC4CE Bit */
  tmpccmr2 &= (uint16_t)~TIM_CCMR2_OC4CE;
 8012ec4:	89fb      	ldrh	r3, [r7, #14]
 8012ec6:	f3c3 030e 	ubfx	r3, r3, #0, #15
 8012eca:	81fb      	strh	r3, [r7, #14]

  /* Enable or Disable the Output Compare Clear Bit */
  tmpccmr2 |= (uint16_t)(TIM_OCClear << 8);
 8012ecc:	887b      	ldrh	r3, [r7, #2]
 8012ece:	021b      	lsls	r3, r3, #8
 8012ed0:	b29a      	uxth	r2, r3
 8012ed2:	89fb      	ldrh	r3, [r7, #14]
 8012ed4:	4313      	orrs	r3, r2
 8012ed6:	81fb      	strh	r3, [r7, #14]

  /* Write to TIMx CCMR2 register */
  TIMx->CCMR2 = tmpccmr2;
 8012ed8:	687b      	ldr	r3, [r7, #4]
 8012eda:	89fa      	ldrh	r2, [r7, #14]
 8012edc:	839a      	strh	r2, [r3, #28]
}
 8012ede:	bf00      	nop
 8012ee0:	3714      	adds	r7, #20
 8012ee2:	46bd      	mov	sp, r7
 8012ee4:	f85d 7b04 	ldr.w	r7, [sp], #4
 8012ee8:	4770      	bx	lr

08012eea <TIM_OC1PolarityConfig>:
  *            @arg TIM_OCPolarity_High: Output Compare active high
  *            @arg TIM_OCPolarity_Low: Output Compare active low
  * @retval None
  */
void TIM_OC1PolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPolarity)
{
 8012eea:	b480      	push	{r7}
 8012eec:	b085      	sub	sp, #20
 8012eee:	af00      	add	r7, sp, #0
 8012ef0:	6078      	str	r0, [r7, #4]
 8012ef2:	460b      	mov	r3, r1
 8012ef4:	807b      	strh	r3, [r7, #2]
  uint16_t tmpccer = 0;
 8012ef6:	2300      	movs	r3, #0
 8012ef8:	81fb      	strh	r3, [r7, #14]

  /* Check the parameters */
  assert_param(IS_TIM_LIST1_PERIPH(TIMx));
  assert_param(IS_TIM_OC_POLARITY(TIM_OCPolarity));

  tmpccer = TIMx->CCER;
 8012efa:	687b      	ldr	r3, [r7, #4]
 8012efc:	8c1b      	ldrh	r3, [r3, #32]
 8012efe:	81fb      	strh	r3, [r7, #14]

  /* Set or Reset the CC1P Bit */
  tmpccer &= (uint16_t)(~TIM_CCER_CC1P);
 8012f00:	89fb      	ldrh	r3, [r7, #14]
 8012f02:	f023 0302 	bic.w	r3, r3, #2
 8012f06:	81fb      	strh	r3, [r7, #14]
  tmpccer |= TIM_OCPolarity;
 8012f08:	89fa      	ldrh	r2, [r7, #14]
 8012f0a:	887b      	ldrh	r3, [r7, #2]
 8012f0c:	4313      	orrs	r3, r2
 8012f0e:	81fb      	strh	r3, [r7, #14]

  /* Write to TIMx CCER register */
  TIMx->CCER = tmpccer;
 8012f10:	687b      	ldr	r3, [r7, #4]
 8012f12:	89fa      	ldrh	r2, [r7, #14]
 8012f14:	841a      	strh	r2, [r3, #32]
}
 8012f16:	bf00      	nop
 8012f18:	3714      	adds	r7, #20
 8012f1a:	46bd      	mov	sp, r7
 8012f1c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8012f20:	4770      	bx	lr

08012f22 <TIM_OC1NPolarityConfig>:
  *            @arg TIM_OCNPolarity_High: Output Compare active high
  *            @arg TIM_OCNPolarity_Low: Output Compare active low
  * @retval None
  */
void TIM_OC1NPolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCNPolarity)
{
 8012f22:	b480      	push	{r7}
 8012f24:	b085      	sub	sp, #20
 8012f26:	af00      	add	r7, sp, #0
 8012f28:	6078      	str	r0, [r7, #4]
 8012f2a:	460b      	mov	r3, r1
 8012f2c:	807b      	strh	r3, [r7, #2]
  uint16_t tmpccer = 0;
 8012f2e:	2300      	movs	r3, #0
 8012f30:	81fb      	strh	r3, [r7, #14]
  /* Check the parameters */
  assert_param(IS_TIM_LIST4_PERIPH(TIMx));
  assert_param(IS_TIM_OCN_POLARITY(TIM_OCNPolarity));
   
  tmpccer = TIMx->CCER;
 8012f32:	687b      	ldr	r3, [r7, #4]
 8012f34:	8c1b      	ldrh	r3, [r3, #32]
 8012f36:	81fb      	strh	r3, [r7, #14]

  /* Set or Reset the CC1NP Bit */
  tmpccer &= (uint16_t)~TIM_CCER_CC1NP;
 8012f38:	89fb      	ldrh	r3, [r7, #14]
 8012f3a:	f023 0308 	bic.w	r3, r3, #8
 8012f3e:	81fb      	strh	r3, [r7, #14]
  tmpccer |= TIM_OCNPolarity;
 8012f40:	89fa      	ldrh	r2, [r7, #14]
 8012f42:	887b      	ldrh	r3, [r7, #2]
 8012f44:	4313      	orrs	r3, r2
 8012f46:	81fb      	strh	r3, [r7, #14]

  /* Write to TIMx CCER register */
  TIMx->CCER = tmpccer;
 8012f48:	687b      	ldr	r3, [r7, #4]
 8012f4a:	89fa      	ldrh	r2, [r7, #14]
 8012f4c:	841a      	strh	r2, [r3, #32]
}
 8012f4e:	bf00      	nop
 8012f50:	3714      	adds	r7, #20
 8012f52:	46bd      	mov	sp, r7
 8012f54:	f85d 7b04 	ldr.w	r7, [sp], #4
 8012f58:	4770      	bx	lr

08012f5a <TIM_OC2PolarityConfig>:
  *            @arg TIM_OCPolarity_High: Output Compare active high
  *            @arg TIM_OCPolarity_Low: Output Compare active low
  * @retval None
  */
void TIM_OC2PolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPolarity)
{
 8012f5a:	b480      	push	{r7}
 8012f5c:	b085      	sub	sp, #20
 8012f5e:	af00      	add	r7, sp, #0
 8012f60:	6078      	str	r0, [r7, #4]
 8012f62:	460b      	mov	r3, r1
 8012f64:	807b      	strh	r3, [r7, #2]
  uint16_t tmpccer = 0;
 8012f66:	2300      	movs	r3, #0
 8012f68:	81fb      	strh	r3, [r7, #14]

  /* Check the parameters */
  assert_param(IS_TIM_LIST2_PERIPH(TIMx));
  assert_param(IS_TIM_OC_POLARITY(TIM_OCPolarity));

  tmpccer = TIMx->CCER;
 8012f6a:	687b      	ldr	r3, [r7, #4]
 8012f6c:	8c1b      	ldrh	r3, [r3, #32]
 8012f6e:	81fb      	strh	r3, [r7, #14]

  /* Set or Reset the CC2P Bit */
  tmpccer &= (uint16_t)(~TIM_CCER_CC2P);
 8012f70:	89fb      	ldrh	r3, [r7, #14]
 8012f72:	f023 0320 	bic.w	r3, r3, #32
 8012f76:	81fb      	strh	r3, [r7, #14]
  tmpccer |= (uint16_t)(TIM_OCPolarity << 4);
 8012f78:	887b      	ldrh	r3, [r7, #2]
 8012f7a:	011b      	lsls	r3, r3, #4
 8012f7c:	b29a      	uxth	r2, r3
 8012f7e:	89fb      	ldrh	r3, [r7, #14]
 8012f80:	4313      	orrs	r3, r2
 8012f82:	81fb      	strh	r3, [r7, #14]

  /* Write to TIMx CCER register */
  TIMx->CCER = tmpccer;
 8012f84:	687b      	ldr	r3, [r7, #4]
 8012f86:	89fa      	ldrh	r2, [r7, #14]
 8012f88:	841a      	strh	r2, [r3, #32]
}
 8012f8a:	bf00      	nop
 8012f8c:	3714      	adds	r7, #20
 8012f8e:	46bd      	mov	sp, r7
 8012f90:	f85d 7b04 	ldr.w	r7, [sp], #4
 8012f94:	4770      	bx	lr

08012f96 <TIM_OC2NPolarityConfig>:
  *            @arg TIM_OCNPolarity_High: Output Compare active high
  *            @arg TIM_OCNPolarity_Low: Output Compare active low
  * @retval None
  */
void TIM_OC2NPolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCNPolarity)
{
 8012f96:	b480      	push	{r7}
 8012f98:	b085      	sub	sp, #20
 8012f9a:	af00      	add	r7, sp, #0
 8012f9c:	6078      	str	r0, [r7, #4]
 8012f9e:	460b      	mov	r3, r1
 8012fa0:	807b      	strh	r3, [r7, #2]
  uint16_t tmpccer = 0;
 8012fa2:	2300      	movs	r3, #0
 8012fa4:	81fb      	strh	r3, [r7, #14]

  /* Check the parameters */
  assert_param(IS_TIM_LIST4_PERIPH(TIMx));
  assert_param(IS_TIM_OCN_POLARITY(TIM_OCNPolarity));
  
  tmpccer = TIMx->CCER;
 8012fa6:	687b      	ldr	r3, [r7, #4]
 8012fa8:	8c1b      	ldrh	r3, [r3, #32]
 8012faa:	81fb      	strh	r3, [r7, #14]

  /* Set or Reset the CC2NP Bit */
  tmpccer &= (uint16_t)~TIM_CCER_CC2NP;
 8012fac:	89fb      	ldrh	r3, [r7, #14]
 8012fae:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 8012fb2:	81fb      	strh	r3, [r7, #14]
  tmpccer |= (uint16_t)(TIM_OCNPolarity << 4);
 8012fb4:	887b      	ldrh	r3, [r7, #2]
 8012fb6:	011b      	lsls	r3, r3, #4
 8012fb8:	b29a      	uxth	r2, r3
 8012fba:	89fb      	ldrh	r3, [r7, #14]
 8012fbc:	4313      	orrs	r3, r2
 8012fbe:	81fb      	strh	r3, [r7, #14]

  /* Write to TIMx CCER register */
  TIMx->CCER = tmpccer;
 8012fc0:	687b      	ldr	r3, [r7, #4]
 8012fc2:	89fa      	ldrh	r2, [r7, #14]
 8012fc4:	841a      	strh	r2, [r3, #32]
}
 8012fc6:	bf00      	nop
 8012fc8:	3714      	adds	r7, #20
 8012fca:	46bd      	mov	sp, r7
 8012fcc:	f85d 7b04 	ldr.w	r7, [sp], #4
 8012fd0:	4770      	bx	lr

08012fd2 <TIM_OC3PolarityConfig>:
  *            @arg TIM_OCPolarity_High: Output Compare active high
  *            @arg TIM_OCPolarity_Low: Output Compare active low
  * @retval None
  */
void TIM_OC3PolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPolarity)
{
 8012fd2:	b480      	push	{r7}
 8012fd4:	b085      	sub	sp, #20
 8012fd6:	af00      	add	r7, sp, #0
 8012fd8:	6078      	str	r0, [r7, #4]
 8012fda:	460b      	mov	r3, r1
 8012fdc:	807b      	strh	r3, [r7, #2]
  uint16_t tmpccer = 0;
 8012fde:	2300      	movs	r3, #0
 8012fe0:	81fb      	strh	r3, [r7, #14]

  /* Check the parameters */
  assert_param(IS_TIM_LIST3_PERIPH(TIMx));
  assert_param(IS_TIM_OC_POLARITY(TIM_OCPolarity));

  tmpccer = TIMx->CCER;
 8012fe2:	687b      	ldr	r3, [r7, #4]
 8012fe4:	8c1b      	ldrh	r3, [r3, #32]
 8012fe6:	81fb      	strh	r3, [r7, #14]

  /* Set or Reset the CC3P Bit */
  tmpccer &= (uint16_t)~TIM_CCER_CC3P;
 8012fe8:	89fb      	ldrh	r3, [r7, #14]
 8012fea:	f423 7300 	bic.w	r3, r3, #512	; 0x200
 8012fee:	81fb      	strh	r3, [r7, #14]
  tmpccer |= (uint16_t)(TIM_OCPolarity << 8);
 8012ff0:	887b      	ldrh	r3, [r7, #2]
 8012ff2:	021b      	lsls	r3, r3, #8
 8012ff4:	b29a      	uxth	r2, r3
 8012ff6:	89fb      	ldrh	r3, [r7, #14]
 8012ff8:	4313      	orrs	r3, r2
 8012ffa:	81fb      	strh	r3, [r7, #14]

  /* Write to TIMx CCER register */
  TIMx->CCER = tmpccer;
 8012ffc:	687b      	ldr	r3, [r7, #4]
 8012ffe:	89fa      	ldrh	r2, [r7, #14]
 8013000:	841a      	strh	r2, [r3, #32]
}
 8013002:	bf00      	nop
 8013004:	3714      	adds	r7, #20
 8013006:	46bd      	mov	sp, r7
 8013008:	f85d 7b04 	ldr.w	r7, [sp], #4
 801300c:	4770      	bx	lr

0801300e <TIM_OC3NPolarityConfig>:
  *            @arg TIM_OCNPolarity_High: Output Compare active high
  *            @arg TIM_OCNPolarity_Low: Output Compare active low
  * @retval None
  */
void TIM_OC3NPolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCNPolarity)
{
 801300e:	b480      	push	{r7}
 8013010:	b085      	sub	sp, #20
 8013012:	af00      	add	r7, sp, #0
 8013014:	6078      	str	r0, [r7, #4]
 8013016:	460b      	mov	r3, r1
 8013018:	807b      	strh	r3, [r7, #2]
  uint16_t tmpccer = 0;
 801301a:	2300      	movs	r3, #0
 801301c:	81fb      	strh	r3, [r7, #14]
 
  /* Check the parameters */
  assert_param(IS_TIM_LIST4_PERIPH(TIMx));
  assert_param(IS_TIM_OCN_POLARITY(TIM_OCNPolarity));
    
  tmpccer = TIMx->CCER;
 801301e:	687b      	ldr	r3, [r7, #4]
 8013020:	8c1b      	ldrh	r3, [r3, #32]
 8013022:	81fb      	strh	r3, [r7, #14]

  /* Set or Reset the CC3NP Bit */
  tmpccer &= (uint16_t)~TIM_CCER_CC3NP;
 8013024:	89fb      	ldrh	r3, [r7, #14]
 8013026:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
 801302a:	81fb      	strh	r3, [r7, #14]
  tmpccer |= (uint16_t)(TIM_OCNPolarity << 8);
 801302c:	887b      	ldrh	r3, [r7, #2]
 801302e:	021b      	lsls	r3, r3, #8
 8013030:	b29a      	uxth	r2, r3
 8013032:	89fb      	ldrh	r3, [r7, #14]
 8013034:	4313      	orrs	r3, r2
 8013036:	81fb      	strh	r3, [r7, #14]

  /* Write to TIMx CCER register */
  TIMx->CCER = tmpccer;
 8013038:	687b      	ldr	r3, [r7, #4]
 801303a:	89fa      	ldrh	r2, [r7, #14]
 801303c:	841a      	strh	r2, [r3, #32]
}
 801303e:	bf00      	nop
 8013040:	3714      	adds	r7, #20
 8013042:	46bd      	mov	sp, r7
 8013044:	f85d 7b04 	ldr.w	r7, [sp], #4
 8013048:	4770      	bx	lr

0801304a <TIM_OC4PolarityConfig>:
  *            @arg TIM_OCPolarity_High: Output Compare active high
  *            @arg TIM_OCPolarity_Low: Output Compare active low
  * @retval None
  */
void TIM_OC4PolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPolarity)
{
 801304a:	b480      	push	{r7}
 801304c:	b085      	sub	sp, #20
 801304e:	af00      	add	r7, sp, #0
 8013050:	6078      	str	r0, [r7, #4]
 8013052:	460b      	mov	r3, r1
 8013054:	807b      	strh	r3, [r7, #2]
  uint16_t tmpccer = 0;
 8013056:	2300      	movs	r3, #0
 8013058:	81fb      	strh	r3, [r7, #14]

  /* Check the parameters */
  assert_param(IS_TIM_LIST3_PERIPH(TIMx));
  assert_param(IS_TIM_OC_POLARITY(TIM_OCPolarity));

  tmpccer = TIMx->CCER;
 801305a:	687b      	ldr	r3, [r7, #4]
 801305c:	8c1b      	ldrh	r3, [r3, #32]
 801305e:	81fb      	strh	r3, [r7, #14]

  /* Set or Reset the CC4P Bit */
  tmpccer &= (uint16_t)~TIM_CCER_CC4P;
 8013060:	89fb      	ldrh	r3, [r7, #14]
 8013062:	f423 5300 	bic.w	r3, r3, #8192	; 0x2000
 8013066:	81fb      	strh	r3, [r7, #14]
  tmpccer |= (uint16_t)(TIM_OCPolarity << 12);
 8013068:	887b      	ldrh	r3, [r7, #2]
 801306a:	031b      	lsls	r3, r3, #12
 801306c:	b29a      	uxth	r2, r3
 801306e:	89fb      	ldrh	r3, [r7, #14]
 8013070:	4313      	orrs	r3, r2
 8013072:	81fb      	strh	r3, [r7, #14]

  /* Write to TIMx CCER register */
  TIMx->CCER = tmpccer;
 8013074:	687b      	ldr	r3, [r7, #4]
 8013076:	89fa      	ldrh	r2, [r7, #14]
 8013078:	841a      	strh	r2, [r3, #32]
}
 801307a:	bf00      	nop
 801307c:	3714      	adds	r7, #20
 801307e:	46bd      	mov	sp, r7
 8013080:	f85d 7b04 	ldr.w	r7, [sp], #4
 8013084:	4770      	bx	lr

08013086 <TIM_CCxCmd>:
  * @param  TIM_CCx: specifies the TIM Channel CCxE bit new state.
  *          This parameter can be: TIM_CCx_Enable or TIM_CCx_Disable. 
  * @retval None
  */
void TIM_CCxCmd(TIM_TypeDef* TIMx, uint16_t TIM_Channel, uint16_t TIM_CCx)
{
 8013086:	b480      	push	{r7}
 8013088:	b085      	sub	sp, #20
 801308a:	af00      	add	r7, sp, #0
 801308c:	6078      	str	r0, [r7, #4]
 801308e:	460b      	mov	r3, r1
 8013090:	807b      	strh	r3, [r7, #2]
 8013092:	4613      	mov	r3, r2
 8013094:	803b      	strh	r3, [r7, #0]
  uint16_t tmp = 0;
 8013096:	2300      	movs	r3, #0
 8013098:	81fb      	strh	r3, [r7, #14]
  /* Check the parameters */
  assert_param(IS_TIM_LIST1_PERIPH(TIMx)); 
  assert_param(IS_TIM_CHANNEL(TIM_Channel));
  assert_param(IS_TIM_CCX(TIM_CCx));

  tmp = CCER_CCE_SET << TIM_Channel;
 801309a:	887b      	ldrh	r3, [r7, #2]
 801309c:	2201      	movs	r2, #1
 801309e:	fa02 f303 	lsl.w	r3, r2, r3
 80130a2:	81fb      	strh	r3, [r7, #14]

  /* Reset the CCxE Bit */
  TIMx->CCER &= (uint16_t)~ tmp;
 80130a4:	687b      	ldr	r3, [r7, #4]
 80130a6:	8c1b      	ldrh	r3, [r3, #32]
 80130a8:	b29a      	uxth	r2, r3
 80130aa:	89fb      	ldrh	r3, [r7, #14]
 80130ac:	43db      	mvns	r3, r3
 80130ae:	b29b      	uxth	r3, r3
 80130b0:	4013      	ands	r3, r2
 80130b2:	b29a      	uxth	r2, r3
 80130b4:	687b      	ldr	r3, [r7, #4]
 80130b6:	841a      	strh	r2, [r3, #32]

  /* Set or reset the CCxE Bit */ 
  TIMx->CCER |=  (uint16_t)(TIM_CCx << TIM_Channel);
 80130b8:	687b      	ldr	r3, [r7, #4]
 80130ba:	8c1b      	ldrh	r3, [r3, #32]
 80130bc:	b29a      	uxth	r2, r3
 80130be:	8839      	ldrh	r1, [r7, #0]
 80130c0:	887b      	ldrh	r3, [r7, #2]
 80130c2:	fa01 f303 	lsl.w	r3, r1, r3
 80130c6:	b29b      	uxth	r3, r3
 80130c8:	4313      	orrs	r3, r2
 80130ca:	b29a      	uxth	r2, r3
 80130cc:	687b      	ldr	r3, [r7, #4]
 80130ce:	841a      	strh	r2, [r3, #32]
}
 80130d0:	bf00      	nop
 80130d2:	3714      	adds	r7, #20
 80130d4:	46bd      	mov	sp, r7
 80130d6:	f85d 7b04 	ldr.w	r7, [sp], #4
 80130da:	4770      	bx	lr

080130dc <TIM_CCxNCmd>:
  * @param  TIM_CCxN: specifies the TIM Channel CCxNE bit new state.
  *          This parameter can be: TIM_CCxN_Enable or TIM_CCxN_Disable. 
  * @retval None
  */
void TIM_CCxNCmd(TIM_TypeDef* TIMx, uint16_t TIM_Channel, uint16_t TIM_CCxN)
{
 80130dc:	b480      	push	{r7}
 80130de:	b085      	sub	sp, #20
 80130e0:	af00      	add	r7, sp, #0
 80130e2:	6078      	str	r0, [r7, #4]
 80130e4:	460b      	mov	r3, r1
 80130e6:	807b      	strh	r3, [r7, #2]
 80130e8:	4613      	mov	r3, r2
 80130ea:	803b      	strh	r3, [r7, #0]
  uint16_t tmp = 0;
 80130ec:	2300      	movs	r3, #0
 80130ee:	81fb      	strh	r3, [r7, #14]
  /* Check the parameters */
  assert_param(IS_TIM_LIST4_PERIPH(TIMx));
  assert_param(IS_TIM_COMPLEMENTARY_CHANNEL(TIM_Channel));
  assert_param(IS_TIM_CCXN(TIM_CCxN));

  tmp = CCER_CCNE_SET << TIM_Channel;
 80130f0:	887b      	ldrh	r3, [r7, #2]
 80130f2:	2204      	movs	r2, #4
 80130f4:	fa02 f303 	lsl.w	r3, r2, r3
 80130f8:	81fb      	strh	r3, [r7, #14]

  /* Reset the CCxNE Bit */
  TIMx->CCER &= (uint16_t) ~tmp;
 80130fa:	687b      	ldr	r3, [r7, #4]
 80130fc:	8c1b      	ldrh	r3, [r3, #32]
 80130fe:	b29a      	uxth	r2, r3
 8013100:	89fb      	ldrh	r3, [r7, #14]
 8013102:	43db      	mvns	r3, r3
 8013104:	b29b      	uxth	r3, r3
 8013106:	4013      	ands	r3, r2
 8013108:	b29a      	uxth	r2, r3
 801310a:	687b      	ldr	r3, [r7, #4]
 801310c:	841a      	strh	r2, [r3, #32]

  /* Set or reset the CCxNE Bit */ 
  TIMx->CCER |=  (uint16_t)(TIM_CCxN << TIM_Channel);
 801310e:	687b      	ldr	r3, [r7, #4]
 8013110:	8c1b      	ldrh	r3, [r3, #32]
 8013112:	b29a      	uxth	r2, r3
 8013114:	8839      	ldrh	r1, [r7, #0]
 8013116:	887b      	ldrh	r3, [r7, #2]
 8013118:	fa01 f303 	lsl.w	r3, r1, r3
 801311c:	b29b      	uxth	r3, r3
 801311e:	4313      	orrs	r3, r2
 8013120:	b29a      	uxth	r2, r3
 8013122:	687b      	ldr	r3, [r7, #4]
 8013124:	841a      	strh	r2, [r3, #32]
}
 8013126:	bf00      	nop
 8013128:	3714      	adds	r7, #20
 801312a:	46bd      	mov	sp, r7
 801312c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8013130:	4770      	bx	lr

08013132 <TIM_ICInit>:
  * @param  TIM_ICInitStruct: pointer to a TIM_ICInitTypeDef structure that contains
  *         the configuration information for the specified TIM peripheral.
  * @retval None
  */
void TIM_ICInit(TIM_TypeDef* TIMx, TIM_ICInitTypeDef* TIM_ICInitStruct)
{
 8013132:	b580      	push	{r7, lr}
 8013134:	b082      	sub	sp, #8
 8013136:	af00      	add	r7, sp, #0
 8013138:	6078      	str	r0, [r7, #4]
 801313a:	6039      	str	r1, [r7, #0]
  assert_param(IS_TIM_IC_POLARITY(TIM_ICInitStruct->TIM_ICPolarity));
  assert_param(IS_TIM_IC_SELECTION(TIM_ICInitStruct->TIM_ICSelection));
  assert_param(IS_TIM_IC_PRESCALER(TIM_ICInitStruct->TIM_ICPrescaler));
  assert_param(IS_TIM_IC_FILTER(TIM_ICInitStruct->TIM_ICFilter));
  
  if (TIM_ICInitStruct->TIM_Channel == TIM_Channel_1)
 801313c:	683b      	ldr	r3, [r7, #0]
 801313e:	881b      	ldrh	r3, [r3, #0]
 8013140:	2b00      	cmp	r3, #0
 8013142:	d10f      	bne.n	8013164 <TIM_ICInit+0x32>
  {
    /* TI1 Configuration */
    TI1_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity,
 8013144:	683b      	ldr	r3, [r7, #0]
 8013146:	8859      	ldrh	r1, [r3, #2]
 8013148:	683b      	ldr	r3, [r7, #0]
 801314a:	889a      	ldrh	r2, [r3, #4]
 801314c:	683b      	ldr	r3, [r7, #0]
 801314e:	891b      	ldrh	r3, [r3, #8]
 8013150:	6878      	ldr	r0, [r7, #4]
 8013152:	f000 fcb7 	bl	8013ac4 <TI1_Config>
               TIM_ICInitStruct->TIM_ICSelection,
               TIM_ICInitStruct->TIM_ICFilter);
    /* Set the Input Capture Prescaler value */
    TIM_SetIC1Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
 8013156:	683b      	ldr	r3, [r7, #0]
 8013158:	88db      	ldrh	r3, [r3, #6]
 801315a:	4619      	mov	r1, r3
 801315c:	6878      	ldr	r0, [r7, #4]
 801315e:	f000 f8e1 	bl	8013324 <TIM_SetIC1Prescaler>
               TIM_ICInitStruct->TIM_ICSelection,
               TIM_ICInitStruct->TIM_ICFilter);
    /* Set the Input Capture Prescaler value */
    TIM_SetIC4Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
  }
}
 8013162:	e036      	b.n	80131d2 <TIM_ICInit+0xa0>
  else if (TIM_ICInitStruct->TIM_Channel == TIM_Channel_2)
 8013164:	683b      	ldr	r3, [r7, #0]
 8013166:	881b      	ldrh	r3, [r3, #0]
 8013168:	2b04      	cmp	r3, #4
 801316a:	d10f      	bne.n	801318c <TIM_ICInit+0x5a>
    TI2_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity,
 801316c:	683b      	ldr	r3, [r7, #0]
 801316e:	8859      	ldrh	r1, [r3, #2]
 8013170:	683b      	ldr	r3, [r7, #0]
 8013172:	889a      	ldrh	r2, [r3, #4]
 8013174:	683b      	ldr	r3, [r7, #0]
 8013176:	891b      	ldrh	r3, [r3, #8]
 8013178:	6878      	ldr	r0, [r7, #4]
 801317a:	f000 fce6 	bl	8013b4a <TI2_Config>
    TIM_SetIC2Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
 801317e:	683b      	ldr	r3, [r7, #0]
 8013180:	88db      	ldrh	r3, [r3, #6]
 8013182:	4619      	mov	r1, r3
 8013184:	6878      	ldr	r0, [r7, #4]
 8013186:	f000 f8e9 	bl	801335c <TIM_SetIC2Prescaler>
}
 801318a:	e022      	b.n	80131d2 <TIM_ICInit+0xa0>
  else if (TIM_ICInitStruct->TIM_Channel == TIM_Channel_3)
 801318c:	683b      	ldr	r3, [r7, #0]
 801318e:	881b      	ldrh	r3, [r3, #0]
 8013190:	2b08      	cmp	r3, #8
 8013192:	d10f      	bne.n	80131b4 <TIM_ICInit+0x82>
    TI3_Config(TIMx,  TIM_ICInitStruct->TIM_ICPolarity,
 8013194:	683b      	ldr	r3, [r7, #0]
 8013196:	8859      	ldrh	r1, [r3, #2]
 8013198:	683b      	ldr	r3, [r7, #0]
 801319a:	889a      	ldrh	r2, [r3, #4]
 801319c:	683b      	ldr	r3, [r7, #0]
 801319e:	891b      	ldrh	r3, [r3, #8]
 80131a0:	6878      	ldr	r0, [r7, #4]
 80131a2:	f000 fd1f 	bl	8013be4 <TI3_Config>
    TIM_SetIC3Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
 80131a6:	683b      	ldr	r3, [r7, #0]
 80131a8:	88db      	ldrh	r3, [r3, #6]
 80131aa:	4619      	mov	r1, r3
 80131ac:	6878      	ldr	r0, [r7, #4]
 80131ae:	f000 f8f3 	bl	8013398 <TIM_SetIC3Prescaler>
}
 80131b2:	e00e      	b.n	80131d2 <TIM_ICInit+0xa0>
    TI4_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity,
 80131b4:	683b      	ldr	r3, [r7, #0]
 80131b6:	8859      	ldrh	r1, [r3, #2]
 80131b8:	683b      	ldr	r3, [r7, #0]
 80131ba:	889a      	ldrh	r2, [r3, #4]
 80131bc:	683b      	ldr	r3, [r7, #0]
 80131be:	891b      	ldrh	r3, [r3, #8]
 80131c0:	6878      	ldr	r0, [r7, #4]
 80131c2:	f000 fd57 	bl	8013c74 <TI4_Config>
    TIM_SetIC4Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
 80131c6:	683b      	ldr	r3, [r7, #0]
 80131c8:	88db      	ldrh	r3, [r3, #6]
 80131ca:	4619      	mov	r1, r3
 80131cc:	6878      	ldr	r0, [r7, #4]
 80131ce:	f000 f8ff 	bl	80133d0 <TIM_SetIC4Prescaler>
}
 80131d2:	bf00      	nop
 80131d4:	3708      	adds	r7, #8
 80131d6:	46bd      	mov	sp, r7
 80131d8:	bd80      	pop	{r7, pc}

080131da <TIM_ICStructInit>:
  * @param  TIM_ICInitStruct: pointer to a TIM_ICInitTypeDef structure which will
  *         be initialized.
  * @retval None
  */
void TIM_ICStructInit(TIM_ICInitTypeDef* TIM_ICInitStruct)
{
 80131da:	b480      	push	{r7}
 80131dc:	b083      	sub	sp, #12
 80131de:	af00      	add	r7, sp, #0
 80131e0:	6078      	str	r0, [r7, #4]
  /* Set the default configuration */
  TIM_ICInitStruct->TIM_Channel = TIM_Channel_1;
 80131e2:	687b      	ldr	r3, [r7, #4]
 80131e4:	2200      	movs	r2, #0
 80131e6:	801a      	strh	r2, [r3, #0]
  TIM_ICInitStruct->TIM_ICPolarity = TIM_ICPolarity_Rising;
 80131e8:	687b      	ldr	r3, [r7, #4]
 80131ea:	2200      	movs	r2, #0
 80131ec:	805a      	strh	r2, [r3, #2]
  TIM_ICInitStruct->TIM_ICSelection = TIM_ICSelection_DirectTI;
 80131ee:	687b      	ldr	r3, [r7, #4]
 80131f0:	2201      	movs	r2, #1
 80131f2:	809a      	strh	r2, [r3, #4]
  TIM_ICInitStruct->TIM_ICPrescaler = TIM_ICPSC_DIV1;
 80131f4:	687b      	ldr	r3, [r7, #4]
 80131f6:	2200      	movs	r2, #0
 80131f8:	80da      	strh	r2, [r3, #6]
  TIM_ICInitStruct->TIM_ICFilter = 0x00;
 80131fa:	687b      	ldr	r3, [r7, #4]
 80131fc:	2200      	movs	r2, #0
 80131fe:	811a      	strh	r2, [r3, #8]
}
 8013200:	bf00      	nop
 8013202:	370c      	adds	r7, #12
 8013204:	46bd      	mov	sp, r7
 8013206:	f85d 7b04 	ldr.w	r7, [sp], #4
 801320a:	4770      	bx	lr

0801320c <TIM_PWMIConfig>:
  * @param  TIM_ICInitStruct: pointer to a TIM_ICInitTypeDef structure that contains
  *         the configuration information for the specified TIM peripheral.
  * @retval None
  */
void TIM_PWMIConfig(TIM_TypeDef* TIMx, TIM_ICInitTypeDef* TIM_ICInitStruct)
{
 801320c:	b580      	push	{r7, lr}
 801320e:	b084      	sub	sp, #16
 8013210:	af00      	add	r7, sp, #0
 8013212:	6078      	str	r0, [r7, #4]
 8013214:	6039      	str	r1, [r7, #0]
  uint16_t icoppositepolarity = TIM_ICPolarity_Rising;
 8013216:	2300      	movs	r3, #0
 8013218:	81fb      	strh	r3, [r7, #14]
  uint16_t icoppositeselection = TIM_ICSelection_DirectTI;
 801321a:	2301      	movs	r3, #1
 801321c:	81bb      	strh	r3, [r7, #12]

  /* Check the parameters */
  assert_param(IS_TIM_LIST2_PERIPH(TIMx));

  /* Select the Opposite Input Polarity */
  if (TIM_ICInitStruct->TIM_ICPolarity == TIM_ICPolarity_Rising)
 801321e:	683b      	ldr	r3, [r7, #0]
 8013220:	885b      	ldrh	r3, [r3, #2]
 8013222:	2b00      	cmp	r3, #0
 8013224:	d102      	bne.n	801322c <TIM_PWMIConfig+0x20>
  {
    icoppositepolarity = TIM_ICPolarity_Falling;
 8013226:	2302      	movs	r3, #2
 8013228:	81fb      	strh	r3, [r7, #14]
 801322a:	e001      	b.n	8013230 <TIM_PWMIConfig+0x24>
  }
  else
  {
    icoppositepolarity = TIM_ICPolarity_Rising;
 801322c:	2300      	movs	r3, #0
 801322e:	81fb      	strh	r3, [r7, #14]
  }
  /* Select the Opposite Input */
  if (TIM_ICInitStruct->TIM_ICSelection == TIM_ICSelection_DirectTI)
 8013230:	683b      	ldr	r3, [r7, #0]
 8013232:	889b      	ldrh	r3, [r3, #4]
 8013234:	2b01      	cmp	r3, #1
 8013236:	d102      	bne.n	801323e <TIM_PWMIConfig+0x32>
  {
    icoppositeselection = TIM_ICSelection_IndirectTI;
 8013238:	2302      	movs	r3, #2
 801323a:	81bb      	strh	r3, [r7, #12]
 801323c:	e001      	b.n	8013242 <TIM_PWMIConfig+0x36>
  }
  else
  {
    icoppositeselection = TIM_ICSelection_DirectTI;
 801323e:	2301      	movs	r3, #1
 8013240:	81bb      	strh	r3, [r7, #12]
  }
  if (TIM_ICInitStruct->TIM_Channel == TIM_Channel_1)
 8013242:	683b      	ldr	r3, [r7, #0]
 8013244:	881b      	ldrh	r3, [r3, #0]
 8013246:	2b00      	cmp	r3, #0
 8013248:	d11c      	bne.n	8013284 <TIM_PWMIConfig+0x78>
  {
    /* TI1 Configuration */
    TI1_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity, TIM_ICInitStruct->TIM_ICSelection,
 801324a:	683b      	ldr	r3, [r7, #0]
 801324c:	8859      	ldrh	r1, [r3, #2]
 801324e:	683b      	ldr	r3, [r7, #0]
 8013250:	889a      	ldrh	r2, [r3, #4]
 8013252:	683b      	ldr	r3, [r7, #0]
 8013254:	891b      	ldrh	r3, [r3, #8]
 8013256:	6878      	ldr	r0, [r7, #4]
 8013258:	f000 fc34 	bl	8013ac4 <TI1_Config>
               TIM_ICInitStruct->TIM_ICFilter);
    /* Set the Input Capture Prescaler value */
    TIM_SetIC1Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
 801325c:	683b      	ldr	r3, [r7, #0]
 801325e:	88db      	ldrh	r3, [r3, #6]
 8013260:	4619      	mov	r1, r3
 8013262:	6878      	ldr	r0, [r7, #4]
 8013264:	f000 f85e 	bl	8013324 <TIM_SetIC1Prescaler>
    /* TI2 Configuration */
    TI2_Config(TIMx, icoppositepolarity, icoppositeselection, TIM_ICInitStruct->TIM_ICFilter);
 8013268:	683b      	ldr	r3, [r7, #0]
 801326a:	891b      	ldrh	r3, [r3, #8]
 801326c:	89ba      	ldrh	r2, [r7, #12]
 801326e:	89f9      	ldrh	r1, [r7, #14]
 8013270:	6878      	ldr	r0, [r7, #4]
 8013272:	f000 fc6a 	bl	8013b4a <TI2_Config>
    /* Set the Input Capture Prescaler value */
    TIM_SetIC2Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
 8013276:	683b      	ldr	r3, [r7, #0]
 8013278:	88db      	ldrh	r3, [r3, #6]
 801327a:	4619      	mov	r1, r3
 801327c:	6878      	ldr	r0, [r7, #4]
 801327e:	f000 f86d 	bl	801335c <TIM_SetIC2Prescaler>
    /* TI1 Configuration */
    TI1_Config(TIMx, icoppositepolarity, icoppositeselection, TIM_ICInitStruct->TIM_ICFilter);
    /* Set the Input Capture Prescaler value */
    TIM_SetIC1Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
  }
}
 8013282:	e01b      	b.n	80132bc <TIM_PWMIConfig+0xb0>
    TI2_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity, TIM_ICInitStruct->TIM_ICSelection,
 8013284:	683b      	ldr	r3, [r7, #0]
 8013286:	8859      	ldrh	r1, [r3, #2]
 8013288:	683b      	ldr	r3, [r7, #0]
 801328a:	889a      	ldrh	r2, [r3, #4]
 801328c:	683b      	ldr	r3, [r7, #0]
 801328e:	891b      	ldrh	r3, [r3, #8]
 8013290:	6878      	ldr	r0, [r7, #4]
 8013292:	f000 fc5a 	bl	8013b4a <TI2_Config>
    TIM_SetIC2Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
 8013296:	683b      	ldr	r3, [r7, #0]
 8013298:	88db      	ldrh	r3, [r3, #6]
 801329a:	4619      	mov	r1, r3
 801329c:	6878      	ldr	r0, [r7, #4]
 801329e:	f000 f85d 	bl	801335c <TIM_SetIC2Prescaler>
    TI1_Config(TIMx, icoppositepolarity, icoppositeselection, TIM_ICInitStruct->TIM_ICFilter);
 80132a2:	683b      	ldr	r3, [r7, #0]
 80132a4:	891b      	ldrh	r3, [r3, #8]
 80132a6:	89ba      	ldrh	r2, [r7, #12]
 80132a8:	89f9      	ldrh	r1, [r7, #14]
 80132aa:	6878      	ldr	r0, [r7, #4]
 80132ac:	f000 fc0a 	bl	8013ac4 <TI1_Config>
    TIM_SetIC1Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
 80132b0:	683b      	ldr	r3, [r7, #0]
 80132b2:	88db      	ldrh	r3, [r3, #6]
 80132b4:	4619      	mov	r1, r3
 80132b6:	6878      	ldr	r0, [r7, #4]
 80132b8:	f000 f834 	bl	8013324 <TIM_SetIC1Prescaler>
}
 80132bc:	bf00      	nop
 80132be:	3710      	adds	r7, #16
 80132c0:	46bd      	mov	sp, r7
 80132c2:	bd80      	pop	{r7, pc}

080132c4 <TIM_GetCapture1>:
  * @brief  Gets the TIMx Input Capture 1 value.
  * @param  TIMx: where x can be 1 to 14 except 6 and 7, to select the TIM peripheral.
  * @retval Capture Compare 1 Register value.
  */
uint32_t TIM_GetCapture1(TIM_TypeDef* TIMx)
{
 80132c4:	b480      	push	{r7}
 80132c6:	b083      	sub	sp, #12
 80132c8:	af00      	add	r7, sp, #0
 80132ca:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_TIM_LIST1_PERIPH(TIMx));

  /* Get the Capture 1 Register value */
  return TIMx->CCR1;
 80132cc:	687b      	ldr	r3, [r7, #4]
 80132ce:	6b5b      	ldr	r3, [r3, #52]	; 0x34
}
 80132d0:	4618      	mov	r0, r3
 80132d2:	370c      	adds	r7, #12
 80132d4:	46bd      	mov	sp, r7
 80132d6:	f85d 7b04 	ldr.w	r7, [sp], #4
 80132da:	4770      	bx	lr

080132dc <TIM_GetCapture2>:
  * @param  TIMx: where x can be 1, 2, 3, 4, 5, 8, 9 or 12 to select the TIM 
  *         peripheral.
  * @retval Capture Compare 2 Register value.
  */
uint32_t TIM_GetCapture2(TIM_TypeDef* TIMx)
{
 80132dc:	b480      	push	{r7}
 80132de:	b083      	sub	sp, #12
 80132e0:	af00      	add	r7, sp, #0
 80132e2:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_TIM_LIST2_PERIPH(TIMx));

  /* Get the Capture 2 Register value */
  return TIMx->CCR2;
 80132e4:	687b      	ldr	r3, [r7, #4]
 80132e6:	6b9b      	ldr	r3, [r3, #56]	; 0x38
}
 80132e8:	4618      	mov	r0, r3
 80132ea:	370c      	adds	r7, #12
 80132ec:	46bd      	mov	sp, r7
 80132ee:	f85d 7b04 	ldr.w	r7, [sp], #4
 80132f2:	4770      	bx	lr

080132f4 <TIM_GetCapture3>:
  * @brief  Gets the TIMx Input Capture 3 value.
  * @param  TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
  * @retval Capture Compare 3 Register value.
  */
uint32_t TIM_GetCapture3(TIM_TypeDef* TIMx)
{
 80132f4:	b480      	push	{r7}
 80132f6:	b083      	sub	sp, #12
 80132f8:	af00      	add	r7, sp, #0
 80132fa:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_TIM_LIST3_PERIPH(TIMx)); 

  /* Get the Capture 3 Register value */
  return TIMx->CCR3;
 80132fc:	687b      	ldr	r3, [r7, #4]
 80132fe:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
}
 8013300:	4618      	mov	r0, r3
 8013302:	370c      	adds	r7, #12
 8013304:	46bd      	mov	sp, r7
 8013306:	f85d 7b04 	ldr.w	r7, [sp], #4
 801330a:	4770      	bx	lr

0801330c <TIM_GetCapture4>:
  * @brief  Gets the TIMx Input Capture 4 value.
  * @param  TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
  * @retval Capture Compare 4 Register value.
  */
uint32_t TIM_GetCapture4(TIM_TypeDef* TIMx)
{
 801330c:	b480      	push	{r7}
 801330e:	b083      	sub	sp, #12
 8013310:	af00      	add	r7, sp, #0
 8013312:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_TIM_LIST3_PERIPH(TIMx));

  /* Get the Capture 4 Register value */
  return TIMx->CCR4;
 8013314:	687b      	ldr	r3, [r7, #4]
 8013316:	6c1b      	ldr	r3, [r3, #64]	; 0x40
}
 8013318:	4618      	mov	r0, r3
 801331a:	370c      	adds	r7, #12
 801331c:	46bd      	mov	sp, r7
 801331e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8013322:	4770      	bx	lr

08013324 <TIM_SetIC1Prescaler>:
  *            @arg TIM_ICPSC_DIV4: capture is done once every 4 events
  *            @arg TIM_ICPSC_DIV8: capture is done once every 8 events
  * @retval None
  */
void TIM_SetIC1Prescaler(TIM_TypeDef* TIMx, uint16_t TIM_ICPSC)
{
 8013324:	b480      	push	{r7}
 8013326:	b083      	sub	sp, #12
 8013328:	af00      	add	r7, sp, #0
 801332a:	6078      	str	r0, [r7, #4]
 801332c:	460b      	mov	r3, r1
 801332e:	807b      	strh	r3, [r7, #2]
  /* Check the parameters */
  assert_param(IS_TIM_LIST1_PERIPH(TIMx));
  assert_param(IS_TIM_IC_PRESCALER(TIM_ICPSC));

  /* Reset the IC1PSC Bits */
  TIMx->CCMR1 &= (uint16_t)~TIM_CCMR1_IC1PSC;
 8013330:	687b      	ldr	r3, [r7, #4]
 8013332:	8b1b      	ldrh	r3, [r3, #24]
 8013334:	b29b      	uxth	r3, r3
 8013336:	f023 030c 	bic.w	r3, r3, #12
 801333a:	b29a      	uxth	r2, r3
 801333c:	687b      	ldr	r3, [r7, #4]
 801333e:	831a      	strh	r2, [r3, #24]

  /* Set the IC1PSC value */
  TIMx->CCMR1 |= TIM_ICPSC;
 8013340:	687b      	ldr	r3, [r7, #4]
 8013342:	8b1b      	ldrh	r3, [r3, #24]
 8013344:	b29a      	uxth	r2, r3
 8013346:	887b      	ldrh	r3, [r7, #2]
 8013348:	4313      	orrs	r3, r2
 801334a:	b29a      	uxth	r2, r3
 801334c:	687b      	ldr	r3, [r7, #4]
 801334e:	831a      	strh	r2, [r3, #24]
}
 8013350:	bf00      	nop
 8013352:	370c      	adds	r7, #12
 8013354:	46bd      	mov	sp, r7
 8013356:	f85d 7b04 	ldr.w	r7, [sp], #4
 801335a:	4770      	bx	lr

0801335c <TIM_SetIC2Prescaler>:
  *            @arg TIM_ICPSC_DIV4: capture is done once every 4 events
  *            @arg TIM_ICPSC_DIV8: capture is done once every 8 events
  * @retval None
  */
void TIM_SetIC2Prescaler(TIM_TypeDef* TIMx, uint16_t TIM_ICPSC)
{
 801335c:	b480      	push	{r7}
 801335e:	b083      	sub	sp, #12
 8013360:	af00      	add	r7, sp, #0
 8013362:	6078      	str	r0, [r7, #4]
 8013364:	460b      	mov	r3, r1
 8013366:	807b      	strh	r3, [r7, #2]
  /* Check the parameters */
  assert_param(IS_TIM_LIST2_PERIPH(TIMx));
  assert_param(IS_TIM_IC_PRESCALER(TIM_ICPSC));

  /* Reset the IC2PSC Bits */
  TIMx->CCMR1 &= (uint16_t)~TIM_CCMR1_IC2PSC;
 8013368:	687b      	ldr	r3, [r7, #4]
 801336a:	8b1b      	ldrh	r3, [r3, #24]
 801336c:	b29b      	uxth	r3, r3
 801336e:	f423 6340 	bic.w	r3, r3, #3072	; 0xc00
 8013372:	b29a      	uxth	r2, r3
 8013374:	687b      	ldr	r3, [r7, #4]
 8013376:	831a      	strh	r2, [r3, #24]

  /* Set the IC2PSC value */
  TIMx->CCMR1 |= (uint16_t)(TIM_ICPSC << 8);
 8013378:	687b      	ldr	r3, [r7, #4]
 801337a:	8b1b      	ldrh	r3, [r3, #24]
 801337c:	b29a      	uxth	r2, r3
 801337e:	887b      	ldrh	r3, [r7, #2]
 8013380:	021b      	lsls	r3, r3, #8
 8013382:	b29b      	uxth	r3, r3
 8013384:	4313      	orrs	r3, r2
 8013386:	b29a      	uxth	r2, r3
 8013388:	687b      	ldr	r3, [r7, #4]
 801338a:	831a      	strh	r2, [r3, #24]
}
 801338c:	bf00      	nop
 801338e:	370c      	adds	r7, #12
 8013390:	46bd      	mov	sp, r7
 8013392:	f85d 7b04 	ldr.w	r7, [sp], #4
 8013396:	4770      	bx	lr

08013398 <TIM_SetIC3Prescaler>:
  *            @arg TIM_ICPSC_DIV4: capture is done once every 4 events
  *            @arg TIM_ICPSC_DIV8: capture is done once every 8 events
  * @retval None
  */
void TIM_SetIC3Prescaler(TIM_TypeDef* TIMx, uint16_t TIM_ICPSC)
{
 8013398:	b480      	push	{r7}
 801339a:	b083      	sub	sp, #12
 801339c:	af00      	add	r7, sp, #0
 801339e:	6078      	str	r0, [r7, #4]
 80133a0:	460b      	mov	r3, r1
 80133a2:	807b      	strh	r3, [r7, #2]
  /* Check the parameters */
  assert_param(IS_TIM_LIST3_PERIPH(TIMx));
  assert_param(IS_TIM_IC_PRESCALER(TIM_ICPSC));

  /* Reset the IC3PSC Bits */
  TIMx->CCMR2 &= (uint16_t)~TIM_CCMR2_IC3PSC;
 80133a4:	687b      	ldr	r3, [r7, #4]
 80133a6:	8b9b      	ldrh	r3, [r3, #28]
 80133a8:	b29b      	uxth	r3, r3
 80133aa:	f023 030c 	bic.w	r3, r3, #12
 80133ae:	b29a      	uxth	r2, r3
 80133b0:	687b      	ldr	r3, [r7, #4]
 80133b2:	839a      	strh	r2, [r3, #28]

  /* Set the IC3PSC value */
  TIMx->CCMR2 |= TIM_ICPSC;
 80133b4:	687b      	ldr	r3, [r7, #4]
 80133b6:	8b9b      	ldrh	r3, [r3, #28]
 80133b8:	b29a      	uxth	r2, r3
 80133ba:	887b      	ldrh	r3, [r7, #2]
 80133bc:	4313      	orrs	r3, r2
 80133be:	b29a      	uxth	r2, r3
 80133c0:	687b      	ldr	r3, [r7, #4]
 80133c2:	839a      	strh	r2, [r3, #28]
}
 80133c4:	bf00      	nop
 80133c6:	370c      	adds	r7, #12
 80133c8:	46bd      	mov	sp, r7
 80133ca:	f85d 7b04 	ldr.w	r7, [sp], #4
 80133ce:	4770      	bx	lr

080133d0 <TIM_SetIC4Prescaler>:
  *            @arg TIM_ICPSC_DIV4: capture is done once every 4 events
  *            @arg TIM_ICPSC_DIV8: capture is done once every 8 events
  * @retval None
  */
void TIM_SetIC4Prescaler(TIM_TypeDef* TIMx, uint16_t TIM_ICPSC)
{  
 80133d0:	b480      	push	{r7}
 80133d2:	b083      	sub	sp, #12
 80133d4:	af00      	add	r7, sp, #0
 80133d6:	6078      	str	r0, [r7, #4]
 80133d8:	460b      	mov	r3, r1
 80133da:	807b      	strh	r3, [r7, #2]
  /* Check the parameters */
  assert_param(IS_TIM_LIST3_PERIPH(TIMx));
  assert_param(IS_TIM_IC_PRESCALER(TIM_ICPSC));

  /* Reset the IC4PSC Bits */
  TIMx->CCMR2 &= (uint16_t)~TIM_CCMR2_IC4PSC;
 80133dc:	687b      	ldr	r3, [r7, #4]
 80133de:	8b9b      	ldrh	r3, [r3, #28]
 80133e0:	b29b      	uxth	r3, r3
 80133e2:	f423 6340 	bic.w	r3, r3, #3072	; 0xc00
 80133e6:	b29a      	uxth	r2, r3
 80133e8:	687b      	ldr	r3, [r7, #4]
 80133ea:	839a      	strh	r2, [r3, #28]

  /* Set the IC4PSC value */
  TIMx->CCMR2 |= (uint16_t)(TIM_ICPSC << 8);
 80133ec:	687b      	ldr	r3, [r7, #4]
 80133ee:	8b9b      	ldrh	r3, [r3, #28]
 80133f0:	b29a      	uxth	r2, r3
 80133f2:	887b      	ldrh	r3, [r7, #2]
 80133f4:	021b      	lsls	r3, r3, #8
 80133f6:	b29b      	uxth	r3, r3
 80133f8:	4313      	orrs	r3, r2
 80133fa:	b29a      	uxth	r2, r3
 80133fc:	687b      	ldr	r3, [r7, #4]
 80133fe:	839a      	strh	r2, [r3, #28]
}
 8013400:	bf00      	nop
 8013402:	370c      	adds	r7, #12
 8013404:	46bd      	mov	sp, r7
 8013406:	f85d 7b04 	ldr.w	r7, [sp], #4
 801340a:	4770      	bx	lr

0801340c <TIM_BDTRConfig>:
  * @param  TIM_BDTRInitStruct: pointer to a TIM_BDTRInitTypeDef structure that
  *         contains the BDTR Register configuration  information for the TIM peripheral.
  * @retval None
  */
void TIM_BDTRConfig(TIM_TypeDef* TIMx, TIM_BDTRInitTypeDef *TIM_BDTRInitStruct)
{
 801340c:	b480      	push	{r7}
 801340e:	b083      	sub	sp, #12
 8013410:	af00      	add	r7, sp, #0
 8013412:	6078      	str	r0, [r7, #4]
 8013414:	6039      	str	r1, [r7, #0]
  assert_param(IS_TIM_BREAK_POLARITY(TIM_BDTRInitStruct->TIM_BreakPolarity));
  assert_param(IS_TIM_AUTOMATIC_OUTPUT_STATE(TIM_BDTRInitStruct->TIM_AutomaticOutput));

  /* Set the Lock level, the Break enable Bit and the Polarity, the OSSR State,
     the OSSI State, the dead time value and the Automatic Output Enable Bit */
  TIMx->BDTR = (uint32_t)TIM_BDTRInitStruct->TIM_OSSRState | TIM_BDTRInitStruct->TIM_OSSIState |
 8013416:	683b      	ldr	r3, [r7, #0]
 8013418:	881a      	ldrh	r2, [r3, #0]
 801341a:	683b      	ldr	r3, [r7, #0]
 801341c:	885b      	ldrh	r3, [r3, #2]
 801341e:	4313      	orrs	r3, r2
 8013420:	b29a      	uxth	r2, r3
             TIM_BDTRInitStruct->TIM_LOCKLevel | TIM_BDTRInitStruct->TIM_DeadTime |
 8013422:	683b      	ldr	r3, [r7, #0]
 8013424:	889b      	ldrh	r3, [r3, #4]
  TIMx->BDTR = (uint32_t)TIM_BDTRInitStruct->TIM_OSSRState | TIM_BDTRInitStruct->TIM_OSSIState |
 8013426:	4313      	orrs	r3, r2
 8013428:	b29a      	uxth	r2, r3
             TIM_BDTRInitStruct->TIM_LOCKLevel | TIM_BDTRInitStruct->TIM_DeadTime |
 801342a:	683b      	ldr	r3, [r7, #0]
 801342c:	88db      	ldrh	r3, [r3, #6]
  TIMx->BDTR = (uint32_t)TIM_BDTRInitStruct->TIM_OSSRState | TIM_BDTRInitStruct->TIM_OSSIState |
 801342e:	4313      	orrs	r3, r2
 8013430:	b29a      	uxth	r2, r3
             TIM_BDTRInitStruct->TIM_Break | TIM_BDTRInitStruct->TIM_BreakPolarity |
 8013432:	683b      	ldr	r3, [r7, #0]
 8013434:	891b      	ldrh	r3, [r3, #8]
  TIMx->BDTR = (uint32_t)TIM_BDTRInitStruct->TIM_OSSRState | TIM_BDTRInitStruct->TIM_OSSIState |
 8013436:	4313      	orrs	r3, r2
 8013438:	b29a      	uxth	r2, r3
             TIM_BDTRInitStruct->TIM_Break | TIM_BDTRInitStruct->TIM_BreakPolarity |
 801343a:	683b      	ldr	r3, [r7, #0]
 801343c:	895b      	ldrh	r3, [r3, #10]
  TIMx->BDTR = (uint32_t)TIM_BDTRInitStruct->TIM_OSSRState | TIM_BDTRInitStruct->TIM_OSSIState |
 801343e:	4313      	orrs	r3, r2
 8013440:	b29a      	uxth	r2, r3
             TIM_BDTRInitStruct->TIM_AutomaticOutput;
 8013442:	683b      	ldr	r3, [r7, #0]
 8013444:	899b      	ldrh	r3, [r3, #12]
  TIMx->BDTR = (uint32_t)TIM_BDTRInitStruct->TIM_OSSRState | TIM_BDTRInitStruct->TIM_OSSIState |
 8013446:	4313      	orrs	r3, r2
 8013448:	b29a      	uxth	r2, r3
 801344a:	687b      	ldr	r3, [r7, #4]
 801344c:	f8a3 2044 	strh.w	r2, [r3, #68]	; 0x44
}
 8013450:	bf00      	nop
 8013452:	370c      	adds	r7, #12
 8013454:	46bd      	mov	sp, r7
 8013456:	f85d 7b04 	ldr.w	r7, [sp], #4
 801345a:	4770      	bx	lr

0801345c <TIM_BDTRStructInit>:
  * @param  TIM_BDTRInitStruct: pointer to a TIM_BDTRInitTypeDef structure which
  *         will be initialized.
  * @retval None
  */
void TIM_BDTRStructInit(TIM_BDTRInitTypeDef* TIM_BDTRInitStruct)
{
 801345c:	b480      	push	{r7}
 801345e:	b083      	sub	sp, #12
 8013460:	af00      	add	r7, sp, #0
 8013462:	6078      	str	r0, [r7, #4]
  /* Set the default configuration */
  TIM_BDTRInitStruct->TIM_OSSRState = TIM_OSSRState_Disable;
 8013464:	687b      	ldr	r3, [r7, #4]
 8013466:	2200      	movs	r2, #0
 8013468:	801a      	strh	r2, [r3, #0]
  TIM_BDTRInitStruct->TIM_OSSIState = TIM_OSSIState_Disable;
 801346a:	687b      	ldr	r3, [r7, #4]
 801346c:	2200      	movs	r2, #0
 801346e:	805a      	strh	r2, [r3, #2]
  TIM_BDTRInitStruct->TIM_LOCKLevel = TIM_LOCKLevel_OFF;
 8013470:	687b      	ldr	r3, [r7, #4]
 8013472:	2200      	movs	r2, #0
 8013474:	809a      	strh	r2, [r3, #4]
  TIM_BDTRInitStruct->TIM_DeadTime = 0x00;
 8013476:	687b      	ldr	r3, [r7, #4]
 8013478:	2200      	movs	r2, #0
 801347a:	80da      	strh	r2, [r3, #6]
  TIM_BDTRInitStruct->TIM_Break = TIM_Break_Disable;
 801347c:	687b      	ldr	r3, [r7, #4]
 801347e:	2200      	movs	r2, #0
 8013480:	811a      	strh	r2, [r3, #8]
  TIM_BDTRInitStruct->TIM_BreakPolarity = TIM_BreakPolarity_Low;
 8013482:	687b      	ldr	r3, [r7, #4]
 8013484:	2200      	movs	r2, #0
 8013486:	815a      	strh	r2, [r3, #10]
  TIM_BDTRInitStruct->TIM_AutomaticOutput = TIM_AutomaticOutput_Disable;
 8013488:	687b      	ldr	r3, [r7, #4]
 801348a:	2200      	movs	r2, #0
 801348c:	819a      	strh	r2, [r3, #12]
}
 801348e:	bf00      	nop
 8013490:	370c      	adds	r7, #12
 8013492:	46bd      	mov	sp, r7
 8013494:	f85d 7b04 	ldr.w	r7, [sp], #4
 8013498:	4770      	bx	lr

0801349a <TIM_CtrlPWMOutputs>:
  * @param  NewState: new state of the TIM peripheral Main Outputs.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void TIM_CtrlPWMOutputs(TIM_TypeDef* TIMx, FunctionalState NewState)
{
 801349a:	b480      	push	{r7}
 801349c:	b083      	sub	sp, #12
 801349e:	af00      	add	r7, sp, #0
 80134a0:	6078      	str	r0, [r7, #4]
 80134a2:	460b      	mov	r3, r1
 80134a4:	70fb      	strb	r3, [r7, #3]
  /* Check the parameters */
  assert_param(IS_TIM_LIST4_PERIPH(TIMx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 80134a6:	78fb      	ldrb	r3, [r7, #3]
 80134a8:	2b00      	cmp	r3, #0
 80134aa:	d00c      	beq.n	80134c6 <TIM_CtrlPWMOutputs+0x2c>
  {
    /* Enable the TIM Main Output */
    TIMx->BDTR |= TIM_BDTR_MOE;
 80134ac:	687b      	ldr	r3, [r7, #4]
 80134ae:	f8b3 3044 	ldrh.w	r3, [r3, #68]	; 0x44
 80134b2:	b29b      	uxth	r3, r3
 80134b4:	ea6f 4343 	mvn.w	r3, r3, lsl #17
 80134b8:	ea6f 4353 	mvn.w	r3, r3, lsr #17
 80134bc:	b29a      	uxth	r2, r3
 80134be:	687b      	ldr	r3, [r7, #4]
 80134c0:	f8a3 2044 	strh.w	r2, [r3, #68]	; 0x44
  else
  {
    /* Disable the TIM Main Output */
    TIMx->BDTR &= (uint16_t)~TIM_BDTR_MOE;
  }  
}
 80134c4:	e009      	b.n	80134da <TIM_CtrlPWMOutputs+0x40>
    TIMx->BDTR &= (uint16_t)~TIM_BDTR_MOE;
 80134c6:	687b      	ldr	r3, [r7, #4]
 80134c8:	f8b3 3044 	ldrh.w	r3, [r3, #68]	; 0x44
 80134cc:	b29b      	uxth	r3, r3
 80134ce:	f3c3 030e 	ubfx	r3, r3, #0, #15
 80134d2:	b29a      	uxth	r2, r3
 80134d4:	687b      	ldr	r3, [r7, #4]
 80134d6:	f8a3 2044 	strh.w	r2, [r3, #68]	; 0x44
}
 80134da:	bf00      	nop
 80134dc:	370c      	adds	r7, #12
 80134de:	46bd      	mov	sp, r7
 80134e0:	f85d 7b04 	ldr.w	r7, [sp], #4
 80134e4:	4770      	bx	lr

080134e6 <TIM_SelectCOM>:
  * @param  NewState: new state of the Commutation event.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void TIM_SelectCOM(TIM_TypeDef* TIMx, FunctionalState NewState)
{
 80134e6:	b480      	push	{r7}
 80134e8:	b083      	sub	sp, #12
 80134ea:	af00      	add	r7, sp, #0
 80134ec:	6078      	str	r0, [r7, #4]
 80134ee:	460b      	mov	r3, r1
 80134f0:	70fb      	strb	r3, [r7, #3]
  /* Check the parameters */
  assert_param(IS_TIM_LIST4_PERIPH(TIMx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 80134f2:	78fb      	ldrb	r3, [r7, #3]
 80134f4:	2b00      	cmp	r3, #0
 80134f6:	d008      	beq.n	801350a <TIM_SelectCOM+0x24>
  {
    /* Set the COM Bit */
    TIMx->CR2 |= TIM_CR2_CCUS;
 80134f8:	687b      	ldr	r3, [r7, #4]
 80134fa:	889b      	ldrh	r3, [r3, #4]
 80134fc:	b29b      	uxth	r3, r3
 80134fe:	f043 0304 	orr.w	r3, r3, #4
 8013502:	b29a      	uxth	r2, r3
 8013504:	687b      	ldr	r3, [r7, #4]
 8013506:	809a      	strh	r2, [r3, #4]
  else
  {
    /* Reset the COM Bit */
    TIMx->CR2 &= (uint16_t)~TIM_CR2_CCUS;
  }
}
 8013508:	e007      	b.n	801351a <TIM_SelectCOM+0x34>
    TIMx->CR2 &= (uint16_t)~TIM_CR2_CCUS;
 801350a:	687b      	ldr	r3, [r7, #4]
 801350c:	889b      	ldrh	r3, [r3, #4]
 801350e:	b29b      	uxth	r3, r3
 8013510:	f023 0304 	bic.w	r3, r3, #4
 8013514:	b29a      	uxth	r2, r3
 8013516:	687b      	ldr	r3, [r7, #4]
 8013518:	809a      	strh	r2, [r3, #4]
}
 801351a:	bf00      	nop
 801351c:	370c      	adds	r7, #12
 801351e:	46bd      	mov	sp, r7
 8013520:	f85d 7b04 	ldr.w	r7, [sp], #4
 8013524:	4770      	bx	lr

08013526 <TIM_CCPreloadControl>:
  * @param  NewState: new state of the Capture Compare Preload Control bit
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void TIM_CCPreloadControl(TIM_TypeDef* TIMx, FunctionalState NewState)
{ 
 8013526:	b480      	push	{r7}
 8013528:	b083      	sub	sp, #12
 801352a:	af00      	add	r7, sp, #0
 801352c:	6078      	str	r0, [r7, #4]
 801352e:	460b      	mov	r3, r1
 8013530:	70fb      	strb	r3, [r7, #3]
  /* Check the parameters */
  assert_param(IS_TIM_LIST4_PERIPH(TIMx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 8013532:	78fb      	ldrb	r3, [r7, #3]
 8013534:	2b00      	cmp	r3, #0
 8013536:	d008      	beq.n	801354a <TIM_CCPreloadControl+0x24>
  {
    /* Set the CCPC Bit */
    TIMx->CR2 |= TIM_CR2_CCPC;
 8013538:	687b      	ldr	r3, [r7, #4]
 801353a:	889b      	ldrh	r3, [r3, #4]
 801353c:	b29b      	uxth	r3, r3
 801353e:	f043 0301 	orr.w	r3, r3, #1
 8013542:	b29a      	uxth	r2, r3
 8013544:	687b      	ldr	r3, [r7, #4]
 8013546:	809a      	strh	r2, [r3, #4]
  else
  {
    /* Reset the CCPC Bit */
    TIMx->CR2 &= (uint16_t)~TIM_CR2_CCPC;
  }
}
 8013548:	e007      	b.n	801355a <TIM_CCPreloadControl+0x34>
    TIMx->CR2 &= (uint16_t)~TIM_CR2_CCPC;
 801354a:	687b      	ldr	r3, [r7, #4]
 801354c:	889b      	ldrh	r3, [r3, #4]
 801354e:	b29b      	uxth	r3, r3
 8013550:	f023 0301 	bic.w	r3, r3, #1
 8013554:	b29a      	uxth	r2, r3
 8013556:	687b      	ldr	r3, [r7, #4]
 8013558:	809a      	strh	r2, [r3, #4]
}
 801355a:	bf00      	nop
 801355c:	370c      	adds	r7, #12
 801355e:	46bd      	mov	sp, r7
 8013560:	f85d 7b04 	ldr.w	r7, [sp], #4
 8013564:	4770      	bx	lr

08013566 <TIM_ITConfig>:
  * @param  NewState: new state of the TIM interrupts.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void TIM_ITConfig(TIM_TypeDef* TIMx, uint16_t TIM_IT, FunctionalState NewState)
{  
 8013566:	b480      	push	{r7}
 8013568:	b083      	sub	sp, #12
 801356a:	af00      	add	r7, sp, #0
 801356c:	6078      	str	r0, [r7, #4]
 801356e:	460b      	mov	r3, r1
 8013570:	807b      	strh	r3, [r7, #2]
 8013572:	4613      	mov	r3, r2
 8013574:	707b      	strb	r3, [r7, #1]
  /* Check the parameters */
  assert_param(IS_TIM_ALL_PERIPH(TIMx));
  assert_param(IS_TIM_IT(TIM_IT));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
 8013576:	787b      	ldrb	r3, [r7, #1]
 8013578:	2b00      	cmp	r3, #0
 801357a:	d008      	beq.n	801358e <TIM_ITConfig+0x28>
  {
    /* Enable the Interrupt sources */
    TIMx->DIER |= TIM_IT;
 801357c:	687b      	ldr	r3, [r7, #4]
 801357e:	899b      	ldrh	r3, [r3, #12]
 8013580:	b29a      	uxth	r2, r3
 8013582:	887b      	ldrh	r3, [r7, #2]
 8013584:	4313      	orrs	r3, r2
 8013586:	b29a      	uxth	r2, r3
 8013588:	687b      	ldr	r3, [r7, #4]
 801358a:	819a      	strh	r2, [r3, #12]
  else
  {
    /* Disable the Interrupt sources */
    TIMx->DIER &= (uint16_t)~TIM_IT;
  }
}
 801358c:	e009      	b.n	80135a2 <TIM_ITConfig+0x3c>
    TIMx->DIER &= (uint16_t)~TIM_IT;
 801358e:	687b      	ldr	r3, [r7, #4]
 8013590:	899b      	ldrh	r3, [r3, #12]
 8013592:	b29a      	uxth	r2, r3
 8013594:	887b      	ldrh	r3, [r7, #2]
 8013596:	43db      	mvns	r3, r3
 8013598:	b29b      	uxth	r3, r3
 801359a:	4013      	ands	r3, r2
 801359c:	b29a      	uxth	r2, r3
 801359e:	687b      	ldr	r3, [r7, #4]
 80135a0:	819a      	strh	r2, [r3, #12]
}
 80135a2:	bf00      	nop
 80135a4:	370c      	adds	r7, #12
 80135a6:	46bd      	mov	sp, r7
 80135a8:	f85d 7b04 	ldr.w	r7, [sp], #4
 80135ac:	4770      	bx	lr

080135ae <TIM_GenerateEvent>:
  * @note   TIM_EventSource_COM and TIM_EventSource_Break are used only with TIM1 and TIM8.
  *        
  * @retval None
  */
void TIM_GenerateEvent(TIM_TypeDef* TIMx, uint16_t TIM_EventSource)
{ 
 80135ae:	b480      	push	{r7}
 80135b0:	b083      	sub	sp, #12
 80135b2:	af00      	add	r7, sp, #0
 80135b4:	6078      	str	r0, [r7, #4]
 80135b6:	460b      	mov	r3, r1
 80135b8:	807b      	strh	r3, [r7, #2]
  /* Check the parameters */
  assert_param(IS_TIM_ALL_PERIPH(TIMx));
  assert_param(IS_TIM_EVENT_SOURCE(TIM_EventSource));
 
  /* Set the event sources */
  TIMx->EGR = TIM_EventSource;
 80135ba:	687b      	ldr	r3, [r7, #4]
 80135bc:	887a      	ldrh	r2, [r7, #2]
 80135be:	829a      	strh	r2, [r3, #20]
}
 80135c0:	bf00      	nop
 80135c2:	370c      	adds	r7, #12
 80135c4:	46bd      	mov	sp, r7
 80135c6:	f85d 7b04 	ldr.w	r7, [sp], #4
 80135ca:	4770      	bx	lr

080135cc <TIM_GetFlagStatus>:
  * @note   TIM_FLAG_COM and TIM_FLAG_Break are used only with TIM1 and TIM8.    
  *
  * @retval The new state of TIM_FLAG (SET or RESET).
  */
FlagStatus TIM_GetFlagStatus(TIM_TypeDef* TIMx, uint16_t TIM_FLAG)
{ 
 80135cc:	b480      	push	{r7}
 80135ce:	b085      	sub	sp, #20
 80135d0:	af00      	add	r7, sp, #0
 80135d2:	6078      	str	r0, [r7, #4]
 80135d4:	460b      	mov	r3, r1
 80135d6:	807b      	strh	r3, [r7, #2]
  ITStatus bitstatus = RESET;  
 80135d8:	2300      	movs	r3, #0
 80135da:	73fb      	strb	r3, [r7, #15]
  /* Check the parameters */
  assert_param(IS_TIM_ALL_PERIPH(TIMx));
  assert_param(IS_TIM_GET_FLAG(TIM_FLAG));

  
  if ((TIMx->SR & TIM_FLAG) != (uint16_t)RESET)
 80135dc:	687b      	ldr	r3, [r7, #4]
 80135de:	8a1b      	ldrh	r3, [r3, #16]
 80135e0:	b29a      	uxth	r2, r3
 80135e2:	887b      	ldrh	r3, [r7, #2]
 80135e4:	4013      	ands	r3, r2
 80135e6:	b29b      	uxth	r3, r3
 80135e8:	2b00      	cmp	r3, #0
 80135ea:	d002      	beq.n	80135f2 <TIM_GetFlagStatus+0x26>
  {
    bitstatus = SET;
 80135ec:	2301      	movs	r3, #1
 80135ee:	73fb      	strb	r3, [r7, #15]
 80135f0:	e001      	b.n	80135f6 <TIM_GetFlagStatus+0x2a>
  }
  else
  {
    bitstatus = RESET;
 80135f2:	2300      	movs	r3, #0
 80135f4:	73fb      	strb	r3, [r7, #15]
  }
  return bitstatus;
 80135f6:	7bfb      	ldrb	r3, [r7, #15]
}
 80135f8:	4618      	mov	r0, r3
 80135fa:	3714      	adds	r7, #20
 80135fc:	46bd      	mov	sp, r7
 80135fe:	f85d 7b04 	ldr.w	r7, [sp], #4
 8013602:	4770      	bx	lr

08013604 <TIM_ClearFlag>:
  * @note   TIM_FLAG_COM and TIM_FLAG_Break are used only with TIM1 and TIM8.
  *    
  * @retval None
  */
void TIM_ClearFlag(TIM_TypeDef* TIMx, uint16_t TIM_FLAG)
{  
 8013604:	b480      	push	{r7}
 8013606:	b083      	sub	sp, #12
 8013608:	af00      	add	r7, sp, #0
 801360a:	6078      	str	r0, [r7, #4]
 801360c:	460b      	mov	r3, r1
 801360e:	807b      	strh	r3, [r7, #2]
  /* Check the parameters */
  assert_param(IS_TIM_ALL_PERIPH(TIMx));
   
  /* Clear the flags */
  TIMx->SR = (uint16_t)~TIM_FLAG;
 8013610:	887b      	ldrh	r3, [r7, #2]
 8013612:	43db      	mvns	r3, r3
 8013614:	b29a      	uxth	r2, r3
 8013616:	687b      	ldr	r3, [r7, #4]
 8013618:	821a      	strh	r2, [r3, #16]
}
 801361a:	bf00      	nop
 801361c:	370c      	adds	r7, #12
 801361e:	46bd      	mov	sp, r7
 8013620:	f85d 7b04 	ldr.w	r7, [sp], #4
 8013624:	4770      	bx	lr

08013626 <TIM_GetITStatus>:
  * @note   TIM_IT_COM and TIM_IT_Break are used only with TIM1 and TIM8.
  *     
  * @retval The new state of the TIM_IT(SET or RESET).
  */
ITStatus TIM_GetITStatus(TIM_TypeDef* TIMx, uint16_t TIM_IT)
{
 8013626:	b480      	push	{r7}
 8013628:	b085      	sub	sp, #20
 801362a:	af00      	add	r7, sp, #0
 801362c:	6078      	str	r0, [r7, #4]
 801362e:	460b      	mov	r3, r1
 8013630:	807b      	strh	r3, [r7, #2]
  ITStatus bitstatus = RESET;  
 8013632:	2300      	movs	r3, #0
 8013634:	73fb      	strb	r3, [r7, #15]
  uint16_t itstatus = 0x0, itenable = 0x0;
 8013636:	2300      	movs	r3, #0
 8013638:	81bb      	strh	r3, [r7, #12]
 801363a:	2300      	movs	r3, #0
 801363c:	817b      	strh	r3, [r7, #10]
  /* Check the parameters */
  assert_param(IS_TIM_ALL_PERIPH(TIMx));
  assert_param(IS_TIM_GET_IT(TIM_IT));
   
  itstatus = TIMx->SR & TIM_IT;
 801363e:	687b      	ldr	r3, [r7, #4]
 8013640:	8a1b      	ldrh	r3, [r3, #16]
 8013642:	b29a      	uxth	r2, r3
 8013644:	887b      	ldrh	r3, [r7, #2]
 8013646:	4013      	ands	r3, r2
 8013648:	81bb      	strh	r3, [r7, #12]
  
  itenable = TIMx->DIER & TIM_IT;
 801364a:	687b      	ldr	r3, [r7, #4]
 801364c:	899b      	ldrh	r3, [r3, #12]
 801364e:	b29a      	uxth	r2, r3
 8013650:	887b      	ldrh	r3, [r7, #2]
 8013652:	4013      	ands	r3, r2
 8013654:	817b      	strh	r3, [r7, #10]
  if ((itstatus != (uint16_t)RESET) && (itenable != (uint16_t)RESET))
 8013656:	89bb      	ldrh	r3, [r7, #12]
 8013658:	2b00      	cmp	r3, #0
 801365a:	d005      	beq.n	8013668 <TIM_GetITStatus+0x42>
 801365c:	897b      	ldrh	r3, [r7, #10]
 801365e:	2b00      	cmp	r3, #0
 8013660:	d002      	beq.n	8013668 <TIM_GetITStatus+0x42>
  {
    bitstatus = SET;
 8013662:	2301      	movs	r3, #1
 8013664:	73fb      	strb	r3, [r7, #15]
 8013666:	e001      	b.n	801366c <TIM_GetITStatus+0x46>
  }
  else
  {
    bitstatus = RESET;
 8013668:	2300      	movs	r3, #0
 801366a:	73fb      	strb	r3, [r7, #15]
  }
  return bitstatus;
 801366c:	7bfb      	ldrb	r3, [r7, #15]
}
 801366e:	4618      	mov	r0, r3
 8013670:	3714      	adds	r7, #20
 8013672:	46bd      	mov	sp, r7
 8013674:	f85d 7b04 	ldr.w	r7, [sp], #4
 8013678:	4770      	bx	lr

0801367a <TIM_ClearITPendingBit>:
  * @note   TIM_IT_COM and TIM_IT_Break are used only with TIM1 and TIM8.
  *      
  * @retval None
  */
void TIM_ClearITPendingBit(TIM_TypeDef* TIMx, uint16_t TIM_IT)
{
 801367a:	b480      	push	{r7}
 801367c:	b083      	sub	sp, #12
 801367e:	af00      	add	r7, sp, #0
 8013680:	6078      	str	r0, [r7, #4]
 8013682:	460b      	mov	r3, r1
 8013684:	807b      	strh	r3, [r7, #2]
  /* Check the parameters */
  assert_param(IS_TIM_ALL_PERIPH(TIMx));

  /* Clear the IT pending Bit */
  TIMx->SR = (uint16_t)~TIM_IT;
 8013686:	887b      	ldrh	r3, [r7, #2]
 8013688:	43db      	mvns	r3, r3
 801368a:	b29a      	uxth	r2, r3
 801368c:	687b      	ldr	r3, [r7, #4]
 801368e:	821a      	strh	r2, [r3, #16]
}
 8013690:	bf00      	nop
 8013692:	370c      	adds	r7, #12
 8013694:	46bd      	mov	sp, r7
 8013696:	f85d 7b04 	ldr.w	r7, [sp], #4
 801369a:	4770      	bx	lr

0801369c <TIM_DMAConfig>:
  * @param  TIM_DMABurstLength: DMA Burst length. This parameter can be one value
  *         between: TIM_DMABurstLength_1Transfer and TIM_DMABurstLength_18Transfers.
  * @retval None
  */
void TIM_DMAConfig(TIM_TypeDef* TIMx, uint16_t TIM_DMABase, uint16_t TIM_DMABurstLength)
{
 801369c:	b480      	push	{r7}
 801369e:	b083      	sub	sp, #12
 80136a0:	af00      	add	r7, sp, #0
 80136a2:	6078      	str	r0, [r7, #4]
 80136a4:	460b      	mov	r3, r1
 80136a6:	807b      	strh	r3, [r7, #2]
 80136a8:	4613      	mov	r3, r2
 80136aa:	803b      	strh	r3, [r7, #0]
  assert_param(IS_TIM_LIST3_PERIPH(TIMx));
  assert_param(IS_TIM_DMA_BASE(TIM_DMABase)); 
  assert_param(IS_TIM_DMA_LENGTH(TIM_DMABurstLength));

  /* Set the DMA Base and the DMA Burst Length */
  TIMx->DCR = TIM_DMABase | TIM_DMABurstLength;
 80136ac:	887a      	ldrh	r2, [r7, #2]
 80136ae:	883b      	ldrh	r3, [r7, #0]
 80136b0:	4313      	orrs	r3, r2
 80136b2:	b29a      	uxth	r2, r3
 80136b4:	687b      	ldr	r3, [r7, #4]
 80136b6:	f8a3 2048 	strh.w	r2, [r3, #72]	; 0x48
}
 80136ba:	bf00      	nop
 80136bc:	370c      	adds	r7, #12
 80136be:	46bd      	mov	sp, r7
 80136c0:	f85d 7b04 	ldr.w	r7, [sp], #4
 80136c4:	4770      	bx	lr

080136c6 <TIM_DMACmd>:
  * @param  NewState: new state of the DMA Request sources.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void TIM_DMACmd(TIM_TypeDef* TIMx, uint16_t TIM_DMASource, FunctionalState NewState)
{ 
 80136c6:	b480      	push	{r7}
 80136c8:	b083      	sub	sp, #12
 80136ca:	af00      	add	r7, sp, #0
 80136cc:	6078      	str	r0, [r7, #4]
 80136ce:	460b      	mov	r3, r1
 80136d0:	807b      	strh	r3, [r7, #2]
 80136d2:	4613      	mov	r3, r2
 80136d4:	707b      	strb	r3, [r7, #1]
  /* Check the parameters */
  assert_param(IS_TIM_LIST5_PERIPH(TIMx)); 
  assert_param(IS_TIM_DMA_SOURCE(TIM_DMASource));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
 80136d6:	787b      	ldrb	r3, [r7, #1]
 80136d8:	2b00      	cmp	r3, #0
 80136da:	d008      	beq.n	80136ee <TIM_DMACmd+0x28>
  {
    /* Enable the DMA sources */
    TIMx->DIER |= TIM_DMASource; 
 80136dc:	687b      	ldr	r3, [r7, #4]
 80136de:	899b      	ldrh	r3, [r3, #12]
 80136e0:	b29a      	uxth	r2, r3
 80136e2:	887b      	ldrh	r3, [r7, #2]
 80136e4:	4313      	orrs	r3, r2
 80136e6:	b29a      	uxth	r2, r3
 80136e8:	687b      	ldr	r3, [r7, #4]
 80136ea:	819a      	strh	r2, [r3, #12]
  else
  {
    /* Disable the DMA sources */
    TIMx->DIER &= (uint16_t)~TIM_DMASource;
  }
}
 80136ec:	e009      	b.n	8013702 <TIM_DMACmd+0x3c>
    TIMx->DIER &= (uint16_t)~TIM_DMASource;
 80136ee:	687b      	ldr	r3, [r7, #4]
 80136f0:	899b      	ldrh	r3, [r3, #12]
 80136f2:	b29a      	uxth	r2, r3
 80136f4:	887b      	ldrh	r3, [r7, #2]
 80136f6:	43db      	mvns	r3, r3
 80136f8:	b29b      	uxth	r3, r3
 80136fa:	4013      	ands	r3, r2
 80136fc:	b29a      	uxth	r2, r3
 80136fe:	687b      	ldr	r3, [r7, #4]
 8013700:	819a      	strh	r2, [r3, #12]
}
 8013702:	bf00      	nop
 8013704:	370c      	adds	r7, #12
 8013706:	46bd      	mov	sp, r7
 8013708:	f85d 7b04 	ldr.w	r7, [sp], #4
 801370c:	4770      	bx	lr

0801370e <TIM_SelectCCDMA>:
  * @param  NewState: new state of the Capture Compare DMA source
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void TIM_SelectCCDMA(TIM_TypeDef* TIMx, FunctionalState NewState)
{
 801370e:	b480      	push	{r7}
 8013710:	b083      	sub	sp, #12
 8013712:	af00      	add	r7, sp, #0
 8013714:	6078      	str	r0, [r7, #4]
 8013716:	460b      	mov	r3, r1
 8013718:	70fb      	strb	r3, [r7, #3]
  /* Check the parameters */
  assert_param(IS_TIM_LIST3_PERIPH(TIMx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 801371a:	78fb      	ldrb	r3, [r7, #3]
 801371c:	2b00      	cmp	r3, #0
 801371e:	d008      	beq.n	8013732 <TIM_SelectCCDMA+0x24>
  {
    /* Set the CCDS Bit */
    TIMx->CR2 |= TIM_CR2_CCDS;
 8013720:	687b      	ldr	r3, [r7, #4]
 8013722:	889b      	ldrh	r3, [r3, #4]
 8013724:	b29b      	uxth	r3, r3
 8013726:	f043 0308 	orr.w	r3, r3, #8
 801372a:	b29a      	uxth	r2, r3
 801372c:	687b      	ldr	r3, [r7, #4]
 801372e:	809a      	strh	r2, [r3, #4]
  else
  {
    /* Reset the CCDS Bit */
    TIMx->CR2 &= (uint16_t)~TIM_CR2_CCDS;
  }
}
 8013730:	e007      	b.n	8013742 <TIM_SelectCCDMA+0x34>
    TIMx->CR2 &= (uint16_t)~TIM_CR2_CCDS;
 8013732:	687b      	ldr	r3, [r7, #4]
 8013734:	889b      	ldrh	r3, [r3, #4]
 8013736:	b29b      	uxth	r3, r3
 8013738:	f023 0308 	bic.w	r3, r3, #8
 801373c:	b29a      	uxth	r2, r3
 801373e:	687b      	ldr	r3, [r7, #4]
 8013740:	809a      	strh	r2, [r3, #4]
}
 8013742:	bf00      	nop
 8013744:	370c      	adds	r7, #12
 8013746:	46bd      	mov	sp, r7
 8013748:	f85d 7b04 	ldr.w	r7, [sp], #4
 801374c:	4770      	bx	lr

0801374e <TIM_InternalClockConfig>:
  * @param  TIMx: where x can be 1, 2, 3, 4, 5, 8, 9 or 12 to select the TIM 
  *         peripheral.
  * @retval None
  */
void TIM_InternalClockConfig(TIM_TypeDef* TIMx)
{
 801374e:	b480      	push	{r7}
 8013750:	b083      	sub	sp, #12
 8013752:	af00      	add	r7, sp, #0
 8013754:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_TIM_LIST2_PERIPH(TIMx));

  /* Disable slave mode to clock the prescaler directly with the internal clock */
  TIMx->SMCR &=  (uint16_t)~TIM_SMCR_SMS;
 8013756:	687b      	ldr	r3, [r7, #4]
 8013758:	891b      	ldrh	r3, [r3, #8]
 801375a:	b29b      	uxth	r3, r3
 801375c:	f023 0307 	bic.w	r3, r3, #7
 8013760:	b29a      	uxth	r2, r3
 8013762:	687b      	ldr	r3, [r7, #4]
 8013764:	811a      	strh	r2, [r3, #8]
}
 8013766:	bf00      	nop
 8013768:	370c      	adds	r7, #12
 801376a:	46bd      	mov	sp, r7
 801376c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8013770:	4770      	bx	lr

08013772 <TIM_ITRxExternalClockConfig>:
  *            @arg TIM_TS_ITR2: Internal Trigger 2
  *            @arg TIM_TS_ITR3: Internal Trigger 3
  * @retval None
  */
void TIM_ITRxExternalClockConfig(TIM_TypeDef* TIMx, uint16_t TIM_InputTriggerSource)
{
 8013772:	b580      	push	{r7, lr}
 8013774:	b082      	sub	sp, #8
 8013776:	af00      	add	r7, sp, #0
 8013778:	6078      	str	r0, [r7, #4]
 801377a:	460b      	mov	r3, r1
 801377c:	807b      	strh	r3, [r7, #2]
  /* Check the parameters */
  assert_param(IS_TIM_LIST2_PERIPH(TIMx));
  assert_param(IS_TIM_INTERNAL_TRIGGER_SELECTION(TIM_InputTriggerSource));

  /* Select the Internal Trigger */
  TIM_SelectInputTrigger(TIMx, TIM_InputTriggerSource);
 801377e:	887b      	ldrh	r3, [r7, #2]
 8013780:	4619      	mov	r1, r3
 8013782:	6878      	ldr	r0, [r7, #4]
 8013784:	f000 f888 	bl	8013898 <TIM_SelectInputTrigger>

  /* Select the External clock mode1 */
  TIMx->SMCR |= TIM_SlaveMode_External1;
 8013788:	687b      	ldr	r3, [r7, #4]
 801378a:	891b      	ldrh	r3, [r3, #8]
 801378c:	b29b      	uxth	r3, r3
 801378e:	f043 0307 	orr.w	r3, r3, #7
 8013792:	b29a      	uxth	r2, r3
 8013794:	687b      	ldr	r3, [r7, #4]
 8013796:	811a      	strh	r2, [r3, #8]
}
 8013798:	bf00      	nop
 801379a:	3708      	adds	r7, #8
 801379c:	46bd      	mov	sp, r7
 801379e:	bd80      	pop	{r7, pc}

080137a0 <TIM_TIxExternalClockConfig>:
  *          This parameter must be a value between 0x0 and 0xF.
  * @retval None
  */
void TIM_TIxExternalClockConfig(TIM_TypeDef* TIMx, uint16_t TIM_TIxExternalCLKSource,
                                uint16_t TIM_ICPolarity, uint16_t ICFilter)
{
 80137a0:	b580      	push	{r7, lr}
 80137a2:	b084      	sub	sp, #16
 80137a4:	af00      	add	r7, sp, #0
 80137a6:	60f8      	str	r0, [r7, #12]
 80137a8:	4608      	mov	r0, r1
 80137aa:	4611      	mov	r1, r2
 80137ac:	461a      	mov	r2, r3
 80137ae:	4603      	mov	r3, r0
 80137b0:	817b      	strh	r3, [r7, #10]
 80137b2:	460b      	mov	r3, r1
 80137b4:	813b      	strh	r3, [r7, #8]
 80137b6:	4613      	mov	r3, r2
 80137b8:	80fb      	strh	r3, [r7, #6]
  assert_param(IS_TIM_LIST1_PERIPH(TIMx));
  assert_param(IS_TIM_IC_POLARITY(TIM_ICPolarity));
  assert_param(IS_TIM_IC_FILTER(ICFilter));

  /* Configure the Timer Input Clock Source */
  if (TIM_TIxExternalCLKSource == TIM_TIxExternalCLK1Source_TI2)
 80137ba:	897b      	ldrh	r3, [r7, #10]
 80137bc:	2b60      	cmp	r3, #96	; 0x60
 80137be:	d106      	bne.n	80137ce <TIM_TIxExternalClockConfig+0x2e>
  {
    TI2_Config(TIMx, TIM_ICPolarity, TIM_ICSelection_DirectTI, ICFilter);
 80137c0:	88fb      	ldrh	r3, [r7, #6]
 80137c2:	8939      	ldrh	r1, [r7, #8]
 80137c4:	2201      	movs	r2, #1
 80137c6:	68f8      	ldr	r0, [r7, #12]
 80137c8:	f000 f9bf 	bl	8013b4a <TI2_Config>
 80137cc:	e005      	b.n	80137da <TIM_TIxExternalClockConfig+0x3a>
  }
  else
  {
    TI1_Config(TIMx, TIM_ICPolarity, TIM_ICSelection_DirectTI, ICFilter);
 80137ce:	88fb      	ldrh	r3, [r7, #6]
 80137d0:	8939      	ldrh	r1, [r7, #8]
 80137d2:	2201      	movs	r2, #1
 80137d4:	68f8      	ldr	r0, [r7, #12]
 80137d6:	f000 f975 	bl	8013ac4 <TI1_Config>
  }
  /* Select the Trigger source */
  TIM_SelectInputTrigger(TIMx, TIM_TIxExternalCLKSource);
 80137da:	897b      	ldrh	r3, [r7, #10]
 80137dc:	4619      	mov	r1, r3
 80137de:	68f8      	ldr	r0, [r7, #12]
 80137e0:	f000 f85a 	bl	8013898 <TIM_SelectInputTrigger>
  /* Select the External clock mode1 */
  TIMx->SMCR |= TIM_SlaveMode_External1;
 80137e4:	68fb      	ldr	r3, [r7, #12]
 80137e6:	891b      	ldrh	r3, [r3, #8]
 80137e8:	b29b      	uxth	r3, r3
 80137ea:	f043 0307 	orr.w	r3, r3, #7
 80137ee:	b29a      	uxth	r2, r3
 80137f0:	68fb      	ldr	r3, [r7, #12]
 80137f2:	811a      	strh	r2, [r3, #8]
}
 80137f4:	bf00      	nop
 80137f6:	3710      	adds	r7, #16
 80137f8:	46bd      	mov	sp, r7
 80137fa:	bd80      	pop	{r7, pc}

080137fc <TIM_ETRClockMode1Config>:
  *          This parameter must be a value between 0x00 and 0x0F
  * @retval None
  */
void TIM_ETRClockMode1Config(TIM_TypeDef* TIMx, uint16_t TIM_ExtTRGPrescaler,
                            uint16_t TIM_ExtTRGPolarity, uint16_t ExtTRGFilter)
{
 80137fc:	b580      	push	{r7, lr}
 80137fe:	b086      	sub	sp, #24
 8013800:	af00      	add	r7, sp, #0
 8013802:	60f8      	str	r0, [r7, #12]
 8013804:	4608      	mov	r0, r1
 8013806:	4611      	mov	r1, r2
 8013808:	461a      	mov	r2, r3
 801380a:	4603      	mov	r3, r0
 801380c:	817b      	strh	r3, [r7, #10]
 801380e:	460b      	mov	r3, r1
 8013810:	813b      	strh	r3, [r7, #8]
 8013812:	4613      	mov	r3, r2
 8013814:	80fb      	strh	r3, [r7, #6]
  uint16_t tmpsmcr = 0;
 8013816:	2300      	movs	r3, #0
 8013818:	82fb      	strh	r3, [r7, #22]
  assert_param(IS_TIM_LIST3_PERIPH(TIMx));
  assert_param(IS_TIM_EXT_PRESCALER(TIM_ExtTRGPrescaler));
  assert_param(IS_TIM_EXT_POLARITY(TIM_ExtTRGPolarity));
  assert_param(IS_TIM_EXT_FILTER(ExtTRGFilter));
  /* Configure the ETR Clock source */
  TIM_ETRConfig(TIMx, TIM_ExtTRGPrescaler, TIM_ExtTRGPolarity, ExtTRGFilter);
 801381a:	88fb      	ldrh	r3, [r7, #6]
 801381c:	893a      	ldrh	r2, [r7, #8]
 801381e:	8979      	ldrh	r1, [r7, #10]
 8013820:	68f8      	ldr	r0, [r7, #12]
 8013822:	f000 f8a9 	bl	8013978 <TIM_ETRConfig>
  
  /* Get the TIMx SMCR register value */
  tmpsmcr = TIMx->SMCR;
 8013826:	68fb      	ldr	r3, [r7, #12]
 8013828:	891b      	ldrh	r3, [r3, #8]
 801382a:	82fb      	strh	r3, [r7, #22]

  /* Reset the SMS Bits */
  tmpsmcr &= (uint16_t)~TIM_SMCR_SMS;
 801382c:	8afb      	ldrh	r3, [r7, #22]
 801382e:	f023 0307 	bic.w	r3, r3, #7
 8013832:	82fb      	strh	r3, [r7, #22]

  /* Select the External clock mode1 */
  tmpsmcr |= TIM_SlaveMode_External1;
 8013834:	8afb      	ldrh	r3, [r7, #22]
 8013836:	f043 0307 	orr.w	r3, r3, #7
 801383a:	82fb      	strh	r3, [r7, #22]

  /* Select the Trigger selection : ETRF */
  tmpsmcr &= (uint16_t)~TIM_SMCR_TS;
 801383c:	8afb      	ldrh	r3, [r7, #22]
 801383e:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 8013842:	82fb      	strh	r3, [r7, #22]
  tmpsmcr |= TIM_TS_ETRF;
 8013844:	8afb      	ldrh	r3, [r7, #22]
 8013846:	f043 0370 	orr.w	r3, r3, #112	; 0x70
 801384a:	82fb      	strh	r3, [r7, #22]

  /* Write to TIMx SMCR */
  TIMx->SMCR = tmpsmcr;
 801384c:	68fb      	ldr	r3, [r7, #12]
 801384e:	8afa      	ldrh	r2, [r7, #22]
 8013850:	811a      	strh	r2, [r3, #8]
}
 8013852:	bf00      	nop
 8013854:	3718      	adds	r7, #24
 8013856:	46bd      	mov	sp, r7
 8013858:	bd80      	pop	{r7, pc}

0801385a <TIM_ETRClockMode2Config>:
  *          This parameter must be a value between 0x00 and 0x0F
  * @retval None
  */
void TIM_ETRClockMode2Config(TIM_TypeDef* TIMx, uint16_t TIM_ExtTRGPrescaler, 
                             uint16_t TIM_ExtTRGPolarity, uint16_t ExtTRGFilter)
{
 801385a:	b580      	push	{r7, lr}
 801385c:	b084      	sub	sp, #16
 801385e:	af00      	add	r7, sp, #0
 8013860:	60f8      	str	r0, [r7, #12]
 8013862:	4608      	mov	r0, r1
 8013864:	4611      	mov	r1, r2
 8013866:	461a      	mov	r2, r3
 8013868:	4603      	mov	r3, r0
 801386a:	817b      	strh	r3, [r7, #10]
 801386c:	460b      	mov	r3, r1
 801386e:	813b      	strh	r3, [r7, #8]
 8013870:	4613      	mov	r3, r2
 8013872:	80fb      	strh	r3, [r7, #6]
  assert_param(IS_TIM_EXT_PRESCALER(TIM_ExtTRGPrescaler));
  assert_param(IS_TIM_EXT_POLARITY(TIM_ExtTRGPolarity));
  assert_param(IS_TIM_EXT_FILTER(ExtTRGFilter));

  /* Configure the ETR Clock source */
  TIM_ETRConfig(TIMx, TIM_ExtTRGPrescaler, TIM_ExtTRGPolarity, ExtTRGFilter);
 8013874:	88fb      	ldrh	r3, [r7, #6]
 8013876:	893a      	ldrh	r2, [r7, #8]
 8013878:	8979      	ldrh	r1, [r7, #10]
 801387a:	68f8      	ldr	r0, [r7, #12]
 801387c:	f000 f87c 	bl	8013978 <TIM_ETRConfig>

  /* Enable the External clock mode2 */
  TIMx->SMCR |= TIM_SMCR_ECE;
 8013880:	68fb      	ldr	r3, [r7, #12]
 8013882:	891b      	ldrh	r3, [r3, #8]
 8013884:	b29b      	uxth	r3, r3
 8013886:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 801388a:	b29a      	uxth	r2, r3
 801388c:	68fb      	ldr	r3, [r7, #12]
 801388e:	811a      	strh	r2, [r3, #8]
}
 8013890:	bf00      	nop
 8013892:	3710      	adds	r7, #16
 8013894:	46bd      	mov	sp, r7
 8013896:	bd80      	pop	{r7, pc}

08013898 <TIM_SelectInputTrigger>:
  *            @arg TIM_TS_TI2FP2: Filtered Timer Input 2
  *            @arg TIM_TS_ETRF: External Trigger input
  * @retval None
  */
void TIM_SelectInputTrigger(TIM_TypeDef* TIMx, uint16_t TIM_InputTriggerSource)
{
 8013898:	b480      	push	{r7}
 801389a:	b085      	sub	sp, #20
 801389c:	af00      	add	r7, sp, #0
 801389e:	6078      	str	r0, [r7, #4]
 80138a0:	460b      	mov	r3, r1
 80138a2:	807b      	strh	r3, [r7, #2]
  uint16_t tmpsmcr = 0;
 80138a4:	2300      	movs	r3, #0
 80138a6:	81fb      	strh	r3, [r7, #14]
  /* Check the parameters */
  assert_param(IS_TIM_LIST1_PERIPH(TIMx)); 
  assert_param(IS_TIM_TRIGGER_SELECTION(TIM_InputTriggerSource));

  /* Get the TIMx SMCR register value */
  tmpsmcr = TIMx->SMCR;
 80138a8:	687b      	ldr	r3, [r7, #4]
 80138aa:	891b      	ldrh	r3, [r3, #8]
 80138ac:	81fb      	strh	r3, [r7, #14]

  /* Reset the TS Bits */
  tmpsmcr &= (uint16_t)~TIM_SMCR_TS;
 80138ae:	89fb      	ldrh	r3, [r7, #14]
 80138b0:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 80138b4:	81fb      	strh	r3, [r7, #14]

  /* Set the Input Trigger source */
  tmpsmcr |= TIM_InputTriggerSource;
 80138b6:	89fa      	ldrh	r2, [r7, #14]
 80138b8:	887b      	ldrh	r3, [r7, #2]
 80138ba:	4313      	orrs	r3, r2
 80138bc:	81fb      	strh	r3, [r7, #14]

  /* Write to TIMx SMCR */
  TIMx->SMCR = tmpsmcr;
 80138be:	687b      	ldr	r3, [r7, #4]
 80138c0:	89fa      	ldrh	r2, [r7, #14]
 80138c2:	811a      	strh	r2, [r3, #8]
}
 80138c4:	bf00      	nop
 80138c6:	3714      	adds	r7, #20
 80138c8:	46bd      	mov	sp, r7
 80138ca:	f85d 7b04 	ldr.w	r7, [sp], #4
 80138ce:	4770      	bx	lr

080138d0 <TIM_SelectOutputTrigger>:
  *            @arg TIM_TRGOSource_OC4Ref: OC4REF signal is used as the trigger output(TRGO)
  *
  * @retval None
  */
void TIM_SelectOutputTrigger(TIM_TypeDef* TIMx, uint16_t TIM_TRGOSource)
{
 80138d0:	b480      	push	{r7}
 80138d2:	b083      	sub	sp, #12
 80138d4:	af00      	add	r7, sp, #0
 80138d6:	6078      	str	r0, [r7, #4]
 80138d8:	460b      	mov	r3, r1
 80138da:	807b      	strh	r3, [r7, #2]
  /* Check the parameters */
  assert_param(IS_TIM_LIST5_PERIPH(TIMx));
  assert_param(IS_TIM_TRGO_SOURCE(TIM_TRGOSource));

  /* Reset the MMS Bits */
  TIMx->CR2 &= (uint16_t)~TIM_CR2_MMS;
 80138dc:	687b      	ldr	r3, [r7, #4]
 80138de:	889b      	ldrh	r3, [r3, #4]
 80138e0:	b29b      	uxth	r3, r3
 80138e2:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 80138e6:	b29a      	uxth	r2, r3
 80138e8:	687b      	ldr	r3, [r7, #4]
 80138ea:	809a      	strh	r2, [r3, #4]
  /* Select the TRGO source */
  TIMx->CR2 |=  TIM_TRGOSource;
 80138ec:	687b      	ldr	r3, [r7, #4]
 80138ee:	889b      	ldrh	r3, [r3, #4]
 80138f0:	b29a      	uxth	r2, r3
 80138f2:	887b      	ldrh	r3, [r7, #2]
 80138f4:	4313      	orrs	r3, r2
 80138f6:	b29a      	uxth	r2, r3
 80138f8:	687b      	ldr	r3, [r7, #4]
 80138fa:	809a      	strh	r2, [r3, #4]
}
 80138fc:	bf00      	nop
 80138fe:	370c      	adds	r7, #12
 8013900:	46bd      	mov	sp, r7
 8013902:	f85d 7b04 	ldr.w	r7, [sp], #4
 8013906:	4770      	bx	lr

08013908 <TIM_SelectSlaveMode>:
  *            @arg TIM_SlaveMode_Trigger:   The counter starts at a rising edge of the trigger TRGI
  *            @arg TIM_SlaveMode_External1: Rising edges of the selected trigger (TRGI) clock the counter
  * @retval None
  */
void TIM_SelectSlaveMode(TIM_TypeDef* TIMx, uint16_t TIM_SlaveMode)
{
 8013908:	b480      	push	{r7}
 801390a:	b083      	sub	sp, #12
 801390c:	af00      	add	r7, sp, #0
 801390e:	6078      	str	r0, [r7, #4]
 8013910:	460b      	mov	r3, r1
 8013912:	807b      	strh	r3, [r7, #2]
  /* Check the parameters */
  assert_param(IS_TIM_LIST2_PERIPH(TIMx));
  assert_param(IS_TIM_SLAVE_MODE(TIM_SlaveMode));

  /* Reset the SMS Bits */
  TIMx->SMCR &= (uint16_t)~TIM_SMCR_SMS;
 8013914:	687b      	ldr	r3, [r7, #4]
 8013916:	891b      	ldrh	r3, [r3, #8]
 8013918:	b29b      	uxth	r3, r3
 801391a:	f023 0307 	bic.w	r3, r3, #7
 801391e:	b29a      	uxth	r2, r3
 8013920:	687b      	ldr	r3, [r7, #4]
 8013922:	811a      	strh	r2, [r3, #8]

  /* Select the Slave Mode */
  TIMx->SMCR |= TIM_SlaveMode;
 8013924:	687b      	ldr	r3, [r7, #4]
 8013926:	891b      	ldrh	r3, [r3, #8]
 8013928:	b29a      	uxth	r2, r3
 801392a:	887b      	ldrh	r3, [r7, #2]
 801392c:	4313      	orrs	r3, r2
 801392e:	b29a      	uxth	r2, r3
 8013930:	687b      	ldr	r3, [r7, #4]
 8013932:	811a      	strh	r2, [r3, #8]
}
 8013934:	bf00      	nop
 8013936:	370c      	adds	r7, #12
 8013938:	46bd      	mov	sp, r7
 801393a:	f85d 7b04 	ldr.w	r7, [sp], #4
 801393e:	4770      	bx	lr

08013940 <TIM_SelectMasterSlaveMode>:
  *                                             and its slaves (through TRGO)
  *            @arg TIM_MasterSlaveMode_Disable: No action
  * @retval None
  */
void TIM_SelectMasterSlaveMode(TIM_TypeDef* TIMx, uint16_t TIM_MasterSlaveMode)
{
 8013940:	b480      	push	{r7}
 8013942:	b083      	sub	sp, #12
 8013944:	af00      	add	r7, sp, #0
 8013946:	6078      	str	r0, [r7, #4]
 8013948:	460b      	mov	r3, r1
 801394a:	807b      	strh	r3, [r7, #2]
  /* Check the parameters */
  assert_param(IS_TIM_LIST2_PERIPH(TIMx));
  assert_param(IS_TIM_MSM_STATE(TIM_MasterSlaveMode));

  /* Reset the MSM Bit */
  TIMx->SMCR &= (uint16_t)~TIM_SMCR_MSM;
 801394c:	687b      	ldr	r3, [r7, #4]
 801394e:	891b      	ldrh	r3, [r3, #8]
 8013950:	b29b      	uxth	r3, r3
 8013952:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 8013956:	b29a      	uxth	r2, r3
 8013958:	687b      	ldr	r3, [r7, #4]
 801395a:	811a      	strh	r2, [r3, #8]
  
  /* Set or Reset the MSM Bit */
  TIMx->SMCR |= TIM_MasterSlaveMode;
 801395c:	687b      	ldr	r3, [r7, #4]
 801395e:	891b      	ldrh	r3, [r3, #8]
 8013960:	b29a      	uxth	r2, r3
 8013962:	887b      	ldrh	r3, [r7, #2]
 8013964:	4313      	orrs	r3, r2
 8013966:	b29a      	uxth	r2, r3
 8013968:	687b      	ldr	r3, [r7, #4]
 801396a:	811a      	strh	r2, [r3, #8]
}
 801396c:	bf00      	nop
 801396e:	370c      	adds	r7, #12
 8013970:	46bd      	mov	sp, r7
 8013972:	f85d 7b04 	ldr.w	r7, [sp], #4
 8013976:	4770      	bx	lr

08013978 <TIM_ETRConfig>:
  *          This parameter must be a value between 0x00 and 0x0F
  * @retval None
  */
void TIM_ETRConfig(TIM_TypeDef* TIMx, uint16_t TIM_ExtTRGPrescaler,
                   uint16_t TIM_ExtTRGPolarity, uint16_t ExtTRGFilter)
{
 8013978:	b480      	push	{r7}
 801397a:	b087      	sub	sp, #28
 801397c:	af00      	add	r7, sp, #0
 801397e:	60f8      	str	r0, [r7, #12]
 8013980:	4608      	mov	r0, r1
 8013982:	4611      	mov	r1, r2
 8013984:	461a      	mov	r2, r3
 8013986:	4603      	mov	r3, r0
 8013988:	817b      	strh	r3, [r7, #10]
 801398a:	460b      	mov	r3, r1
 801398c:	813b      	strh	r3, [r7, #8]
 801398e:	4613      	mov	r3, r2
 8013990:	80fb      	strh	r3, [r7, #6]
  uint16_t tmpsmcr = 0;
 8013992:	2300      	movs	r3, #0
 8013994:	82fb      	strh	r3, [r7, #22]
  assert_param(IS_TIM_LIST3_PERIPH(TIMx));
  assert_param(IS_TIM_EXT_PRESCALER(TIM_ExtTRGPrescaler));
  assert_param(IS_TIM_EXT_POLARITY(TIM_ExtTRGPolarity));
  assert_param(IS_TIM_EXT_FILTER(ExtTRGFilter));

  tmpsmcr = TIMx->SMCR;
 8013996:	68fb      	ldr	r3, [r7, #12]
 8013998:	891b      	ldrh	r3, [r3, #8]
 801399a:	82fb      	strh	r3, [r7, #22]

  /* Reset the ETR Bits */
  tmpsmcr &= SMCR_ETR_MASK;
 801399c:	8afb      	ldrh	r3, [r7, #22]
 801399e:	b2db      	uxtb	r3, r3
 80139a0:	82fb      	strh	r3, [r7, #22]

  /* Set the Prescaler, the Filter value and the Polarity */
  tmpsmcr |= (uint16_t)(TIM_ExtTRGPrescaler | (uint16_t)(TIM_ExtTRGPolarity | (uint16_t)(ExtTRGFilter << (uint16_t)8)));
 80139a2:	88fb      	ldrh	r3, [r7, #6]
 80139a4:	021b      	lsls	r3, r3, #8
 80139a6:	b29a      	uxth	r2, r3
 80139a8:	893b      	ldrh	r3, [r7, #8]
 80139aa:	4313      	orrs	r3, r2
 80139ac:	b29a      	uxth	r2, r3
 80139ae:	897b      	ldrh	r3, [r7, #10]
 80139b0:	4313      	orrs	r3, r2
 80139b2:	b29a      	uxth	r2, r3
 80139b4:	8afb      	ldrh	r3, [r7, #22]
 80139b6:	4313      	orrs	r3, r2
 80139b8:	82fb      	strh	r3, [r7, #22]

  /* Write to TIMx SMCR */
  TIMx->SMCR = tmpsmcr;
 80139ba:	68fb      	ldr	r3, [r7, #12]
 80139bc:	8afa      	ldrh	r2, [r7, #22]
 80139be:	811a      	strh	r2, [r3, #8]
}
 80139c0:	bf00      	nop
 80139c2:	371c      	adds	r7, #28
 80139c4:	46bd      	mov	sp, r7
 80139c6:	f85d 7b04 	ldr.w	r7, [sp], #4
 80139ca:	4770      	bx	lr

080139cc <TIM_EncoderInterfaceConfig>:
  *            @arg TIM_ICPolarity_Rising: IC Rising edge.
  * @retval None
  */
void TIM_EncoderInterfaceConfig(TIM_TypeDef* TIMx, uint16_t TIM_EncoderMode,
                                uint16_t TIM_IC1Polarity, uint16_t TIM_IC2Polarity)
{
 80139cc:	b480      	push	{r7}
 80139ce:	b087      	sub	sp, #28
 80139d0:	af00      	add	r7, sp, #0
 80139d2:	60f8      	str	r0, [r7, #12]
 80139d4:	4608      	mov	r0, r1
 80139d6:	4611      	mov	r1, r2
 80139d8:	461a      	mov	r2, r3
 80139da:	4603      	mov	r3, r0
 80139dc:	817b      	strh	r3, [r7, #10]
 80139de:	460b      	mov	r3, r1
 80139e0:	813b      	strh	r3, [r7, #8]
 80139e2:	4613      	mov	r3, r2
 80139e4:	80fb      	strh	r3, [r7, #6]
  uint16_t tmpsmcr = 0;
 80139e6:	2300      	movs	r3, #0
 80139e8:	82fb      	strh	r3, [r7, #22]
  uint16_t tmpccmr1 = 0;
 80139ea:	2300      	movs	r3, #0
 80139ec:	82bb      	strh	r3, [r7, #20]
  uint16_t tmpccer = 0;
 80139ee:	2300      	movs	r3, #0
 80139f0:	827b      	strh	r3, [r7, #18]
  assert_param(IS_TIM_ENCODER_MODE(TIM_EncoderMode));
  assert_param(IS_TIM_IC_POLARITY(TIM_IC1Polarity));
  assert_param(IS_TIM_IC_POLARITY(TIM_IC2Polarity));

  /* Get the TIMx SMCR register value */
  tmpsmcr = TIMx->SMCR;
 80139f2:	68fb      	ldr	r3, [r7, #12]
 80139f4:	891b      	ldrh	r3, [r3, #8]
 80139f6:	82fb      	strh	r3, [r7, #22]

  /* Get the TIMx CCMR1 register value */
  tmpccmr1 = TIMx->CCMR1;
 80139f8:	68fb      	ldr	r3, [r7, #12]
 80139fa:	8b1b      	ldrh	r3, [r3, #24]
 80139fc:	82bb      	strh	r3, [r7, #20]

  /* Get the TIMx CCER register value */
  tmpccer = TIMx->CCER;
 80139fe:	68fb      	ldr	r3, [r7, #12]
 8013a00:	8c1b      	ldrh	r3, [r3, #32]
 8013a02:	827b      	strh	r3, [r7, #18]

  /* Set the encoder Mode */
  tmpsmcr &= (uint16_t)~TIM_SMCR_SMS;
 8013a04:	8afb      	ldrh	r3, [r7, #22]
 8013a06:	f023 0307 	bic.w	r3, r3, #7
 8013a0a:	82fb      	strh	r3, [r7, #22]
  tmpsmcr |= TIM_EncoderMode;
 8013a0c:	8afa      	ldrh	r2, [r7, #22]
 8013a0e:	897b      	ldrh	r3, [r7, #10]
 8013a10:	4313      	orrs	r3, r2
 8013a12:	82fb      	strh	r3, [r7, #22]

  /* Select the Capture Compare 1 and the Capture Compare 2 as input */
  tmpccmr1 &= ((uint16_t)~TIM_CCMR1_CC1S) & ((uint16_t)~TIM_CCMR1_CC2S);
 8013a14:	8abb      	ldrh	r3, [r7, #20]
 8013a16:	f423 7340 	bic.w	r3, r3, #768	; 0x300
 8013a1a:	f023 0303 	bic.w	r3, r3, #3
 8013a1e:	82bb      	strh	r3, [r7, #20]
  tmpccmr1 |= TIM_CCMR1_CC1S_0 | TIM_CCMR1_CC2S_0;
 8013a20:	8abb      	ldrh	r3, [r7, #20]
 8013a22:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 8013a26:	f043 0301 	orr.w	r3, r3, #1
 8013a2a:	82bb      	strh	r3, [r7, #20]

  /* Set the TI1 and the TI2 Polarities */
  tmpccer &= ((uint16_t)~TIM_CCER_CC1P) & ((uint16_t)~TIM_CCER_CC2P);
 8013a2c:	8a7b      	ldrh	r3, [r7, #18]
 8013a2e:	f023 0322 	bic.w	r3, r3, #34	; 0x22
 8013a32:	827b      	strh	r3, [r7, #18]
  tmpccer |= (uint16_t)(TIM_IC1Polarity | (uint16_t)(TIM_IC2Polarity << (uint16_t)4));
 8013a34:	88fb      	ldrh	r3, [r7, #6]
 8013a36:	011b      	lsls	r3, r3, #4
 8013a38:	b29a      	uxth	r2, r3
 8013a3a:	893b      	ldrh	r3, [r7, #8]
 8013a3c:	4313      	orrs	r3, r2
 8013a3e:	b29a      	uxth	r2, r3
 8013a40:	8a7b      	ldrh	r3, [r7, #18]
 8013a42:	4313      	orrs	r3, r2
 8013a44:	827b      	strh	r3, [r7, #18]

  /* Write to TIMx SMCR */
  TIMx->SMCR = tmpsmcr;
 8013a46:	68fb      	ldr	r3, [r7, #12]
 8013a48:	8afa      	ldrh	r2, [r7, #22]
 8013a4a:	811a      	strh	r2, [r3, #8]

  /* Write to TIMx CCMR1 */
  TIMx->CCMR1 = tmpccmr1;
 8013a4c:	68fb      	ldr	r3, [r7, #12]
 8013a4e:	8aba      	ldrh	r2, [r7, #20]
 8013a50:	831a      	strh	r2, [r3, #24]

  /* Write to TIMx CCER */
  TIMx->CCER = tmpccer;
 8013a52:	68fb      	ldr	r3, [r7, #12]
 8013a54:	8a7a      	ldrh	r2, [r7, #18]
 8013a56:	841a      	strh	r2, [r3, #32]
}
 8013a58:	bf00      	nop
 8013a5a:	371c      	adds	r7, #28
 8013a5c:	46bd      	mov	sp, r7
 8013a5e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8013a62:	4770      	bx	lr

08013a64 <TIM_SelectHallSensor>:
  * @param  NewState: new state of the TIMx Hall sensor interface.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void TIM_SelectHallSensor(TIM_TypeDef* TIMx, FunctionalState NewState)
{
 8013a64:	b480      	push	{r7}
 8013a66:	b083      	sub	sp, #12
 8013a68:	af00      	add	r7, sp, #0
 8013a6a:	6078      	str	r0, [r7, #4]
 8013a6c:	460b      	mov	r3, r1
 8013a6e:	70fb      	strb	r3, [r7, #3]
  /* Check the parameters */
  assert_param(IS_TIM_LIST2_PERIPH(TIMx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 8013a70:	78fb      	ldrb	r3, [r7, #3]
 8013a72:	2b00      	cmp	r3, #0
 8013a74:	d008      	beq.n	8013a88 <TIM_SelectHallSensor+0x24>
  {
    /* Set the TI1S Bit */
    TIMx->CR2 |= TIM_CR2_TI1S;
 8013a76:	687b      	ldr	r3, [r7, #4]
 8013a78:	889b      	ldrh	r3, [r3, #4]
 8013a7a:	b29b      	uxth	r3, r3
 8013a7c:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8013a80:	b29a      	uxth	r2, r3
 8013a82:	687b      	ldr	r3, [r7, #4]
 8013a84:	809a      	strh	r2, [r3, #4]
  else
  {
    /* Reset the TI1S Bit */
    TIMx->CR2 &= (uint16_t)~TIM_CR2_TI1S;
  }
}
 8013a86:	e007      	b.n	8013a98 <TIM_SelectHallSensor+0x34>
    TIMx->CR2 &= (uint16_t)~TIM_CR2_TI1S;
 8013a88:	687b      	ldr	r3, [r7, #4]
 8013a8a:	889b      	ldrh	r3, [r3, #4]
 8013a8c:	b29b      	uxth	r3, r3
 8013a8e:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 8013a92:	b29a      	uxth	r2, r3
 8013a94:	687b      	ldr	r3, [r7, #4]
 8013a96:	809a      	strh	r2, [r3, #4]
}
 8013a98:	bf00      	nop
 8013a9a:	370c      	adds	r7, #12
 8013a9c:	46bd      	mov	sp, r7
 8013a9e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8013aa2:	4770      	bx	lr

08013aa4 <TIM_RemapConfig>:
  *            @arg TIM11_HSE:      TIM11 CH4 input is connected to HSE_RTC clock
  *                                 (HSE divided by a programmable prescaler)  
  * @retval None
  */
void TIM_RemapConfig(TIM_TypeDef* TIMx, uint16_t TIM_Remap)
{
 8013aa4:	b480      	push	{r7}
 8013aa6:	b083      	sub	sp, #12
 8013aa8:	af00      	add	r7, sp, #0
 8013aaa:	6078      	str	r0, [r7, #4]
 8013aac:	460b      	mov	r3, r1
 8013aae:	807b      	strh	r3, [r7, #2]
 /* Check the parameters */
  assert_param(IS_TIM_LIST6_PERIPH(TIMx));
  assert_param(IS_TIM_REMAP(TIM_Remap));

  /* Set the Timer remapping configuration */
  TIMx->OR =  TIM_Remap;
 8013ab0:	687b      	ldr	r3, [r7, #4]
 8013ab2:	887a      	ldrh	r2, [r7, #2]
 8013ab4:	f8a3 2050 	strh.w	r2, [r3, #80]	; 0x50
}
 8013ab8:	bf00      	nop
 8013aba:	370c      	adds	r7, #12
 8013abc:	46bd      	mov	sp, r7
 8013abe:	f85d 7b04 	ldr.w	r7, [sp], #4
 8013ac2:	4770      	bx	lr

08013ac4 <TI1_Config>:
  *          This parameter must be a value between 0x00 and 0x0F.
  * @retval None
  */
static void TI1_Config(TIM_TypeDef* TIMx, uint16_t TIM_ICPolarity, uint16_t TIM_ICSelection,
                       uint16_t TIM_ICFilter)
{
 8013ac4:	b480      	push	{r7}
 8013ac6:	b087      	sub	sp, #28
 8013ac8:	af00      	add	r7, sp, #0
 8013aca:	60f8      	str	r0, [r7, #12]
 8013acc:	4608      	mov	r0, r1
 8013ace:	4611      	mov	r1, r2
 8013ad0:	461a      	mov	r2, r3
 8013ad2:	4603      	mov	r3, r0
 8013ad4:	817b      	strh	r3, [r7, #10]
 8013ad6:	460b      	mov	r3, r1
 8013ad8:	813b      	strh	r3, [r7, #8]
 8013ada:	4613      	mov	r3, r2
 8013adc:	80fb      	strh	r3, [r7, #6]
  uint16_t tmpccmr1 = 0, tmpccer = 0;
 8013ade:	2300      	movs	r3, #0
 8013ae0:	82fb      	strh	r3, [r7, #22]
 8013ae2:	2300      	movs	r3, #0
 8013ae4:	82bb      	strh	r3, [r7, #20]

  /* Disable the Channel 1: Reset the CC1E Bit */
  TIMx->CCER &= (uint16_t)~TIM_CCER_CC1E;
 8013ae6:	68fb      	ldr	r3, [r7, #12]
 8013ae8:	8c1b      	ldrh	r3, [r3, #32]
 8013aea:	b29b      	uxth	r3, r3
 8013aec:	f023 0301 	bic.w	r3, r3, #1
 8013af0:	b29a      	uxth	r2, r3
 8013af2:	68fb      	ldr	r3, [r7, #12]
 8013af4:	841a      	strh	r2, [r3, #32]
  tmpccmr1 = TIMx->CCMR1;
 8013af6:	68fb      	ldr	r3, [r7, #12]
 8013af8:	8b1b      	ldrh	r3, [r3, #24]
 8013afa:	82fb      	strh	r3, [r7, #22]
  tmpccer = TIMx->CCER;
 8013afc:	68fb      	ldr	r3, [r7, #12]
 8013afe:	8c1b      	ldrh	r3, [r3, #32]
 8013b00:	82bb      	strh	r3, [r7, #20]

  /* Select the Input and set the filter */
  tmpccmr1 &= ((uint16_t)~TIM_CCMR1_CC1S) & ((uint16_t)~TIM_CCMR1_IC1F);
 8013b02:	8afb      	ldrh	r3, [r7, #22]
 8013b04:	f023 03f3 	bic.w	r3, r3, #243	; 0xf3
 8013b08:	82fb      	strh	r3, [r7, #22]
  tmpccmr1 |= (uint16_t)(TIM_ICSelection | (uint16_t)(TIM_ICFilter << (uint16_t)4));
 8013b0a:	88fb      	ldrh	r3, [r7, #6]
 8013b0c:	011b      	lsls	r3, r3, #4
 8013b0e:	b29a      	uxth	r2, r3
 8013b10:	893b      	ldrh	r3, [r7, #8]
 8013b12:	4313      	orrs	r3, r2
 8013b14:	b29a      	uxth	r2, r3
 8013b16:	8afb      	ldrh	r3, [r7, #22]
 8013b18:	4313      	orrs	r3, r2
 8013b1a:	82fb      	strh	r3, [r7, #22]

  /* Select the Polarity and set the CC1E Bit */
  tmpccer &= (uint16_t)~(TIM_CCER_CC1P | TIM_CCER_CC1NP);
 8013b1c:	8abb      	ldrh	r3, [r7, #20]
 8013b1e:	f023 030a 	bic.w	r3, r3, #10
 8013b22:	82bb      	strh	r3, [r7, #20]
  tmpccer |= (uint16_t)(TIM_ICPolarity | (uint16_t)TIM_CCER_CC1E);
 8013b24:	897a      	ldrh	r2, [r7, #10]
 8013b26:	8abb      	ldrh	r3, [r7, #20]
 8013b28:	4313      	orrs	r3, r2
 8013b2a:	b29b      	uxth	r3, r3
 8013b2c:	f043 0301 	orr.w	r3, r3, #1
 8013b30:	82bb      	strh	r3, [r7, #20]

  /* Write to TIMx CCMR1 and CCER registers */
  TIMx->CCMR1 = tmpccmr1;
 8013b32:	68fb      	ldr	r3, [r7, #12]
 8013b34:	8afa      	ldrh	r2, [r7, #22]
 8013b36:	831a      	strh	r2, [r3, #24]
  TIMx->CCER = tmpccer;
 8013b38:	68fb      	ldr	r3, [r7, #12]
 8013b3a:	8aba      	ldrh	r2, [r7, #20]
 8013b3c:	841a      	strh	r2, [r3, #32]
}
 8013b3e:	bf00      	nop
 8013b40:	371c      	adds	r7, #28
 8013b42:	46bd      	mov	sp, r7
 8013b44:	f85d 7b04 	ldr.w	r7, [sp], #4
 8013b48:	4770      	bx	lr

08013b4a <TI2_Config>:
  *          This parameter must be a value between 0x00 and 0x0F.
  * @retval None
  */
static void TI2_Config(TIM_TypeDef* TIMx, uint16_t TIM_ICPolarity, uint16_t TIM_ICSelection,
                       uint16_t TIM_ICFilter)
{
 8013b4a:	b480      	push	{r7}
 8013b4c:	b087      	sub	sp, #28
 8013b4e:	af00      	add	r7, sp, #0
 8013b50:	60f8      	str	r0, [r7, #12]
 8013b52:	4608      	mov	r0, r1
 8013b54:	4611      	mov	r1, r2
 8013b56:	461a      	mov	r2, r3
 8013b58:	4603      	mov	r3, r0
 8013b5a:	817b      	strh	r3, [r7, #10]
 8013b5c:	460b      	mov	r3, r1
 8013b5e:	813b      	strh	r3, [r7, #8]
 8013b60:	4613      	mov	r3, r2
 8013b62:	80fb      	strh	r3, [r7, #6]
  uint16_t tmpccmr1 = 0, tmpccer = 0, tmp = 0;
 8013b64:	2300      	movs	r3, #0
 8013b66:	82fb      	strh	r3, [r7, #22]
 8013b68:	2300      	movs	r3, #0
 8013b6a:	82bb      	strh	r3, [r7, #20]
 8013b6c:	2300      	movs	r3, #0
 8013b6e:	827b      	strh	r3, [r7, #18]

  /* Disable the Channel 2: Reset the CC2E Bit */
  TIMx->CCER &= (uint16_t)~TIM_CCER_CC2E;
 8013b70:	68fb      	ldr	r3, [r7, #12]
 8013b72:	8c1b      	ldrh	r3, [r3, #32]
 8013b74:	b29b      	uxth	r3, r3
 8013b76:	f023 0310 	bic.w	r3, r3, #16
 8013b7a:	b29a      	uxth	r2, r3
 8013b7c:	68fb      	ldr	r3, [r7, #12]
 8013b7e:	841a      	strh	r2, [r3, #32]
  tmpccmr1 = TIMx->CCMR1;
 8013b80:	68fb      	ldr	r3, [r7, #12]
 8013b82:	8b1b      	ldrh	r3, [r3, #24]
 8013b84:	82fb      	strh	r3, [r7, #22]
  tmpccer = TIMx->CCER;
 8013b86:	68fb      	ldr	r3, [r7, #12]
 8013b88:	8c1b      	ldrh	r3, [r3, #32]
 8013b8a:	82bb      	strh	r3, [r7, #20]
  tmp = (uint16_t)(TIM_ICPolarity << 4);
 8013b8c:	897b      	ldrh	r3, [r7, #10]
 8013b8e:	011b      	lsls	r3, r3, #4
 8013b90:	827b      	strh	r3, [r7, #18]

  /* Select the Input and set the filter */
  tmpccmr1 &= ((uint16_t)~TIM_CCMR1_CC2S) & ((uint16_t)~TIM_CCMR1_IC2F);
 8013b92:	8afb      	ldrh	r3, [r7, #22]
 8013b94:	f423 7340 	bic.w	r3, r3, #768	; 0x300
 8013b98:	051b      	lsls	r3, r3, #20
 8013b9a:	0d1b      	lsrs	r3, r3, #20
 8013b9c:	82fb      	strh	r3, [r7, #22]
  tmpccmr1 |= (uint16_t)(TIM_ICFilter << 12);
 8013b9e:	88fb      	ldrh	r3, [r7, #6]
 8013ba0:	031b      	lsls	r3, r3, #12
 8013ba2:	b29a      	uxth	r2, r3
 8013ba4:	8afb      	ldrh	r3, [r7, #22]
 8013ba6:	4313      	orrs	r3, r2
 8013ba8:	82fb      	strh	r3, [r7, #22]
  tmpccmr1 |= (uint16_t)(TIM_ICSelection << 8);
 8013baa:	893b      	ldrh	r3, [r7, #8]
 8013bac:	021b      	lsls	r3, r3, #8
 8013bae:	b29a      	uxth	r2, r3
 8013bb0:	8afb      	ldrh	r3, [r7, #22]
 8013bb2:	4313      	orrs	r3, r2
 8013bb4:	82fb      	strh	r3, [r7, #22]

  /* Select the Polarity and set the CC2E Bit */
  tmpccer &= (uint16_t)~(TIM_CCER_CC2P | TIM_CCER_CC2NP);
 8013bb6:	8abb      	ldrh	r3, [r7, #20]
 8013bb8:	f023 03a0 	bic.w	r3, r3, #160	; 0xa0
 8013bbc:	82bb      	strh	r3, [r7, #20]
  tmpccer |=  (uint16_t)(tmp | (uint16_t)TIM_CCER_CC2E);
 8013bbe:	8a7a      	ldrh	r2, [r7, #18]
 8013bc0:	8abb      	ldrh	r3, [r7, #20]
 8013bc2:	4313      	orrs	r3, r2
 8013bc4:	b29b      	uxth	r3, r3
 8013bc6:	f043 0310 	orr.w	r3, r3, #16
 8013bca:	82bb      	strh	r3, [r7, #20]

  /* Write to TIMx CCMR1 and CCER registers */
  TIMx->CCMR1 = tmpccmr1 ;
 8013bcc:	68fb      	ldr	r3, [r7, #12]
 8013bce:	8afa      	ldrh	r2, [r7, #22]
 8013bd0:	831a      	strh	r2, [r3, #24]
  TIMx->CCER = tmpccer;
 8013bd2:	68fb      	ldr	r3, [r7, #12]
 8013bd4:	8aba      	ldrh	r2, [r7, #20]
 8013bd6:	841a      	strh	r2, [r3, #32]
}
 8013bd8:	bf00      	nop
 8013bda:	371c      	adds	r7, #28
 8013bdc:	46bd      	mov	sp, r7
 8013bde:	f85d 7b04 	ldr.w	r7, [sp], #4
 8013be2:	4770      	bx	lr

08013be4 <TI3_Config>:
  *          This parameter must be a value between 0x00 and 0x0F.
  * @retval None
  */
static void TI3_Config(TIM_TypeDef* TIMx, uint16_t TIM_ICPolarity, uint16_t TIM_ICSelection,
                       uint16_t TIM_ICFilter)
{
 8013be4:	b480      	push	{r7}
 8013be6:	b087      	sub	sp, #28
 8013be8:	af00      	add	r7, sp, #0
 8013bea:	60f8      	str	r0, [r7, #12]
 8013bec:	4608      	mov	r0, r1
 8013bee:	4611      	mov	r1, r2
 8013bf0:	461a      	mov	r2, r3
 8013bf2:	4603      	mov	r3, r0
 8013bf4:	817b      	strh	r3, [r7, #10]
 8013bf6:	460b      	mov	r3, r1
 8013bf8:	813b      	strh	r3, [r7, #8]
 8013bfa:	4613      	mov	r3, r2
 8013bfc:	80fb      	strh	r3, [r7, #6]
  uint16_t tmpccmr2 = 0, tmpccer = 0, tmp = 0;
 8013bfe:	2300      	movs	r3, #0
 8013c00:	82fb      	strh	r3, [r7, #22]
 8013c02:	2300      	movs	r3, #0
 8013c04:	82bb      	strh	r3, [r7, #20]
 8013c06:	2300      	movs	r3, #0
 8013c08:	827b      	strh	r3, [r7, #18]

  /* Disable the Channel 3: Reset the CC3E Bit */
  TIMx->CCER &= (uint16_t)~TIM_CCER_CC3E;
 8013c0a:	68fb      	ldr	r3, [r7, #12]
 8013c0c:	8c1b      	ldrh	r3, [r3, #32]
 8013c0e:	b29b      	uxth	r3, r3
 8013c10:	f423 7380 	bic.w	r3, r3, #256	; 0x100
 8013c14:	b29a      	uxth	r2, r3
 8013c16:	68fb      	ldr	r3, [r7, #12]
 8013c18:	841a      	strh	r2, [r3, #32]
  tmpccmr2 = TIMx->CCMR2;
 8013c1a:	68fb      	ldr	r3, [r7, #12]
 8013c1c:	8b9b      	ldrh	r3, [r3, #28]
 8013c1e:	82fb      	strh	r3, [r7, #22]
  tmpccer = TIMx->CCER;
 8013c20:	68fb      	ldr	r3, [r7, #12]
 8013c22:	8c1b      	ldrh	r3, [r3, #32]
 8013c24:	82bb      	strh	r3, [r7, #20]
  tmp = (uint16_t)(TIM_ICPolarity << 8);
 8013c26:	897b      	ldrh	r3, [r7, #10]
 8013c28:	021b      	lsls	r3, r3, #8
 8013c2a:	827b      	strh	r3, [r7, #18]

  /* Select the Input and set the filter */
  tmpccmr2 &= ((uint16_t)~TIM_CCMR1_CC1S) & ((uint16_t)~TIM_CCMR2_IC3F);
 8013c2c:	8afb      	ldrh	r3, [r7, #22]
 8013c2e:	f023 03f3 	bic.w	r3, r3, #243	; 0xf3
 8013c32:	82fb      	strh	r3, [r7, #22]
  tmpccmr2 |= (uint16_t)(TIM_ICSelection | (uint16_t)(TIM_ICFilter << (uint16_t)4));
 8013c34:	88fb      	ldrh	r3, [r7, #6]
 8013c36:	011b      	lsls	r3, r3, #4
 8013c38:	b29a      	uxth	r2, r3
 8013c3a:	893b      	ldrh	r3, [r7, #8]
 8013c3c:	4313      	orrs	r3, r2
 8013c3e:	b29a      	uxth	r2, r3
 8013c40:	8afb      	ldrh	r3, [r7, #22]
 8013c42:	4313      	orrs	r3, r2
 8013c44:	82fb      	strh	r3, [r7, #22]

  /* Select the Polarity and set the CC3E Bit */
  tmpccer &= (uint16_t)~(TIM_CCER_CC3P | TIM_CCER_CC3NP);
 8013c46:	8abb      	ldrh	r3, [r7, #20]
 8013c48:	f423 6320 	bic.w	r3, r3, #2560	; 0xa00
 8013c4c:	82bb      	strh	r3, [r7, #20]
  tmpccer |= (uint16_t)(tmp | (uint16_t)TIM_CCER_CC3E);
 8013c4e:	8a7a      	ldrh	r2, [r7, #18]
 8013c50:	8abb      	ldrh	r3, [r7, #20]
 8013c52:	4313      	orrs	r3, r2
 8013c54:	b29b      	uxth	r3, r3
 8013c56:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 8013c5a:	82bb      	strh	r3, [r7, #20]

  /* Write to TIMx CCMR2 and CCER registers */
  TIMx->CCMR2 = tmpccmr2;
 8013c5c:	68fb      	ldr	r3, [r7, #12]
 8013c5e:	8afa      	ldrh	r2, [r7, #22]
 8013c60:	839a      	strh	r2, [r3, #28]
  TIMx->CCER = tmpccer;
 8013c62:	68fb      	ldr	r3, [r7, #12]
 8013c64:	8aba      	ldrh	r2, [r7, #20]
 8013c66:	841a      	strh	r2, [r3, #32]
}
 8013c68:	bf00      	nop
 8013c6a:	371c      	adds	r7, #28
 8013c6c:	46bd      	mov	sp, r7
 8013c6e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8013c72:	4770      	bx	lr

08013c74 <TI4_Config>:
  *          This parameter must be a value between 0x00 and 0x0F.
  * @retval None
  */
static void TI4_Config(TIM_TypeDef* TIMx, uint16_t TIM_ICPolarity, uint16_t TIM_ICSelection,
                       uint16_t TIM_ICFilter)
{
 8013c74:	b480      	push	{r7}
 8013c76:	b087      	sub	sp, #28
 8013c78:	af00      	add	r7, sp, #0
 8013c7a:	60f8      	str	r0, [r7, #12]
 8013c7c:	4608      	mov	r0, r1
 8013c7e:	4611      	mov	r1, r2
 8013c80:	461a      	mov	r2, r3
 8013c82:	4603      	mov	r3, r0
 8013c84:	817b      	strh	r3, [r7, #10]
 8013c86:	460b      	mov	r3, r1
 8013c88:	813b      	strh	r3, [r7, #8]
 8013c8a:	4613      	mov	r3, r2
 8013c8c:	80fb      	strh	r3, [r7, #6]
  uint16_t tmpccmr2 = 0, tmpccer = 0, tmp = 0;
 8013c8e:	2300      	movs	r3, #0
 8013c90:	82fb      	strh	r3, [r7, #22]
 8013c92:	2300      	movs	r3, #0
 8013c94:	82bb      	strh	r3, [r7, #20]
 8013c96:	2300      	movs	r3, #0
 8013c98:	827b      	strh	r3, [r7, #18]

  /* Disable the Channel 4: Reset the CC4E Bit */
  TIMx->CCER &= (uint16_t)~TIM_CCER_CC4E;
 8013c9a:	68fb      	ldr	r3, [r7, #12]
 8013c9c:	8c1b      	ldrh	r3, [r3, #32]
 8013c9e:	b29b      	uxth	r3, r3
 8013ca0:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
 8013ca4:	b29a      	uxth	r2, r3
 8013ca6:	68fb      	ldr	r3, [r7, #12]
 8013ca8:	841a      	strh	r2, [r3, #32]
  tmpccmr2 = TIMx->CCMR2;
 8013caa:	68fb      	ldr	r3, [r7, #12]
 8013cac:	8b9b      	ldrh	r3, [r3, #28]
 8013cae:	82fb      	strh	r3, [r7, #22]
  tmpccer = TIMx->CCER;
 8013cb0:	68fb      	ldr	r3, [r7, #12]
 8013cb2:	8c1b      	ldrh	r3, [r3, #32]
 8013cb4:	82bb      	strh	r3, [r7, #20]
  tmp = (uint16_t)(TIM_ICPolarity << 12);
 8013cb6:	897b      	ldrh	r3, [r7, #10]
 8013cb8:	031b      	lsls	r3, r3, #12
 8013cba:	827b      	strh	r3, [r7, #18]

  /* Select the Input and set the filter */
  tmpccmr2 &= ((uint16_t)~TIM_CCMR1_CC2S) & ((uint16_t)~TIM_CCMR1_IC2F);
 8013cbc:	8afb      	ldrh	r3, [r7, #22]
 8013cbe:	f423 7340 	bic.w	r3, r3, #768	; 0x300
 8013cc2:	051b      	lsls	r3, r3, #20
 8013cc4:	0d1b      	lsrs	r3, r3, #20
 8013cc6:	82fb      	strh	r3, [r7, #22]
  tmpccmr2 |= (uint16_t)(TIM_ICSelection << 8);
 8013cc8:	893b      	ldrh	r3, [r7, #8]
 8013cca:	021b      	lsls	r3, r3, #8
 8013ccc:	b29a      	uxth	r2, r3
 8013cce:	8afb      	ldrh	r3, [r7, #22]
 8013cd0:	4313      	orrs	r3, r2
 8013cd2:	82fb      	strh	r3, [r7, #22]
  tmpccmr2 |= (uint16_t)(TIM_ICFilter << 12);
 8013cd4:	88fb      	ldrh	r3, [r7, #6]
 8013cd6:	031b      	lsls	r3, r3, #12
 8013cd8:	b29a      	uxth	r2, r3
 8013cda:	8afb      	ldrh	r3, [r7, #22]
 8013cdc:	4313      	orrs	r3, r2
 8013cde:	82fb      	strh	r3, [r7, #22]

  /* Select the Polarity and set the CC4E Bit */
  tmpccer &= (uint16_t)~(TIM_CCER_CC4P | TIM_CCER_CC4NP);
 8013ce0:	8abb      	ldrh	r3, [r7, #20]
 8013ce2:	f423 5300 	bic.w	r3, r3, #8192	; 0x2000
 8013ce6:	045b      	lsls	r3, r3, #17
 8013ce8:	0c5b      	lsrs	r3, r3, #17
 8013cea:	82bb      	strh	r3, [r7, #20]
  tmpccer |= (uint16_t)(tmp | (uint16_t)TIM_CCER_CC4E);
 8013cec:	8a7a      	ldrh	r2, [r7, #18]
 8013cee:	8abb      	ldrh	r3, [r7, #20]
 8013cf0:	4313      	orrs	r3, r2
 8013cf2:	b29b      	uxth	r3, r3
 8013cf4:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
 8013cf8:	82bb      	strh	r3, [r7, #20]

  /* Write to TIMx CCMR2 and CCER registers */
  TIMx->CCMR2 = tmpccmr2;
 8013cfa:	68fb      	ldr	r3, [r7, #12]
 8013cfc:	8afa      	ldrh	r2, [r7, #22]
 8013cfe:	839a      	strh	r2, [r3, #28]
  TIMx->CCER = tmpccer ;
 8013d00:	68fb      	ldr	r3, [r7, #12]
 8013d02:	8aba      	ldrh	r2, [r7, #20]
 8013d04:	841a      	strh	r2, [r3, #32]
}
 8013d06:	bf00      	nop
 8013d08:	371c      	adds	r7, #28
 8013d0a:	46bd      	mov	sp, r7
 8013d0c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8013d10:	4770      	bx	lr
 8013d12:	bf00      	nop

08013d14 <USART_DeInit>:
  * @param  USARTx: where x can be 1, 2, 3, 4, 5 or 6 to select the USART or 
  *         UART peripheral.
  * @retval None
  */
void USART_DeInit(USART_TypeDef* USARTx)
{
 8013d14:	b580      	push	{r7, lr}
 8013d16:	b082      	sub	sp, #8
 8013d18:	af00      	add	r7, sp, #0
 8013d1a:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));

  if (USARTx == USART1)
 8013d1c:	687b      	ldr	r3, [r7, #4]
 8013d1e:	4a2c      	ldr	r2, [pc, #176]	; (8013dd0 <USART_DeInit+0xbc>)
 8013d20:	4293      	cmp	r3, r2
 8013d22:	d108      	bne.n	8013d36 <USART_DeInit+0x22>
  {
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_USART1, ENABLE);
 8013d24:	2101      	movs	r1, #1
 8013d26:	2010      	movs	r0, #16
 8013d28:	f7fb fe14 	bl	800f954 <RCC_APB2PeriphResetCmd>
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_USART1, DISABLE);
 8013d2c:	2100      	movs	r1, #0
 8013d2e:	2010      	movs	r0, #16
 8013d30:	f7fb fe10 	bl	800f954 <RCC_APB2PeriphResetCmd>
    { 
      RCC_APB2PeriphResetCmd(RCC_APB2Periph_USART6, ENABLE);
      RCC_APB2PeriphResetCmd(RCC_APB2Periph_USART6, DISABLE);
    }
  }
}
 8013d34:	e047      	b.n	8013dc6 <USART_DeInit+0xb2>
  else if (USARTx == USART2)
 8013d36:	687b      	ldr	r3, [r7, #4]
 8013d38:	4a26      	ldr	r2, [pc, #152]	; (8013dd4 <USART_DeInit+0xc0>)
 8013d3a:	4293      	cmp	r3, r2
 8013d3c:	d10a      	bne.n	8013d54 <USART_DeInit+0x40>
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART2, ENABLE);
 8013d3e:	2101      	movs	r1, #1
 8013d40:	f44f 3000 	mov.w	r0, #131072	; 0x20000
 8013d44:	f7fb fde6 	bl	800f914 <RCC_APB1PeriphResetCmd>
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART2, DISABLE);
 8013d48:	2100      	movs	r1, #0
 8013d4a:	f44f 3000 	mov.w	r0, #131072	; 0x20000
 8013d4e:	f7fb fde1 	bl	800f914 <RCC_APB1PeriphResetCmd>
}
 8013d52:	e038      	b.n	8013dc6 <USART_DeInit+0xb2>
  else if (USARTx == USART3)
 8013d54:	687b      	ldr	r3, [r7, #4]
 8013d56:	4a20      	ldr	r2, [pc, #128]	; (8013dd8 <USART_DeInit+0xc4>)
 8013d58:	4293      	cmp	r3, r2
 8013d5a:	d10a      	bne.n	8013d72 <USART_DeInit+0x5e>
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART3, ENABLE);
 8013d5c:	2101      	movs	r1, #1
 8013d5e:	f44f 2080 	mov.w	r0, #262144	; 0x40000
 8013d62:	f7fb fdd7 	bl	800f914 <RCC_APB1PeriphResetCmd>
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART3, DISABLE);
 8013d66:	2100      	movs	r1, #0
 8013d68:	f44f 2080 	mov.w	r0, #262144	; 0x40000
 8013d6c:	f7fb fdd2 	bl	800f914 <RCC_APB1PeriphResetCmd>
}
 8013d70:	e029      	b.n	8013dc6 <USART_DeInit+0xb2>
  else if (USARTx == UART4)
 8013d72:	687b      	ldr	r3, [r7, #4]
 8013d74:	4a19      	ldr	r2, [pc, #100]	; (8013ddc <USART_DeInit+0xc8>)
 8013d76:	4293      	cmp	r3, r2
 8013d78:	d10a      	bne.n	8013d90 <USART_DeInit+0x7c>
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART4, ENABLE);
 8013d7a:	2101      	movs	r1, #1
 8013d7c:	f44f 2000 	mov.w	r0, #524288	; 0x80000
 8013d80:	f7fb fdc8 	bl	800f914 <RCC_APB1PeriphResetCmd>
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART4, DISABLE);
 8013d84:	2100      	movs	r1, #0
 8013d86:	f44f 2000 	mov.w	r0, #524288	; 0x80000
 8013d8a:	f7fb fdc3 	bl	800f914 <RCC_APB1PeriphResetCmd>
}
 8013d8e:	e01a      	b.n	8013dc6 <USART_DeInit+0xb2>
  else if (USARTx == UART5)
 8013d90:	687b      	ldr	r3, [r7, #4]
 8013d92:	4a13      	ldr	r2, [pc, #76]	; (8013de0 <USART_DeInit+0xcc>)
 8013d94:	4293      	cmp	r3, r2
 8013d96:	d10a      	bne.n	8013dae <USART_DeInit+0x9a>
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART5, ENABLE);
 8013d98:	2101      	movs	r1, #1
 8013d9a:	f44f 1080 	mov.w	r0, #1048576	; 0x100000
 8013d9e:	f7fb fdb9 	bl	800f914 <RCC_APB1PeriphResetCmd>
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART5, DISABLE);
 8013da2:	2100      	movs	r1, #0
 8013da4:	f44f 1080 	mov.w	r0, #1048576	; 0x100000
 8013da8:	f7fb fdb4 	bl	800f914 <RCC_APB1PeriphResetCmd>
}
 8013dac:	e00b      	b.n	8013dc6 <USART_DeInit+0xb2>
    if (USARTx == USART6)
 8013dae:	687b      	ldr	r3, [r7, #4]
 8013db0:	4a0c      	ldr	r2, [pc, #48]	; (8013de4 <USART_DeInit+0xd0>)
 8013db2:	4293      	cmp	r3, r2
 8013db4:	d107      	bne.n	8013dc6 <USART_DeInit+0xb2>
      RCC_APB2PeriphResetCmd(RCC_APB2Periph_USART6, ENABLE);
 8013db6:	2101      	movs	r1, #1
 8013db8:	2020      	movs	r0, #32
 8013dba:	f7fb fdcb 	bl	800f954 <RCC_APB2PeriphResetCmd>
      RCC_APB2PeriphResetCmd(RCC_APB2Periph_USART6, DISABLE);
 8013dbe:	2100      	movs	r1, #0
 8013dc0:	2020      	movs	r0, #32
 8013dc2:	f7fb fdc7 	bl	800f954 <RCC_APB2PeriphResetCmd>
}
 8013dc6:	bf00      	nop
 8013dc8:	3708      	adds	r7, #8
 8013dca:	46bd      	mov	sp, r7
 8013dcc:	bd80      	pop	{r7, pc}
 8013dce:	bf00      	nop
 8013dd0:	40011000 	.word	0x40011000
 8013dd4:	40004400 	.word	0x40004400
 8013dd8:	40004800 	.word	0x40004800
 8013ddc:	40004c00 	.word	0x40004c00
 8013de0:	40005000 	.word	0x40005000
 8013de4:	40011400 	.word	0x40011400

08013de8 <USART_Init>:
  * @param  USART_InitStruct: pointer to a USART_InitTypeDef structure that contains
  *         the configuration information for the specified USART peripheral.
  * @retval None
  */
void USART_Init(USART_TypeDef* USARTx, USART_InitTypeDef* USART_InitStruct)
{
 8013de8:	b580      	push	{r7, lr}
 8013dea:	b08a      	sub	sp, #40	; 0x28
 8013dec:	af00      	add	r7, sp, #0
 8013dee:	6078      	str	r0, [r7, #4]
 8013df0:	6039      	str	r1, [r7, #0]
  uint32_t tmpreg = 0x00, apbclock = 0x00;
 8013df2:	2300      	movs	r3, #0
 8013df4:	627b      	str	r3, [r7, #36]	; 0x24
 8013df6:	2300      	movs	r3, #0
 8013df8:	623b      	str	r3, [r7, #32]
  uint32_t integerdivider = 0x00;
 8013dfa:	2300      	movs	r3, #0
 8013dfc:	61fb      	str	r3, [r7, #28]
  uint32_t fractionaldivider = 0x00;
 8013dfe:	2300      	movs	r3, #0
 8013e00:	61bb      	str	r3, [r7, #24]
  {
    assert_param(IS_USART_1236_PERIPH(USARTx));
  }

/*---------------------------- USART CR2 Configuration -----------------------*/
  tmpreg = USARTx->CR2;
 8013e02:	687b      	ldr	r3, [r7, #4]
 8013e04:	8a1b      	ldrh	r3, [r3, #16]
 8013e06:	b29b      	uxth	r3, r3
 8013e08:	627b      	str	r3, [r7, #36]	; 0x24

  /* Clear STOP[13:12] bits */
  tmpreg &= (uint32_t)~((uint32_t)USART_CR2_STOP);
 8013e0a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8013e0c:	f423 5340 	bic.w	r3, r3, #12288	; 0x3000
 8013e10:	627b      	str	r3, [r7, #36]	; 0x24

  /* Configure the USART Stop Bits, Clock, CPOL, CPHA and LastBit :
      Set STOP[13:12] bits according to USART_StopBits value */
  tmpreg |= (uint32_t)USART_InitStruct->USART_StopBits;
 8013e12:	683b      	ldr	r3, [r7, #0]
 8013e14:	88db      	ldrh	r3, [r3, #6]
 8013e16:	461a      	mov	r2, r3
 8013e18:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8013e1a:	4313      	orrs	r3, r2
 8013e1c:	627b      	str	r3, [r7, #36]	; 0x24
  
  /* Write to USART CR2 */
  USARTx->CR2 = (uint16_t)tmpreg;
 8013e1e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8013e20:	b29a      	uxth	r2, r3
 8013e22:	687b      	ldr	r3, [r7, #4]
 8013e24:	821a      	strh	r2, [r3, #16]

/*---------------------------- USART CR1 Configuration -----------------------*/
  tmpreg = USARTx->CR1;
 8013e26:	687b      	ldr	r3, [r7, #4]
 8013e28:	899b      	ldrh	r3, [r3, #12]
 8013e2a:	b29b      	uxth	r3, r3
 8013e2c:	627b      	str	r3, [r7, #36]	; 0x24

  /* Clear M, PCE, PS, TE and RE bits */
  tmpreg &= (uint32_t)~((uint32_t)CR1_CLEAR_MASK);
 8013e2e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8013e30:	f423 53b0 	bic.w	r3, r3, #5632	; 0x1600
 8013e34:	f023 030c 	bic.w	r3, r3, #12
 8013e38:	627b      	str	r3, [r7, #36]	; 0x24

  /* Configure the USART Word Length, Parity and mode: 
     Set the M bits according to USART_WordLength value 
     Set PCE and PS bits according to USART_Parity value
     Set TE and RE bits according to USART_Mode value */
  tmpreg |= (uint32_t)USART_InitStruct->USART_WordLength | USART_InitStruct->USART_Parity |
 8013e3a:	683b      	ldr	r3, [r7, #0]
 8013e3c:	889a      	ldrh	r2, [r3, #4]
 8013e3e:	683b      	ldr	r3, [r7, #0]
 8013e40:	891b      	ldrh	r3, [r3, #8]
 8013e42:	4313      	orrs	r3, r2
 8013e44:	b29a      	uxth	r2, r3
            USART_InitStruct->USART_Mode;
 8013e46:	683b      	ldr	r3, [r7, #0]
 8013e48:	895b      	ldrh	r3, [r3, #10]
  tmpreg |= (uint32_t)USART_InitStruct->USART_WordLength | USART_InitStruct->USART_Parity |
 8013e4a:	4313      	orrs	r3, r2
 8013e4c:	b29b      	uxth	r3, r3
 8013e4e:	461a      	mov	r2, r3
 8013e50:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8013e52:	4313      	orrs	r3, r2
 8013e54:	627b      	str	r3, [r7, #36]	; 0x24

  /* Write to USART CR1 */
  USARTx->CR1 = (uint16_t)tmpreg;
 8013e56:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8013e58:	b29a      	uxth	r2, r3
 8013e5a:	687b      	ldr	r3, [r7, #4]
 8013e5c:	819a      	strh	r2, [r3, #12]

/*---------------------------- USART CR3 Configuration -----------------------*/  
  tmpreg = USARTx->CR3;
 8013e5e:	687b      	ldr	r3, [r7, #4]
 8013e60:	8a9b      	ldrh	r3, [r3, #20]
 8013e62:	b29b      	uxth	r3, r3
 8013e64:	627b      	str	r3, [r7, #36]	; 0x24

  /* Clear CTSE and RTSE bits */
  tmpreg &= (uint32_t)~((uint32_t)CR3_CLEAR_MASK);
 8013e66:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8013e68:	f423 7340 	bic.w	r3, r3, #768	; 0x300
 8013e6c:	627b      	str	r3, [r7, #36]	; 0x24

  /* Configure the USART HFC : 
      Set CTSE and RTSE bits according to USART_HardwareFlowControl value */
  tmpreg |= USART_InitStruct->USART_HardwareFlowControl;
 8013e6e:	683b      	ldr	r3, [r7, #0]
 8013e70:	899b      	ldrh	r3, [r3, #12]
 8013e72:	461a      	mov	r2, r3
 8013e74:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8013e76:	4313      	orrs	r3, r2
 8013e78:	627b      	str	r3, [r7, #36]	; 0x24

  /* Write to USART CR3 */
  USARTx->CR3 = (uint16_t)tmpreg;
 8013e7a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8013e7c:	b29a      	uxth	r2, r3
 8013e7e:	687b      	ldr	r3, [r7, #4]
 8013e80:	829a      	strh	r2, [r3, #20]

/*---------------------------- USART BRR Configuration -----------------------*/
  /* Configure the USART Baud Rate */
  RCC_GetClocksFreq(&RCC_ClocksStatus);
 8013e82:	f107 0308 	add.w	r3, r7, #8
 8013e86:	4618      	mov	r0, r3
 8013e88:	f7fb fb3e 	bl	800f508 <RCC_GetClocksFreq>

  if ((USARTx == USART1) || (USARTx == USART6))
 8013e8c:	687b      	ldr	r3, [r7, #4]
 8013e8e:	4a30      	ldr	r2, [pc, #192]	; (8013f50 <USART_Init+0x168>)
 8013e90:	4293      	cmp	r3, r2
 8013e92:	d003      	beq.n	8013e9c <USART_Init+0xb4>
 8013e94:	687b      	ldr	r3, [r7, #4]
 8013e96:	4a2f      	ldr	r2, [pc, #188]	; (8013f54 <USART_Init+0x16c>)
 8013e98:	4293      	cmp	r3, r2
 8013e9a:	d102      	bne.n	8013ea2 <USART_Init+0xba>
  {
    apbclock = RCC_ClocksStatus.PCLK2_Frequency;
 8013e9c:	697b      	ldr	r3, [r7, #20]
 8013e9e:	623b      	str	r3, [r7, #32]
 8013ea0:	e001      	b.n	8013ea6 <USART_Init+0xbe>
  }
  else
  {
    apbclock = RCC_ClocksStatus.PCLK1_Frequency;
 8013ea2:	693b      	ldr	r3, [r7, #16]
 8013ea4:	623b      	str	r3, [r7, #32]
  }
  
  /* Determine the integer part */
  if ((USARTx->CR1 & USART_CR1_OVER8) != 0)
 8013ea6:	687b      	ldr	r3, [r7, #4]
 8013ea8:	899b      	ldrh	r3, [r3, #12]
 8013eaa:	b29b      	uxth	r3, r3
 8013eac:	b21b      	sxth	r3, r3
 8013eae:	2b00      	cmp	r3, #0
 8013eb0:	da0c      	bge.n	8013ecc <USART_Init+0xe4>
  {
    /* Integer part computing in case Oversampling mode is 8 Samples */
    integerdivider = ((25 * apbclock) / (2 * (USART_InitStruct->USART_BaudRate)));    
 8013eb2:	6a3a      	ldr	r2, [r7, #32]
 8013eb4:	4613      	mov	r3, r2
 8013eb6:	009b      	lsls	r3, r3, #2
 8013eb8:	4413      	add	r3, r2
 8013eba:	009a      	lsls	r2, r3, #2
 8013ebc:	441a      	add	r2, r3
 8013ebe:	683b      	ldr	r3, [r7, #0]
 8013ec0:	681b      	ldr	r3, [r3, #0]
 8013ec2:	005b      	lsls	r3, r3, #1
 8013ec4:	fbb2 f3f3 	udiv	r3, r2, r3
 8013ec8:	61fb      	str	r3, [r7, #28]
 8013eca:	e00b      	b.n	8013ee4 <USART_Init+0xfc>
  }
  else /* if ((USARTx->CR1 & USART_CR1_OVER8) == 0) */
  {
    /* Integer part computing in case Oversampling mode is 16 Samples */
    integerdivider = ((25 * apbclock) / (4 * (USART_InitStruct->USART_BaudRate)));    
 8013ecc:	6a3a      	ldr	r2, [r7, #32]
 8013ece:	4613      	mov	r3, r2
 8013ed0:	009b      	lsls	r3, r3, #2
 8013ed2:	4413      	add	r3, r2
 8013ed4:	009a      	lsls	r2, r3, #2
 8013ed6:	441a      	add	r2, r3
 8013ed8:	683b      	ldr	r3, [r7, #0]
 8013eda:	681b      	ldr	r3, [r3, #0]
 8013edc:	009b      	lsls	r3, r3, #2
 8013ede:	fbb2 f3f3 	udiv	r3, r2, r3
 8013ee2:	61fb      	str	r3, [r7, #28]
  }
  tmpreg = (integerdivider / 100) << 4;
 8013ee4:	69fb      	ldr	r3, [r7, #28]
 8013ee6:	4a1c      	ldr	r2, [pc, #112]	; (8013f58 <USART_Init+0x170>)
 8013ee8:	fba2 2303 	umull	r2, r3, r2, r3
 8013eec:	095b      	lsrs	r3, r3, #5
 8013eee:	011b      	lsls	r3, r3, #4
 8013ef0:	627b      	str	r3, [r7, #36]	; 0x24

  /* Determine the fractional part */
  fractionaldivider = integerdivider - (100 * (tmpreg >> 4));
 8013ef2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8013ef4:	091b      	lsrs	r3, r3, #4
 8013ef6:	2264      	movs	r2, #100	; 0x64
 8013ef8:	fb02 f303 	mul.w	r3, r2, r3
 8013efc:	69fa      	ldr	r2, [r7, #28]
 8013efe:	1ad3      	subs	r3, r2, r3
 8013f00:	61bb      	str	r3, [r7, #24]

  /* Implement the fractional part in the register */
  if ((USARTx->CR1 & USART_CR1_OVER8) != 0)
 8013f02:	687b      	ldr	r3, [r7, #4]
 8013f04:	899b      	ldrh	r3, [r3, #12]
 8013f06:	b29b      	uxth	r3, r3
 8013f08:	b21b      	sxth	r3, r3
 8013f0a:	2b00      	cmp	r3, #0
 8013f0c:	da0c      	bge.n	8013f28 <USART_Init+0x140>
  {
    tmpreg |= ((((fractionaldivider * 8) + 50) / 100)) & ((uint8_t)0x07);
 8013f0e:	69bb      	ldr	r3, [r7, #24]
 8013f10:	00db      	lsls	r3, r3, #3
 8013f12:	3332      	adds	r3, #50	; 0x32
 8013f14:	4a10      	ldr	r2, [pc, #64]	; (8013f58 <USART_Init+0x170>)
 8013f16:	fba2 2303 	umull	r2, r3, r2, r3
 8013f1a:	095b      	lsrs	r3, r3, #5
 8013f1c:	f003 0307 	and.w	r3, r3, #7
 8013f20:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8013f22:	4313      	orrs	r3, r2
 8013f24:	627b      	str	r3, [r7, #36]	; 0x24
 8013f26:	e00b      	b.n	8013f40 <USART_Init+0x158>
  }
  else /* if ((USARTx->CR1 & USART_CR1_OVER8) == 0) */
  {
    tmpreg |= ((((fractionaldivider * 16) + 50) / 100)) & ((uint8_t)0x0F);
 8013f28:	69bb      	ldr	r3, [r7, #24]
 8013f2a:	011b      	lsls	r3, r3, #4
 8013f2c:	3332      	adds	r3, #50	; 0x32
 8013f2e:	4a0a      	ldr	r2, [pc, #40]	; (8013f58 <USART_Init+0x170>)
 8013f30:	fba2 2303 	umull	r2, r3, r2, r3
 8013f34:	095b      	lsrs	r3, r3, #5
 8013f36:	f003 030f 	and.w	r3, r3, #15
 8013f3a:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8013f3c:	4313      	orrs	r3, r2
 8013f3e:	627b      	str	r3, [r7, #36]	; 0x24
  }
  
  /* Write to USART BRR register */
  USARTx->BRR = (uint16_t)tmpreg;
 8013f40:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8013f42:	b29a      	uxth	r2, r3
 8013f44:	687b      	ldr	r3, [r7, #4]
 8013f46:	811a      	strh	r2, [r3, #8]
}
 8013f48:	bf00      	nop
 8013f4a:	3728      	adds	r7, #40	; 0x28
 8013f4c:	46bd      	mov	sp, r7
 8013f4e:	bd80      	pop	{r7, pc}
 8013f50:	40011000 	.word	0x40011000
 8013f54:	40011400 	.word	0x40011400
 8013f58:	51eb851f 	.word	0x51eb851f

08013f5c <USART_StructInit>:
  * @param  USART_InitStruct: pointer to a USART_InitTypeDef structure which will
  *         be initialized.
  * @retval None
  */
void USART_StructInit(USART_InitTypeDef* USART_InitStruct)
{
 8013f5c:	b480      	push	{r7}
 8013f5e:	b083      	sub	sp, #12
 8013f60:	af00      	add	r7, sp, #0
 8013f62:	6078      	str	r0, [r7, #4]
  /* USART_InitStruct members default value */
  USART_InitStruct->USART_BaudRate = 9600;
 8013f64:	687b      	ldr	r3, [r7, #4]
 8013f66:	f44f 5216 	mov.w	r2, #9600	; 0x2580
 8013f6a:	601a      	str	r2, [r3, #0]
  USART_InitStruct->USART_WordLength = USART_WordLength_8b;
 8013f6c:	687b      	ldr	r3, [r7, #4]
 8013f6e:	2200      	movs	r2, #0
 8013f70:	809a      	strh	r2, [r3, #4]
  USART_InitStruct->USART_StopBits = USART_StopBits_1;
 8013f72:	687b      	ldr	r3, [r7, #4]
 8013f74:	2200      	movs	r2, #0
 8013f76:	80da      	strh	r2, [r3, #6]
  USART_InitStruct->USART_Parity = USART_Parity_No ;
 8013f78:	687b      	ldr	r3, [r7, #4]
 8013f7a:	2200      	movs	r2, #0
 8013f7c:	811a      	strh	r2, [r3, #8]
  USART_InitStruct->USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
 8013f7e:	687b      	ldr	r3, [r7, #4]
 8013f80:	220c      	movs	r2, #12
 8013f82:	815a      	strh	r2, [r3, #10]
  USART_InitStruct->USART_HardwareFlowControl = USART_HardwareFlowControl_None;  
 8013f84:	687b      	ldr	r3, [r7, #4]
 8013f86:	2200      	movs	r2, #0
 8013f88:	819a      	strh	r2, [r3, #12]
}
 8013f8a:	bf00      	nop
 8013f8c:	370c      	adds	r7, #12
 8013f8e:	46bd      	mov	sp, r7
 8013f90:	f85d 7b04 	ldr.w	r7, [sp], #4
 8013f94:	4770      	bx	lr

08013f96 <USART_ClockInit>:
  *         contains the configuration information for the specified  USART peripheral.
  * @note   The Smart Card and Synchronous modes are not available for UART4 and UART5.    
  * @retval None
  */
void USART_ClockInit(USART_TypeDef* USARTx, USART_ClockInitTypeDef* USART_ClockInitStruct)
{
 8013f96:	b480      	push	{r7}
 8013f98:	b085      	sub	sp, #20
 8013f9a:	af00      	add	r7, sp, #0
 8013f9c:	6078      	str	r0, [r7, #4]
 8013f9e:	6039      	str	r1, [r7, #0]
  uint32_t tmpreg = 0x00;
 8013fa0:	2300      	movs	r3, #0
 8013fa2:	60fb      	str	r3, [r7, #12]
  assert_param(IS_USART_CPOL(USART_ClockInitStruct->USART_CPOL));
  assert_param(IS_USART_CPHA(USART_ClockInitStruct->USART_CPHA));
  assert_param(IS_USART_LASTBIT(USART_ClockInitStruct->USART_LastBit));
  
/*---------------------------- USART CR2 Configuration -----------------------*/
  tmpreg = USARTx->CR2;
 8013fa4:	687b      	ldr	r3, [r7, #4]
 8013fa6:	8a1b      	ldrh	r3, [r3, #16]
 8013fa8:	b29b      	uxth	r3, r3
 8013faa:	60fb      	str	r3, [r7, #12]
  /* Clear CLKEN, CPOL, CPHA and LBCL bits */
  tmpreg &= (uint32_t)~((uint32_t)CR2_CLOCK_CLEAR_MASK);
 8013fac:	68fb      	ldr	r3, [r7, #12]
 8013fae:	f423 6370 	bic.w	r3, r3, #3840	; 0xf00
 8013fb2:	60fb      	str	r3, [r7, #12]
  /* Configure the USART Clock, CPOL, CPHA and LastBit ------------*/
  /* Set CLKEN bit according to USART_Clock value */
  /* Set CPOL bit according to USART_CPOL value */
  /* Set CPHA bit according to USART_CPHA value */
  /* Set LBCL bit according to USART_LastBit value */
  tmpreg |= (uint32_t)USART_ClockInitStruct->USART_Clock | USART_ClockInitStruct->USART_CPOL | 
 8013fb4:	683b      	ldr	r3, [r7, #0]
 8013fb6:	881a      	ldrh	r2, [r3, #0]
 8013fb8:	683b      	ldr	r3, [r7, #0]
 8013fba:	885b      	ldrh	r3, [r3, #2]
                 USART_ClockInitStruct->USART_CPHA | USART_ClockInitStruct->USART_LastBit;
 8013fbc:	4313      	orrs	r3, r2
 8013fbe:	b29a      	uxth	r2, r3
 8013fc0:	683b      	ldr	r3, [r7, #0]
 8013fc2:	889b      	ldrh	r3, [r3, #4]
 8013fc4:	4313      	orrs	r3, r2
 8013fc6:	b29a      	uxth	r2, r3
 8013fc8:	683b      	ldr	r3, [r7, #0]
 8013fca:	88db      	ldrh	r3, [r3, #6]
 8013fcc:	4313      	orrs	r3, r2
 8013fce:	b29b      	uxth	r3, r3
 8013fd0:	461a      	mov	r2, r3
  tmpreg |= (uint32_t)USART_ClockInitStruct->USART_Clock | USART_ClockInitStruct->USART_CPOL | 
 8013fd2:	68fb      	ldr	r3, [r7, #12]
 8013fd4:	4313      	orrs	r3, r2
 8013fd6:	60fb      	str	r3, [r7, #12]
  /* Write to USART CR2 */
  USARTx->CR2 = (uint16_t)tmpreg;
 8013fd8:	68fb      	ldr	r3, [r7, #12]
 8013fda:	b29a      	uxth	r2, r3
 8013fdc:	687b      	ldr	r3, [r7, #4]
 8013fde:	821a      	strh	r2, [r3, #16]
}
 8013fe0:	bf00      	nop
 8013fe2:	3714      	adds	r7, #20
 8013fe4:	46bd      	mov	sp, r7
 8013fe6:	f85d 7b04 	ldr.w	r7, [sp], #4
 8013fea:	4770      	bx	lr

08013fec <USART_ClockStructInit>:
  * @param  USART_ClockInitStruct: pointer to a USART_ClockInitTypeDef structure
  *         which will be initialized.
  * @retval None
  */
void USART_ClockStructInit(USART_ClockInitTypeDef* USART_ClockInitStruct)
{
 8013fec:	b480      	push	{r7}
 8013fee:	b083      	sub	sp, #12
 8013ff0:	af00      	add	r7, sp, #0
 8013ff2:	6078      	str	r0, [r7, #4]
  /* USART_ClockInitStruct members default value */
  USART_ClockInitStruct->USART_Clock = USART_Clock_Disable;
 8013ff4:	687b      	ldr	r3, [r7, #4]
 8013ff6:	2200      	movs	r2, #0
 8013ff8:	801a      	strh	r2, [r3, #0]
  USART_ClockInitStruct->USART_CPOL = USART_CPOL_Low;
 8013ffa:	687b      	ldr	r3, [r7, #4]
 8013ffc:	2200      	movs	r2, #0
 8013ffe:	805a      	strh	r2, [r3, #2]
  USART_ClockInitStruct->USART_CPHA = USART_CPHA_1Edge;
 8014000:	687b      	ldr	r3, [r7, #4]
 8014002:	2200      	movs	r2, #0
 8014004:	809a      	strh	r2, [r3, #4]
  USART_ClockInitStruct->USART_LastBit = USART_LastBit_Disable;
 8014006:	687b      	ldr	r3, [r7, #4]
 8014008:	2200      	movs	r2, #0
 801400a:	80da      	strh	r2, [r3, #6]
}
 801400c:	bf00      	nop
 801400e:	370c      	adds	r7, #12
 8014010:	46bd      	mov	sp, r7
 8014012:	f85d 7b04 	ldr.w	r7, [sp], #4
 8014016:	4770      	bx	lr

08014018 <USART_Cmd>:
  * @param  NewState: new state of the USARTx peripheral.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void USART_Cmd(USART_TypeDef* USARTx, FunctionalState NewState)
{
 8014018:	b480      	push	{r7}
 801401a:	b083      	sub	sp, #12
 801401c:	af00      	add	r7, sp, #0
 801401e:	6078      	str	r0, [r7, #4]
 8014020:	460b      	mov	r3, r1
 8014022:	70fb      	strb	r3, [r7, #3]
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
 8014024:	78fb      	ldrb	r3, [r7, #3]
 8014026:	2b00      	cmp	r3, #0
 8014028:	d008      	beq.n	801403c <USART_Cmd+0x24>
  {
    /* Enable the selected USART by setting the UE bit in the CR1 register */
    USARTx->CR1 |= USART_CR1_UE;
 801402a:	687b      	ldr	r3, [r7, #4]
 801402c:	899b      	ldrh	r3, [r3, #12]
 801402e:	b29b      	uxth	r3, r3
 8014030:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
 8014034:	b29a      	uxth	r2, r3
 8014036:	687b      	ldr	r3, [r7, #4]
 8014038:	819a      	strh	r2, [r3, #12]
  else
  {
    /* Disable the selected USART by clearing the UE bit in the CR1 register */
    USARTx->CR1 &= (uint16_t)~((uint16_t)USART_CR1_UE);
  }
}
 801403a:	e007      	b.n	801404c <USART_Cmd+0x34>
    USARTx->CR1 &= (uint16_t)~((uint16_t)USART_CR1_UE);
 801403c:	687b      	ldr	r3, [r7, #4]
 801403e:	899b      	ldrh	r3, [r3, #12]
 8014040:	b29b      	uxth	r3, r3
 8014042:	f423 5300 	bic.w	r3, r3, #8192	; 0x2000
 8014046:	b29a      	uxth	r2, r3
 8014048:	687b      	ldr	r3, [r7, #4]
 801404a:	819a      	strh	r2, [r3, #12]
}
 801404c:	bf00      	nop
 801404e:	370c      	adds	r7, #12
 8014050:	46bd      	mov	sp, r7
 8014052:	f85d 7b04 	ldr.w	r7, [sp], #4
 8014056:	4770      	bx	lr

08014058 <USART_SetPrescaler>:
  * @param  USART_Prescaler: specifies the prescaler clock. 
  * @note   The function is used for IrDA mode with UART4 and UART5.   
  * @retval None
  */
void USART_SetPrescaler(USART_TypeDef* USARTx, uint8_t USART_Prescaler)
{ 
 8014058:	b480      	push	{r7}
 801405a:	b083      	sub	sp, #12
 801405c:	af00      	add	r7, sp, #0
 801405e:	6078      	str	r0, [r7, #4]
 8014060:	460b      	mov	r3, r1
 8014062:	70fb      	strb	r3, [r7, #3]
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  
  /* Clear the USART prescaler */
  USARTx->GTPR &= USART_GTPR_GT;
 8014064:	687b      	ldr	r3, [r7, #4]
 8014066:	8b1b      	ldrh	r3, [r3, #24]
 8014068:	b29b      	uxth	r3, r3
 801406a:	f023 03ff 	bic.w	r3, r3, #255	; 0xff
 801406e:	b29a      	uxth	r2, r3
 8014070:	687b      	ldr	r3, [r7, #4]
 8014072:	831a      	strh	r2, [r3, #24]
  /* Set the USART prescaler */
  USARTx->GTPR |= USART_Prescaler;
 8014074:	687b      	ldr	r3, [r7, #4]
 8014076:	8b1b      	ldrh	r3, [r3, #24]
 8014078:	b29a      	uxth	r2, r3
 801407a:	78fb      	ldrb	r3, [r7, #3]
 801407c:	b29b      	uxth	r3, r3
 801407e:	4313      	orrs	r3, r2
 8014080:	b29a      	uxth	r2, r3
 8014082:	687b      	ldr	r3, [r7, #4]
 8014084:	831a      	strh	r2, [r3, #24]
}
 8014086:	bf00      	nop
 8014088:	370c      	adds	r7, #12
 801408a:	46bd      	mov	sp, r7
 801408c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8014090:	4770      	bx	lr

08014092 <USART_OverSampling8Cmd>:
  * @param  NewState: new state of the USART 8x oversampling mode.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void USART_OverSampling8Cmd(USART_TypeDef* USARTx, FunctionalState NewState)
{
 8014092:	b480      	push	{r7}
 8014094:	b083      	sub	sp, #12
 8014096:	af00      	add	r7, sp, #0
 8014098:	6078      	str	r0, [r7, #4]
 801409a:	460b      	mov	r3, r1
 801409c:	70fb      	strb	r3, [r7, #3]
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
 801409e:	78fb      	ldrb	r3, [r7, #3]
 80140a0:	2b00      	cmp	r3, #0
 80140a2:	d00a      	beq.n	80140ba <USART_OverSampling8Cmd+0x28>
  {
    /* Enable the 8x Oversampling mode by setting the OVER8 bit in the CR1 register */
    USARTx->CR1 |= USART_CR1_OVER8;
 80140a4:	687b      	ldr	r3, [r7, #4]
 80140a6:	899b      	ldrh	r3, [r3, #12]
 80140a8:	b29b      	uxth	r3, r3
 80140aa:	ea6f 4343 	mvn.w	r3, r3, lsl #17
 80140ae:	ea6f 4353 	mvn.w	r3, r3, lsr #17
 80140b2:	b29a      	uxth	r2, r3
 80140b4:	687b      	ldr	r3, [r7, #4]
 80140b6:	819a      	strh	r2, [r3, #12]
  else
  {
    /* Disable the 8x Oversampling mode by clearing the OVER8 bit in the CR1 register */
    USARTx->CR1 &= (uint16_t)~((uint16_t)USART_CR1_OVER8);
  }
}  
 80140b8:	e007      	b.n	80140ca <USART_OverSampling8Cmd+0x38>
    USARTx->CR1 &= (uint16_t)~((uint16_t)USART_CR1_OVER8);
 80140ba:	687b      	ldr	r3, [r7, #4]
 80140bc:	899b      	ldrh	r3, [r3, #12]
 80140be:	b29b      	uxth	r3, r3
 80140c0:	f3c3 030e 	ubfx	r3, r3, #0, #15
 80140c4:	b29a      	uxth	r2, r3
 80140c6:	687b      	ldr	r3, [r7, #4]
 80140c8:	819a      	strh	r2, [r3, #12]
}  
 80140ca:	bf00      	nop
 80140cc:	370c      	adds	r7, #12
 80140ce:	46bd      	mov	sp, r7
 80140d0:	f85d 7b04 	ldr.w	r7, [sp], #4
 80140d4:	4770      	bx	lr

080140d6 <USART_OneBitMethodCmd>:
  * @param  NewState: new state of the USART one bit sampling method.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void USART_OneBitMethodCmd(USART_TypeDef* USARTx, FunctionalState NewState)
{
 80140d6:	b480      	push	{r7}
 80140d8:	b083      	sub	sp, #12
 80140da:	af00      	add	r7, sp, #0
 80140dc:	6078      	str	r0, [r7, #4]
 80140de:	460b      	mov	r3, r1
 80140e0:	70fb      	strb	r3, [r7, #3]
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
 80140e2:	78fb      	ldrb	r3, [r7, #3]
 80140e4:	2b00      	cmp	r3, #0
 80140e6:	d008      	beq.n	80140fa <USART_OneBitMethodCmd+0x24>
  {
    /* Enable the one bit method by setting the ONEBITE bit in the CR3 register */
    USARTx->CR3 |= USART_CR3_ONEBIT;
 80140e8:	687b      	ldr	r3, [r7, #4]
 80140ea:	8a9b      	ldrh	r3, [r3, #20]
 80140ec:	b29b      	uxth	r3, r3
 80140ee:	f443 6300 	orr.w	r3, r3, #2048	; 0x800
 80140f2:	b29a      	uxth	r2, r3
 80140f4:	687b      	ldr	r3, [r7, #4]
 80140f6:	829a      	strh	r2, [r3, #20]
  else
  {
    /* Disable the one bit method by clearing the ONEBITE bit in the CR3 register */
    USARTx->CR3 &= (uint16_t)~((uint16_t)USART_CR3_ONEBIT);
  }
}
 80140f8:	e007      	b.n	801410a <USART_OneBitMethodCmd+0x34>
    USARTx->CR3 &= (uint16_t)~((uint16_t)USART_CR3_ONEBIT);
 80140fa:	687b      	ldr	r3, [r7, #4]
 80140fc:	8a9b      	ldrh	r3, [r3, #20]
 80140fe:	b29b      	uxth	r3, r3
 8014100:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
 8014104:	b29a      	uxth	r2, r3
 8014106:	687b      	ldr	r3, [r7, #4]
 8014108:	829a      	strh	r2, [r3, #20]
}
 801410a:	bf00      	nop
 801410c:	370c      	adds	r7, #12
 801410e:	46bd      	mov	sp, r7
 8014110:	f85d 7b04 	ldr.w	r7, [sp], #4
 8014114:	4770      	bx	lr

08014116 <USART_SendData>:
  *         UART peripheral.
  * @param  Data: the data to transmit.
  * @retval None
  */
void USART_SendData(USART_TypeDef* USARTx, uint16_t Data)
{
 8014116:	b480      	push	{r7}
 8014118:	b083      	sub	sp, #12
 801411a:	af00      	add	r7, sp, #0
 801411c:	6078      	str	r0, [r7, #4]
 801411e:	460b      	mov	r3, r1
 8014120:	807b      	strh	r3, [r7, #2]
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  assert_param(IS_USART_DATA(Data)); 
    
  /* Transmit Data */
  USARTx->DR = (Data & (uint16_t)0x01FF);
 8014122:	887b      	ldrh	r3, [r7, #2]
 8014124:	f3c3 0308 	ubfx	r3, r3, #0, #9
 8014128:	b29a      	uxth	r2, r3
 801412a:	687b      	ldr	r3, [r7, #4]
 801412c:	809a      	strh	r2, [r3, #4]
}
 801412e:	bf00      	nop
 8014130:	370c      	adds	r7, #12
 8014132:	46bd      	mov	sp, r7
 8014134:	f85d 7b04 	ldr.w	r7, [sp], #4
 8014138:	4770      	bx	lr

0801413a <USART_ReceiveData>:
  * @param  USARTx: where x can be 1, 2, 3, 4, 5 or 6 to select the USART or 
  *         UART peripheral.
  * @retval The received data.
  */
uint16_t USART_ReceiveData(USART_TypeDef* USARTx)
{
 801413a:	b480      	push	{r7}
 801413c:	b083      	sub	sp, #12
 801413e:	af00      	add	r7, sp, #0
 8014140:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  
  /* Receive Data */
  return (uint16_t)(USARTx->DR & (uint16_t)0x01FF);
 8014142:	687b      	ldr	r3, [r7, #4]
 8014144:	889b      	ldrh	r3, [r3, #4]
 8014146:	b29b      	uxth	r3, r3
 8014148:	f3c3 0308 	ubfx	r3, r3, #0, #9
 801414c:	b29b      	uxth	r3, r3
}
 801414e:	4618      	mov	r0, r3
 8014150:	370c      	adds	r7, #12
 8014152:	46bd      	mov	sp, r7
 8014154:	f85d 7b04 	ldr.w	r7, [sp], #4
 8014158:	4770      	bx	lr

0801415a <USART_SetAddress>:
  *         UART peripheral.
  * @param  USART_Address: Indicates the address of the USART node.
  * @retval None
  */
void USART_SetAddress(USART_TypeDef* USARTx, uint8_t USART_Address)
{
 801415a:	b480      	push	{r7}
 801415c:	b083      	sub	sp, #12
 801415e:	af00      	add	r7, sp, #0
 8014160:	6078      	str	r0, [r7, #4]
 8014162:	460b      	mov	r3, r1
 8014164:	70fb      	strb	r3, [r7, #3]
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  assert_param(IS_USART_ADDRESS(USART_Address)); 
    
  /* Clear the USART address */
  USARTx->CR2 &= (uint16_t)~((uint16_t)USART_CR2_ADD);
 8014166:	687b      	ldr	r3, [r7, #4]
 8014168:	8a1b      	ldrh	r3, [r3, #16]
 801416a:	b29b      	uxth	r3, r3
 801416c:	f023 030f 	bic.w	r3, r3, #15
 8014170:	b29a      	uxth	r2, r3
 8014172:	687b      	ldr	r3, [r7, #4]
 8014174:	821a      	strh	r2, [r3, #16]
  /* Set the USART address node */
  USARTx->CR2 |= USART_Address;
 8014176:	687b      	ldr	r3, [r7, #4]
 8014178:	8a1b      	ldrh	r3, [r3, #16]
 801417a:	b29a      	uxth	r2, r3
 801417c:	78fb      	ldrb	r3, [r7, #3]
 801417e:	b29b      	uxth	r3, r3
 8014180:	4313      	orrs	r3, r2
 8014182:	b29a      	uxth	r2, r3
 8014184:	687b      	ldr	r3, [r7, #4]
 8014186:	821a      	strh	r2, [r3, #16]
}
 8014188:	bf00      	nop
 801418a:	370c      	adds	r7, #12
 801418c:	46bd      	mov	sp, r7
 801418e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8014192:	4770      	bx	lr

08014194 <USART_ReceiverWakeUpCmd>:
  * @param  NewState: new state of the USART mute mode.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void USART_ReceiverWakeUpCmd(USART_TypeDef* USARTx, FunctionalState NewState)
{
 8014194:	b480      	push	{r7}
 8014196:	b083      	sub	sp, #12
 8014198:	af00      	add	r7, sp, #0
 801419a:	6078      	str	r0, [r7, #4]
 801419c:	460b      	mov	r3, r1
 801419e:	70fb      	strb	r3, [r7, #3]
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  assert_param(IS_FUNCTIONAL_STATE(NewState)); 
  
  if (NewState != DISABLE)
 80141a0:	78fb      	ldrb	r3, [r7, #3]
 80141a2:	2b00      	cmp	r3, #0
 80141a4:	d008      	beq.n	80141b8 <USART_ReceiverWakeUpCmd+0x24>
  {
    /* Enable the USART mute mode  by setting the RWU bit in the CR1 register */
    USARTx->CR1 |= USART_CR1_RWU;
 80141a6:	687b      	ldr	r3, [r7, #4]
 80141a8:	899b      	ldrh	r3, [r3, #12]
 80141aa:	b29b      	uxth	r3, r3
 80141ac:	f043 0302 	orr.w	r3, r3, #2
 80141b0:	b29a      	uxth	r2, r3
 80141b2:	687b      	ldr	r3, [r7, #4]
 80141b4:	819a      	strh	r2, [r3, #12]
  else
  {
    /* Disable the USART mute mode by clearing the RWU bit in the CR1 register */
    USARTx->CR1 &= (uint16_t)~((uint16_t)USART_CR1_RWU);
  }
}
 80141b6:	e007      	b.n	80141c8 <USART_ReceiverWakeUpCmd+0x34>
    USARTx->CR1 &= (uint16_t)~((uint16_t)USART_CR1_RWU);
 80141b8:	687b      	ldr	r3, [r7, #4]
 80141ba:	899b      	ldrh	r3, [r3, #12]
 80141bc:	b29b      	uxth	r3, r3
 80141be:	f023 0302 	bic.w	r3, r3, #2
 80141c2:	b29a      	uxth	r2, r3
 80141c4:	687b      	ldr	r3, [r7, #4]
 80141c6:	819a      	strh	r2, [r3, #12]
}
 80141c8:	bf00      	nop
 80141ca:	370c      	adds	r7, #12
 80141cc:	46bd      	mov	sp, r7
 80141ce:	f85d 7b04 	ldr.w	r7, [sp], #4
 80141d2:	4770      	bx	lr

080141d4 <USART_WakeUpConfig>:
  *            @arg USART_WakeUp_IdleLine: WakeUp by an idle line detection
  *            @arg USART_WakeUp_AddressMark: WakeUp by an address mark
  * @retval None
  */
void USART_WakeUpConfig(USART_TypeDef* USARTx, uint16_t USART_WakeUp)
{
 80141d4:	b480      	push	{r7}
 80141d6:	b083      	sub	sp, #12
 80141d8:	af00      	add	r7, sp, #0
 80141da:	6078      	str	r0, [r7, #4]
 80141dc:	460b      	mov	r3, r1
 80141de:	807b      	strh	r3, [r7, #2]
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  assert_param(IS_USART_WAKEUP(USART_WakeUp));
  
  USARTx->CR1 &= (uint16_t)~((uint16_t)USART_CR1_WAKE);
 80141e0:	687b      	ldr	r3, [r7, #4]
 80141e2:	899b      	ldrh	r3, [r3, #12]
 80141e4:	b29b      	uxth	r3, r3
 80141e6:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
 80141ea:	b29a      	uxth	r2, r3
 80141ec:	687b      	ldr	r3, [r7, #4]
 80141ee:	819a      	strh	r2, [r3, #12]
  USARTx->CR1 |= USART_WakeUp;
 80141f0:	687b      	ldr	r3, [r7, #4]
 80141f2:	899b      	ldrh	r3, [r3, #12]
 80141f4:	b29a      	uxth	r2, r3
 80141f6:	887b      	ldrh	r3, [r7, #2]
 80141f8:	4313      	orrs	r3, r2
 80141fa:	b29a      	uxth	r2, r3
 80141fc:	687b      	ldr	r3, [r7, #4]
 80141fe:	819a      	strh	r2, [r3, #12]
}
 8014200:	bf00      	nop
 8014202:	370c      	adds	r7, #12
 8014204:	46bd      	mov	sp, r7
 8014206:	f85d 7b04 	ldr.w	r7, [sp], #4
 801420a:	4770      	bx	lr

0801420c <USART_LINBreakDetectLengthConfig>:
  *            @arg USART_LINBreakDetectLength_10b: 10-bit break detection
  *            @arg USART_LINBreakDetectLength_11b: 11-bit break detection
  * @retval None
  */
void USART_LINBreakDetectLengthConfig(USART_TypeDef* USARTx, uint16_t USART_LINBreakDetectLength)
{
 801420c:	b480      	push	{r7}
 801420e:	b083      	sub	sp, #12
 8014210:	af00      	add	r7, sp, #0
 8014212:	6078      	str	r0, [r7, #4]
 8014214:	460b      	mov	r3, r1
 8014216:	807b      	strh	r3, [r7, #2]
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  assert_param(IS_USART_LIN_BREAK_DETECT_LENGTH(USART_LINBreakDetectLength));
  
  USARTx->CR2 &= (uint16_t)~((uint16_t)USART_CR2_LBDL);
 8014218:	687b      	ldr	r3, [r7, #4]
 801421a:	8a1b      	ldrh	r3, [r3, #16]
 801421c:	b29b      	uxth	r3, r3
 801421e:	f023 0320 	bic.w	r3, r3, #32
 8014222:	b29a      	uxth	r2, r3
 8014224:	687b      	ldr	r3, [r7, #4]
 8014226:	821a      	strh	r2, [r3, #16]
  USARTx->CR2 |= USART_LINBreakDetectLength;  
 8014228:	687b      	ldr	r3, [r7, #4]
 801422a:	8a1b      	ldrh	r3, [r3, #16]
 801422c:	b29a      	uxth	r2, r3
 801422e:	887b      	ldrh	r3, [r7, #2]
 8014230:	4313      	orrs	r3, r2
 8014232:	b29a      	uxth	r2, r3
 8014234:	687b      	ldr	r3, [r7, #4]
 8014236:	821a      	strh	r2, [r3, #16]
}
 8014238:	bf00      	nop
 801423a:	370c      	adds	r7, #12
 801423c:	46bd      	mov	sp, r7
 801423e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8014242:	4770      	bx	lr

08014244 <USART_LINCmd>:
  * @param  NewState: new state of the USART LIN mode.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void USART_LINCmd(USART_TypeDef* USARTx, FunctionalState NewState)
{
 8014244:	b480      	push	{r7}
 8014246:	b083      	sub	sp, #12
 8014248:	af00      	add	r7, sp, #0
 801424a:	6078      	str	r0, [r7, #4]
 801424c:	460b      	mov	r3, r1
 801424e:	70fb      	strb	r3, [r7, #3]
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
 8014250:	78fb      	ldrb	r3, [r7, #3]
 8014252:	2b00      	cmp	r3, #0
 8014254:	d008      	beq.n	8014268 <USART_LINCmd+0x24>
  {
    /* Enable the LIN mode by setting the LINEN bit in the CR2 register */
    USARTx->CR2 |= USART_CR2_LINEN;
 8014256:	687b      	ldr	r3, [r7, #4]
 8014258:	8a1b      	ldrh	r3, [r3, #16]
 801425a:	b29b      	uxth	r3, r3
 801425c:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 8014260:	b29a      	uxth	r2, r3
 8014262:	687b      	ldr	r3, [r7, #4]
 8014264:	821a      	strh	r2, [r3, #16]
  else
  {
    /* Disable the LIN mode by clearing the LINEN bit in the CR2 register */
    USARTx->CR2 &= (uint16_t)~((uint16_t)USART_CR2_LINEN);
  }
}
 8014266:	e007      	b.n	8014278 <USART_LINCmd+0x34>
    USARTx->CR2 &= (uint16_t)~((uint16_t)USART_CR2_LINEN);
 8014268:	687b      	ldr	r3, [r7, #4]
 801426a:	8a1b      	ldrh	r3, [r3, #16]
 801426c:	b29b      	uxth	r3, r3
 801426e:	f423 4380 	bic.w	r3, r3, #16384	; 0x4000
 8014272:	b29a      	uxth	r2, r3
 8014274:	687b      	ldr	r3, [r7, #4]
 8014276:	821a      	strh	r2, [r3, #16]
}
 8014278:	bf00      	nop
 801427a:	370c      	adds	r7, #12
 801427c:	46bd      	mov	sp, r7
 801427e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8014282:	4770      	bx	lr

08014284 <USART_SendBreak>:
  * @param  USARTx: where x can be 1, 2, 3, 4, 5 or 6 to select the USART or 
  *         UART peripheral.
  * @retval None
  */
void USART_SendBreak(USART_TypeDef* USARTx)
{
 8014284:	b480      	push	{r7}
 8014286:	b083      	sub	sp, #12
 8014288:	af00      	add	r7, sp, #0
 801428a:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  
  /* Send break characters */
  USARTx->CR1 |= USART_CR1_SBK;
 801428c:	687b      	ldr	r3, [r7, #4]
 801428e:	899b      	ldrh	r3, [r3, #12]
 8014290:	b29b      	uxth	r3, r3
 8014292:	f043 0301 	orr.w	r3, r3, #1
 8014296:	b29a      	uxth	r2, r3
 8014298:	687b      	ldr	r3, [r7, #4]
 801429a:	819a      	strh	r2, [r3, #12]
}
 801429c:	bf00      	nop
 801429e:	370c      	adds	r7, #12
 80142a0:	46bd      	mov	sp, r7
 80142a2:	f85d 7b04 	ldr.w	r7, [sp], #4
 80142a6:	4770      	bx	lr

080142a8 <USART_HalfDuplexCmd>:
  * @param  NewState: new state of the USART Communication.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void USART_HalfDuplexCmd(USART_TypeDef* USARTx, FunctionalState NewState)
{
 80142a8:	b480      	push	{r7}
 80142aa:	b083      	sub	sp, #12
 80142ac:	af00      	add	r7, sp, #0
 80142ae:	6078      	str	r0, [r7, #4]
 80142b0:	460b      	mov	r3, r1
 80142b2:	70fb      	strb	r3, [r7, #3]
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
 80142b4:	78fb      	ldrb	r3, [r7, #3]
 80142b6:	2b00      	cmp	r3, #0
 80142b8:	d008      	beq.n	80142cc <USART_HalfDuplexCmd+0x24>
  {
    /* Enable the Half-Duplex mode by setting the HDSEL bit in the CR3 register */
    USARTx->CR3 |= USART_CR3_HDSEL;
 80142ba:	687b      	ldr	r3, [r7, #4]
 80142bc:	8a9b      	ldrh	r3, [r3, #20]
 80142be:	b29b      	uxth	r3, r3
 80142c0:	f043 0308 	orr.w	r3, r3, #8
 80142c4:	b29a      	uxth	r2, r3
 80142c6:	687b      	ldr	r3, [r7, #4]
 80142c8:	829a      	strh	r2, [r3, #20]
  else
  {
    /* Disable the Half-Duplex mode by clearing the HDSEL bit in the CR3 register */
    USARTx->CR3 &= (uint16_t)~((uint16_t)USART_CR3_HDSEL);
  }
}
 80142ca:	e007      	b.n	80142dc <USART_HalfDuplexCmd+0x34>
    USARTx->CR3 &= (uint16_t)~((uint16_t)USART_CR3_HDSEL);
 80142cc:	687b      	ldr	r3, [r7, #4]
 80142ce:	8a9b      	ldrh	r3, [r3, #20]
 80142d0:	b29b      	uxth	r3, r3
 80142d2:	f023 0308 	bic.w	r3, r3, #8
 80142d6:	b29a      	uxth	r2, r3
 80142d8:	687b      	ldr	r3, [r7, #4]
 80142da:	829a      	strh	r2, [r3, #20]
}
 80142dc:	bf00      	nop
 80142de:	370c      	adds	r7, #12
 80142e0:	46bd      	mov	sp, r7
 80142e2:	f85d 7b04 	ldr.w	r7, [sp], #4
 80142e6:	4770      	bx	lr

080142e8 <USART_SetGuardTime>:
  *         UART peripheral.
  * @param  USART_GuardTime: specifies the guard time.   
  * @retval None
  */
void USART_SetGuardTime(USART_TypeDef* USARTx, uint8_t USART_GuardTime)
{    
 80142e8:	b480      	push	{r7}
 80142ea:	b083      	sub	sp, #12
 80142ec:	af00      	add	r7, sp, #0
 80142ee:	6078      	str	r0, [r7, #4]
 80142f0:	460b      	mov	r3, r1
 80142f2:	70fb      	strb	r3, [r7, #3]
  /* Check the parameters */
  assert_param(IS_USART_1236_PERIPH(USARTx));
  
  /* Clear the USART Guard time */
  USARTx->GTPR &= USART_GTPR_PSC;
 80142f4:	687b      	ldr	r3, [r7, #4]
 80142f6:	8b1b      	ldrh	r3, [r3, #24]
 80142f8:	b29b      	uxth	r3, r3
 80142fa:	b2db      	uxtb	r3, r3
 80142fc:	b29a      	uxth	r2, r3
 80142fe:	687b      	ldr	r3, [r7, #4]
 8014300:	831a      	strh	r2, [r3, #24]
  /* Set the USART guard time */
  USARTx->GTPR |= (uint16_t)((uint16_t)USART_GuardTime << 0x08);
 8014302:	687b      	ldr	r3, [r7, #4]
 8014304:	8b1b      	ldrh	r3, [r3, #24]
 8014306:	b29a      	uxth	r2, r3
 8014308:	78fb      	ldrb	r3, [r7, #3]
 801430a:	b29b      	uxth	r3, r3
 801430c:	021b      	lsls	r3, r3, #8
 801430e:	b29b      	uxth	r3, r3
 8014310:	4313      	orrs	r3, r2
 8014312:	b29a      	uxth	r2, r3
 8014314:	687b      	ldr	r3, [r7, #4]
 8014316:	831a      	strh	r2, [r3, #24]
}
 8014318:	bf00      	nop
 801431a:	370c      	adds	r7, #12
 801431c:	46bd      	mov	sp, r7
 801431e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8014322:	4770      	bx	lr

08014324 <USART_SmartCardCmd>:
  * @param  NewState: new state of the Smart Card mode.
  *          This parameter can be: ENABLE or DISABLE.      
  * @retval None
  */
void USART_SmartCardCmd(USART_TypeDef* USARTx, FunctionalState NewState)
{
 8014324:	b480      	push	{r7}
 8014326:	b083      	sub	sp, #12
 8014328:	af00      	add	r7, sp, #0
 801432a:	6078      	str	r0, [r7, #4]
 801432c:	460b      	mov	r3, r1
 801432e:	70fb      	strb	r3, [r7, #3]
  /* Check the parameters */
  assert_param(IS_USART_1236_PERIPH(USARTx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 8014330:	78fb      	ldrb	r3, [r7, #3]
 8014332:	2b00      	cmp	r3, #0
 8014334:	d008      	beq.n	8014348 <USART_SmartCardCmd+0x24>
  {
    /* Enable the SC mode by setting the SCEN bit in the CR3 register */
    USARTx->CR3 |= USART_CR3_SCEN;
 8014336:	687b      	ldr	r3, [r7, #4]
 8014338:	8a9b      	ldrh	r3, [r3, #20]
 801433a:	b29b      	uxth	r3, r3
 801433c:	f043 0320 	orr.w	r3, r3, #32
 8014340:	b29a      	uxth	r2, r3
 8014342:	687b      	ldr	r3, [r7, #4]
 8014344:	829a      	strh	r2, [r3, #20]
  else
  {
    /* Disable the SC mode by clearing the SCEN bit in the CR3 register */
    USARTx->CR3 &= (uint16_t)~((uint16_t)USART_CR3_SCEN);
  }
}
 8014346:	e007      	b.n	8014358 <USART_SmartCardCmd+0x34>
    USARTx->CR3 &= (uint16_t)~((uint16_t)USART_CR3_SCEN);
 8014348:	687b      	ldr	r3, [r7, #4]
 801434a:	8a9b      	ldrh	r3, [r3, #20]
 801434c:	b29b      	uxth	r3, r3
 801434e:	f023 0320 	bic.w	r3, r3, #32
 8014352:	b29a      	uxth	r2, r3
 8014354:	687b      	ldr	r3, [r7, #4]
 8014356:	829a      	strh	r2, [r3, #20]
}
 8014358:	bf00      	nop
 801435a:	370c      	adds	r7, #12
 801435c:	46bd      	mov	sp, r7
 801435e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8014362:	4770      	bx	lr

08014364 <USART_SmartCardNACKCmd>:
  * @param  NewState: new state of the NACK transmission.
  *          This parameter can be: ENABLE or DISABLE.  
  * @retval None
  */
void USART_SmartCardNACKCmd(USART_TypeDef* USARTx, FunctionalState NewState)
{
 8014364:	b480      	push	{r7}
 8014366:	b083      	sub	sp, #12
 8014368:	af00      	add	r7, sp, #0
 801436a:	6078      	str	r0, [r7, #4]
 801436c:	460b      	mov	r3, r1
 801436e:	70fb      	strb	r3, [r7, #3]
  /* Check the parameters */
  assert_param(IS_USART_1236_PERIPH(USARTx)); 
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 8014370:	78fb      	ldrb	r3, [r7, #3]
 8014372:	2b00      	cmp	r3, #0
 8014374:	d008      	beq.n	8014388 <USART_SmartCardNACKCmd+0x24>
  {
    /* Enable the NACK transmission by setting the NACK bit in the CR3 register */
    USARTx->CR3 |= USART_CR3_NACK;
 8014376:	687b      	ldr	r3, [r7, #4]
 8014378:	8a9b      	ldrh	r3, [r3, #20]
 801437a:	b29b      	uxth	r3, r3
 801437c:	f043 0310 	orr.w	r3, r3, #16
 8014380:	b29a      	uxth	r2, r3
 8014382:	687b      	ldr	r3, [r7, #4]
 8014384:	829a      	strh	r2, [r3, #20]
  else
  {
    /* Disable the NACK transmission by clearing the NACK bit in the CR3 register */
    USARTx->CR3 &= (uint16_t)~((uint16_t)USART_CR3_NACK);
  }
}
 8014386:	e007      	b.n	8014398 <USART_SmartCardNACKCmd+0x34>
    USARTx->CR3 &= (uint16_t)~((uint16_t)USART_CR3_NACK);
 8014388:	687b      	ldr	r3, [r7, #4]
 801438a:	8a9b      	ldrh	r3, [r3, #20]
 801438c:	b29b      	uxth	r3, r3
 801438e:	f023 0310 	bic.w	r3, r3, #16
 8014392:	b29a      	uxth	r2, r3
 8014394:	687b      	ldr	r3, [r7, #4]
 8014396:	829a      	strh	r2, [r3, #20]
}
 8014398:	bf00      	nop
 801439a:	370c      	adds	r7, #12
 801439c:	46bd      	mov	sp, r7
 801439e:	f85d 7b04 	ldr.w	r7, [sp], #4
 80143a2:	4770      	bx	lr

080143a4 <USART_IrDAConfig>:
  *            @arg USART_IrDAMode_LowPower
  *            @arg USART_IrDAMode_Normal
  * @retval None
  */
void USART_IrDAConfig(USART_TypeDef* USARTx, uint16_t USART_IrDAMode)
{
 80143a4:	b480      	push	{r7}
 80143a6:	b083      	sub	sp, #12
 80143a8:	af00      	add	r7, sp, #0
 80143aa:	6078      	str	r0, [r7, #4]
 80143ac:	460b      	mov	r3, r1
 80143ae:	807b      	strh	r3, [r7, #2]
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  assert_param(IS_USART_IRDA_MODE(USART_IrDAMode));
    
  USARTx->CR3 &= (uint16_t)~((uint16_t)USART_CR3_IRLP);
 80143b0:	687b      	ldr	r3, [r7, #4]
 80143b2:	8a9b      	ldrh	r3, [r3, #20]
 80143b4:	b29b      	uxth	r3, r3
 80143b6:	f023 0304 	bic.w	r3, r3, #4
 80143ba:	b29a      	uxth	r2, r3
 80143bc:	687b      	ldr	r3, [r7, #4]
 80143be:	829a      	strh	r2, [r3, #20]
  USARTx->CR3 |= USART_IrDAMode;
 80143c0:	687b      	ldr	r3, [r7, #4]
 80143c2:	8a9b      	ldrh	r3, [r3, #20]
 80143c4:	b29a      	uxth	r2, r3
 80143c6:	887b      	ldrh	r3, [r7, #2]
 80143c8:	4313      	orrs	r3, r2
 80143ca:	b29a      	uxth	r2, r3
 80143cc:	687b      	ldr	r3, [r7, #4]
 80143ce:	829a      	strh	r2, [r3, #20]
}
 80143d0:	bf00      	nop
 80143d2:	370c      	adds	r7, #12
 80143d4:	46bd      	mov	sp, r7
 80143d6:	f85d 7b04 	ldr.w	r7, [sp], #4
 80143da:	4770      	bx	lr

080143dc <USART_IrDACmd>:
  * @param  NewState: new state of the IrDA mode.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void USART_IrDACmd(USART_TypeDef* USARTx, FunctionalState NewState)
{
 80143dc:	b480      	push	{r7}
 80143de:	b083      	sub	sp, #12
 80143e0:	af00      	add	r7, sp, #0
 80143e2:	6078      	str	r0, [r7, #4]
 80143e4:	460b      	mov	r3, r1
 80143e6:	70fb      	strb	r3, [r7, #3]
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
    
  if (NewState != DISABLE)
 80143e8:	78fb      	ldrb	r3, [r7, #3]
 80143ea:	2b00      	cmp	r3, #0
 80143ec:	d008      	beq.n	8014400 <USART_IrDACmd+0x24>
  {
    /* Enable the IrDA mode by setting the IREN bit in the CR3 register */
    USARTx->CR3 |= USART_CR3_IREN;
 80143ee:	687b      	ldr	r3, [r7, #4]
 80143f0:	8a9b      	ldrh	r3, [r3, #20]
 80143f2:	b29b      	uxth	r3, r3
 80143f4:	f043 0302 	orr.w	r3, r3, #2
 80143f8:	b29a      	uxth	r2, r3
 80143fa:	687b      	ldr	r3, [r7, #4]
 80143fc:	829a      	strh	r2, [r3, #20]
  else
  {
    /* Disable the IrDA mode by clearing the IREN bit in the CR3 register */
    USARTx->CR3 &= (uint16_t)~((uint16_t)USART_CR3_IREN);
  }
}
 80143fe:	e007      	b.n	8014410 <USART_IrDACmd+0x34>
    USARTx->CR3 &= (uint16_t)~((uint16_t)USART_CR3_IREN);
 8014400:	687b      	ldr	r3, [r7, #4]
 8014402:	8a9b      	ldrh	r3, [r3, #20]
 8014404:	b29b      	uxth	r3, r3
 8014406:	f023 0302 	bic.w	r3, r3, #2
 801440a:	b29a      	uxth	r2, r3
 801440c:	687b      	ldr	r3, [r7, #4]
 801440e:	829a      	strh	r2, [r3, #20]
}
 8014410:	bf00      	nop
 8014412:	370c      	adds	r7, #12
 8014414:	46bd      	mov	sp, r7
 8014416:	f85d 7b04 	ldr.w	r7, [sp], #4
 801441a:	4770      	bx	lr

0801441c <USART_DMACmd>:
  * @param  NewState: new state of the DMA Request sources.
  *          This parameter can be: ENABLE or DISABLE.   
  * @retval None
  */
void USART_DMACmd(USART_TypeDef* USARTx, uint16_t USART_DMAReq, FunctionalState NewState)
{
 801441c:	b480      	push	{r7}
 801441e:	b083      	sub	sp, #12
 8014420:	af00      	add	r7, sp, #0
 8014422:	6078      	str	r0, [r7, #4]
 8014424:	460b      	mov	r3, r1
 8014426:	807b      	strh	r3, [r7, #2]
 8014428:	4613      	mov	r3, r2
 801442a:	707b      	strb	r3, [r7, #1]
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  assert_param(IS_USART_DMAREQ(USART_DMAReq));  
  assert_param(IS_FUNCTIONAL_STATE(NewState)); 

  if (NewState != DISABLE)
 801442c:	787b      	ldrb	r3, [r7, #1]
 801442e:	2b00      	cmp	r3, #0
 8014430:	d008      	beq.n	8014444 <USART_DMACmd+0x28>
  {
    /* Enable the DMA transfer for selected requests by setting the DMAT and/or
       DMAR bits in the USART CR3 register */
    USARTx->CR3 |= USART_DMAReq;
 8014432:	687b      	ldr	r3, [r7, #4]
 8014434:	8a9b      	ldrh	r3, [r3, #20]
 8014436:	b29a      	uxth	r2, r3
 8014438:	887b      	ldrh	r3, [r7, #2]
 801443a:	4313      	orrs	r3, r2
 801443c:	b29a      	uxth	r2, r3
 801443e:	687b      	ldr	r3, [r7, #4]
 8014440:	829a      	strh	r2, [r3, #20]
  {
    /* Disable the DMA transfer for selected requests by clearing the DMAT and/or
       DMAR bits in the USART CR3 register */
    USARTx->CR3 &= (uint16_t)~USART_DMAReq;
  }
}
 8014442:	e009      	b.n	8014458 <USART_DMACmd+0x3c>
    USARTx->CR3 &= (uint16_t)~USART_DMAReq;
 8014444:	687b      	ldr	r3, [r7, #4]
 8014446:	8a9b      	ldrh	r3, [r3, #20]
 8014448:	b29a      	uxth	r2, r3
 801444a:	887b      	ldrh	r3, [r7, #2]
 801444c:	43db      	mvns	r3, r3
 801444e:	b29b      	uxth	r3, r3
 8014450:	4013      	ands	r3, r2
 8014452:	b29a      	uxth	r2, r3
 8014454:	687b      	ldr	r3, [r7, #4]
 8014456:	829a      	strh	r2, [r3, #20]
}
 8014458:	bf00      	nop
 801445a:	370c      	adds	r7, #12
 801445c:	46bd      	mov	sp, r7
 801445e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8014462:	4770      	bx	lr

08014464 <USART_ITConfig>:
  * @param  NewState: new state of the specified USARTx interrupts.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void USART_ITConfig(USART_TypeDef* USARTx, uint16_t USART_IT, FunctionalState NewState)
{
 8014464:	b480      	push	{r7}
 8014466:	b087      	sub	sp, #28
 8014468:	af00      	add	r7, sp, #0
 801446a:	6078      	str	r0, [r7, #4]
 801446c:	460b      	mov	r3, r1
 801446e:	807b      	strh	r3, [r7, #2]
 8014470:	4613      	mov	r3, r2
 8014472:	707b      	strb	r3, [r7, #1]
  uint32_t usartreg = 0x00, itpos = 0x00, itmask = 0x00;
 8014474:	2300      	movs	r3, #0
 8014476:	613b      	str	r3, [r7, #16]
 8014478:	2300      	movs	r3, #0
 801447a:	60fb      	str	r3, [r7, #12]
 801447c:	2300      	movs	r3, #0
 801447e:	60bb      	str	r3, [r7, #8]
  uint32_t usartxbase = 0x00;
 8014480:	2300      	movs	r3, #0
 8014482:	617b      	str	r3, [r7, #20]
  if (USART_IT == USART_IT_CTS)
  {
    assert_param(IS_USART_1236_PERIPH(USARTx));
  } 
    
  usartxbase = (uint32_t)USARTx;
 8014484:	687b      	ldr	r3, [r7, #4]
 8014486:	617b      	str	r3, [r7, #20]

  /* Get the USART register index */
  usartreg = (((uint8_t)USART_IT) >> 0x05);
 8014488:	887b      	ldrh	r3, [r7, #2]
 801448a:	b2db      	uxtb	r3, r3
 801448c:	095b      	lsrs	r3, r3, #5
 801448e:	b2db      	uxtb	r3, r3
 8014490:	613b      	str	r3, [r7, #16]

  /* Get the interrupt position */
  itpos = USART_IT & IT_MASK;
 8014492:	887b      	ldrh	r3, [r7, #2]
 8014494:	f003 031f 	and.w	r3, r3, #31
 8014498:	60fb      	str	r3, [r7, #12]
  itmask = (((uint32_t)0x01) << itpos);
 801449a:	2201      	movs	r2, #1
 801449c:	68fb      	ldr	r3, [r7, #12]
 801449e:	fa02 f303 	lsl.w	r3, r2, r3
 80144a2:	60bb      	str	r3, [r7, #8]
    
  if (usartreg == 0x01) /* The IT is in CR1 register */
 80144a4:	693b      	ldr	r3, [r7, #16]
 80144a6:	2b01      	cmp	r3, #1
 80144a8:	d103      	bne.n	80144b2 <USART_ITConfig+0x4e>
  {
    usartxbase += 0x0C;
 80144aa:	697b      	ldr	r3, [r7, #20]
 80144ac:	330c      	adds	r3, #12
 80144ae:	617b      	str	r3, [r7, #20]
 80144b0:	e009      	b.n	80144c6 <USART_ITConfig+0x62>
  }
  else if (usartreg == 0x02) /* The IT is in CR2 register */
 80144b2:	693b      	ldr	r3, [r7, #16]
 80144b4:	2b02      	cmp	r3, #2
 80144b6:	d103      	bne.n	80144c0 <USART_ITConfig+0x5c>
  {
    usartxbase += 0x10;
 80144b8:	697b      	ldr	r3, [r7, #20]
 80144ba:	3310      	adds	r3, #16
 80144bc:	617b      	str	r3, [r7, #20]
 80144be:	e002      	b.n	80144c6 <USART_ITConfig+0x62>
  }
  else /* The IT is in CR3 register */
  {
    usartxbase += 0x14; 
 80144c0:	697b      	ldr	r3, [r7, #20]
 80144c2:	3314      	adds	r3, #20
 80144c4:	617b      	str	r3, [r7, #20]
  }
  if (NewState != DISABLE)
 80144c6:	787b      	ldrb	r3, [r7, #1]
 80144c8:	2b00      	cmp	r3, #0
 80144ca:	d006      	beq.n	80144da <USART_ITConfig+0x76>
  {
    *(__IO uint32_t*)usartxbase  |= itmask;
 80144cc:	697b      	ldr	r3, [r7, #20]
 80144ce:	697a      	ldr	r2, [r7, #20]
 80144d0:	6811      	ldr	r1, [r2, #0]
 80144d2:	68ba      	ldr	r2, [r7, #8]
 80144d4:	430a      	orrs	r2, r1
 80144d6:	601a      	str	r2, [r3, #0]
  }
  else
  {
    *(__IO uint32_t*)usartxbase &= ~itmask;
  }
}
 80144d8:	e006      	b.n	80144e8 <USART_ITConfig+0x84>
    *(__IO uint32_t*)usartxbase &= ~itmask;
 80144da:	697b      	ldr	r3, [r7, #20]
 80144dc:	697a      	ldr	r2, [r7, #20]
 80144de:	6811      	ldr	r1, [r2, #0]
 80144e0:	68ba      	ldr	r2, [r7, #8]
 80144e2:	43d2      	mvns	r2, r2
 80144e4:	400a      	ands	r2, r1
 80144e6:	601a      	str	r2, [r3, #0]
}
 80144e8:	bf00      	nop
 80144ea:	371c      	adds	r7, #28
 80144ec:	46bd      	mov	sp, r7
 80144ee:	f85d 7b04 	ldr.w	r7, [sp], #4
 80144f2:	4770      	bx	lr

080144f4 <USART_GetFlagStatus>:
  *            @arg USART_FLAG_FE:   Framing Error flag
  *            @arg USART_FLAG_PE:   Parity Error flag
  * @retval The new state of USART_FLAG (SET or RESET).
  */
FlagStatus USART_GetFlagStatus(USART_TypeDef* USARTx, uint16_t USART_FLAG)
{
 80144f4:	b480      	push	{r7}
 80144f6:	b085      	sub	sp, #20
 80144f8:	af00      	add	r7, sp, #0
 80144fa:	6078      	str	r0, [r7, #4]
 80144fc:	460b      	mov	r3, r1
 80144fe:	807b      	strh	r3, [r7, #2]
  FlagStatus bitstatus = RESET;
 8014500:	2300      	movs	r3, #0
 8014502:	73fb      	strb	r3, [r7, #15]
  if (USART_FLAG == USART_FLAG_CTS)
  {
    assert_param(IS_USART_1236_PERIPH(USARTx));
  } 
    
  if ((USARTx->SR & USART_FLAG) != (uint16_t)RESET)
 8014504:	687b      	ldr	r3, [r7, #4]
 8014506:	881b      	ldrh	r3, [r3, #0]
 8014508:	b29a      	uxth	r2, r3
 801450a:	887b      	ldrh	r3, [r7, #2]
 801450c:	4013      	ands	r3, r2
 801450e:	b29b      	uxth	r3, r3
 8014510:	2b00      	cmp	r3, #0
 8014512:	d002      	beq.n	801451a <USART_GetFlagStatus+0x26>
  {
    bitstatus = SET;
 8014514:	2301      	movs	r3, #1
 8014516:	73fb      	strb	r3, [r7, #15]
 8014518:	e001      	b.n	801451e <USART_GetFlagStatus+0x2a>
  }
  else
  {
    bitstatus = RESET;
 801451a:	2300      	movs	r3, #0
 801451c:	73fb      	strb	r3, [r7, #15]
  }
  return bitstatus;
 801451e:	7bfb      	ldrb	r3, [r7, #15]
}
 8014520:	4618      	mov	r0, r3
 8014522:	3714      	adds	r7, #20
 8014524:	46bd      	mov	sp, r7
 8014526:	f85d 7b04 	ldr.w	r7, [sp], #4
 801452a:	4770      	bx	lr

0801452c <USART_ClearFlag>:
  *          (USART_SendData()).
  *   
  * @retval None
  */
void USART_ClearFlag(USART_TypeDef* USARTx, uint16_t USART_FLAG)
{
 801452c:	b480      	push	{r7}
 801452e:	b083      	sub	sp, #12
 8014530:	af00      	add	r7, sp, #0
 8014532:	6078      	str	r0, [r7, #4]
 8014534:	460b      	mov	r3, r1
 8014536:	807b      	strh	r3, [r7, #2]
  if ((USART_FLAG & USART_FLAG_CTS) == USART_FLAG_CTS)
  {
    assert_param(IS_USART_1236_PERIPH(USARTx));
  } 
       
  USARTx->SR = (uint16_t)~USART_FLAG;
 8014538:	887b      	ldrh	r3, [r7, #2]
 801453a:	43db      	mvns	r3, r3
 801453c:	b29a      	uxth	r2, r3
 801453e:	687b      	ldr	r3, [r7, #4]
 8014540:	801a      	strh	r2, [r3, #0]
}
 8014542:	bf00      	nop
 8014544:	370c      	adds	r7, #12
 8014546:	46bd      	mov	sp, r7
 8014548:	f85d 7b04 	ldr.w	r7, [sp], #4
 801454c:	4770      	bx	lr

0801454e <USART_GetITStatus>:
  *            @arg USART_IT_FE:   Framing Error interrupt
  *            @arg USART_IT_PE:   Parity Error interrupt
  * @retval The new state of USART_IT (SET or RESET).
  */
ITStatus USART_GetITStatus(USART_TypeDef* USARTx, uint16_t USART_IT)
{
 801454e:	b480      	push	{r7}
 8014550:	b087      	sub	sp, #28
 8014552:	af00      	add	r7, sp, #0
 8014554:	6078      	str	r0, [r7, #4]
 8014556:	460b      	mov	r3, r1
 8014558:	807b      	strh	r3, [r7, #2]
  uint32_t bitpos = 0x00, itmask = 0x00, usartreg = 0x00;
 801455a:	2300      	movs	r3, #0
 801455c:	60fb      	str	r3, [r7, #12]
 801455e:	2300      	movs	r3, #0
 8014560:	617b      	str	r3, [r7, #20]
 8014562:	2300      	movs	r3, #0
 8014564:	60bb      	str	r3, [r7, #8]
  ITStatus bitstatus = RESET;
 8014566:	2300      	movs	r3, #0
 8014568:	74fb      	strb	r3, [r7, #19]
  {
    assert_param(IS_USART_1236_PERIPH(USARTx));
  } 
    
  /* Get the USART register index */
  usartreg = (((uint8_t)USART_IT) >> 0x05);
 801456a:	887b      	ldrh	r3, [r7, #2]
 801456c:	b2db      	uxtb	r3, r3
 801456e:	095b      	lsrs	r3, r3, #5
 8014570:	b2db      	uxtb	r3, r3
 8014572:	60bb      	str	r3, [r7, #8]
  /* Get the interrupt position */
  itmask = USART_IT & IT_MASK;
 8014574:	887b      	ldrh	r3, [r7, #2]
 8014576:	f003 031f 	and.w	r3, r3, #31
 801457a:	617b      	str	r3, [r7, #20]
  itmask = (uint32_t)0x01 << itmask;
 801457c:	2201      	movs	r2, #1
 801457e:	697b      	ldr	r3, [r7, #20]
 8014580:	fa02 f303 	lsl.w	r3, r2, r3
 8014584:	617b      	str	r3, [r7, #20]
  
  if (usartreg == 0x01) /* The IT  is in CR1 register */
 8014586:	68bb      	ldr	r3, [r7, #8]
 8014588:	2b01      	cmp	r3, #1
 801458a:	d107      	bne.n	801459c <USART_GetITStatus+0x4e>
  {
    itmask &= USARTx->CR1;
 801458c:	687b      	ldr	r3, [r7, #4]
 801458e:	899b      	ldrh	r3, [r3, #12]
 8014590:	b29b      	uxth	r3, r3
 8014592:	461a      	mov	r2, r3
 8014594:	697b      	ldr	r3, [r7, #20]
 8014596:	4013      	ands	r3, r2
 8014598:	617b      	str	r3, [r7, #20]
 801459a:	e011      	b.n	80145c0 <USART_GetITStatus+0x72>
  }
  else if (usartreg == 0x02) /* The IT  is in CR2 register */
 801459c:	68bb      	ldr	r3, [r7, #8]
 801459e:	2b02      	cmp	r3, #2
 80145a0:	d107      	bne.n	80145b2 <USART_GetITStatus+0x64>
  {
    itmask &= USARTx->CR2;
 80145a2:	687b      	ldr	r3, [r7, #4]
 80145a4:	8a1b      	ldrh	r3, [r3, #16]
 80145a6:	b29b      	uxth	r3, r3
 80145a8:	461a      	mov	r2, r3
 80145aa:	697b      	ldr	r3, [r7, #20]
 80145ac:	4013      	ands	r3, r2
 80145ae:	617b      	str	r3, [r7, #20]
 80145b0:	e006      	b.n	80145c0 <USART_GetITStatus+0x72>
  }
  else /* The IT  is in CR3 register */
  {
    itmask &= USARTx->CR3;
 80145b2:	687b      	ldr	r3, [r7, #4]
 80145b4:	8a9b      	ldrh	r3, [r3, #20]
 80145b6:	b29b      	uxth	r3, r3
 80145b8:	461a      	mov	r2, r3
 80145ba:	697b      	ldr	r3, [r7, #20]
 80145bc:	4013      	ands	r3, r2
 80145be:	617b      	str	r3, [r7, #20]
  }
  
  bitpos = USART_IT >> 0x08;
 80145c0:	887b      	ldrh	r3, [r7, #2]
 80145c2:	0a1b      	lsrs	r3, r3, #8
 80145c4:	b29b      	uxth	r3, r3
 80145c6:	60fb      	str	r3, [r7, #12]
  bitpos = (uint32_t)0x01 << bitpos;
 80145c8:	2201      	movs	r2, #1
 80145ca:	68fb      	ldr	r3, [r7, #12]
 80145cc:	fa02 f303 	lsl.w	r3, r2, r3
 80145d0:	60fb      	str	r3, [r7, #12]
  bitpos &= USARTx->SR;
 80145d2:	687b      	ldr	r3, [r7, #4]
 80145d4:	881b      	ldrh	r3, [r3, #0]
 80145d6:	b29b      	uxth	r3, r3
 80145d8:	461a      	mov	r2, r3
 80145da:	68fb      	ldr	r3, [r7, #12]
 80145dc:	4013      	ands	r3, r2
 80145de:	60fb      	str	r3, [r7, #12]
  if ((itmask != (uint16_t)RESET)&&(bitpos != (uint16_t)RESET))
 80145e0:	697b      	ldr	r3, [r7, #20]
 80145e2:	2b00      	cmp	r3, #0
 80145e4:	d005      	beq.n	80145f2 <USART_GetITStatus+0xa4>
 80145e6:	68fb      	ldr	r3, [r7, #12]
 80145e8:	2b00      	cmp	r3, #0
 80145ea:	d002      	beq.n	80145f2 <USART_GetITStatus+0xa4>
  {
    bitstatus = SET;
 80145ec:	2301      	movs	r3, #1
 80145ee:	74fb      	strb	r3, [r7, #19]
 80145f0:	e001      	b.n	80145f6 <USART_GetITStatus+0xa8>
  }
  else
  {
    bitstatus = RESET;
 80145f2:	2300      	movs	r3, #0
 80145f4:	74fb      	strb	r3, [r7, #19]
  }
  
  return bitstatus;  
 80145f6:	7cfb      	ldrb	r3, [r7, #19]
}
 80145f8:	4618      	mov	r0, r3
 80145fa:	371c      	adds	r7, #28
 80145fc:	46bd      	mov	sp, r7
 80145fe:	f85d 7b04 	ldr.w	r7, [sp], #4
 8014602:	4770      	bx	lr

08014604 <USART_ClearITPendingBit>:
  *          (USART_SendData()).
  *  
  * @retval None
  */
void USART_ClearITPendingBit(USART_TypeDef* USARTx, uint16_t USART_IT)
{
 8014604:	b480      	push	{r7}
 8014606:	b085      	sub	sp, #20
 8014608:	af00      	add	r7, sp, #0
 801460a:	6078      	str	r0, [r7, #4]
 801460c:	460b      	mov	r3, r1
 801460e:	807b      	strh	r3, [r7, #2]
  uint16_t bitpos = 0x00, itmask = 0x00;
 8014610:	2300      	movs	r3, #0
 8014612:	81fb      	strh	r3, [r7, #14]
 8014614:	2300      	movs	r3, #0
 8014616:	81bb      	strh	r3, [r7, #12]
  if (USART_IT == USART_IT_CTS)
  {
    assert_param(IS_USART_1236_PERIPH(USARTx));
  } 
    
  bitpos = USART_IT >> 0x08;
 8014618:	887b      	ldrh	r3, [r7, #2]
 801461a:	0a1b      	lsrs	r3, r3, #8
 801461c:	81fb      	strh	r3, [r7, #14]
  itmask = ((uint16_t)0x01 << (uint16_t)bitpos);
 801461e:	89fb      	ldrh	r3, [r7, #14]
 8014620:	2201      	movs	r2, #1
 8014622:	fa02 f303 	lsl.w	r3, r2, r3
 8014626:	81bb      	strh	r3, [r7, #12]
  USARTx->SR = (uint16_t)~itmask;
 8014628:	89bb      	ldrh	r3, [r7, #12]
 801462a:	43db      	mvns	r3, r3
 801462c:	b29a      	uxth	r2, r3
 801462e:	687b      	ldr	r3, [r7, #4]
 8014630:	801a      	strh	r2, [r3, #0]
}
 8014632:	bf00      	nop
 8014634:	3714      	adds	r7, #20
 8014636:	46bd      	mov	sp, r7
 8014638:	f85d 7b04 	ldr.w	r7, [sp], #4
 801463c:	4770      	bx	lr
 801463e:	bf00      	nop

08014640 <WWDG_DeInit>:
  * @brief  Deinitializes the WWDG peripheral registers to their default reset values.
  * @param  None
  * @retval None
  */
void WWDG_DeInit(void)
{
 8014640:	b580      	push	{r7, lr}
 8014642:	af00      	add	r7, sp, #0
  RCC_APB1PeriphResetCmd(RCC_APB1Periph_WWDG, ENABLE);
 8014644:	2101      	movs	r1, #1
 8014646:	f44f 6000 	mov.w	r0, #2048	; 0x800
 801464a:	f7fb f963 	bl	800f914 <RCC_APB1PeriphResetCmd>
  RCC_APB1PeriphResetCmd(RCC_APB1Periph_WWDG, DISABLE);
 801464e:	2100      	movs	r1, #0
 8014650:	f44f 6000 	mov.w	r0, #2048	; 0x800
 8014654:	f7fb f95e 	bl	800f914 <RCC_APB1PeriphResetCmd>
}
 8014658:	bf00      	nop
 801465a:	bd80      	pop	{r7, pc}

0801465c <WWDG_SetPrescaler>:
  *     @arg WWDG_Prescaler_4: WWDG counter clock = (PCLK1/4096)/4
  *     @arg WWDG_Prescaler_8: WWDG counter clock = (PCLK1/4096)/8
  * @retval None
  */
void WWDG_SetPrescaler(uint32_t WWDG_Prescaler)
{
 801465c:	b480      	push	{r7}
 801465e:	b085      	sub	sp, #20
 8014660:	af00      	add	r7, sp, #0
 8014662:	6078      	str	r0, [r7, #4]
  uint32_t tmpreg = 0;
 8014664:	2300      	movs	r3, #0
 8014666:	60fb      	str	r3, [r7, #12]
  /* Check the parameters */
  assert_param(IS_WWDG_PRESCALER(WWDG_Prescaler));
  /* Clear WDGTB[1:0] bits */
  tmpreg = WWDG->CFR & CFR_WDGTB_MASK;
 8014668:	4b08      	ldr	r3, [pc, #32]	; (801468c <WWDG_SetPrescaler+0x30>)
 801466a:	685b      	ldr	r3, [r3, #4]
 801466c:	f423 73c0 	bic.w	r3, r3, #384	; 0x180
 8014670:	60fb      	str	r3, [r7, #12]
  /* Set WDGTB[1:0] bits according to WWDG_Prescaler value */
  tmpreg |= WWDG_Prescaler;
 8014672:	68fa      	ldr	r2, [r7, #12]
 8014674:	687b      	ldr	r3, [r7, #4]
 8014676:	4313      	orrs	r3, r2
 8014678:	60fb      	str	r3, [r7, #12]
  /* Store the new value */
  WWDG->CFR = tmpreg;
 801467a:	4a04      	ldr	r2, [pc, #16]	; (801468c <WWDG_SetPrescaler+0x30>)
 801467c:	68fb      	ldr	r3, [r7, #12]
 801467e:	6053      	str	r3, [r2, #4]
}
 8014680:	bf00      	nop
 8014682:	3714      	adds	r7, #20
 8014684:	46bd      	mov	sp, r7
 8014686:	f85d 7b04 	ldr.w	r7, [sp], #4
 801468a:	4770      	bx	lr
 801468c:	40002c00 	.word	0x40002c00

08014690 <WWDG_SetWindowValue>:
  * @param  WindowValue: specifies the window value to be compared to the downcounter.
  *   This parameter value must be lower than 0x80.
  * @retval None
  */
void WWDG_SetWindowValue(uint8_t WindowValue)
{
 8014690:	b480      	push	{r7}
 8014692:	b085      	sub	sp, #20
 8014694:	af00      	add	r7, sp, #0
 8014696:	4603      	mov	r3, r0
 8014698:	71fb      	strb	r3, [r7, #7]
  __IO uint32_t tmpreg = 0;
 801469a:	2300      	movs	r3, #0
 801469c:	60fb      	str	r3, [r7, #12]

  /* Check the parameters */
  assert_param(IS_WWDG_WINDOW_VALUE(WindowValue));
  /* Clear W[6:0] bits */

  tmpreg = WWDG->CFR & CFR_W_MASK;
 801469e:	4b0a      	ldr	r3, [pc, #40]	; (80146c8 <WWDG_SetWindowValue+0x38>)
 80146a0:	685b      	ldr	r3, [r3, #4]
 80146a2:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
 80146a6:	60fb      	str	r3, [r7, #12]

  /* Set W[6:0] bits according to WindowValue value */
  tmpreg |= WindowValue & (uint32_t) BIT_MASK;
 80146a8:	79fb      	ldrb	r3, [r7, #7]
 80146aa:	f003 027f 	and.w	r2, r3, #127	; 0x7f
 80146ae:	68fb      	ldr	r3, [r7, #12]
 80146b0:	4313      	orrs	r3, r2
 80146b2:	60fb      	str	r3, [r7, #12]

  /* Store the new value */
  WWDG->CFR = tmpreg;
 80146b4:	4a04      	ldr	r2, [pc, #16]	; (80146c8 <WWDG_SetWindowValue+0x38>)
 80146b6:	68fb      	ldr	r3, [r7, #12]
 80146b8:	6053      	str	r3, [r2, #4]
}
 80146ba:	bf00      	nop
 80146bc:	3714      	adds	r7, #20
 80146be:	46bd      	mov	sp, r7
 80146c0:	f85d 7b04 	ldr.w	r7, [sp], #4
 80146c4:	4770      	bx	lr
 80146c6:	bf00      	nop
 80146c8:	40002c00 	.word	0x40002c00

080146cc <WWDG_EnableIT>:
  * @note   Once enabled this interrupt cannot be disabled except by a system reset.
  * @param  None
  * @retval None
  */
void WWDG_EnableIT(void)
{
 80146cc:	b480      	push	{r7}
 80146ce:	af00      	add	r7, sp, #0
  *(__IO uint32_t *) CFR_EWI_BB = (uint32_t)ENABLE;
 80146d0:	4b03      	ldr	r3, [pc, #12]	; (80146e0 <WWDG_EnableIT+0x14>)
 80146d2:	2201      	movs	r2, #1
 80146d4:	601a      	str	r2, [r3, #0]
}
 80146d6:	bf00      	nop
 80146d8:	46bd      	mov	sp, r7
 80146da:	f85d 7b04 	ldr.w	r7, [sp], #4
 80146de:	4770      	bx	lr
 80146e0:	420580a4 	.word	0x420580a4

080146e4 <WWDG_SetCounter>:
  *   This parameter must be a number between 0x40 and 0x7F (to prevent generating
  *   an immediate reset) 
  * @retval None
  */
void WWDG_SetCounter(uint8_t Counter)
{
 80146e4:	b480      	push	{r7}
 80146e6:	b083      	sub	sp, #12
 80146e8:	af00      	add	r7, sp, #0
 80146ea:	4603      	mov	r3, r0
 80146ec:	71fb      	strb	r3, [r7, #7]
  /* Check the parameters */
  assert_param(IS_WWDG_COUNTER(Counter));
  /* Write to T[6:0] bits to configure the counter value, no need to do
     a read-modify-write; writing a 0 to WDGA bit does nothing */
  WWDG->CR = Counter & BIT_MASK;
 80146ee:	4a05      	ldr	r2, [pc, #20]	; (8014704 <WWDG_SetCounter+0x20>)
 80146f0:	79fb      	ldrb	r3, [r7, #7]
 80146f2:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 80146f6:	6013      	str	r3, [r2, #0]
}
 80146f8:	bf00      	nop
 80146fa:	370c      	adds	r7, #12
 80146fc:	46bd      	mov	sp, r7
 80146fe:	f85d 7b04 	ldr.w	r7, [sp], #4
 8014702:	4770      	bx	lr
 8014704:	40002c00 	.word	0x40002c00

08014708 <WWDG_Enable>:
  *   This parameter must be a number between 0x40 and 0x7F (to prevent generating
  *   an immediate reset)
  * @retval None
  */
void WWDG_Enable(uint8_t Counter)
{
 8014708:	b480      	push	{r7}
 801470a:	b083      	sub	sp, #12
 801470c:	af00      	add	r7, sp, #0
 801470e:	4603      	mov	r3, r0
 8014710:	71fb      	strb	r3, [r7, #7]
  /* Check the parameters */
  assert_param(IS_WWDG_COUNTER(Counter));
  WWDG->CR = WWDG_CR_WDGA | Counter;
 8014712:	4a06      	ldr	r2, [pc, #24]	; (801472c <WWDG_Enable+0x24>)
 8014714:	79fb      	ldrb	r3, [r7, #7]
 8014716:	f063 037f 	orn	r3, r3, #127	; 0x7f
 801471a:	b2db      	uxtb	r3, r3
 801471c:	6013      	str	r3, [r2, #0]
}
 801471e:	bf00      	nop
 8014720:	370c      	adds	r7, #12
 8014722:	46bd      	mov	sp, r7
 8014724:	f85d 7b04 	ldr.w	r7, [sp], #4
 8014728:	4770      	bx	lr
 801472a:	bf00      	nop
 801472c:	40002c00 	.word	0x40002c00

08014730 <WWDG_GetFlagStatus>:
  * @brief  Checks whether the Early Wakeup interrupt flag is set or not.
  * @param  None
  * @retval The new state of the Early Wakeup interrupt flag (SET or RESET)
  */
FlagStatus WWDG_GetFlagStatus(void)
{
 8014730:	b480      	push	{r7}
 8014732:	b083      	sub	sp, #12
 8014734:	af00      	add	r7, sp, #0
  FlagStatus bitstatus = RESET;
 8014736:	2300      	movs	r3, #0
 8014738:	71fb      	strb	r3, [r7, #7]
    
  if ((WWDG->SR) != (uint32_t)RESET)
 801473a:	4b08      	ldr	r3, [pc, #32]	; (801475c <WWDG_GetFlagStatus+0x2c>)
 801473c:	689b      	ldr	r3, [r3, #8]
 801473e:	2b00      	cmp	r3, #0
 8014740:	d002      	beq.n	8014748 <WWDG_GetFlagStatus+0x18>
  {
    bitstatus = SET;
 8014742:	2301      	movs	r3, #1
 8014744:	71fb      	strb	r3, [r7, #7]
 8014746:	e001      	b.n	801474c <WWDG_GetFlagStatus+0x1c>
  }
  else
  {
    bitstatus = RESET;
 8014748:	2300      	movs	r3, #0
 801474a:	71fb      	strb	r3, [r7, #7]
  }
  return bitstatus;
 801474c:	79fb      	ldrb	r3, [r7, #7]
}
 801474e:	4618      	mov	r0, r3
 8014750:	370c      	adds	r7, #12
 8014752:	46bd      	mov	sp, r7
 8014754:	f85d 7b04 	ldr.w	r7, [sp], #4
 8014758:	4770      	bx	lr
 801475a:	bf00      	nop
 801475c:	40002c00 	.word	0x40002c00

08014760 <WWDG_ClearFlag>:
  * @brief  Clears Early Wakeup interrupt flag.
  * @param  None
  * @retval None
  */
void WWDG_ClearFlag(void)
{
 8014760:	b480      	push	{r7}
 8014762:	af00      	add	r7, sp, #0
  WWDG->SR = (uint32_t)RESET;
 8014764:	4b03      	ldr	r3, [pc, #12]	; (8014774 <WWDG_ClearFlag+0x14>)
 8014766:	2200      	movs	r2, #0
 8014768:	609a      	str	r2, [r3, #8]
}
 801476a:	bf00      	nop
 801476c:	46bd      	mov	sp, r7
 801476e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8014772:	4770      	bx	lr
 8014774:	40002c00 	.word	0x40002c00
 8014778:	0806bc90 	.word	0x0806bc90
 801477c:	20000000 	.word	0x20000000
 8014780:	20000098 	.word	0x20000098
 8014784:	20000098 	.word	0x20000098
 8014788:	20009e70 	.word	0x20009e70

0801478c <NVIC_EnableIRQ>:
    The interrupt number cannot be a negative value.

    \param [in]      IRQn  Number of the external interrupt to enable
 */
static __INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
{
 801478c:	b480      	push	{r7}
 801478e:	b083      	sub	sp, #12
 8014790:	af00      	add	r7, sp, #0
 8014792:	4603      	mov	r3, r0
 8014794:	71fb      	strb	r3, [r7, #7]
/*  NVIC->ISER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F));  enable interrupt */
  NVIC->ISER[(uint32_t)((int32_t)IRQn) >> 5] = (uint32_t)(1 << ((uint32_t)((int32_t)IRQn) & (uint32_t)0x1F)); /* enable interrupt */
 8014796:	4909      	ldr	r1, [pc, #36]	; (80147bc <NVIC_EnableIRQ+0x30>)
 8014798:	f997 3007 	ldrsb.w	r3, [r7, #7]
 801479c:	095b      	lsrs	r3, r3, #5
 801479e:	79fa      	ldrb	r2, [r7, #7]
 80147a0:	f002 021f 	and.w	r2, r2, #31
 80147a4:	2001      	movs	r0, #1
 80147a6:	fa00 f202 	lsl.w	r2, r0, r2
 80147aa:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
 80147ae:	bf00      	nop
 80147b0:	370c      	adds	r7, #12
 80147b2:	46bd      	mov	sp, r7
 80147b4:	f85d 7b04 	ldr.w	r7, [sp], #4
 80147b8:	4770      	bx	lr
 80147ba:	bf00      	nop
 80147bc:	e000e100 	.word	0xe000e100

080147c0 <NVIC_DisableIRQ>:
    The interrupt number cannot be a negative value.

    \param [in]      IRQn  Number of the external interrupt to disable
 */
static __INLINE void NVIC_DisableIRQ(IRQn_Type IRQn)
{
 80147c0:	b480      	push	{r7}
 80147c2:	b083      	sub	sp, #12
 80147c4:	af00      	add	r7, sp, #0
 80147c6:	4603      	mov	r3, r0
 80147c8:	71fb      	strb	r3, [r7, #7]
  NVIC->ICER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* disable interrupt */
 80147ca:	4909      	ldr	r1, [pc, #36]	; (80147f0 <NVIC_DisableIRQ+0x30>)
 80147cc:	f997 3007 	ldrsb.w	r3, [r7, #7]
 80147d0:	095b      	lsrs	r3, r3, #5
 80147d2:	79fa      	ldrb	r2, [r7, #7]
 80147d4:	f002 021f 	and.w	r2, r2, #31
 80147d8:	2001      	movs	r0, #1
 80147da:	fa00 f202 	lsl.w	r2, r0, r2
 80147de:	3320      	adds	r3, #32
 80147e0:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
 80147e4:	bf00      	nop
 80147e6:	370c      	adds	r7, #12
 80147e8:	46bd      	mov	sp, r7
 80147ea:	f85d 7b04 	ldr.w	r7, [sp], #4
 80147ee:	4770      	bx	lr
 80147f0:	e000e100 	.word	0xe000e100

080147f4 <NVIC_SetPriority>:

    \param [in]      IRQn  Number of the interrupt for set priority
    \param [in]  priority  Priority to set
 */
static __INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
 80147f4:	b480      	push	{r7}
 80147f6:	b083      	sub	sp, #12
 80147f8:	af00      	add	r7, sp, #0
 80147fa:	4603      	mov	r3, r0
 80147fc:	6039      	str	r1, [r7, #0]
 80147fe:	71fb      	strb	r3, [r7, #7]
  if(IRQn < 0) {
 8014800:	f997 3007 	ldrsb.w	r3, [r7, #7]
 8014804:	2b00      	cmp	r3, #0
 8014806:	da0b      	bge.n	8014820 <NVIC_SetPriority+0x2c>
    SCB->SHP[((uint32_t)(IRQn) & 0xF)-4] = ((priority << (8 - __NVIC_PRIO_BITS)) & 0xff); } /* set Priority for Cortex-M  System Interrupts */
 8014808:	490d      	ldr	r1, [pc, #52]	; (8014840 <NVIC_SetPriority+0x4c>)
 801480a:	79fb      	ldrb	r3, [r7, #7]
 801480c:	f003 030f 	and.w	r3, r3, #15
 8014810:	3b04      	subs	r3, #4
 8014812:	683a      	ldr	r2, [r7, #0]
 8014814:	b2d2      	uxtb	r2, r2
 8014816:	0112      	lsls	r2, r2, #4
 8014818:	b2d2      	uxtb	r2, r2
 801481a:	440b      	add	r3, r1
 801481c:	761a      	strb	r2, [r3, #24]
  else {
    NVIC->IP[(uint32_t)(IRQn)] = ((priority << (8 - __NVIC_PRIO_BITS)) & 0xff);    }        /* set Priority for device specific Interrupts  */
}
 801481e:	e009      	b.n	8014834 <NVIC_SetPriority+0x40>
    NVIC->IP[(uint32_t)(IRQn)] = ((priority << (8 - __NVIC_PRIO_BITS)) & 0xff);    }        /* set Priority for device specific Interrupts  */
 8014820:	4908      	ldr	r1, [pc, #32]	; (8014844 <NVIC_SetPriority+0x50>)
 8014822:	f997 3007 	ldrsb.w	r3, [r7, #7]
 8014826:	683a      	ldr	r2, [r7, #0]
 8014828:	b2d2      	uxtb	r2, r2
 801482a:	0112      	lsls	r2, r2, #4
 801482c:	b2d2      	uxtb	r2, r2
 801482e:	440b      	add	r3, r1
 8014830:	f883 2300 	strb.w	r2, [r3, #768]	; 0x300
}
 8014834:	bf00      	nop
 8014836:	370c      	adds	r7, #12
 8014838:	46bd      	mov	sp, r7
 801483a:	f85d 7b04 	ldr.w	r7, [sp], #4
 801483e:	4770      	bx	lr
 8014840:	e000ed00 	.word	0xe000ed00
 8014844:	e000e100 	.word	0xe000e100

08014848 <InitializeAudio>:
static int16_t * volatile NextBufferSamples;
static volatile int NextBufferLength;
static volatile int BufferNumber;
static volatile bool DMARunning;

void InitializeAudio(int plln, int pllr, int i2sdiv, int i2sodd) {
 8014848:	b580      	push	{r7, lr}
 801484a:	b08a      	sub	sp, #40	; 0x28
 801484c:	af00      	add	r7, sp, #0
 801484e:	60f8      	str	r0, [r7, #12]
 8014850:	60b9      	str	r1, [r7, #8]
 8014852:	607a      	str	r2, [r7, #4]
 8014854:	603b      	str	r3, [r7, #0]
	GPIO_InitTypeDef  GPIO_InitStructure;

	// Intitialize state.
	CallbackFunction = NULL;
 8014856:	4b9e      	ldr	r3, [pc, #632]	; (8014ad0 <InitializeAudio+0x288>)
 8014858:	2200      	movs	r2, #0
 801485a:	601a      	str	r2, [r3, #0]
	CallbackContext = NULL;
 801485c:	4b9d      	ldr	r3, [pc, #628]	; (8014ad4 <InitializeAudio+0x28c>)
 801485e:	2200      	movs	r2, #0
 8014860:	601a      	str	r2, [r3, #0]
	NextBufferSamples = NULL;
 8014862:	4b9d      	ldr	r3, [pc, #628]	; (8014ad8 <InitializeAudio+0x290>)
 8014864:	2200      	movs	r2, #0
 8014866:	601a      	str	r2, [r3, #0]
	NextBufferLength = 0;
 8014868:	4b9c      	ldr	r3, [pc, #624]	; (8014adc <InitializeAudio+0x294>)
 801486a:	2200      	movs	r2, #0
 801486c:	601a      	str	r2, [r3, #0]
	BufferNumber = 0;
 801486e:	4b9c      	ldr	r3, [pc, #624]	; (8014ae0 <InitializeAudio+0x298>)
 8014870:	2200      	movs	r2, #0
 8014872:	601a      	str	r2, [r3, #0]
	DMARunning = false;
 8014874:	4b9b      	ldr	r3, [pc, #620]	; (8014ae4 <InitializeAudio+0x29c>)
 8014876:	2200      	movs	r2, #0
 8014878:	701a      	strb	r2, [r3, #0]

	// Turn on peripherals.
	RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOA, ENABLE);
 801487a:	2101      	movs	r1, #1
 801487c:	2001      	movs	r0, #1
 801487e:	f7fa ff49 	bl	800f714 <RCC_AHB1PeriphClockCmd>
	RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOB, ENABLE);
 8014882:	2101      	movs	r1, #1
 8014884:	2002      	movs	r0, #2
 8014886:	f7fa ff45 	bl	800f714 <RCC_AHB1PeriphClockCmd>
	RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOC, ENABLE);
 801488a:	2101      	movs	r1, #1
 801488c:	2004      	movs	r0, #4
 801488e:	f7fa ff41 	bl	800f714 <RCC_AHB1PeriphClockCmd>
	RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOD, ENABLE);
 8014892:	2101      	movs	r1, #1
 8014894:	2008      	movs	r0, #8
 8014896:	f7fa ff3d 	bl	800f714 <RCC_AHB1PeriphClockCmd>
	RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_DMA1, ENABLE);
 801489a:	2101      	movs	r1, #1
 801489c:	f44f 1000 	mov.w	r0, #2097152	; 0x200000
 80148a0:	f7fa ff38 	bl	800f714 <RCC_AHB1PeriphClockCmd>

	RCC_APB1PeriphClockCmd(RCC_APB1Periph_I2C1, ENABLE);
 80148a4:	2101      	movs	r1, #1
 80148a6:	f44f 1000 	mov.w	r0, #2097152	; 0x200000
 80148aa:	f7fa ff93 	bl	800f7d4 <RCC_APB1PeriphClockCmd>
	RCC_APB1PeriphClockCmd(RCC_APB1Periph_SPI3, ENABLE);
 80148ae:	2101      	movs	r1, #1
 80148b0:	f44f 4000 	mov.w	r0, #32768	; 0x8000
 80148b4:	f7fa ff8e 	bl	800f7d4 <RCC_APB1PeriphClockCmd>

	// Configure reset pin.
	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_4;;
 80148b8:	2310      	movs	r3, #16
 80148ba:	617b      	str	r3, [r7, #20]
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
 80148bc:	2301      	movs	r3, #1
 80148be:	763b      	strb	r3, [r7, #24]
	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
 80148c0:	2300      	movs	r3, #0
 80148c2:	76bb      	strb	r3, [r7, #26]
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
 80148c4:	2302      	movs	r3, #2
 80148c6:	767b      	strb	r3, [r7, #25]
	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
 80148c8:	2300      	movs	r3, #0
 80148ca:	76fb      	strb	r3, [r7, #27]
	GPIO_Init(GPIOD, &GPIO_InitStructure);
 80148cc:	f107 0314 	add.w	r3, r7, #20
 80148d0:	4619      	mov	r1, r3
 80148d2:	4885      	ldr	r0, [pc, #532]	; (8014ae8 <InitializeAudio+0x2a0>)
 80148d4:	f7f8 ff0a 	bl	800d6ec <GPIO_Init>

	// Configure I2C SCL and SDA pins.
	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_6 | GPIO_Pin_9;
 80148d8:	f44f 7310 	mov.w	r3, #576	; 0x240
 80148dc:	617b      	str	r3, [r7, #20]
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
 80148de:	2302      	movs	r3, #2
 80148e0:	767b      	strb	r3, [r7, #25]
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
 80148e2:	2302      	movs	r3, #2
 80148e4:	763b      	strb	r3, [r7, #24]
	GPIO_InitStructure.GPIO_OType = GPIO_OType_OD;
 80148e6:	2301      	movs	r3, #1
 80148e8:	76bb      	strb	r3, [r7, #26]
	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
 80148ea:	2300      	movs	r3, #0
 80148ec:	76fb      	strb	r3, [r7, #27]
	GPIO_Init(GPIOB, &GPIO_InitStructure);
 80148ee:	f107 0314 	add.w	r3, r7, #20
 80148f2:	4619      	mov	r1, r3
 80148f4:	487d      	ldr	r0, [pc, #500]	; (8014aec <InitializeAudio+0x2a4>)
 80148f6:	f7f8 fef9 	bl	800d6ec <GPIO_Init>

	GPIO_PinAFConfig(GPIOB, GPIO_PinSource6, GPIO_AF_I2C1);
 80148fa:	2204      	movs	r2, #4
 80148fc:	2106      	movs	r1, #6
 80148fe:	487b      	ldr	r0, [pc, #492]	; (8014aec <InitializeAudio+0x2a4>)
 8014900:	f7f9 f863 	bl	800d9ca <GPIO_PinAFConfig>
	GPIO_PinAFConfig(GPIOB, GPIO_PinSource9, GPIO_AF_I2C1);
 8014904:	2204      	movs	r2, #4
 8014906:	2109      	movs	r1, #9
 8014908:	4878      	ldr	r0, [pc, #480]	; (8014aec <InitializeAudio+0x2a4>)
 801490a:	f7f9 f85e 	bl	800d9ca <GPIO_PinAFConfig>

	// Configure I2S MCK, SCK, SD pins.
	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_7 | GPIO_Pin_10 | GPIO_Pin_12;
 801490e:	f44f 53a4 	mov.w	r3, #5248	; 0x1480
 8014912:	617b      	str	r3, [r7, #20]
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
 8014914:	2302      	movs	r3, #2
 8014916:	767b      	strb	r3, [r7, #25]
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
 8014918:	2302      	movs	r3, #2
 801491a:	763b      	strb	r3, [r7, #24]
	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
 801491c:	2300      	movs	r3, #0
 801491e:	76bb      	strb	r3, [r7, #26]
	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
 8014920:	2300      	movs	r3, #0
 8014922:	76fb      	strb	r3, [r7, #27]
	GPIO_Init(GPIOC, &GPIO_InitStructure);
 8014924:	f107 0314 	add.w	r3, r7, #20
 8014928:	4619      	mov	r1, r3
 801492a:	4871      	ldr	r0, [pc, #452]	; (8014af0 <InitializeAudio+0x2a8>)
 801492c:	f7f8 fede 	bl	800d6ec <GPIO_Init>

	GPIO_PinAFConfig(GPIOC, GPIO_PinSource7, GPIO_AF_SPI3);
 8014930:	2206      	movs	r2, #6
 8014932:	2107      	movs	r1, #7
 8014934:	486e      	ldr	r0, [pc, #440]	; (8014af0 <InitializeAudio+0x2a8>)
 8014936:	f7f9 f848 	bl	800d9ca <GPIO_PinAFConfig>
	GPIO_PinAFConfig(GPIOC, GPIO_PinSource10, GPIO_AF_SPI3);
 801493a:	2206      	movs	r2, #6
 801493c:	210a      	movs	r1, #10
 801493e:	486c      	ldr	r0, [pc, #432]	; (8014af0 <InitializeAudio+0x2a8>)
 8014940:	f7f9 f843 	bl	800d9ca <GPIO_PinAFConfig>
	GPIO_PinAFConfig(GPIOC, GPIO_PinSource12, GPIO_AF_SPI3);
 8014944:	2206      	movs	r2, #6
 8014946:	210c      	movs	r1, #12
 8014948:	4869      	ldr	r0, [pc, #420]	; (8014af0 <InitializeAudio+0x2a8>)
 801494a:	f7f9 f83e 	bl	800d9ca <GPIO_PinAFConfig>

	// Configure I2S WS pin.
	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_4;
 801494e:	2310      	movs	r3, #16
 8014950:	617b      	str	r3, [r7, #20]
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
 8014952:	2302      	movs	r3, #2
 8014954:	767b      	strb	r3, [r7, #25]
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
 8014956:	2302      	movs	r3, #2
 8014958:	763b      	strb	r3, [r7, #24]
	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
 801495a:	2300      	movs	r3, #0
 801495c:	76bb      	strb	r3, [r7, #26]
	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
 801495e:	2300      	movs	r3, #0
 8014960:	76fb      	strb	r3, [r7, #27]
	GPIO_Init(GPIOA, &GPIO_InitStructure);
 8014962:	f107 0314 	add.w	r3, r7, #20
 8014966:	4619      	mov	r1, r3
 8014968:	4862      	ldr	r0, [pc, #392]	; (8014af4 <InitializeAudio+0x2ac>)
 801496a:	f7f8 febf 	bl	800d6ec <GPIO_Init>

	GPIO_PinAFConfig(GPIOA, GPIO_PinSource4, GPIO_AF_SPI3);
 801496e:	2206      	movs	r2, #6
 8014970:	2104      	movs	r1, #4
 8014972:	4860      	ldr	r0, [pc, #384]	; (8014af4 <InitializeAudio+0x2ac>)
 8014974:	f7f9 f829 	bl	800d9ca <GPIO_PinAFConfig>

	// Reset the codec.
	GPIOD ->BSRRH = 1 << 4;
 8014978:	4b5b      	ldr	r3, [pc, #364]	; (8014ae8 <InitializeAudio+0x2a0>)
 801497a:	2210      	movs	r2, #16
 801497c:	835a      	strh	r2, [r3, #26]
	for (volatile int i = 0; i < 0x4fff; i++) {
 801497e:	2300      	movs	r3, #0
 8014980:	613b      	str	r3, [r7, #16]
 8014982:	e003      	b.n	801498c <InitializeAudio+0x144>
		__asm__ volatile("nop");
 8014984:	bf00      	nop
	for (volatile int i = 0; i < 0x4fff; i++) {
 8014986:	693b      	ldr	r3, [r7, #16]
 8014988:	3301      	adds	r3, #1
 801498a:	613b      	str	r3, [r7, #16]
 801498c:	693b      	ldr	r3, [r7, #16]
 801498e:	f644 72fe 	movw	r2, #20478	; 0x4ffe
 8014992:	4293      	cmp	r3, r2
 8014994:	ddf6      	ble.n	8014984 <InitializeAudio+0x13c>
	}
	GPIOD ->BSRRL = 1 << 4;
 8014996:	4b54      	ldr	r3, [pc, #336]	; (8014ae8 <InitializeAudio+0x2a0>)
 8014998:	2210      	movs	r2, #16
 801499a:	831a      	strh	r2, [r3, #24]

	// Reset I2C.
	RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C1, ENABLE);
 801499c:	2101      	movs	r1, #1
 801499e:	f44f 1000 	mov.w	r0, #2097152	; 0x200000
 80149a2:	f7fa ffb7 	bl	800f914 <RCC_APB1PeriphResetCmd>
	RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C1, DISABLE);
 80149a6:	2100      	movs	r1, #0
 80149a8:	f44f 1000 	mov.w	r0, #2097152	; 0x200000
 80149ac:	f7fa ffb2 	bl	800f914 <RCC_APB1PeriphResetCmd>

	// Configure I2C.
	uint32_t pclk1 = 42000000;
 80149b0:	4b51      	ldr	r3, [pc, #324]	; (8014af8 <InitializeAudio+0x2b0>)
 80149b2:	623b      	str	r3, [r7, #32]

	I2C1 ->CR2 = pclk1 / 1000000; // Configure frequency and disable interrupts and DMA.
 80149b4:	4a51      	ldr	r2, [pc, #324]	; (8014afc <InitializeAudio+0x2b4>)
 80149b6:	6a3b      	ldr	r3, [r7, #32]
 80149b8:	4951      	ldr	r1, [pc, #324]	; (8014b00 <InitializeAudio+0x2b8>)
 80149ba:	fba1 1303 	umull	r1, r3, r1, r3
 80149be:	0c9b      	lsrs	r3, r3, #18
 80149c0:	b29b      	uxth	r3, r3
 80149c2:	8093      	strh	r3, [r2, #4]
	I2C1 ->OAR1 = I2C_OAR1_ADDMODE | 0x33;
 80149c4:	4b4d      	ldr	r3, [pc, #308]	; (8014afc <InitializeAudio+0x2b4>)
 80149c6:	f248 0233 	movw	r2, #32819	; 0x8033
 80149ca:	811a      	strh	r2, [r3, #8]

	// Configure I2C speed in standard mode.
	const uint32_t i2c_speed = 100000;
 80149cc:	4b4d      	ldr	r3, [pc, #308]	; (8014b04 <InitializeAudio+0x2bc>)
 80149ce:	61fb      	str	r3, [r7, #28]
	int ccrspeed = pclk1 / (i2c_speed * 2);
 80149d0:	69fb      	ldr	r3, [r7, #28]
 80149d2:	005b      	lsls	r3, r3, #1
 80149d4:	6a3a      	ldr	r2, [r7, #32]
 80149d6:	fbb2 f3f3 	udiv	r3, r2, r3
 80149da:	627b      	str	r3, [r7, #36]	; 0x24
	if (ccrspeed < 4) {
 80149dc:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80149de:	2b03      	cmp	r3, #3
 80149e0:	dc01      	bgt.n	80149e6 <InitializeAudio+0x19e>
		ccrspeed = 4;
 80149e2:	2304      	movs	r3, #4
 80149e4:	627b      	str	r3, [r7, #36]	; 0x24
	}
	I2C1 ->CCR = ccrspeed;
 80149e6:	4b45      	ldr	r3, [pc, #276]	; (8014afc <InitializeAudio+0x2b4>)
 80149e8:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 80149ea:	b292      	uxth	r2, r2
 80149ec:	839a      	strh	r2, [r3, #28]
	I2C1 ->TRISE = pclk1 / 1000000 + 1;
 80149ee:	4a43      	ldr	r2, [pc, #268]	; (8014afc <InitializeAudio+0x2b4>)
 80149f0:	6a3b      	ldr	r3, [r7, #32]
 80149f2:	4943      	ldr	r1, [pc, #268]	; (8014b00 <InitializeAudio+0x2b8>)
 80149f4:	fba1 1303 	umull	r1, r3, r1, r3
 80149f8:	0c9b      	lsrs	r3, r3, #18
 80149fa:	b29b      	uxth	r3, r3
 80149fc:	3301      	adds	r3, #1
 80149fe:	b29b      	uxth	r3, r3
 8014a00:	8413      	strh	r3, [r2, #32]

	I2C1 ->CR1 = I2C_CR1_ACK | I2C_CR1_PE; // Enable and configure the I2C peripheral.
 8014a02:	4b3e      	ldr	r3, [pc, #248]	; (8014afc <InitializeAudio+0x2b4>)
 8014a04:	f240 4201 	movw	r2, #1025	; 0x401
 8014a08:	801a      	strh	r2, [r3, #0]

	// Configure codec.
	WriteRegister(0x02, 0x01); // Keep codec powered off.
 8014a0a:	2101      	movs	r1, #1
 8014a0c:	2002      	movs	r0, #2
 8014a0e:	f000 f96d 	bl	8014cec <WriteRegister>
	WriteRegister(0x04, 0xaf); // SPK always off and HP always on.
 8014a12:	21af      	movs	r1, #175	; 0xaf
 8014a14:	2004      	movs	r0, #4
 8014a16:	f000 f969 	bl	8014cec <WriteRegister>

	WriteRegister(0x05, 0x81); // Clock configuration: Auto detection.
 8014a1a:	2181      	movs	r1, #129	; 0x81
 8014a1c:	2005      	movs	r0, #5
 8014a1e:	f000 f965 	bl	8014cec <WriteRegister>
	WriteRegister(0x06, 0x04); // Set slave mode and Philips audio standard.
 8014a22:	2104      	movs	r1, #4
 8014a24:	2006      	movs	r0, #6
 8014a26:	f000 f961 	bl	8014cec <WriteRegister>

	SetAudioVolume(0xff);
 8014a2a:	20ff      	movs	r0, #255	; 0xff
 8014a2c:	f000 f88c 	bl	8014b48 <SetAudioVolume>

	// Power on the codec.
	WriteRegister(0x02, 0x9e);
 8014a30:	219e      	movs	r1, #158	; 0x9e
 8014a32:	2002      	movs	r0, #2
 8014a34:	f000 f95a 	bl	8014cec <WriteRegister>

	// Configure codec for fast shutdown.
	WriteRegister(0x0a, 0x00); // Disable the analog soft ramp.
 8014a38:	2100      	movs	r1, #0
 8014a3a:	200a      	movs	r0, #10
 8014a3c:	f000 f956 	bl	8014cec <WriteRegister>
	WriteRegister(0x0e, 0x04); // Disable the digital soft ramp.
 8014a40:	2104      	movs	r1, #4
 8014a42:	200e      	movs	r0, #14
 8014a44:	f000 f952 	bl	8014cec <WriteRegister>

	WriteRegister(0x27, 0x00); // Disable the limiter attack level.
 8014a48:	2100      	movs	r1, #0
 8014a4a:	2027      	movs	r0, #39	; 0x27
 8014a4c:	f000 f94e 	bl	8014cec <WriteRegister>
	WriteRegister(0x1f, 0x0f); // Adjust bass and treble levels.
 8014a50:	210f      	movs	r1, #15
 8014a52:	201f      	movs	r0, #31
 8014a54:	f000 f94a 	bl	8014cec <WriteRegister>

	WriteRegister(0x1a, 0x0a); // Adjust PCM volume level.
 8014a58:	210a      	movs	r1, #10
 8014a5a:	201a      	movs	r0, #26
 8014a5c:	f000 f946 	bl	8014cec <WriteRegister>
	WriteRegister(0x1b, 0x0a);
 8014a60:	210a      	movs	r1, #10
 8014a62:	201b      	movs	r0, #27
 8014a64:	f000 f942 	bl	8014cec <WriteRegister>

	// Disable I2S.
	SPI3 ->I2SCFGR = 0;
 8014a68:	4b27      	ldr	r3, [pc, #156]	; (8014b08 <InitializeAudio+0x2c0>)
 8014a6a:	2200      	movs	r2, #0
 8014a6c:	839a      	strh	r2, [r3, #28]

	// I2S clock configuration
	RCC ->CFGR &= ~RCC_CFGR_I2SSRC; // PLLI2S clock used as I2S clock source.
 8014a6e:	4a27      	ldr	r2, [pc, #156]	; (8014b0c <InitializeAudio+0x2c4>)
 8014a70:	4b26      	ldr	r3, [pc, #152]	; (8014b0c <InitializeAudio+0x2c4>)
 8014a72:	689b      	ldr	r3, [r3, #8]
 8014a74:	f423 0300 	bic.w	r3, r3, #8388608	; 0x800000
 8014a78:	6093      	str	r3, [r2, #8]
	RCC ->PLLI2SCFGR = (pllr << 28) | (plln << 6);
 8014a7a:	4924      	ldr	r1, [pc, #144]	; (8014b0c <InitializeAudio+0x2c4>)
 8014a7c:	68bb      	ldr	r3, [r7, #8]
 8014a7e:	071a      	lsls	r2, r3, #28
 8014a80:	68fb      	ldr	r3, [r7, #12]
 8014a82:	019b      	lsls	r3, r3, #6
 8014a84:	4313      	orrs	r3, r2
 8014a86:	f8c1 3084 	str.w	r3, [r1, #132]	; 0x84

	// Enable PLLI2S and wait until it is ready.
	RCC ->CR |= RCC_CR_PLLI2SON;
 8014a8a:	4a20      	ldr	r2, [pc, #128]	; (8014b0c <InitializeAudio+0x2c4>)
 8014a8c:	4b1f      	ldr	r3, [pc, #124]	; (8014b0c <InitializeAudio+0x2c4>)
 8014a8e:	681b      	ldr	r3, [r3, #0]
 8014a90:	f043 6380 	orr.w	r3, r3, #67108864	; 0x4000000
 8014a94:	6013      	str	r3, [r2, #0]
	while (!(RCC ->CR & RCC_CR_PLLI2SRDY ))
 8014a96:	bf00      	nop
 8014a98:	4b1c      	ldr	r3, [pc, #112]	; (8014b0c <InitializeAudio+0x2c4>)
 8014a9a:	681b      	ldr	r3, [r3, #0]
 8014a9c:	f003 6300 	and.w	r3, r3, #134217728	; 0x8000000
 8014aa0:	2b00      	cmp	r3, #0
 8014aa2:	d0f9      	beq.n	8014a98 <InitializeAudio+0x250>
		;

	// Configure I2S.
	SPI3 ->I2SPR = i2sdiv | (i2sodd << 8) | SPI_I2SPR_MCKOE;
 8014aa4:	4918      	ldr	r1, [pc, #96]	; (8014b08 <InitializeAudio+0x2c0>)
 8014aa6:	683b      	ldr	r3, [r7, #0]
 8014aa8:	021b      	lsls	r3, r3, #8
 8014aaa:	b21a      	sxth	r2, r3
 8014aac:	687b      	ldr	r3, [r7, #4]
 8014aae:	b21b      	sxth	r3, r3
 8014ab0:	4313      	orrs	r3, r2
 8014ab2:	b21b      	sxth	r3, r3
 8014ab4:	f443 7300 	orr.w	r3, r3, #512	; 0x200
 8014ab8:	b21b      	sxth	r3, r3
 8014aba:	b29b      	uxth	r3, r3
 8014abc:	840b      	strh	r3, [r1, #32]
	SPI3 ->I2SCFGR = SPI_I2SCFGR_I2SMOD | SPI_I2SCFGR_I2SCFG_1
 8014abe:	4b12      	ldr	r3, [pc, #72]	; (8014b08 <InitializeAudio+0x2c0>)
 8014ac0:	f44f 6260 	mov.w	r2, #3584	; 0xe00
 8014ac4:	839a      	strh	r2, [r3, #28]
			| SPI_I2SCFGR_I2SE; // Master transmitter, Phillips mode, 16 bit values, clock polarity low, enable.

}
 8014ac6:	bf00      	nop
 8014ac8:	3728      	adds	r7, #40	; 0x28
 8014aca:	46bd      	mov	sp, r7
 8014acc:	bd80      	pop	{r7, pc}
 8014ace:	bf00      	nop
 8014ad0:	20005dbc 	.word	0x20005dbc
 8014ad4:	20005dc0 	.word	0x20005dc0
 8014ad8:	20005dc4 	.word	0x20005dc4
 8014adc:	20005dc8 	.word	0x20005dc8
 8014ae0:	20005dcc 	.word	0x20005dcc
 8014ae4:	20005dd0 	.word	0x20005dd0
 8014ae8:	40020c00 	.word	0x40020c00
 8014aec:	40020400 	.word	0x40020400
 8014af0:	40020800 	.word	0x40020800
 8014af4:	40020000 	.word	0x40020000
 8014af8:	0280de80 	.word	0x0280de80
 8014afc:	40005400 	.word	0x40005400
 8014b00:	431bde83 	.word	0x431bde83
 8014b04:	000186a0 	.word	0x000186a0
 8014b08:	40003c00 	.word	0x40003c00
 8014b0c:	40023800 	.word	0x40023800

08014b10 <AudioOn>:

void AudioOn() {
 8014b10:	b580      	push	{r7, lr}
 8014b12:	af00      	add	r7, sp, #0
	WriteRegister(0x02, 0x9e);
 8014b14:	219e      	movs	r1, #158	; 0x9e
 8014b16:	2002      	movs	r0, #2
 8014b18:	f000 f8e8 	bl	8014cec <WriteRegister>
	SPI3 ->I2SCFGR = SPI_I2SCFGR_I2SMOD | SPI_I2SCFGR_I2SCFG_1
 8014b1c:	4b02      	ldr	r3, [pc, #8]	; (8014b28 <AudioOn+0x18>)
 8014b1e:	f44f 6260 	mov.w	r2, #3584	; 0xe00
 8014b22:	839a      	strh	r2, [r3, #28]
			| SPI_I2SCFGR_I2SE; // Master transmitter, Phillips mode, 16 bit values, clock polarity low, enable.
}
 8014b24:	bf00      	nop
 8014b26:	bd80      	pop	{r7, pc}
 8014b28:	40003c00 	.word	0x40003c00

08014b2c <AudioOff>:

void AudioOff() {
 8014b2c:	b580      	push	{r7, lr}
 8014b2e:	af00      	add	r7, sp, #0
	WriteRegister(0x02, 0x01);
 8014b30:	2101      	movs	r1, #1
 8014b32:	2002      	movs	r0, #2
 8014b34:	f000 f8da 	bl	8014cec <WriteRegister>
	SPI3 ->I2SCFGR = 0;
 8014b38:	4b02      	ldr	r3, [pc, #8]	; (8014b44 <AudioOff+0x18>)
 8014b3a:	2200      	movs	r2, #0
 8014b3c:	839a      	strh	r2, [r3, #28]
}
 8014b3e:	bf00      	nop
 8014b40:	bd80      	pop	{r7, pc}
 8014b42:	bf00      	nop
 8014b44:	40003c00 	.word	0x40003c00

08014b48 <SetAudioVolume>:

void SetAudioVolume(int volume) {
 8014b48:	b580      	push	{r7, lr}
 8014b4a:	b082      	sub	sp, #8
 8014b4c:	af00      	add	r7, sp, #0
 8014b4e:	6078      	str	r0, [r7, #4]
	WriteRegister(0x20, (volume + 0x19) & 0xff);
 8014b50:	687b      	ldr	r3, [r7, #4]
 8014b52:	b2db      	uxtb	r3, r3
 8014b54:	3319      	adds	r3, #25
 8014b56:	b2db      	uxtb	r3, r3
 8014b58:	4619      	mov	r1, r3
 8014b5a:	2020      	movs	r0, #32
 8014b5c:	f000 f8c6 	bl	8014cec <WriteRegister>
	WriteRegister(0x21, (volume + 0x19) & 0xff);
 8014b60:	687b      	ldr	r3, [r7, #4]
 8014b62:	b2db      	uxtb	r3, r3
 8014b64:	3319      	adds	r3, #25
 8014b66:	b2db      	uxtb	r3, r3
 8014b68:	4619      	mov	r1, r3
 8014b6a:	2021      	movs	r0, #33	; 0x21
 8014b6c:	f000 f8be 	bl	8014cec <WriteRegister>
}
 8014b70:	bf00      	nop
 8014b72:	3708      	adds	r7, #8
 8014b74:	46bd      	mov	sp, r7
 8014b76:	bd80      	pop	{r7, pc}

08014b78 <OutputAudioSample>:

void OutputAudioSample(int16_t sample) {
 8014b78:	b480      	push	{r7}
 8014b7a:	b083      	sub	sp, #12
 8014b7c:	af00      	add	r7, sp, #0
 8014b7e:	4603      	mov	r3, r0
 8014b80:	80fb      	strh	r3, [r7, #6]
	while (!(SPI3 ->SR & SPI_SR_TXE ))
 8014b82:	bf00      	nop
 8014b84:	4b07      	ldr	r3, [pc, #28]	; (8014ba4 <OutputAudioSample+0x2c>)
 8014b86:	891b      	ldrh	r3, [r3, #8]
 8014b88:	b29b      	uxth	r3, r3
 8014b8a:	f003 0302 	and.w	r3, r3, #2
 8014b8e:	2b00      	cmp	r3, #0
 8014b90:	d0f8      	beq.n	8014b84 <OutputAudioSample+0xc>
		;
	SPI3 ->DR = sample;
 8014b92:	4b04      	ldr	r3, [pc, #16]	; (8014ba4 <OutputAudioSample+0x2c>)
 8014b94:	88fa      	ldrh	r2, [r7, #6]
 8014b96:	819a      	strh	r2, [r3, #12]
}
 8014b98:	bf00      	nop
 8014b9a:	370c      	adds	r7, #12
 8014b9c:	46bd      	mov	sp, r7
 8014b9e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8014ba2:	4770      	bx	lr
 8014ba4:	40003c00 	.word	0x40003c00

08014ba8 <OutputAudioSampleWithoutBlocking>:

void OutputAudioSampleWithoutBlocking(int16_t sample) {
 8014ba8:	b480      	push	{r7}
 8014baa:	b083      	sub	sp, #12
 8014bac:	af00      	add	r7, sp, #0
 8014bae:	4603      	mov	r3, r0
 8014bb0:	80fb      	strh	r3, [r7, #6]
	SPI3 ->DR = sample;
 8014bb2:	4b04      	ldr	r3, [pc, #16]	; (8014bc4 <OutputAudioSampleWithoutBlocking+0x1c>)
 8014bb4:	88fa      	ldrh	r2, [r7, #6]
 8014bb6:	819a      	strh	r2, [r3, #12]
}
 8014bb8:	bf00      	nop
 8014bba:	370c      	adds	r7, #12
 8014bbc:	46bd      	mov	sp, r7
 8014bbe:	f85d 7b04 	ldr.w	r7, [sp], #4
 8014bc2:	4770      	bx	lr
 8014bc4:	40003c00 	.word	0x40003c00

08014bc8 <PlayAudioWithCallback>:

void PlayAudioWithCallback(AudioCallbackFunction *callback, void *context) {
 8014bc8:	b580      	push	{r7, lr}
 8014bca:	b082      	sub	sp, #8
 8014bcc:	af00      	add	r7, sp, #0
 8014bce:	6078      	str	r0, [r7, #4]
 8014bd0:	6039      	str	r1, [r7, #0]
	StopAudioDMA();
 8014bd2:	f000 f927 	bl	8014e24 <StopAudioDMA>

	NVIC_EnableIRQ(DMA1_Stream7_IRQn);
 8014bd6:	202f      	movs	r0, #47	; 0x2f
 8014bd8:	f7ff fdd8 	bl	801478c <NVIC_EnableIRQ>
	NVIC_SetPriority(DMA1_Stream7_IRQn, 4);
 8014bdc:	2104      	movs	r1, #4
 8014bde:	202f      	movs	r0, #47	; 0x2f
 8014be0:	f7ff fe08 	bl	80147f4 <NVIC_SetPriority>

	SPI3 ->CR2 |= SPI_CR2_TXDMAEN; // Enable I2S TX DMA request.
 8014be4:	4a10      	ldr	r2, [pc, #64]	; (8014c28 <PlayAudioWithCallback+0x60>)
 8014be6:	4b10      	ldr	r3, [pc, #64]	; (8014c28 <PlayAudioWithCallback+0x60>)
 8014be8:	889b      	ldrh	r3, [r3, #4]
 8014bea:	b29b      	uxth	r3, r3
 8014bec:	f043 0302 	orr.w	r3, r3, #2
 8014bf0:	b29b      	uxth	r3, r3
 8014bf2:	8093      	strh	r3, [r2, #4]

	CallbackFunction = callback;
 8014bf4:	4a0d      	ldr	r2, [pc, #52]	; (8014c2c <PlayAudioWithCallback+0x64>)
 8014bf6:	687b      	ldr	r3, [r7, #4]
 8014bf8:	6013      	str	r3, [r2, #0]
	CallbackContext = context;
 8014bfa:	4a0d      	ldr	r2, [pc, #52]	; (8014c30 <PlayAudioWithCallback+0x68>)
 8014bfc:	683b      	ldr	r3, [r7, #0]
 8014bfe:	6013      	str	r3, [r2, #0]
	BufferNumber = 0;
 8014c00:	4b0c      	ldr	r3, [pc, #48]	; (8014c34 <PlayAudioWithCallback+0x6c>)
 8014c02:	2200      	movs	r2, #0
 8014c04:	601a      	str	r2, [r3, #0]

	if (CallbackFunction)
 8014c06:	4b09      	ldr	r3, [pc, #36]	; (8014c2c <PlayAudioWithCallback+0x64>)
 8014c08:	681b      	ldr	r3, [r3, #0]
 8014c0a:	2b00      	cmp	r3, #0
 8014c0c:	d007      	beq.n	8014c1e <PlayAudioWithCallback+0x56>
		CallbackFunction(CallbackContext, BufferNumber);
 8014c0e:	4b07      	ldr	r3, [pc, #28]	; (8014c2c <PlayAudioWithCallback+0x64>)
 8014c10:	681b      	ldr	r3, [r3, #0]
 8014c12:	4a07      	ldr	r2, [pc, #28]	; (8014c30 <PlayAudioWithCallback+0x68>)
 8014c14:	6810      	ldr	r0, [r2, #0]
 8014c16:	4a07      	ldr	r2, [pc, #28]	; (8014c34 <PlayAudioWithCallback+0x6c>)
 8014c18:	6812      	ldr	r2, [r2, #0]
 8014c1a:	4611      	mov	r1, r2
 8014c1c:	4798      	blx	r3
}
 8014c1e:	bf00      	nop
 8014c20:	3708      	adds	r7, #8
 8014c22:	46bd      	mov	sp, r7
 8014c24:	bd80      	pop	{r7, pc}
 8014c26:	bf00      	nop
 8014c28:	40003c00 	.word	0x40003c00
 8014c2c:	20005dbc 	.word	0x20005dbc
 8014c30:	20005dc0 	.word	0x20005dc0
 8014c34:	20005dcc 	.word	0x20005dcc

08014c38 <StopAudio>:

void StopAudio() {
 8014c38:	b580      	push	{r7, lr}
 8014c3a:	af00      	add	r7, sp, #0
	StopAudioDMA();
 8014c3c:	f000 f8f2 	bl	8014e24 <StopAudioDMA>
	SPI3 ->CR2 &= ~SPI_CR2_TXDMAEN; // Disable I2S TX DMA request.
 8014c40:	4a07      	ldr	r2, [pc, #28]	; (8014c60 <StopAudio+0x28>)
 8014c42:	4b07      	ldr	r3, [pc, #28]	; (8014c60 <StopAudio+0x28>)
 8014c44:	889b      	ldrh	r3, [r3, #4]
 8014c46:	b29b      	uxth	r3, r3
 8014c48:	f023 0302 	bic.w	r3, r3, #2
 8014c4c:	b29b      	uxth	r3, r3
 8014c4e:	8093      	strh	r3, [r2, #4]
	NVIC_DisableIRQ(DMA1_Stream7_IRQn);
 8014c50:	202f      	movs	r0, #47	; 0x2f
 8014c52:	f7ff fdb5 	bl	80147c0 <NVIC_DisableIRQ>
	CallbackFunction = NULL;
 8014c56:	4b03      	ldr	r3, [pc, #12]	; (8014c64 <StopAudio+0x2c>)
 8014c58:	2200      	movs	r2, #0
 8014c5a:	601a      	str	r2, [r3, #0]
}
 8014c5c:	bf00      	nop
 8014c5e:	bd80      	pop	{r7, pc}
 8014c60:	40003c00 	.word	0x40003c00
 8014c64:	20005dbc 	.word	0x20005dbc

08014c68 <ProvideAudioBuffer>:

void ProvideAudioBuffer(void *samples, int numsamples) {
 8014c68:	b580      	push	{r7, lr}
 8014c6a:	b082      	sub	sp, #8
 8014c6c:	af00      	add	r7, sp, #0
 8014c6e:	6078      	str	r0, [r7, #4]
 8014c70:	6039      	str	r1, [r7, #0]
	while (!ProvideAudioBufferWithoutBlocking(samples, numsamples))
 8014c72:	e000      	b.n	8014c76 <ProvideAudioBuffer+0xe>
		__asm__ volatile ("wfi");
 8014c74:	bf30      	wfi
	while (!ProvideAudioBufferWithoutBlocking(samples, numsamples))
 8014c76:	6839      	ldr	r1, [r7, #0]
 8014c78:	6878      	ldr	r0, [r7, #4]
 8014c7a:	f000 f80a 	bl	8014c92 <ProvideAudioBufferWithoutBlocking>
 8014c7e:	4603      	mov	r3, r0
 8014c80:	f083 0301 	eor.w	r3, r3, #1
 8014c84:	b2db      	uxtb	r3, r3
 8014c86:	2b00      	cmp	r3, #0
 8014c88:	d1f4      	bne.n	8014c74 <ProvideAudioBuffer+0xc>
}
 8014c8a:	bf00      	nop
 8014c8c:	3708      	adds	r7, #8
 8014c8e:	46bd      	mov	sp, r7
 8014c90:	bd80      	pop	{r7, pc}

08014c92 <ProvideAudioBufferWithoutBlocking>:

bool ProvideAudioBufferWithoutBlocking(void *samples, int numsamples) {
 8014c92:	b580      	push	{r7, lr}
 8014c94:	b082      	sub	sp, #8
 8014c96:	af00      	add	r7, sp, #0
 8014c98:	6078      	str	r0, [r7, #4]
 8014c9a:	6039      	str	r1, [r7, #0]
	if (NextBufferSamples)
 8014c9c:	4b10      	ldr	r3, [pc, #64]	; (8014ce0 <ProvideAudioBufferWithoutBlocking+0x4e>)
 8014c9e:	681b      	ldr	r3, [r3, #0]
 8014ca0:	2b00      	cmp	r3, #0
 8014ca2:	d001      	beq.n	8014ca8 <ProvideAudioBufferWithoutBlocking+0x16>
		return false;
 8014ca4:	2300      	movs	r3, #0
 8014ca6:	e016      	b.n	8014cd6 <ProvideAudioBufferWithoutBlocking+0x44>

	NVIC_DisableIRQ(DMA1_Stream7_IRQn);
 8014ca8:	202f      	movs	r0, #47	; 0x2f
 8014caa:	f7ff fd89 	bl	80147c0 <NVIC_DisableIRQ>

	NextBufferSamples = samples;
 8014cae:	4a0c      	ldr	r2, [pc, #48]	; (8014ce0 <ProvideAudioBufferWithoutBlocking+0x4e>)
 8014cb0:	687b      	ldr	r3, [r7, #4]
 8014cb2:	6013      	str	r3, [r2, #0]
	NextBufferLength = numsamples;
 8014cb4:	4a0b      	ldr	r2, [pc, #44]	; (8014ce4 <ProvideAudioBufferWithoutBlocking+0x52>)
 8014cb6:	683b      	ldr	r3, [r7, #0]
 8014cb8:	6013      	str	r3, [r2, #0]

	if (!DMARunning)
 8014cba:	4b0b      	ldr	r3, [pc, #44]	; (8014ce8 <ProvideAudioBufferWithoutBlocking+0x56>)
 8014cbc:	781b      	ldrb	r3, [r3, #0]
 8014cbe:	b2db      	uxtb	r3, r3
 8014cc0:	f083 0301 	eor.w	r3, r3, #1
 8014cc4:	b2db      	uxtb	r3, r3
 8014cc6:	2b00      	cmp	r3, #0
 8014cc8:	d001      	beq.n	8014cce <ProvideAudioBufferWithoutBlocking+0x3c>
		StartAudioDMAAndRequestBuffers();
 8014cca:	f000 f865 	bl	8014d98 <StartAudioDMAAndRequestBuffers>

	NVIC_EnableIRQ(DMA1_Stream7_IRQn);
 8014cce:	202f      	movs	r0, #47	; 0x2f
 8014cd0:	f7ff fd5c 	bl	801478c <NVIC_EnableIRQ>

	return true;
 8014cd4:	2301      	movs	r3, #1
}
 8014cd6:	4618      	mov	r0, r3
 8014cd8:	3708      	adds	r7, #8
 8014cda:	46bd      	mov	sp, r7
 8014cdc:	bd80      	pop	{r7, pc}
 8014cde:	bf00      	nop
 8014ce0:	20005dc4 	.word	0x20005dc4
 8014ce4:	20005dc8 	.word	0x20005dc8
 8014ce8:	20005dd0 	.word	0x20005dd0

08014cec <WriteRegister>:

static void WriteRegister(uint8_t address, uint8_t value) {
 8014cec:	b480      	push	{r7}
 8014cee:	b083      	sub	sp, #12
 8014cf0:	af00      	add	r7, sp, #0
 8014cf2:	4603      	mov	r3, r0
 8014cf4:	460a      	mov	r2, r1
 8014cf6:	71fb      	strb	r3, [r7, #7]
 8014cf8:	4613      	mov	r3, r2
 8014cfa:	71bb      	strb	r3, [r7, #6]
	while (I2C1 ->SR2 & I2C_SR2_BUSY )
 8014cfc:	bf00      	nop
 8014cfe:	4b25      	ldr	r3, [pc, #148]	; (8014d94 <WriteRegister+0xa8>)
 8014d00:	8b1b      	ldrh	r3, [r3, #24]
 8014d02:	b29b      	uxth	r3, r3
 8014d04:	f003 0302 	and.w	r3, r3, #2
 8014d08:	2b00      	cmp	r3, #0
 8014d0a:	d1f8      	bne.n	8014cfe <WriteRegister+0x12>
		;

	I2C1 ->CR1 |= I2C_CR1_START; // Start the transfer sequence.
 8014d0c:	4a21      	ldr	r2, [pc, #132]	; (8014d94 <WriteRegister+0xa8>)
 8014d0e:	4b21      	ldr	r3, [pc, #132]	; (8014d94 <WriteRegister+0xa8>)
 8014d10:	881b      	ldrh	r3, [r3, #0]
 8014d12:	b29b      	uxth	r3, r3
 8014d14:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 8014d18:	b29b      	uxth	r3, r3
 8014d1a:	8013      	strh	r3, [r2, #0]
	while (!(I2C1 ->SR1 & I2C_SR1_SB ))
 8014d1c:	bf00      	nop
 8014d1e:	4b1d      	ldr	r3, [pc, #116]	; (8014d94 <WriteRegister+0xa8>)
 8014d20:	8a9b      	ldrh	r3, [r3, #20]
 8014d22:	b29b      	uxth	r3, r3
 8014d24:	f003 0301 	and.w	r3, r3, #1
 8014d28:	2b00      	cmp	r3, #0
 8014d2a:	d0f8      	beq.n	8014d1e <WriteRegister+0x32>
		; // Wait for start bit.

	I2C1 ->DR = 0x94;
 8014d2c:	4b19      	ldr	r3, [pc, #100]	; (8014d94 <WriteRegister+0xa8>)
 8014d2e:	2294      	movs	r2, #148	; 0x94
 8014d30:	821a      	strh	r2, [r3, #16]
	while (!(I2C1 ->SR1 & I2C_SR1_ADDR ))
 8014d32:	bf00      	nop
 8014d34:	4b17      	ldr	r3, [pc, #92]	; (8014d94 <WriteRegister+0xa8>)
 8014d36:	8a9b      	ldrh	r3, [r3, #20]
 8014d38:	b29b      	uxth	r3, r3
 8014d3a:	f003 0302 	and.w	r3, r3, #2
 8014d3e:	2b00      	cmp	r3, #0
 8014d40:	d0f8      	beq.n	8014d34 <WriteRegister+0x48>
		; // Wait for master transmitter mode.
	I2C1 ->SR2;
 8014d42:	4b14      	ldr	r3, [pc, #80]	; (8014d94 <WriteRegister+0xa8>)
 8014d44:	8b1b      	ldrh	r3, [r3, #24]

	I2C1 ->DR = address; // Transmit the address to write to.
 8014d46:	4b13      	ldr	r3, [pc, #76]	; (8014d94 <WriteRegister+0xa8>)
 8014d48:	79fa      	ldrb	r2, [r7, #7]
 8014d4a:	b292      	uxth	r2, r2
 8014d4c:	821a      	strh	r2, [r3, #16]
	while (!(I2C1 ->SR1 & I2C_SR1_TXE ))
 8014d4e:	bf00      	nop
 8014d50:	4b10      	ldr	r3, [pc, #64]	; (8014d94 <WriteRegister+0xa8>)
 8014d52:	8a9b      	ldrh	r3, [r3, #20]
 8014d54:	b29b      	uxth	r3, r3
 8014d56:	f003 0380 	and.w	r3, r3, #128	; 0x80
 8014d5a:	2b00      	cmp	r3, #0
 8014d5c:	d0f8      	beq.n	8014d50 <WriteRegister+0x64>
		; // Wait for byte to move to shift register.

	I2C1 ->DR = value; // Transmit the value.
 8014d5e:	4b0d      	ldr	r3, [pc, #52]	; (8014d94 <WriteRegister+0xa8>)
 8014d60:	79ba      	ldrb	r2, [r7, #6]
 8014d62:	b292      	uxth	r2, r2
 8014d64:	821a      	strh	r2, [r3, #16]

	while (!(I2C1 ->SR1 & I2C_SR1_BTF ))
 8014d66:	bf00      	nop
 8014d68:	4b0a      	ldr	r3, [pc, #40]	; (8014d94 <WriteRegister+0xa8>)
 8014d6a:	8a9b      	ldrh	r3, [r3, #20]
 8014d6c:	b29b      	uxth	r3, r3
 8014d6e:	f003 0304 	and.w	r3, r3, #4
 8014d72:	2b00      	cmp	r3, #0
 8014d74:	d0f8      	beq.n	8014d68 <WriteRegister+0x7c>
		; // Wait for all bytes to finish.
	I2C1 ->CR1 |= I2C_CR1_STOP; // End the transfer sequence.
 8014d76:	4a07      	ldr	r2, [pc, #28]	; (8014d94 <WriteRegister+0xa8>)
 8014d78:	4b06      	ldr	r3, [pc, #24]	; (8014d94 <WriteRegister+0xa8>)
 8014d7a:	881b      	ldrh	r3, [r3, #0]
 8014d7c:	b29b      	uxth	r3, r3
 8014d7e:	f443 7300 	orr.w	r3, r3, #512	; 0x200
 8014d82:	b29b      	uxth	r3, r3
 8014d84:	8013      	strh	r3, [r2, #0]
}
 8014d86:	bf00      	nop
 8014d88:	370c      	adds	r7, #12
 8014d8a:	46bd      	mov	sp, r7
 8014d8c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8014d90:	4770      	bx	lr
 8014d92:	bf00      	nop
 8014d94:	40005400 	.word	0x40005400

08014d98 <StartAudioDMAAndRequestBuffers>:

static void StartAudioDMAAndRequestBuffers() {
 8014d98:	b580      	push	{r7, lr}
 8014d9a:	af00      	add	r7, sp, #0
	// Configure DMA stream.
	DMA1_Stream7 ->CR = (0 * DMA_SxCR_CHSEL_0 ) | // Channel 0
 8014d9c:	4b18      	ldr	r3, [pc, #96]	; (8014e00 <StartAudioDMAAndRequestBuffers+0x68>)
 8014d9e:	4a19      	ldr	r2, [pc, #100]	; (8014e04 <StartAudioDMAAndRequestBuffers+0x6c>)
 8014da0:	601a      	str	r2, [r3, #0]
			(1 * DMA_SxCR_PSIZE_0 ) | // PSIZE = 16 bit
			(1 * DMA_SxCR_MSIZE_0 ) | // MSIZE = 16 bit
			DMA_SxCR_MINC | // Increase memory address
			(1 * DMA_SxCR_DIR_0 ) | // Memory to peripheral
			DMA_SxCR_TCIE; // Transfer complete interrupt
	DMA1_Stream7 ->NDTR = NextBufferLength;
 8014da2:	4b17      	ldr	r3, [pc, #92]	; (8014e00 <StartAudioDMAAndRequestBuffers+0x68>)
 8014da4:	4a18      	ldr	r2, [pc, #96]	; (8014e08 <StartAudioDMAAndRequestBuffers+0x70>)
 8014da6:	6812      	ldr	r2, [r2, #0]
 8014da8:	605a      	str	r2, [r3, #4]
	DMA1_Stream7 ->PAR = (uint32_t) &SPI3 ->DR;
 8014daa:	4b15      	ldr	r3, [pc, #84]	; (8014e00 <StartAudioDMAAndRequestBuffers+0x68>)
 8014dac:	4a17      	ldr	r2, [pc, #92]	; (8014e0c <StartAudioDMAAndRequestBuffers+0x74>)
 8014dae:	609a      	str	r2, [r3, #8]
	DMA1_Stream7 ->M0AR = (uint32_t) NextBufferSamples;
 8014db0:	4b13      	ldr	r3, [pc, #76]	; (8014e00 <StartAudioDMAAndRequestBuffers+0x68>)
 8014db2:	4a17      	ldr	r2, [pc, #92]	; (8014e10 <StartAudioDMAAndRequestBuffers+0x78>)
 8014db4:	6812      	ldr	r2, [r2, #0]
 8014db6:	60da      	str	r2, [r3, #12]
	DMA1_Stream7 ->FCR = DMA_SxFCR_DMDIS;
 8014db8:	4b11      	ldr	r3, [pc, #68]	; (8014e00 <StartAudioDMAAndRequestBuffers+0x68>)
 8014dba:	2204      	movs	r2, #4
 8014dbc:	615a      	str	r2, [r3, #20]
	DMA1_Stream7 ->CR |= DMA_SxCR_EN;
 8014dbe:	4a10      	ldr	r2, [pc, #64]	; (8014e00 <StartAudioDMAAndRequestBuffers+0x68>)
 8014dc0:	4b0f      	ldr	r3, [pc, #60]	; (8014e00 <StartAudioDMAAndRequestBuffers+0x68>)
 8014dc2:	681b      	ldr	r3, [r3, #0]
 8014dc4:	f043 0301 	orr.w	r3, r3, #1
 8014dc8:	6013      	str	r3, [r2, #0]

	// Update state.
	NextBufferSamples = NULL;
 8014dca:	4b11      	ldr	r3, [pc, #68]	; (8014e10 <StartAudioDMAAndRequestBuffers+0x78>)
 8014dcc:	2200      	movs	r2, #0
 8014dce:	601a      	str	r2, [r3, #0]
	BufferNumber ^= 1;
 8014dd0:	4b10      	ldr	r3, [pc, #64]	; (8014e14 <StartAudioDMAAndRequestBuffers+0x7c>)
 8014dd2:	681b      	ldr	r3, [r3, #0]
 8014dd4:	f083 0301 	eor.w	r3, r3, #1
 8014dd8:	4a0e      	ldr	r2, [pc, #56]	; (8014e14 <StartAudioDMAAndRequestBuffers+0x7c>)
 8014dda:	6013      	str	r3, [r2, #0]
	DMARunning = true;
 8014ddc:	4b0e      	ldr	r3, [pc, #56]	; (8014e18 <StartAudioDMAAndRequestBuffers+0x80>)
 8014dde:	2201      	movs	r2, #1
 8014de0:	701a      	strb	r2, [r3, #0]

	// Invoke callback if it exists to queue up another buffer.
	if (CallbackFunction)
 8014de2:	4b0e      	ldr	r3, [pc, #56]	; (8014e1c <StartAudioDMAAndRequestBuffers+0x84>)
 8014de4:	681b      	ldr	r3, [r3, #0]
 8014de6:	2b00      	cmp	r3, #0
 8014de8:	d007      	beq.n	8014dfa <StartAudioDMAAndRequestBuffers+0x62>
		CallbackFunction(CallbackContext, BufferNumber);
 8014dea:	4b0c      	ldr	r3, [pc, #48]	; (8014e1c <StartAudioDMAAndRequestBuffers+0x84>)
 8014dec:	681b      	ldr	r3, [r3, #0]
 8014dee:	4a0c      	ldr	r2, [pc, #48]	; (8014e20 <StartAudioDMAAndRequestBuffers+0x88>)
 8014df0:	6810      	ldr	r0, [r2, #0]
 8014df2:	4a08      	ldr	r2, [pc, #32]	; (8014e14 <StartAudioDMAAndRequestBuffers+0x7c>)
 8014df4:	6812      	ldr	r2, [r2, #0]
 8014df6:	4611      	mov	r1, r2
 8014df8:	4798      	blx	r3
}
 8014dfa:	bf00      	nop
 8014dfc:	bd80      	pop	{r7, pc}
 8014dfe:	bf00      	nop
 8014e00:	400260b8 	.word	0x400260b8
 8014e04:	00012c50 	.word	0x00012c50
 8014e08:	20005dc8 	.word	0x20005dc8
 8014e0c:	40003c0c 	.word	0x40003c0c
 8014e10:	20005dc4 	.word	0x20005dc4
 8014e14:	20005dcc 	.word	0x20005dcc
 8014e18:	20005dd0 	.word	0x20005dd0
 8014e1c:	20005dbc 	.word	0x20005dbc
 8014e20:	20005dc0 	.word	0x20005dc0

08014e24 <StopAudioDMA>:

static void StopAudioDMA() {
 8014e24:	b480      	push	{r7}
 8014e26:	af00      	add	r7, sp, #0
	DMA1_Stream7 ->CR &= ~DMA_SxCR_EN; // Disable DMA stream.
 8014e28:	4a0a      	ldr	r2, [pc, #40]	; (8014e54 <StopAudioDMA+0x30>)
 8014e2a:	4b0a      	ldr	r3, [pc, #40]	; (8014e54 <StopAudioDMA+0x30>)
 8014e2c:	681b      	ldr	r3, [r3, #0]
 8014e2e:	f023 0301 	bic.w	r3, r3, #1
 8014e32:	6013      	str	r3, [r2, #0]
	while (DMA1_Stream7 ->CR & DMA_SxCR_EN )
 8014e34:	bf00      	nop
 8014e36:	4b07      	ldr	r3, [pc, #28]	; (8014e54 <StopAudioDMA+0x30>)
 8014e38:	681b      	ldr	r3, [r3, #0]
 8014e3a:	f003 0301 	and.w	r3, r3, #1
 8014e3e:	2b00      	cmp	r3, #0
 8014e40:	d1f9      	bne.n	8014e36 <StopAudioDMA+0x12>
		; // Wait for DMA stream to stop.

	DMARunning = false;
 8014e42:	4b05      	ldr	r3, [pc, #20]	; (8014e58 <StopAudioDMA+0x34>)
 8014e44:	2200      	movs	r2, #0
 8014e46:	701a      	strb	r2, [r3, #0]
}
 8014e48:	bf00      	nop
 8014e4a:	46bd      	mov	sp, r7
 8014e4c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8014e50:	4770      	bx	lr
 8014e52:	bf00      	nop
 8014e54:	400260b8 	.word	0x400260b8
 8014e58:	20005dd0 	.word	0x20005dd0

08014e5c <DMA1_Stream7_IRQHandler>:

void DMA1_Stream7_IRQHandler() {
 8014e5c:	b580      	push	{r7, lr}
 8014e5e:	af00      	add	r7, sp, #0
	DMA1 ->HIFCR |= DMA_HIFCR_CTCIF7; // Clear interrupt flag.
 8014e60:	4a08      	ldr	r2, [pc, #32]	; (8014e84 <DMA1_Stream7_IRQHandler+0x28>)
 8014e62:	4b08      	ldr	r3, [pc, #32]	; (8014e84 <DMA1_Stream7_IRQHandler+0x28>)
 8014e64:	68db      	ldr	r3, [r3, #12]
 8014e66:	f043 6300 	orr.w	r3, r3, #134217728	; 0x8000000
 8014e6a:	60d3      	str	r3, [r2, #12]

	if (NextBufferSamples) {
 8014e6c:	4b06      	ldr	r3, [pc, #24]	; (8014e88 <DMA1_Stream7_IRQHandler+0x2c>)
 8014e6e:	681b      	ldr	r3, [r3, #0]
 8014e70:	2b00      	cmp	r3, #0
 8014e72:	d002      	beq.n	8014e7a <DMA1_Stream7_IRQHandler+0x1e>
		StartAudioDMAAndRequestBuffers();
 8014e74:	f7ff ff90 	bl	8014d98 <StartAudioDMAAndRequestBuffers>
	} else {
		DMARunning = false;
	}
}
 8014e78:	e002      	b.n	8014e80 <DMA1_Stream7_IRQHandler+0x24>
		DMARunning = false;
 8014e7a:	4b04      	ldr	r3, [pc, #16]	; (8014e8c <DMA1_Stream7_IRQHandler+0x30>)
 8014e7c:	2200      	movs	r2, #0
 8014e7e:	701a      	strb	r2, [r3, #0]
}
 8014e80:	bf00      	nop
 8014e82:	bd80      	pop	{r7, pc}
 8014e84:	40026000 	.word	0x40026000
 8014e88:	20005dc4 	.word	0x20005dc4
 8014e8c:	20005dd0 	.word	0x20005dd0

08014e90 <NVIC_SetPriority>:
{
 8014e90:	b480      	push	{r7}
 8014e92:	b083      	sub	sp, #12
 8014e94:	af00      	add	r7, sp, #0
 8014e96:	4603      	mov	r3, r0
 8014e98:	6039      	str	r1, [r7, #0]
 8014e9a:	71fb      	strb	r3, [r7, #7]
  if(IRQn < 0) {
 8014e9c:	f997 3007 	ldrsb.w	r3, [r7, #7]
 8014ea0:	2b00      	cmp	r3, #0
 8014ea2:	da0b      	bge.n	8014ebc <NVIC_SetPriority+0x2c>
    SCB->SHP[((uint32_t)(IRQn) & 0xF)-4] = ((priority << (8 - __NVIC_PRIO_BITS)) & 0xff); } /* set Priority for Cortex-M  System Interrupts */
 8014ea4:	490d      	ldr	r1, [pc, #52]	; (8014edc <NVIC_SetPriority+0x4c>)
 8014ea6:	79fb      	ldrb	r3, [r7, #7]
 8014ea8:	f003 030f 	and.w	r3, r3, #15
 8014eac:	3b04      	subs	r3, #4
 8014eae:	683a      	ldr	r2, [r7, #0]
 8014eb0:	b2d2      	uxtb	r2, r2
 8014eb2:	0112      	lsls	r2, r2, #4
 8014eb4:	b2d2      	uxtb	r2, r2
 8014eb6:	440b      	add	r3, r1
 8014eb8:	761a      	strb	r2, [r3, #24]
}
 8014eba:	e009      	b.n	8014ed0 <NVIC_SetPriority+0x40>
    NVIC->IP[(uint32_t)(IRQn)] = ((priority << (8 - __NVIC_PRIO_BITS)) & 0xff);    }        /* set Priority for device specific Interrupts  */
 8014ebc:	4908      	ldr	r1, [pc, #32]	; (8014ee0 <NVIC_SetPriority+0x50>)
 8014ebe:	f997 3007 	ldrsb.w	r3, [r7, #7]
 8014ec2:	683a      	ldr	r2, [r7, #0]
 8014ec4:	b2d2      	uxtb	r2, r2
 8014ec6:	0112      	lsls	r2, r2, #4
 8014ec8:	b2d2      	uxtb	r2, r2
 8014eca:	440b      	add	r3, r1
 8014ecc:	f883 2300 	strb.w	r2, [r3, #768]	; 0x300
}
 8014ed0:	bf00      	nop
 8014ed2:	370c      	adds	r7, #12
 8014ed4:	46bd      	mov	sp, r7
 8014ed6:	f85d 7b04 	ldr.w	r7, [sp], #4
 8014eda:	4770      	bx	lr
 8014edc:	e000ed00 	.word	0xe000ed00
 8014ee0:	e000e100 	.word	0xe000e100

08014ee4 <SysTick_Config>:
    \param [in]  ticks  Number of ticks between two interrupts
    \return          0  Function succeeded
    \return          1  Function failed
 */
static __INLINE uint32_t SysTick_Config(uint32_t ticks)
{
 8014ee4:	b580      	push	{r7, lr}
 8014ee6:	b082      	sub	sp, #8
 8014ee8:	af00      	add	r7, sp, #0
 8014eea:	6078      	str	r0, [r7, #4]
  if (ticks > SysTick_LOAD_RELOAD_Msk)  return (1);            /* Reload value impossible */
 8014eec:	687b      	ldr	r3, [r7, #4]
 8014eee:	f1b3 7f80 	cmp.w	r3, #16777216	; 0x1000000
 8014ef2:	d301      	bcc.n	8014ef8 <SysTick_Config+0x14>
 8014ef4:	2301      	movs	r3, #1
 8014ef6:	e011      	b.n	8014f1c <SysTick_Config+0x38>

  SysTick->LOAD  = (ticks & SysTick_LOAD_RELOAD_Msk) - 1;      /* set reload register */
 8014ef8:	4a0a      	ldr	r2, [pc, #40]	; (8014f24 <SysTick_Config+0x40>)
 8014efa:	687b      	ldr	r3, [r7, #4]
 8014efc:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
 8014f00:	3b01      	subs	r3, #1
 8014f02:	6053      	str	r3, [r2, #4]
  NVIC_SetPriority (SysTick_IRQn, (1<<__NVIC_PRIO_BITS) - 1);  /* set Priority for Cortex-M0 System Interrupts */
 8014f04:	210f      	movs	r1, #15
 8014f06:	f04f 30ff 	mov.w	r0, #4294967295
 8014f0a:	f7ff ffc1 	bl	8014e90 <NVIC_SetPriority>
  SysTick->VAL   = 0;                                          /* Load the SysTick Counter Value */
 8014f0e:	4b05      	ldr	r3, [pc, #20]	; (8014f24 <SysTick_Config+0x40>)
 8014f10:	2200      	movs	r2, #0
 8014f12:	609a      	str	r2, [r3, #8]
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
 8014f14:	4b03      	ldr	r3, [pc, #12]	; (8014f24 <SysTick_Config+0x40>)
 8014f16:	2207      	movs	r2, #7
 8014f18:	601a      	str	r2, [r3, #0]
                   SysTick_CTRL_TICKINT_Msk   |
                   SysTick_CTRL_ENABLE_Msk;                    /* Enable SysTick IRQ and SysTick Timer */
  return (0);                                                  /* Function successful */
 8014f1a:	2300      	movs	r3, #0
}
 8014f1c:	4618      	mov	r0, r3
 8014f1e:	3708      	adds	r7, #8
 8014f20:	46bd      	mov	sp, r7
 8014f22:	bd80      	pop	{r7, pc}
 8014f24:	e000e010 	.word	0xe000e010

08014f28 <main>:

// Some macros
#define MP3_SIZE	332107
#define BUTTON		(GPIOA->IDR & GPIO_Pin_0)

int main(void) {
 8014f28:	b580      	push	{r7, lr}
 8014f2a:	b082      	sub	sp, #8
 8014f2c:	af00      	add	r7, sp, #0
	init();
 8014f2e:	f000 f8d1 	bl	80150d4 <init>
	int volume = 0;
 8014f32:	2300      	movs	r3, #0
 8014f34:	607b      	str	r3, [r7, #4]

	// Play mp3
	hMP3Decoder = MP3InitDecoder();
 8014f36:	f7eb f94b 	bl	80001d0 <MP3InitDecoder>
 8014f3a:	4602      	mov	r2, r0
 8014f3c:	4b1a      	ldr	r3, [pc, #104]	; (8014fa8 <main+0x80>)
 8014f3e:	601a      	str	r2, [r3, #0]
	InitializeAudio(Audio44100HzSettings);
 8014f40:	2300      	movs	r3, #0
 8014f42:	2206      	movs	r2, #6
 8014f44:	2102      	movs	r1, #2
 8014f46:	f240 100f 	movw	r0, #271	; 0x10f
 8014f4a:	f7ff fc7d 	bl	8014848 <InitializeAudio>
	SetAudioVolume(0xC0);
 8014f4e:	20c0      	movs	r0, #192	; 0xc0
 8014f50:	f7ff fdfa 	bl	8014b48 <SetAudioVolume>
	PlayAudioWithCallback(AudioCallback, 0);
 8014f54:	2100      	movs	r1, #0
 8014f56:	4815      	ldr	r0, [pc, #84]	; (8014fac <main+0x84>)
 8014f58:	f7ff fe36 	bl	8014bc8 <PlayAudioWithCallback>

	for(;;) {
		/*
		 * Check if user button is pressed
		 */
		if (BUTTON) {
 8014f5c:	4b14      	ldr	r3, [pc, #80]	; (8014fb0 <main+0x88>)
 8014f5e:	691b      	ldr	r3, [r3, #16]
 8014f60:	f003 0301 	and.w	r3, r3, #1
 8014f64:	2b00      	cmp	r3, #0
 8014f66:	d0f9      	beq.n	8014f5c <main+0x34>
			// Debounce
			Delay(10);
 8014f68:	200a      	movs	r0, #10
 8014f6a:	f000 f937 	bl	80151dc <Delay>
			if (BUTTON) {
 8014f6e:	4b10      	ldr	r3, [pc, #64]	; (8014fb0 <main+0x88>)
 8014f70:	691b      	ldr	r3, [r3, #16]
 8014f72:	f003 0301 	and.w	r3, r3, #1
 8014f76:	2b00      	cmp	r3, #0
 8014f78:	d0f0      	beq.n	8014f5c <main+0x34>

				// Toggle audio volume
				if (volume) {
 8014f7a:	687b      	ldr	r3, [r7, #4]
 8014f7c:	2b00      	cmp	r3, #0
 8014f7e:	d005      	beq.n	8014f8c <main+0x64>
					volume = 0;
 8014f80:	2300      	movs	r3, #0
 8014f82:	607b      	str	r3, [r7, #4]
					SetAudioVolume(0xC0);
 8014f84:	20c0      	movs	r0, #192	; 0xc0
 8014f86:	f7ff fddf 	bl	8014b48 <SetAudioVolume>
 8014f8a:	e004      	b.n	8014f96 <main+0x6e>
				} else {
					volume = 1;
 8014f8c:	2301      	movs	r3, #1
 8014f8e:	607b      	str	r3, [r7, #4]
					SetAudioVolume(0xCF);
 8014f90:	20cf      	movs	r0, #207	; 0xcf
 8014f92:	f7ff fdd9 	bl	8014b48 <SetAudioVolume>
				}
				while(BUTTON){};
 8014f96:	bf00      	nop
 8014f98:	4b05      	ldr	r3, [pc, #20]	; (8014fb0 <main+0x88>)
 8014f9a:	691b      	ldr	r3, [r3, #16]
 8014f9c:	f003 0301 	and.w	r3, r3, #1
 8014fa0:	2b00      	cmp	r3, #0
 8014fa2:	d1f9      	bne.n	8014f98 <main+0x70>
		if (BUTTON) {
 8014fa4:	e7da      	b.n	8014f5c <main+0x34>
 8014fa6:	bf00      	nop
 8014fa8:	20009e48 	.word	0x20009e48
 8014fac:	08014fb5 	.word	0x08014fb5
 8014fb0:	40020000 	.word	0x40020000

08014fb4 <AudioCallback>:
 * Called by the audio driver when it is time to provide data to
 * one of the audio buffers (while the other buffer is sent to the
 * CODEC using DMA). One mp3 frame is decoded at a time and
 * provided to the audio driver.
 */
static void AudioCallback(void *context, int buffer) {
 8014fb4:	b580      	push	{r7, lr}
 8014fb6:	b088      	sub	sp, #32
 8014fb8:	af02      	add	r7, sp, #8
 8014fba:	6078      	str	r0, [r7, #4]
 8014fbc:	6039      	str	r1, [r7, #0]
	static int16_t audio_buffer0[4096];
	static int16_t audio_buffer1[4096];

	int offset, err;
	int outOfData = 0;
 8014fbe:	2300      	movs	r3, #0
 8014fc0:	613b      	str	r3, [r7, #16]
	static const char *read_ptr = mp3_data;
	static int bytes_left = MP3_SIZE;

	int16_t *samples;

	if (buffer) {
 8014fc2:	683b      	ldr	r3, [r7, #0]
 8014fc4:	2b00      	cmp	r3, #0
 8014fc6:	d00c      	beq.n	8014fe2 <AudioCallback+0x2e>
		samples = audio_buffer0;
 8014fc8:	4b39      	ldr	r3, [pc, #228]	; (80150b0 <AudioCallback+0xfc>)
 8014fca:	60fb      	str	r3, [r7, #12]
		GPIO_SetBits(GPIOD, GPIO_Pin_13);
 8014fcc:	f44f 5100 	mov.w	r1, #8192	; 0x2000
 8014fd0:	4838      	ldr	r0, [pc, #224]	; (80150b4 <AudioCallback+0x100>)
 8014fd2:	f7f8 fca3 	bl	800d91c <GPIO_SetBits>
		GPIO_ResetBits(GPIOD, GPIO_Pin_14);
 8014fd6:	f44f 4180 	mov.w	r1, #16384	; 0x4000
 8014fda:	4836      	ldr	r0, [pc, #216]	; (80150b4 <AudioCallback+0x100>)
 8014fdc:	f7f8 fcad 	bl	800d93a <GPIO_ResetBits>
 8014fe0:	e00b      	b.n	8014ffa <AudioCallback+0x46>
	} else {
		samples = audio_buffer1;
 8014fe2:	4b35      	ldr	r3, [pc, #212]	; (80150b8 <AudioCallback+0x104>)
 8014fe4:	60fb      	str	r3, [r7, #12]
		GPIO_SetBits(GPIOD, GPIO_Pin_14);
 8014fe6:	f44f 4180 	mov.w	r1, #16384	; 0x4000
 8014fea:	4832      	ldr	r0, [pc, #200]	; (80150b4 <AudioCallback+0x100>)
 8014fec:	f7f8 fc96 	bl	800d91c <GPIO_SetBits>
		GPIO_ResetBits(GPIOD, GPIO_Pin_13);
 8014ff0:	f44f 5100 	mov.w	r1, #8192	; 0x2000
 8014ff4:	482f      	ldr	r0, [pc, #188]	; (80150b4 <AudioCallback+0x100>)
 8014ff6:	f7f8 fca0 	bl	800d93a <GPIO_ResetBits>
	}

	offset = MP3FindSyncWord((unsigned char*)read_ptr, bytes_left);
 8014ffa:	4b30      	ldr	r3, [pc, #192]	; (80150bc <AudioCallback+0x108>)
 8014ffc:	681a      	ldr	r2, [r3, #0]
 8014ffe:	4b30      	ldr	r3, [pc, #192]	; (80150c0 <AudioCallback+0x10c>)
 8015000:	681b      	ldr	r3, [r3, #0]
 8015002:	4619      	mov	r1, r3
 8015004:	4610      	mov	r0, r2
 8015006:	f7eb f8ff 	bl	8000208 <MP3FindSyncWord>
 801500a:	6178      	str	r0, [r7, #20]
	bytes_left -= offset;
 801500c:	4b2c      	ldr	r3, [pc, #176]	; (80150c0 <AudioCallback+0x10c>)
 801500e:	681a      	ldr	r2, [r3, #0]
 8015010:	697b      	ldr	r3, [r7, #20]
 8015012:	1ad3      	subs	r3, r2, r3
 8015014:	4a2a      	ldr	r2, [pc, #168]	; (80150c0 <AudioCallback+0x10c>)
 8015016:	6013      	str	r3, [r2, #0]

	if (bytes_left <= 10000) {
 8015018:	4b29      	ldr	r3, [pc, #164]	; (80150c0 <AudioCallback+0x10c>)
 801501a:	681b      	ldr	r3, [r3, #0]
 801501c:	f242 7210 	movw	r2, #10000	; 0x2710
 8015020:	4293      	cmp	r3, r2
 8015022:	dc0e      	bgt.n	8015042 <AudioCallback+0x8e>
		read_ptr = mp3_data;
 8015024:	4b25      	ldr	r3, [pc, #148]	; (80150bc <AudioCallback+0x108>)
 8015026:	4a27      	ldr	r2, [pc, #156]	; (80150c4 <AudioCallback+0x110>)
 8015028:	601a      	str	r2, [r3, #0]
		bytes_left = MP3_SIZE;
 801502a:	4b25      	ldr	r3, [pc, #148]	; (80150c0 <AudioCallback+0x10c>)
 801502c:	4a26      	ldr	r2, [pc, #152]	; (80150c8 <AudioCallback+0x114>)
 801502e:	601a      	str	r2, [r3, #0]
		offset = MP3FindSyncWord((unsigned char*)read_ptr, bytes_left);
 8015030:	4b22      	ldr	r3, [pc, #136]	; (80150bc <AudioCallback+0x108>)
 8015032:	681a      	ldr	r2, [r3, #0]
 8015034:	4b22      	ldr	r3, [pc, #136]	; (80150c0 <AudioCallback+0x10c>)
 8015036:	681b      	ldr	r3, [r3, #0]
 8015038:	4619      	mov	r1, r3
 801503a:	4610      	mov	r0, r2
 801503c:	f7eb f8e4 	bl	8000208 <MP3FindSyncWord>
 8015040:	6178      	str	r0, [r7, #20]
	}

	read_ptr += offset;
 8015042:	4b1e      	ldr	r3, [pc, #120]	; (80150bc <AudioCallback+0x108>)
 8015044:	681a      	ldr	r2, [r3, #0]
 8015046:	697b      	ldr	r3, [r7, #20]
 8015048:	4413      	add	r3, r2
 801504a:	4a1c      	ldr	r2, [pc, #112]	; (80150bc <AudioCallback+0x108>)
 801504c:	6013      	str	r3, [r2, #0]
	err = MP3Decode(hMP3Decoder, (unsigned char**)&read_ptr, &bytes_left, samples, 0);
 801504e:	4b1f      	ldr	r3, [pc, #124]	; (80150cc <AudioCallback+0x118>)
 8015050:	6818      	ldr	r0, [r3, #0]
 8015052:	2300      	movs	r3, #0
 8015054:	9300      	str	r3, [sp, #0]
 8015056:	68fb      	ldr	r3, [r7, #12]
 8015058:	4a19      	ldr	r2, [pc, #100]	; (80150c0 <AudioCallback+0x10c>)
 801505a:	4918      	ldr	r1, [pc, #96]	; (80150bc <AudioCallback+0x108>)
 801505c:	f7eb f9fe 	bl	800045c <MP3Decode>
 8015060:	60b8      	str	r0, [r7, #8]

	if (err) {
 8015062:	68bb      	ldr	r3, [r7, #8]
 8015064:	2b00      	cmp	r3, #0
 8015066:	d00d      	beq.n	8015084 <AudioCallback+0xd0>
		/* error occurred */
		switch (err) {
 8015068:	68bb      	ldr	r3, [r7, #8]
 801506a:	f113 0f02 	cmn.w	r3, #2
 801506e:	d010      	beq.n	8015092 <AudioCallback+0xde>
 8015070:	f1b3 3fff 	cmp.w	r3, #4294967295
 8015074:	d102      	bne.n	801507c <AudioCallback+0xc8>
		case ERR_MP3_INDATA_UNDERFLOW:
			outOfData = 1;
 8015076:	2301      	movs	r3, #1
 8015078:	613b      	str	r3, [r7, #16]
			break;
 801507a:	e00b      	b.n	8015094 <AudioCallback+0xe0>
		case ERR_MP3_MAINDATA_UNDERFLOW:
			/* do nothing - next call to decode will provide more mainData */
			break;
		case ERR_MP3_FREE_BITRATE_SYNC:
		default:
			outOfData = 1;
 801507c:	2301      	movs	r3, #1
 801507e:	613b      	str	r3, [r7, #16]
			break;
 8015080:	bf00      	nop
 8015082:	e007      	b.n	8015094 <AudioCallback+0xe0>
		}
	} else {
		/* no error */
		MP3GetLastFrameInfo(hMP3Decoder, &mp3FrameInfo);
 8015084:	4b11      	ldr	r3, [pc, #68]	; (80150cc <AudioCallback+0x118>)
 8015086:	681b      	ldr	r3, [r3, #0]
 8015088:	4911      	ldr	r1, [pc, #68]	; (80150d0 <AudioCallback+0x11c>)
 801508a:	4618      	mov	r0, r3
 801508c:	f7eb f935 	bl	80002fa <MP3GetLastFrameInfo>
 8015090:	e000      	b.n	8015094 <AudioCallback+0xe0>
			break;
 8015092:	bf00      	nop
	}

	if (!outOfData) {
 8015094:	693b      	ldr	r3, [r7, #16]
 8015096:	2b00      	cmp	r3, #0
 8015098:	d105      	bne.n	80150a6 <AudioCallback+0xf2>
		ProvideAudioBuffer(samples, mp3FrameInfo.outputSamps);
 801509a:	4b0d      	ldr	r3, [pc, #52]	; (80150d0 <AudioCallback+0x11c>)
 801509c:	691b      	ldr	r3, [r3, #16]
 801509e:	4619      	mov	r1, r3
 80150a0:	68f8      	ldr	r0, [r7, #12]
 80150a2:	f7ff fde1 	bl	8014c68 <ProvideAudioBuffer>
	}
}
 80150a6:	bf00      	nop
 80150a8:	3718      	adds	r7, #24
 80150aa:	46bd      	mov	sp, r7
 80150ac:	bd80      	pop	{r7, pc}
 80150ae:	bf00      	nop
 80150b0:	20005dd4 	.word	0x20005dd4
 80150b4:	40020c00 	.word	0x40020c00
 80150b8:	20007dd4 	.word	0x20007dd4
 80150bc:	20000014 	.word	0x20000014
 80150c0:	20000018 	.word	0x20000018
 80150c4:	0801aac8 	.word	0x0801aac8
 80150c8:	0005114b 	.word	0x0005114b
 80150cc:	20009e48 	.word	0x20009e48
 80150d0:	20009e50 	.word	0x20009e50

080150d4 <init>:

void init() {
 80150d4:	b580      	push	{r7, lr}
 80150d6:	b086      	sub	sp, #24
 80150d8:	af00      	add	r7, sp, #0
	GPIO_InitTypeDef  GPIO_InitStructure;
	USART_InitTypeDef USART_InitStructure;
	// ---------- SysTick timer -------- //
	if (SysTick_Config(SystemCoreClock / 1000)) {
 80150da:	4b2f      	ldr	r3, [pc, #188]	; (8015198 <init+0xc4>)
 80150dc:	681b      	ldr	r3, [r3, #0]
 80150de:	4a2f      	ldr	r2, [pc, #188]	; (801519c <init+0xc8>)
 80150e0:	fba2 2303 	umull	r2, r3, r2, r3
 80150e4:	099b      	lsrs	r3, r3, #6
 80150e6:	4618      	mov	r0, r3
 80150e8:	f7ff fefc 	bl	8014ee4 <SysTick_Config>
 80150ec:	4603      	mov	r3, r0
 80150ee:	2b00      	cmp	r3, #0
 80150f0:	d000      	beq.n	80150f4 <init+0x20>
		// Capture error
		while (1){};
 80150f2:	e7fe      	b.n	80150f2 <init+0x1e>

	// Enable full access to FPU (Should be done automatically in system_stm32f4xx.c):
	//SCB->CPACR |= ((3UL << 10*2)|(3UL << 11*2));  // set CP10 and CP11 Full Access

	// GPIOD Periph clock enable
	RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOD, ENABLE);
 80150f4:	2101      	movs	r1, #1
 80150f6:	2008      	movs	r0, #8
 80150f8:	f7fa fb0c 	bl	800f714 <RCC_AHB1PeriphClockCmd>

	// Configure PD12, PD13, PD14 and PD15 in output pushpull mode
	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_12 | GPIO_Pin_13| GPIO_Pin_14| GPIO_Pin_15;
 80150fc:	f44f 4370 	mov.w	r3, #61440	; 0xf000
 8015100:	613b      	str	r3, [r7, #16]
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
 8015102:	2301      	movs	r3, #1
 8015104:	753b      	strb	r3, [r7, #20]
	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
 8015106:	2300      	movs	r3, #0
 8015108:	75bb      	strb	r3, [r7, #22]
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;
 801510a:	2303      	movs	r3, #3
 801510c:	757b      	strb	r3, [r7, #21]
	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
 801510e:	2300      	movs	r3, #0
 8015110:	75fb      	strb	r3, [r7, #23]
	GPIO_Init(GPIOD, &GPIO_InitStructure);
 8015112:	f107 0310 	add.w	r3, r7, #16
 8015116:	4619      	mov	r1, r3
 8015118:	4821      	ldr	r0, [pc, #132]	; (80151a0 <init+0xcc>)
 801511a:	f7f8 fae7 	bl	800d6ec <GPIO_Init>


	// ------ UART ------ //

	// Clock
	RCC_APB1PeriphClockCmd(RCC_APB1Periph_USART2, ENABLE);
 801511e:	2101      	movs	r1, #1
 8015120:	f44f 3000 	mov.w	r0, #131072	; 0x20000
 8015124:	f7fa fb56 	bl	800f7d4 <RCC_APB1PeriphClockCmd>
	RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOA, ENABLE);
 8015128:	2101      	movs	r1, #1
 801512a:	2001      	movs	r0, #1
 801512c:	f7fa faf2 	bl	800f714 <RCC_AHB1PeriphClockCmd>

	// IO
	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_5 | GPIO_Pin_6;
 8015130:	2360      	movs	r3, #96	; 0x60
 8015132:	613b      	str	r3, [r7, #16]
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;
 8015134:	2303      	movs	r3, #3
 8015136:	757b      	strb	r3, [r7, #21]
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
 8015138:	2302      	movs	r3, #2
 801513a:	753b      	strb	r3, [r7, #20]
	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
 801513c:	2300      	movs	r3, #0
 801513e:	75bb      	strb	r3, [r7, #22]
	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP;
 8015140:	2301      	movs	r3, #1
 8015142:	75fb      	strb	r3, [r7, #23]
	GPIO_Init(GPIOD, &GPIO_InitStructure);
 8015144:	f107 0310 	add.w	r3, r7, #16
 8015148:	4619      	mov	r1, r3
 801514a:	4815      	ldr	r0, [pc, #84]	; (80151a0 <init+0xcc>)
 801514c:	f7f8 face 	bl	800d6ec <GPIO_Init>

	GPIO_PinAFConfig(GPIOD, GPIO_PinSource5, GPIO_AF_USART1);
 8015150:	2207      	movs	r2, #7
 8015152:	2105      	movs	r1, #5
 8015154:	4812      	ldr	r0, [pc, #72]	; (80151a0 <init+0xcc>)
 8015156:	f7f8 fc38 	bl	800d9ca <GPIO_PinAFConfig>
	GPIO_PinAFConfig(GPIOD, GPIO_PinSource6, GPIO_AF_USART1);
 801515a:	2207      	movs	r2, #7
 801515c:	2106      	movs	r1, #6
 801515e:	4810      	ldr	r0, [pc, #64]	; (80151a0 <init+0xcc>)
 8015160:	f7f8 fc33 	bl	800d9ca <GPIO_PinAFConfig>

	// Conf
	USART_InitStructure.USART_BaudRate = 115200;
 8015164:	f44f 33e1 	mov.w	r3, #115200	; 0x1c200
 8015168:	603b      	str	r3, [r7, #0]
	USART_InitStructure.USART_WordLength = USART_WordLength_8b;
 801516a:	2300      	movs	r3, #0
 801516c:	80bb      	strh	r3, [r7, #4]
	USART_InitStructure.USART_StopBits = USART_StopBits_1;
 801516e:	2300      	movs	r3, #0
 8015170:	80fb      	strh	r3, [r7, #6]
	USART_InitStructure.USART_Parity = USART_Parity_No;
 8015172:	2300      	movs	r3, #0
 8015174:	813b      	strh	r3, [r7, #8]
	USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
 8015176:	2300      	movs	r3, #0
 8015178:	81bb      	strh	r3, [r7, #12]
	USART_InitStructure.USART_Mode = USART_Mode_Tx | USART_Mode_Rx;
 801517a:	230c      	movs	r3, #12
 801517c:	817b      	strh	r3, [r7, #10]
	USART_Init(USART2, &USART_InitStructure);
 801517e:	463b      	mov	r3, r7
 8015180:	4619      	mov	r1, r3
 8015182:	4808      	ldr	r0, [pc, #32]	; (80151a4 <init+0xd0>)
 8015184:	f7fe fe30 	bl	8013de8 <USART_Init>

	// Enable
	USART_Cmd(USART2, ENABLE);
 8015188:	2101      	movs	r1, #1
 801518a:	4806      	ldr	r0, [pc, #24]	; (80151a4 <init+0xd0>)
 801518c:	f7fe ff44 	bl	8014018 <USART_Cmd>
}
 8015190:	bf00      	nop
 8015192:	3718      	adds	r7, #24
 8015194:	46bd      	mov	sp, r7
 8015196:	bd80      	pop	{r7, pc}
 8015198:	2000001c 	.word	0x2000001c
 801519c:	10624dd3 	.word	0x10624dd3
 80151a0:	40020c00 	.word	0x40020c00
 80151a4:	40004400 	.word	0x40004400

080151a8 <timing_handler>:

/*
 * Called from systick handler
 */
void timing_handler() {
 80151a8:	b480      	push	{r7}
 80151aa:	af00      	add	r7, sp, #0
	if (time_var1) {
 80151ac:	4b09      	ldr	r3, [pc, #36]	; (80151d4 <timing_handler+0x2c>)
 80151ae:	681b      	ldr	r3, [r3, #0]
 80151b0:	2b00      	cmp	r3, #0
 80151b2:	d004      	beq.n	80151be <timing_handler+0x16>
		time_var1--;
 80151b4:	4b07      	ldr	r3, [pc, #28]	; (80151d4 <timing_handler+0x2c>)
 80151b6:	681b      	ldr	r3, [r3, #0]
 80151b8:	3b01      	subs	r3, #1
 80151ba:	4a06      	ldr	r2, [pc, #24]	; (80151d4 <timing_handler+0x2c>)
 80151bc:	6013      	str	r3, [r2, #0]
	}

	time_var2++;
 80151be:	4b06      	ldr	r3, [pc, #24]	; (80151d8 <timing_handler+0x30>)
 80151c0:	681b      	ldr	r3, [r3, #0]
 80151c2:	3301      	adds	r3, #1
 80151c4:	4a04      	ldr	r2, [pc, #16]	; (80151d8 <timing_handler+0x30>)
 80151c6:	6013      	str	r3, [r2, #0]
}
 80151c8:	bf00      	nop
 80151ca:	46bd      	mov	sp, r7
 80151cc:	f85d 7b04 	ldr.w	r7, [sp], #4
 80151d0:	4770      	bx	lr
 80151d2:	bf00      	nop
 80151d4:	20009e44 	.word	0x20009e44
 80151d8:	20009e4c 	.word	0x20009e4c

080151dc <Delay>:

/*
 * Delay a number of systick cycles
 */
void Delay(volatile uint32_t nCount) {
 80151dc:	b480      	push	{r7}
 80151de:	b083      	sub	sp, #12
 80151e0:	af00      	add	r7, sp, #0
 80151e2:	6078      	str	r0, [r7, #4]
	time_var1 = nCount;
 80151e4:	687b      	ldr	r3, [r7, #4]
 80151e6:	4a06      	ldr	r2, [pc, #24]	; (8015200 <Delay+0x24>)
 80151e8:	6013      	str	r3, [r2, #0]

	while(time_var1){};
 80151ea:	bf00      	nop
 80151ec:	4b04      	ldr	r3, [pc, #16]	; (8015200 <Delay+0x24>)
 80151ee:	681b      	ldr	r3, [r3, #0]
 80151f0:	2b00      	cmp	r3, #0
 80151f2:	d1fb      	bne.n	80151ec <Delay+0x10>
}
 80151f4:	bf00      	nop
 80151f6:	370c      	adds	r7, #12
 80151f8:	46bd      	mov	sp, r7
 80151fa:	f85d 7b04 	ldr.w	r7, [sp], #4
 80151fe:	4770      	bx	lr
 8015200:	20009e44 	.word	0x20009e44

08015204 <NMI_Handler>:
  * @brief   This function handles NMI exception.
  * @param  None
  * @retval None
  */
void NMI_Handler(void)
{
 8015204:	b480      	push	{r7}
 8015206:	af00      	add	r7, sp, #0
}
 8015208:	bf00      	nop
 801520a:	46bd      	mov	sp, r7
 801520c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8015210:	4770      	bx	lr

08015212 <HardFault_Handler>:
  * @brief  This function handles Hard Fault exception.
  * @param  None
  * @retval None
  */
void HardFault_Handler(void)
{
 8015212:	b480      	push	{r7}
 8015214:	af00      	add	r7, sp, #0
  /* Go to infinite loop when Hard Fault exception occurs */
  while (1)
 8015216:	e7fe      	b.n	8015216 <HardFault_Handler+0x4>

08015218 <MemManage_Handler>:
  * @brief  This function handles Memory Manage exception.
  * @param  None
  * @retval None
  */
void MemManage_Handler(void)
{
 8015218:	b480      	push	{r7}
 801521a:	af00      	add	r7, sp, #0
  /* Go to infinite loop when Memory Manage exception occurs */
  while (1)
 801521c:	e7fe      	b.n	801521c <MemManage_Handler+0x4>

0801521e <BusFault_Handler>:
  * @brief  This function handles Bus Fault exception.
  * @param  None
  * @retval None
  */
void BusFault_Handler(void)
{
 801521e:	b480      	push	{r7}
 8015220:	af00      	add	r7, sp, #0
  /* Go to infinite loop when Bus Fault exception occurs */
  while (1)
 8015222:	e7fe      	b.n	8015222 <BusFault_Handler+0x4>

08015224 <UsageFault_Handler>:
  * @brief  This function handles Usage Fault exception.
  * @param  None
  * @retval None
  */
void UsageFault_Handler(void)
{
 8015224:	b480      	push	{r7}
 8015226:	af00      	add	r7, sp, #0
  /* Go to infinite loop when Usage Fault exception occurs */
  while (1)
 8015228:	e7fe      	b.n	8015228 <UsageFault_Handler+0x4>

0801522a <SVC_Handler>:
  * @brief  This function handles SVCall exception.
  * @param  None
  * @retval None
  */
void SVC_Handler(void)
{
 801522a:	b480      	push	{r7}
 801522c:	af00      	add	r7, sp, #0
}
 801522e:	bf00      	nop
 8015230:	46bd      	mov	sp, r7
 8015232:	f85d 7b04 	ldr.w	r7, [sp], #4
 8015236:	4770      	bx	lr

08015238 <DebugMon_Handler>:
  * @brief  This function handles Debug Monitor exception.
  * @param  None
  * @retval None
  */
void DebugMon_Handler(void)
{
 8015238:	b480      	push	{r7}
 801523a:	af00      	add	r7, sp, #0
}
 801523c:	bf00      	nop
 801523e:	46bd      	mov	sp, r7
 8015240:	f85d 7b04 	ldr.w	r7, [sp], #4
 8015244:	4770      	bx	lr

08015246 <PendSV_Handler>:
  * @brief  This function handles PendSVC exception.
  * @param  None
  * @retval None
  */
void PendSV_Handler(void)
{
 8015246:	b480      	push	{r7}
 8015248:	af00      	add	r7, sp, #0
}
 801524a:	bf00      	nop
 801524c:	46bd      	mov	sp, r7
 801524e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8015252:	4770      	bx	lr

08015254 <SysTick_Handler>:
  * @brief  This function handles SysTick Handler.
  * @param  None
  * @retval None
  */
void SysTick_Handler(void)
{
 8015254:	b580      	push	{r7, lr}
 8015256:	af00      	add	r7, sp, #0
	timing_handler();
 8015258:	f7ff ffa6 	bl	80151a8 <timing_handler>
}
 801525c:	bf00      	nop
 801525e:	bd80      	pop	{r7, pc}

08015260 <_close>:
#include <sys/stat.h>
#include "stm32f4xx_conf.h"

int __errno;

int _close(int file) {
 8015260:	b480      	push	{r7}
 8015262:	b083      	sub	sp, #12
 8015264:	af00      	add	r7, sp, #0
 8015266:	6078      	str	r0, [r7, #4]
	return 0;
 8015268:	2300      	movs	r3, #0
}
 801526a:	4618      	mov	r0, r3
 801526c:	370c      	adds	r7, #12
 801526e:	46bd      	mov	sp, r7
 8015270:	f85d 7b04 	ldr.w	r7, [sp], #4
 8015274:	4770      	bx	lr

08015276 <_fstat>:

int _fstat(int file, struct stat *st) {
 8015276:	b480      	push	{r7}
 8015278:	b083      	sub	sp, #12
 801527a:	af00      	add	r7, sp, #0
 801527c:	6078      	str	r0, [r7, #4]
 801527e:	6039      	str	r1, [r7, #0]
	return 0;
 8015280:	2300      	movs	r3, #0
}
 8015282:	4618      	mov	r0, r3
 8015284:	370c      	adds	r7, #12
 8015286:	46bd      	mov	sp, r7
 8015288:	f85d 7b04 	ldr.w	r7, [sp], #4
 801528c:	4770      	bx	lr

0801528e <_isatty>:

int _isatty(int file) {
 801528e:	b480      	push	{r7}
 8015290:	b083      	sub	sp, #12
 8015292:	af00      	add	r7, sp, #0
 8015294:	6078      	str	r0, [r7, #4]
	return 1;
 8015296:	2301      	movs	r3, #1
}
 8015298:	4618      	mov	r0, r3
 801529a:	370c      	adds	r7, #12
 801529c:	46bd      	mov	sp, r7
 801529e:	f85d 7b04 	ldr.w	r7, [sp], #4
 80152a2:	4770      	bx	lr

080152a4 <_lseek>:

int _lseek(int file, int ptr, int dir) {
 80152a4:	b480      	push	{r7}
 80152a6:	b085      	sub	sp, #20
 80152a8:	af00      	add	r7, sp, #0
 80152aa:	60f8      	str	r0, [r7, #12]
 80152ac:	60b9      	str	r1, [r7, #8]
 80152ae:	607a      	str	r2, [r7, #4]
	return 0;
 80152b0:	2300      	movs	r3, #0
}
 80152b2:	4618      	mov	r0, r3
 80152b4:	3714      	adds	r7, #20
 80152b6:	46bd      	mov	sp, r7
 80152b8:	f85d 7b04 	ldr.w	r7, [sp], #4
 80152bc:	4770      	bx	lr

080152be <_open>:

int _open(const char *name, int flags, int mode) {
 80152be:	b480      	push	{r7}
 80152c0:	b085      	sub	sp, #20
 80152c2:	af00      	add	r7, sp, #0
 80152c4:	60f8      	str	r0, [r7, #12]
 80152c6:	60b9      	str	r1, [r7, #8]
 80152c8:	607a      	str	r2, [r7, #4]
	return -1;
 80152ca:	f04f 33ff 	mov.w	r3, #4294967295
}
 80152ce:	4618      	mov	r0, r3
 80152d0:	3714      	adds	r7, #20
 80152d2:	46bd      	mov	sp, r7
 80152d4:	f85d 7b04 	ldr.w	r7, [sp], #4
 80152d8:	4770      	bx	lr

080152da <_read>:

int _read(int file, char *ptr, int len) {
 80152da:	b480      	push	{r7}
 80152dc:	b085      	sub	sp, #20
 80152de:	af00      	add	r7, sp, #0
 80152e0:	60f8      	str	r0, [r7, #12]
 80152e2:	60b9      	str	r1, [r7, #8]
 80152e4:	607a      	str	r2, [r7, #4]
	return 0;
 80152e6:	2300      	movs	r3, #0
}
 80152e8:	4618      	mov	r0, r3
 80152ea:	3714      	adds	r7, #20
 80152ec:	46bd      	mov	sp, r7
 80152ee:	f85d 7b04 	ldr.w	r7, [sp], #4
 80152f2:	4770      	bx	lr

080152f4 <_sbrk_r>:

/* Register name faking - works in collusion with the linker.  */
register char * stack_ptr asm ("sp");

caddr_t _sbrk_r (struct _reent *r, int incr)
{
 80152f4:	b480      	push	{r7}
 80152f6:	b085      	sub	sp, #20
 80152f8:	af00      	add	r7, sp, #0
 80152fa:	6078      	str	r0, [r7, #4]
 80152fc:	6039      	str	r1, [r7, #0]
	extern char   end asm ("end"); /* Defined by the linker.  */
	static char * heap_end;
	char *        prev_heap_end;

	if (heap_end == NULL)
 80152fe:	4b10      	ldr	r3, [pc, #64]	; (8015340 <_sbrk_r+0x4c>)
 8015300:	681b      	ldr	r3, [r3, #0]
 8015302:	2b00      	cmp	r3, #0
 8015304:	d102      	bne.n	801530c <_sbrk_r+0x18>
		heap_end = & end;
 8015306:	4b0e      	ldr	r3, [pc, #56]	; (8015340 <_sbrk_r+0x4c>)
 8015308:	4a0e      	ldr	r2, [pc, #56]	; (8015344 <_sbrk_r+0x50>)
 801530a:	601a      	str	r2, [r3, #0]

	prev_heap_end = heap_end;
 801530c:	4b0c      	ldr	r3, [pc, #48]	; (8015340 <_sbrk_r+0x4c>)
 801530e:	681b      	ldr	r3, [r3, #0]
 8015310:	60fb      	str	r3, [r7, #12]

	if (heap_end + incr > stack_ptr)
 8015312:	4b0b      	ldr	r3, [pc, #44]	; (8015340 <_sbrk_r+0x4c>)
 8015314:	681a      	ldr	r2, [r3, #0]
 8015316:	683b      	ldr	r3, [r7, #0]
 8015318:	4413      	add	r3, r2
 801531a:	466a      	mov	r2, sp
 801531c:	4293      	cmp	r3, r2
 801531e:	d902      	bls.n	8015326 <_sbrk_r+0x32>
		_write (1, "_sbrk: Heap and stack collision\n", 32);

		abort ();
#else
		//errno = ENOMEM;
		return (caddr_t) -1;
 8015320:	f04f 33ff 	mov.w	r3, #4294967295
 8015324:	e006      	b.n	8015334 <_sbrk_r+0x40>
#endif
	}

	heap_end += incr;
 8015326:	4b06      	ldr	r3, [pc, #24]	; (8015340 <_sbrk_r+0x4c>)
 8015328:	681a      	ldr	r2, [r3, #0]
 801532a:	683b      	ldr	r3, [r7, #0]
 801532c:	4413      	add	r3, r2
 801532e:	4a04      	ldr	r2, [pc, #16]	; (8015340 <_sbrk_r+0x4c>)
 8015330:	6013      	str	r3, [r2, #0]

	return (caddr_t) prev_heap_end;
 8015332:	68fb      	ldr	r3, [r7, #12]
}
 8015334:	4618      	mov	r0, r3
 8015336:	3714      	adds	r7, #20
 8015338:	46bd      	mov	sp, r7
 801533a:	f85d 7b04 	ldr.w	r7, [sp], #4
 801533e:	4770      	bx	lr
 8015340:	20009dd4 	.word	0x20009dd4
 8015344:	20009e70 	.word	0x20009e70

08015348 <_write>:

int _write(int file, char *ptr, int len) {
 8015348:	b580      	push	{r7, lr}
 801534a:	b086      	sub	sp, #24
 801534c:	af00      	add	r7, sp, #0
 801534e:	60f8      	str	r0, [r7, #12]
 8015350:	60b9      	str	r1, [r7, #8]
 8015352:	607a      	str	r2, [r7, #4]
	int i;

	for(i = 0;i < len;i++) {
 8015354:	2300      	movs	r3, #0
 8015356:	617b      	str	r3, [r7, #20]
 8015358:	e013      	b.n	8015382 <_write+0x3a>
		USART_SendData(USART2, (uint8_t)ptr[i]);
 801535a:	697b      	ldr	r3, [r7, #20]
 801535c:	68ba      	ldr	r2, [r7, #8]
 801535e:	4413      	add	r3, r2
 8015360:	781b      	ldrb	r3, [r3, #0]
 8015362:	b29b      	uxth	r3, r3
 8015364:	4619      	mov	r1, r3
 8015366:	480b      	ldr	r0, [pc, #44]	; (8015394 <_write+0x4c>)
 8015368:	f7fe fed5 	bl	8014116 <USART_SendData>
		while (USART_GetFlagStatus(USART2, USART_FLAG_TC) == RESET){};
 801536c:	bf00      	nop
 801536e:	2140      	movs	r1, #64	; 0x40
 8015370:	4808      	ldr	r0, [pc, #32]	; (8015394 <_write+0x4c>)
 8015372:	f7ff f8bf 	bl	80144f4 <USART_GetFlagStatus>
 8015376:	4603      	mov	r3, r0
 8015378:	2b00      	cmp	r3, #0
 801537a:	d0f8      	beq.n	801536e <_write+0x26>
	for(i = 0;i < len;i++) {
 801537c:	697b      	ldr	r3, [r7, #20]
 801537e:	3301      	adds	r3, #1
 8015380:	617b      	str	r3, [r7, #20]
 8015382:	697a      	ldr	r2, [r7, #20]
 8015384:	687b      	ldr	r3, [r7, #4]
 8015386:	429a      	cmp	r2, r3
 8015388:	dbe7      	blt.n	801535a <_write+0x12>
	}

	return len;
 801538a:	687b      	ldr	r3, [r7, #4]
}
 801538c:	4618      	mov	r0, r3
 801538e:	3718      	adds	r7, #24
 8015390:	46bd      	mov	sp, r7
 8015392:	bd80      	pop	{r7, pc}
 8015394:	40004400 	.word	0x40004400

08015398 <SystemInit>:
 *         SystemFrequency variable.
 * @param  None
 * @retval None
 */
void SystemInit(void)
{
 8015398:	b580      	push	{r7, lr}
 801539a:	af00      	add	r7, sp, #0
	/* FPU settings ------------------------------------------------------------*/
#if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
	SCB->CPACR |= ((3UL << 10*2)|(3UL << 11*2));  /* set CP10 and CP11 Full Access */
 801539c:	4a16      	ldr	r2, [pc, #88]	; (80153f8 <SystemInit+0x60>)
 801539e:	4b16      	ldr	r3, [pc, #88]	; (80153f8 <SystemInit+0x60>)
 80153a0:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 80153a4:	f443 0370 	orr.w	r3, r3, #15728640	; 0xf00000
 80153a8:	f8c2 3088 	str.w	r3, [r2, #136]	; 0x88
#endif
	/* Reset the RCC clock configuration to the default reset state ------------*/
	/* Set HSION bit */
	RCC->CR |= (uint32_t)0x00000001;
 80153ac:	4a13      	ldr	r2, [pc, #76]	; (80153fc <SystemInit+0x64>)
 80153ae:	4b13      	ldr	r3, [pc, #76]	; (80153fc <SystemInit+0x64>)
 80153b0:	681b      	ldr	r3, [r3, #0]
 80153b2:	f043 0301 	orr.w	r3, r3, #1
 80153b6:	6013      	str	r3, [r2, #0]

	/* Reset CFGR register */
	RCC->CFGR = 0x00000000;
 80153b8:	4b10      	ldr	r3, [pc, #64]	; (80153fc <SystemInit+0x64>)
 80153ba:	2200      	movs	r2, #0
 80153bc:	609a      	str	r2, [r3, #8]

	/* Reset HSEON, CSSON and PLLON bits */
	RCC->CR &= (uint32_t)0xFEF6FFFF;
 80153be:	4a0f      	ldr	r2, [pc, #60]	; (80153fc <SystemInit+0x64>)
 80153c0:	4b0e      	ldr	r3, [pc, #56]	; (80153fc <SystemInit+0x64>)
 80153c2:	681b      	ldr	r3, [r3, #0]
 80153c4:	f023 7384 	bic.w	r3, r3, #17301504	; 0x1080000
 80153c8:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 80153cc:	6013      	str	r3, [r2, #0]

	/* Reset PLLCFGR register */
	RCC->PLLCFGR = 0x24003010;
 80153ce:	4b0b      	ldr	r3, [pc, #44]	; (80153fc <SystemInit+0x64>)
 80153d0:	4a0b      	ldr	r2, [pc, #44]	; (8015400 <SystemInit+0x68>)
 80153d2:	605a      	str	r2, [r3, #4]

	/* Reset HSEBYP bit */
	RCC->CR &= (uint32_t)0xFFFBFFFF;
 80153d4:	4a09      	ldr	r2, [pc, #36]	; (80153fc <SystemInit+0x64>)
 80153d6:	4b09      	ldr	r3, [pc, #36]	; (80153fc <SystemInit+0x64>)
 80153d8:	681b      	ldr	r3, [r3, #0]
 80153da:	f423 2380 	bic.w	r3, r3, #262144	; 0x40000
 80153de:	6013      	str	r3, [r2, #0]

	/* Disable all interrupts */
	RCC->CIR = 0x00000000;
 80153e0:	4b06      	ldr	r3, [pc, #24]	; (80153fc <SystemInit+0x64>)
 80153e2:	2200      	movs	r2, #0
 80153e4:	60da      	str	r2, [r3, #12]
	SystemInit_ExtMemCtl();
#endif /* DATA_IN_ExtSRAM */

	/* Configure the System clock source, PLL Multiplier and Divider factors,
     AHB/APBx prescalers and Flash settings ----------------------------------*/
	SetSysClock();
 80153e6:	f000 f889 	bl	80154fc <SetSysClock>

	/* Configure the Vector Table location add offset address ------------------*/
#ifdef VECT_TAB_SRAM
	SCB->VTOR = SRAM_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal SRAM */
#else
	SCB->VTOR = FLASH_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal FLASH */
 80153ea:	4b03      	ldr	r3, [pc, #12]	; (80153f8 <SystemInit+0x60>)
 80153ec:	f04f 6200 	mov.w	r2, #134217728	; 0x8000000
 80153f0:	609a      	str	r2, [r3, #8]
#endif
}
 80153f2:	bf00      	nop
 80153f4:	bd80      	pop	{r7, pc}
 80153f6:	bf00      	nop
 80153f8:	e000ed00 	.word	0xe000ed00
 80153fc:	40023800 	.word	0x40023800
 8015400:	24003010 	.word	0x24003010

08015404 <SystemCoreClockUpdate>:
 *
 * @param  None
 * @retval None
 */
void SystemCoreClockUpdate(void)
{
 8015404:	b480      	push	{r7}
 8015406:	b087      	sub	sp, #28
 8015408:	af00      	add	r7, sp, #0
	uint32_t tmp = 0, pllvco = 0, pllp = 2, pllsource = 0, pllm = 2;
 801540a:	2300      	movs	r3, #0
 801540c:	613b      	str	r3, [r7, #16]
 801540e:	2300      	movs	r3, #0
 8015410:	617b      	str	r3, [r7, #20]
 8015412:	2302      	movs	r3, #2
 8015414:	60fb      	str	r3, [r7, #12]
 8015416:	2300      	movs	r3, #0
 8015418:	60bb      	str	r3, [r7, #8]
 801541a:	2302      	movs	r3, #2
 801541c:	607b      	str	r3, [r7, #4]

	/* Get SYSCLK source -------------------------------------------------------*/
	tmp = RCC->CFGR & RCC_CFGR_SWS;
 801541e:	4b32      	ldr	r3, [pc, #200]	; (80154e8 <SystemCoreClockUpdate+0xe4>)
 8015420:	689b      	ldr	r3, [r3, #8]
 8015422:	f003 030c 	and.w	r3, r3, #12
 8015426:	613b      	str	r3, [r7, #16]

	switch (tmp)
 8015428:	693b      	ldr	r3, [r7, #16]
 801542a:	2b04      	cmp	r3, #4
 801542c:	d007      	beq.n	801543e <SystemCoreClockUpdate+0x3a>
 801542e:	2b08      	cmp	r3, #8
 8015430:	d009      	beq.n	8015446 <SystemCoreClockUpdate+0x42>
 8015432:	2b00      	cmp	r3, #0
 8015434:	d13d      	bne.n	80154b2 <SystemCoreClockUpdate+0xae>
	{
	case 0x00:  /* HSI used as system clock source */
		SystemCoreClock = HSI_VALUE;
 8015436:	4b2d      	ldr	r3, [pc, #180]	; (80154ec <SystemCoreClockUpdate+0xe8>)
 8015438:	4a2d      	ldr	r2, [pc, #180]	; (80154f0 <SystemCoreClockUpdate+0xec>)
 801543a:	601a      	str	r2, [r3, #0]
		break;
 801543c:	e03d      	b.n	80154ba <SystemCoreClockUpdate+0xb6>
	case 0x04:  /* HSE used as system clock source */
		SystemCoreClock = HSE_VALUE;
 801543e:	4b2b      	ldr	r3, [pc, #172]	; (80154ec <SystemCoreClockUpdate+0xe8>)
 8015440:	4a2c      	ldr	r2, [pc, #176]	; (80154f4 <SystemCoreClockUpdate+0xf0>)
 8015442:	601a      	str	r2, [r3, #0]
		break;
 8015444:	e039      	b.n	80154ba <SystemCoreClockUpdate+0xb6>
	case 0x08:  /* PLL used as system clock source */

		/* PLL_VCO = (HSE_VALUE or HSI_VALUE / PLL_M) * PLL_N
         SYSCLK = PLL_VCO / PLL_P
		 */
		pllsource = (RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) >> 22;
 8015446:	4b28      	ldr	r3, [pc, #160]	; (80154e8 <SystemCoreClockUpdate+0xe4>)
 8015448:	685b      	ldr	r3, [r3, #4]
 801544a:	0d9b      	lsrs	r3, r3, #22
 801544c:	f003 0301 	and.w	r3, r3, #1
 8015450:	60bb      	str	r3, [r7, #8]
		pllm = RCC->PLLCFGR & RCC_PLLCFGR_PLLM;
 8015452:	4b25      	ldr	r3, [pc, #148]	; (80154e8 <SystemCoreClockUpdate+0xe4>)
 8015454:	685b      	ldr	r3, [r3, #4]
 8015456:	f003 033f 	and.w	r3, r3, #63	; 0x3f
 801545a:	607b      	str	r3, [r7, #4]

		if (pllsource != 0)
 801545c:	68bb      	ldr	r3, [r7, #8]
 801545e:	2b00      	cmp	r3, #0
 8015460:	d00c      	beq.n	801547c <SystemCoreClockUpdate+0x78>
		{
			/* HSE used as PLL clock source */
			pllvco = (HSE_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> 6);
 8015462:	4a24      	ldr	r2, [pc, #144]	; (80154f4 <SystemCoreClockUpdate+0xf0>)
 8015464:	687b      	ldr	r3, [r7, #4]
 8015466:	fbb2 f3f3 	udiv	r3, r2, r3
 801546a:	4a1f      	ldr	r2, [pc, #124]	; (80154e8 <SystemCoreClockUpdate+0xe4>)
 801546c:	6852      	ldr	r2, [r2, #4]
 801546e:	0992      	lsrs	r2, r2, #6
 8015470:	f3c2 0208 	ubfx	r2, r2, #0, #9
 8015474:	fb02 f303 	mul.w	r3, r2, r3
 8015478:	617b      	str	r3, [r7, #20]
 801547a:	e00b      	b.n	8015494 <SystemCoreClockUpdate+0x90>
		}
		else
		{
			/* HSI used as PLL clock source */
			pllvco = (HSI_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> 6);
 801547c:	4a1c      	ldr	r2, [pc, #112]	; (80154f0 <SystemCoreClockUpdate+0xec>)
 801547e:	687b      	ldr	r3, [r7, #4]
 8015480:	fbb2 f3f3 	udiv	r3, r2, r3
 8015484:	4a18      	ldr	r2, [pc, #96]	; (80154e8 <SystemCoreClockUpdate+0xe4>)
 8015486:	6852      	ldr	r2, [r2, #4]
 8015488:	0992      	lsrs	r2, r2, #6
 801548a:	f3c2 0208 	ubfx	r2, r2, #0, #9
 801548e:	fb02 f303 	mul.w	r3, r2, r3
 8015492:	617b      	str	r3, [r7, #20]
		}

		pllp = (((RCC->PLLCFGR & RCC_PLLCFGR_PLLP) >>16) + 1 ) *2;
 8015494:	4b14      	ldr	r3, [pc, #80]	; (80154e8 <SystemCoreClockUpdate+0xe4>)
 8015496:	685b      	ldr	r3, [r3, #4]
 8015498:	0c1b      	lsrs	r3, r3, #16
 801549a:	f003 0303 	and.w	r3, r3, #3
 801549e:	3301      	adds	r3, #1
 80154a0:	005b      	lsls	r3, r3, #1
 80154a2:	60fb      	str	r3, [r7, #12]
		SystemCoreClock = pllvco/pllp;
 80154a4:	697a      	ldr	r2, [r7, #20]
 80154a6:	68fb      	ldr	r3, [r7, #12]
 80154a8:	fbb2 f3f3 	udiv	r3, r2, r3
 80154ac:	4a0f      	ldr	r2, [pc, #60]	; (80154ec <SystemCoreClockUpdate+0xe8>)
 80154ae:	6013      	str	r3, [r2, #0]
		break;
 80154b0:	e003      	b.n	80154ba <SystemCoreClockUpdate+0xb6>
	default:
		SystemCoreClock = HSI_VALUE;
 80154b2:	4b0e      	ldr	r3, [pc, #56]	; (80154ec <SystemCoreClockUpdate+0xe8>)
 80154b4:	4a0e      	ldr	r2, [pc, #56]	; (80154f0 <SystemCoreClockUpdate+0xec>)
 80154b6:	601a      	str	r2, [r3, #0]
		break;
 80154b8:	bf00      	nop
	}
	/* Compute HCLK frequency --------------------------------------------------*/
	/* Get HCLK prescaler */
	tmp = AHBPrescTable[((RCC->CFGR & RCC_CFGR_HPRE) >> 4)];
 80154ba:	4b0b      	ldr	r3, [pc, #44]	; (80154e8 <SystemCoreClockUpdate+0xe4>)
 80154bc:	689b      	ldr	r3, [r3, #8]
 80154be:	091b      	lsrs	r3, r3, #4
 80154c0:	f003 030f 	and.w	r3, r3, #15
 80154c4:	4a0c      	ldr	r2, [pc, #48]	; (80154f8 <SystemCoreClockUpdate+0xf4>)
 80154c6:	5cd3      	ldrb	r3, [r2, r3]
 80154c8:	b2db      	uxtb	r3, r3
 80154ca:	613b      	str	r3, [r7, #16]
	/* HCLK frequency */
	SystemCoreClock >>= tmp;
 80154cc:	4b07      	ldr	r3, [pc, #28]	; (80154ec <SystemCoreClockUpdate+0xe8>)
 80154ce:	681a      	ldr	r2, [r3, #0]
 80154d0:	693b      	ldr	r3, [r7, #16]
 80154d2:	fa22 f303 	lsr.w	r3, r2, r3
 80154d6:	4a05      	ldr	r2, [pc, #20]	; (80154ec <SystemCoreClockUpdate+0xe8>)
 80154d8:	6013      	str	r3, [r2, #0]
}
 80154da:	bf00      	nop
 80154dc:	371c      	adds	r7, #28
 80154de:	46bd      	mov	sp, r7
 80154e0:	f85d 7b04 	ldr.w	r7, [sp], #4
 80154e4:	4770      	bx	lr
 80154e6:	bf00      	nop
 80154e8:	40023800 	.word	0x40023800
 80154ec:	2000001c 	.word	0x2000001c
 80154f0:	00f42400 	.word	0x00f42400
 80154f4:	017d7840 	.word	0x017d7840
 80154f8:	20000020 	.word	0x20000020

080154fc <SetSysClock>:
 *         is reset to the default reset state (done in SystemInit() function).
 * @param  None
 * @retval None
 */
static void SetSysClock(void)
{
 80154fc:	b480      	push	{r7}
 80154fe:	b083      	sub	sp, #12
 8015500:	af00      	add	r7, sp, #0
	/******************************************************************************/
	/*            PLL (clocked by HSE) used as System clock source                */
	/******************************************************************************/
	__IO uint32_t StartUpCounter = 0, HSEStatus = 0;
 8015502:	2300      	movs	r3, #0
 8015504:	607b      	str	r3, [r7, #4]
 8015506:	2300      	movs	r3, #0
 8015508:	603b      	str	r3, [r7, #0]

	/* Enable HSE */
	RCC->CR |= ((uint32_t)RCC_CR_HSEON);
 801550a:	4a36      	ldr	r2, [pc, #216]	; (80155e4 <SetSysClock+0xe8>)
 801550c:	4b35      	ldr	r3, [pc, #212]	; (80155e4 <SetSysClock+0xe8>)
 801550e:	681b      	ldr	r3, [r3, #0]
 8015510:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 8015514:	6013      	str	r3, [r2, #0]

	/* Wait till HSE is ready and if Time out is reached exit */
	do
	{
		HSEStatus = RCC->CR & RCC_CR_HSERDY;
 8015516:	4b33      	ldr	r3, [pc, #204]	; (80155e4 <SetSysClock+0xe8>)
 8015518:	681b      	ldr	r3, [r3, #0]
 801551a:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 801551e:	603b      	str	r3, [r7, #0]
		StartUpCounter++;
 8015520:	687b      	ldr	r3, [r7, #4]
 8015522:	3301      	adds	r3, #1
 8015524:	607b      	str	r3, [r7, #4]
	} while((HSEStatus == 0) && (StartUpCounter != HSE_STARTUP_TIMEOUT));
 8015526:	683b      	ldr	r3, [r7, #0]
 8015528:	2b00      	cmp	r3, #0
 801552a:	d103      	bne.n	8015534 <SetSysClock+0x38>
 801552c:	687b      	ldr	r3, [r7, #4]
 801552e:	f5b3 6fa0 	cmp.w	r3, #1280	; 0x500
 8015532:	d1f0      	bne.n	8015516 <SetSysClock+0x1a>

	if ((RCC->CR & RCC_CR_HSERDY) != RESET)
 8015534:	4b2b      	ldr	r3, [pc, #172]	; (80155e4 <SetSysClock+0xe8>)
 8015536:	681b      	ldr	r3, [r3, #0]
 8015538:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 801553c:	2b00      	cmp	r3, #0
 801553e:	d002      	beq.n	8015546 <SetSysClock+0x4a>
	{
		HSEStatus = (uint32_t)0x01;
 8015540:	2301      	movs	r3, #1
 8015542:	603b      	str	r3, [r7, #0]
 8015544:	e001      	b.n	801554a <SetSysClock+0x4e>
	}
	else
	{
		HSEStatus = (uint32_t)0x00;
 8015546:	2300      	movs	r3, #0
 8015548:	603b      	str	r3, [r7, #0]
	}

	if (HSEStatus == (uint32_t)0x01)
 801554a:	683b      	ldr	r3, [r7, #0]
 801554c:	2b01      	cmp	r3, #1
 801554e:	d142      	bne.n	80155d6 <SetSysClock+0xda>
	{
		/* Select regulator voltage output Scale 1 mode, System frequency up to 168 MHz */
		RCC->APB1ENR |= RCC_APB1ENR_PWREN;
 8015550:	4a24      	ldr	r2, [pc, #144]	; (80155e4 <SetSysClock+0xe8>)
 8015552:	4b24      	ldr	r3, [pc, #144]	; (80155e4 <SetSysClock+0xe8>)
 8015554:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8015556:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 801555a:	6413      	str	r3, [r2, #64]	; 0x40
		PWR->CR |= PWR_CR_VOS;
 801555c:	4a22      	ldr	r2, [pc, #136]	; (80155e8 <SetSysClock+0xec>)
 801555e:	4b22      	ldr	r3, [pc, #136]	; (80155e8 <SetSysClock+0xec>)
 8015560:	681b      	ldr	r3, [r3, #0]
 8015562:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 8015566:	6013      	str	r3, [r2, #0]

		/* HCLK = SYSCLK / 1*/
		RCC->CFGR |= RCC_CFGR_HPRE_DIV1;
 8015568:	4a1e      	ldr	r2, [pc, #120]	; (80155e4 <SetSysClock+0xe8>)
 801556a:	4b1e      	ldr	r3, [pc, #120]	; (80155e4 <SetSysClock+0xe8>)
 801556c:	689b      	ldr	r3, [r3, #8]
 801556e:	6093      	str	r3, [r2, #8]

		/* PCLK2 = HCLK / 2*/
		RCC->CFGR |= RCC_CFGR_PPRE2_DIV2;
 8015570:	4a1c      	ldr	r2, [pc, #112]	; (80155e4 <SetSysClock+0xe8>)
 8015572:	4b1c      	ldr	r3, [pc, #112]	; (80155e4 <SetSysClock+0xe8>)
 8015574:	689b      	ldr	r3, [r3, #8]
 8015576:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 801557a:	6093      	str	r3, [r2, #8]

		/* PCLK1 = HCLK / 4*/
		RCC->CFGR |= RCC_CFGR_PPRE1_DIV4;
 801557c:	4a19      	ldr	r2, [pc, #100]	; (80155e4 <SetSysClock+0xe8>)
 801557e:	4b19      	ldr	r3, [pc, #100]	; (80155e4 <SetSysClock+0xe8>)
 8015580:	689b      	ldr	r3, [r3, #8]
 8015582:	f443 53a0 	orr.w	r3, r3, #5120	; 0x1400
 8015586:	6093      	str	r3, [r2, #8]

		/* Configure the main PLL */
		RCC->PLLCFGR = PLL_M | (PLL_N << 6) | (((PLL_P >> 1) -1) << 16) |
 8015588:	4b16      	ldr	r3, [pc, #88]	; (80155e4 <SetSysClock+0xe8>)
 801558a:	4a18      	ldr	r2, [pc, #96]	; (80155ec <SetSysClock+0xf0>)
 801558c:	605a      	str	r2, [r3, #4]
				(RCC_PLLCFGR_PLLSRC_HSE) | (PLL_Q << 24);

		/* Enable the main PLL */
		RCC->CR |= RCC_CR_PLLON;
 801558e:	4a15      	ldr	r2, [pc, #84]	; (80155e4 <SetSysClock+0xe8>)
 8015590:	4b14      	ldr	r3, [pc, #80]	; (80155e4 <SetSysClock+0xe8>)
 8015592:	681b      	ldr	r3, [r3, #0]
 8015594:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
 8015598:	6013      	str	r3, [r2, #0]

		/* Wait till the main PLL is ready */
		while((RCC->CR & RCC_CR_PLLRDY) == 0)
 801559a:	bf00      	nop
 801559c:	4b11      	ldr	r3, [pc, #68]	; (80155e4 <SetSysClock+0xe8>)
 801559e:	681b      	ldr	r3, [r3, #0]
 80155a0:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
 80155a4:	2b00      	cmp	r3, #0
 80155a6:	d0f9      	beq.n	801559c <SetSysClock+0xa0>
		{
		}

		/* Configure Flash prefetch, Instruction cache, Data cache and wait state */
		FLASH->ACR = FLASH_ACR_ICEN |FLASH_ACR_DCEN |FLASH_ACR_LATENCY_5WS;
 80155a8:	4b11      	ldr	r3, [pc, #68]	; (80155f0 <SetSysClock+0xf4>)
 80155aa:	f240 6205 	movw	r2, #1541	; 0x605
 80155ae:	601a      	str	r2, [r3, #0]

		/* Select the main PLL as system clock source */
		RCC->CFGR &= (uint32_t)((uint32_t)~(RCC_CFGR_SW));
 80155b0:	4a0c      	ldr	r2, [pc, #48]	; (80155e4 <SetSysClock+0xe8>)
 80155b2:	4b0c      	ldr	r3, [pc, #48]	; (80155e4 <SetSysClock+0xe8>)
 80155b4:	689b      	ldr	r3, [r3, #8]
 80155b6:	f023 0303 	bic.w	r3, r3, #3
 80155ba:	6093      	str	r3, [r2, #8]
		RCC->CFGR |= RCC_CFGR_SW_PLL;
 80155bc:	4a09      	ldr	r2, [pc, #36]	; (80155e4 <SetSysClock+0xe8>)
 80155be:	4b09      	ldr	r3, [pc, #36]	; (80155e4 <SetSysClock+0xe8>)
 80155c0:	689b      	ldr	r3, [r3, #8]
 80155c2:	f043 0302 	orr.w	r3, r3, #2
 80155c6:	6093      	str	r3, [r2, #8]

		/* Wait till the main PLL is used as system clock source */
		while ((RCC->CFGR & (uint32_t)RCC_CFGR_SWS ) != RCC_CFGR_SWS_PLL);
 80155c8:	bf00      	nop
 80155ca:	4b06      	ldr	r3, [pc, #24]	; (80155e4 <SetSysClock+0xe8>)
 80155cc:	689b      	ldr	r3, [r3, #8]
 80155ce:	f003 030c 	and.w	r3, r3, #12
 80155d2:	2b08      	cmp	r3, #8
 80155d4:	d1f9      	bne.n	80155ca <SetSysClock+0xce>
	/* Wait till PLLI2S is ready */
	while((RCC->CR & RCC_CR_PLLI2SRDY) == 0)
	{
	}
#endif
}
 80155d6:	bf00      	nop
 80155d8:	370c      	adds	r7, #12
 80155da:	46bd      	mov	sp, r7
 80155dc:	f85d 7b04 	ldr.w	r7, [sp], #4
 80155e0:	4770      	bx	lr
 80155e2:	bf00      	nop
 80155e4:	40023800 	.word	0x40023800
 80155e8:	40007000 	.word	0x40007000
 80155ec:	07405408 	.word	0x07405408
 80155f0:	40023c00 	.word	0x40023c00

080155f4 <ftostr>:
#include "utils.h"
#include <math.h>
#include <stdint.h>
#include <stdio.h>

char* ftostr(float value, int places) {
 80155f4:	b580      	push	{r7, lr}
 80155f6:	ed2d 8b02 	vpush	{d8}
 80155fa:	b08a      	sub	sp, #40	; 0x28
 80155fc:	af04      	add	r7, sp, #16
 80155fe:	ed87 0a01 	vstr	s0, [r7, #4]
 8015602:	6038      	str	r0, [r7, #0]
	static char buffer[100];
	uint32_t whole;
	uint32_t fraction;
	char sign[2] = "";
 8015604:	2300      	movs	r3, #0
 8015606:	81bb      	strh	r3, [r7, #12]

	if (value < 0) {
 8015608:	edd7 7a01 	vldr	s15, [r7, #4]
 801560c:	eef5 7ac0 	vcmpe.f32	s15, #0.0
 8015610:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8015614:	d509      	bpl.n	801562a <ftostr+0x36>
		value = -value;
 8015616:	edd7 7a01 	vldr	s15, [r7, #4]
 801561a:	eef1 7a67 	vneg.f32	s15, s15
 801561e:	edc7 7a01 	vstr	s15, [r7, #4]
		sign[0] = '-';
 8015622:	232d      	movs	r3, #45	; 0x2d
 8015624:	733b      	strb	r3, [r7, #12]
		sign[1] = '\0';
 8015626:	2300      	movs	r3, #0
 8015628:	737b      	strb	r3, [r7, #13]
	}

	whole = (uint32_t) value;
 801562a:	edd7 7a01 	vldr	s15, [r7, #4]
 801562e:	eefc 7ae7 	vcvt.u32.f32	s15, s15
 8015632:	ee17 3a90 	vmov	r3, s15
 8015636:	617b      	str	r3, [r7, #20]
	fraction = (uint32_t) ((value - floorf(value)) * powf(10.0f, (float)places) + 0.5f);
 8015638:	ed97 0a01 	vldr	s0, [r7, #4]
 801563c:	f000 fd50 	bl	80160e0 <floorf>
 8015640:	eeb0 7a40 	vmov.f32	s14, s0
 8015644:	edd7 7a01 	vldr	s15, [r7, #4]
 8015648:	ee37 8ac7 	vsub.f32	s16, s15, s14
 801564c:	683b      	ldr	r3, [r7, #0]
 801564e:	ee07 3a90 	vmov	s15, r3
 8015652:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 8015656:	eef0 0a67 	vmov.f32	s1, s15
 801565a:	eeb2 0a04 	vmov.f32	s0, #36	; 0x41200000  10.0
 801565e:	f000 fd81 	bl	8016164 <powf>
 8015662:	eef0 7a40 	vmov.f32	s15, s0
 8015666:	ee68 7a27 	vmul.f32	s15, s16, s15
 801566a:	eeb6 7a00 	vmov.f32	s14, #96	; 0x3f000000  0.5
 801566e:	ee77 7a87 	vadd.f32	s15, s15, s14
 8015672:	eefc 7ae7 	vcvt.u32.f32	s15, s15
 8015676:	ee17 3a90 	vmov	r3, s15
 801567a:	613b      	str	r3, [r7, #16]
	sprintf(buffer, "%s%lu.%*.*lu", sign, whole, places, places, fraction);
 801567c:	f107 020c 	add.w	r2, r7, #12
 8015680:	693b      	ldr	r3, [r7, #16]
 8015682:	9302      	str	r3, [sp, #8]
 8015684:	683b      	ldr	r3, [r7, #0]
 8015686:	9301      	str	r3, [sp, #4]
 8015688:	683b      	ldr	r3, [r7, #0]
 801568a:	9300      	str	r3, [sp, #0]
 801568c:	697b      	ldr	r3, [r7, #20]
 801568e:	4905      	ldr	r1, [pc, #20]	; (80156a4 <ftostr+0xb0>)
 8015690:	4805      	ldr	r0, [pc, #20]	; (80156a8 <ftostr+0xb4>)
 8015692:	f001 fb65 	bl	8016d60 <siprintf>

	return buffer;
 8015696:	4b04      	ldr	r3, [pc, #16]	; (80156a8 <ftostr+0xb4>)
}
 8015698:	4618      	mov	r0, r3
 801569a:	3718      	adds	r7, #24
 801569c:	46bd      	mov	sp, r7
 801569e:	ecbd 8b02 	vpop	{d8}
 80156a2:	bd80      	pop	{r7, pc}
 80156a4:	0806bc14 	.word	0x0806bc14
 80156a8:	20009dd8 	.word	0x20009dd8
 80156ac:	00000000 	.word	0x00000000

080156b0 <memchr>:
 80156b0:	f001 01ff 	and.w	r1, r1, #255	; 0xff
 80156b4:	2a10      	cmp	r2, #16
 80156b6:	db2b      	blt.n	8015710 <memchr+0x60>
 80156b8:	f010 0f07 	tst.w	r0, #7
 80156bc:	d008      	beq.n	80156d0 <memchr+0x20>
 80156be:	f810 3b01 	ldrb.w	r3, [r0], #1
 80156c2:	3a01      	subs	r2, #1
 80156c4:	428b      	cmp	r3, r1
 80156c6:	d02d      	beq.n	8015724 <memchr+0x74>
 80156c8:	f010 0f07 	tst.w	r0, #7
 80156cc:	b342      	cbz	r2, 8015720 <memchr+0x70>
 80156ce:	d1f6      	bne.n	80156be <memchr+0xe>
 80156d0:	b4f0      	push	{r4, r5, r6, r7}
 80156d2:	ea41 2101 	orr.w	r1, r1, r1, lsl #8
 80156d6:	ea41 4101 	orr.w	r1, r1, r1, lsl #16
 80156da:	f022 0407 	bic.w	r4, r2, #7
 80156de:	f07f 0700 	mvns.w	r7, #0
 80156e2:	2300      	movs	r3, #0
 80156e4:	e8f0 5602 	ldrd	r5, r6, [r0], #8
 80156e8:	3c08      	subs	r4, #8
 80156ea:	ea85 0501 	eor.w	r5, r5, r1
 80156ee:	ea86 0601 	eor.w	r6, r6, r1
 80156f2:	fa85 f547 	uadd8	r5, r5, r7
 80156f6:	faa3 f587 	sel	r5, r3, r7
 80156fa:	fa86 f647 	uadd8	r6, r6, r7
 80156fe:	faa5 f687 	sel	r6, r5, r7
 8015702:	b98e      	cbnz	r6, 8015728 <memchr+0x78>
 8015704:	d1ee      	bne.n	80156e4 <memchr+0x34>
 8015706:	bcf0      	pop	{r4, r5, r6, r7}
 8015708:	f001 01ff 	and.w	r1, r1, #255	; 0xff
 801570c:	f002 0207 	and.w	r2, r2, #7
 8015710:	b132      	cbz	r2, 8015720 <memchr+0x70>
 8015712:	f810 3b01 	ldrb.w	r3, [r0], #1
 8015716:	3a01      	subs	r2, #1
 8015718:	ea83 0301 	eor.w	r3, r3, r1
 801571c:	b113      	cbz	r3, 8015724 <memchr+0x74>
 801571e:	d1f8      	bne.n	8015712 <memchr+0x62>
 8015720:	2000      	movs	r0, #0
 8015722:	4770      	bx	lr
 8015724:	3801      	subs	r0, #1
 8015726:	4770      	bx	lr
 8015728:	2d00      	cmp	r5, #0
 801572a:	bf06      	itte	eq
 801572c:	4635      	moveq	r5, r6
 801572e:	3803      	subeq	r0, #3
 8015730:	3807      	subne	r0, #7
 8015732:	f015 0f01 	tst.w	r5, #1
 8015736:	d107      	bne.n	8015748 <memchr+0x98>
 8015738:	3001      	adds	r0, #1
 801573a:	f415 7f80 	tst.w	r5, #256	; 0x100
 801573e:	bf02      	ittt	eq
 8015740:	3001      	addeq	r0, #1
 8015742:	f415 3fc0 	tsteq.w	r5, #98304	; 0x18000
 8015746:	3001      	addeq	r0, #1
 8015748:	bcf0      	pop	{r4, r5, r6, r7}
 801574a:	3801      	subs	r0, #1
 801574c:	4770      	bx	lr
 801574e:	bf00      	nop

08015750 <__aeabi_drsub>:
 8015750:	f081 4100 	eor.w	r1, r1, #2147483648	; 0x80000000
 8015754:	e002      	b.n	801575c <__adddf3>
 8015756:	bf00      	nop

08015758 <__aeabi_dsub>:
 8015758:	f083 4300 	eor.w	r3, r3, #2147483648	; 0x80000000

0801575c <__adddf3>:
 801575c:	b530      	push	{r4, r5, lr}
 801575e:	ea4f 0441 	mov.w	r4, r1, lsl #1
 8015762:	ea4f 0543 	mov.w	r5, r3, lsl #1
 8015766:	ea94 0f05 	teq	r4, r5
 801576a:	bf08      	it	eq
 801576c:	ea90 0f02 	teqeq	r0, r2
 8015770:	bf1f      	itttt	ne
 8015772:	ea54 0c00 	orrsne.w	ip, r4, r0
 8015776:	ea55 0c02 	orrsne.w	ip, r5, r2
 801577a:	ea7f 5c64 	mvnsne.w	ip, r4, asr #21
 801577e:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
 8015782:	f000 80e2 	beq.w	801594a <__adddf3+0x1ee>
 8015786:	ea4f 5454 	mov.w	r4, r4, lsr #21
 801578a:	ebd4 5555 	rsbs	r5, r4, r5, lsr #21
 801578e:	bfb8      	it	lt
 8015790:	426d      	neglt	r5, r5
 8015792:	dd0c      	ble.n	80157ae <__adddf3+0x52>
 8015794:	442c      	add	r4, r5
 8015796:	ea80 0202 	eor.w	r2, r0, r2
 801579a:	ea81 0303 	eor.w	r3, r1, r3
 801579e:	ea82 0000 	eor.w	r0, r2, r0
 80157a2:	ea83 0101 	eor.w	r1, r3, r1
 80157a6:	ea80 0202 	eor.w	r2, r0, r2
 80157aa:	ea81 0303 	eor.w	r3, r1, r3
 80157ae:	2d36      	cmp	r5, #54	; 0x36
 80157b0:	bf88      	it	hi
 80157b2:	bd30      	pophi	{r4, r5, pc}
 80157b4:	f011 4f00 	tst.w	r1, #2147483648	; 0x80000000
 80157b8:	ea4f 3101 	mov.w	r1, r1, lsl #12
 80157bc:	f44f 1c80 	mov.w	ip, #1048576	; 0x100000
 80157c0:	ea4c 3111 	orr.w	r1, ip, r1, lsr #12
 80157c4:	d002      	beq.n	80157cc <__adddf3+0x70>
 80157c6:	4240      	negs	r0, r0
 80157c8:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 80157cc:	f013 4f00 	tst.w	r3, #2147483648	; 0x80000000
 80157d0:	ea4f 3303 	mov.w	r3, r3, lsl #12
 80157d4:	ea4c 3313 	orr.w	r3, ip, r3, lsr #12
 80157d8:	d002      	beq.n	80157e0 <__adddf3+0x84>
 80157da:	4252      	negs	r2, r2
 80157dc:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
 80157e0:	ea94 0f05 	teq	r4, r5
 80157e4:	f000 80a7 	beq.w	8015936 <__adddf3+0x1da>
 80157e8:	f1a4 0401 	sub.w	r4, r4, #1
 80157ec:	f1d5 0e20 	rsbs	lr, r5, #32
 80157f0:	db0d      	blt.n	801580e <__adddf3+0xb2>
 80157f2:	fa02 fc0e 	lsl.w	ip, r2, lr
 80157f6:	fa22 f205 	lsr.w	r2, r2, r5
 80157fa:	1880      	adds	r0, r0, r2
 80157fc:	f141 0100 	adc.w	r1, r1, #0
 8015800:	fa03 f20e 	lsl.w	r2, r3, lr
 8015804:	1880      	adds	r0, r0, r2
 8015806:	fa43 f305 	asr.w	r3, r3, r5
 801580a:	4159      	adcs	r1, r3
 801580c:	e00e      	b.n	801582c <__adddf3+0xd0>
 801580e:	f1a5 0520 	sub.w	r5, r5, #32
 8015812:	f10e 0e20 	add.w	lr, lr, #32
 8015816:	2a01      	cmp	r2, #1
 8015818:	fa03 fc0e 	lsl.w	ip, r3, lr
 801581c:	bf28      	it	cs
 801581e:	f04c 0c02 	orrcs.w	ip, ip, #2
 8015822:	fa43 f305 	asr.w	r3, r3, r5
 8015826:	18c0      	adds	r0, r0, r3
 8015828:	eb51 71e3 	adcs.w	r1, r1, r3, asr #31
 801582c:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
 8015830:	d507      	bpl.n	8015842 <__adddf3+0xe6>
 8015832:	f04f 0e00 	mov.w	lr, #0
 8015836:	f1dc 0c00 	rsbs	ip, ip, #0
 801583a:	eb7e 0000 	sbcs.w	r0, lr, r0
 801583e:	eb6e 0101 	sbc.w	r1, lr, r1
 8015842:	f5b1 1f80 	cmp.w	r1, #1048576	; 0x100000
 8015846:	d31b      	bcc.n	8015880 <__adddf3+0x124>
 8015848:	f5b1 1f00 	cmp.w	r1, #2097152	; 0x200000
 801584c:	d30c      	bcc.n	8015868 <__adddf3+0x10c>
 801584e:	0849      	lsrs	r1, r1, #1
 8015850:	ea5f 0030 	movs.w	r0, r0, rrx
 8015854:	ea4f 0c3c 	mov.w	ip, ip, rrx
 8015858:	f104 0401 	add.w	r4, r4, #1
 801585c:	ea4f 5244 	mov.w	r2, r4, lsl #21
 8015860:	f512 0f80 	cmn.w	r2, #4194304	; 0x400000
 8015864:	f080 809a 	bcs.w	801599c <__adddf3+0x240>
 8015868:	f1bc 4f00 	cmp.w	ip, #2147483648	; 0x80000000
 801586c:	bf08      	it	eq
 801586e:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
 8015872:	f150 0000 	adcs.w	r0, r0, #0
 8015876:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
 801587a:	ea41 0105 	orr.w	r1, r1, r5
 801587e:	bd30      	pop	{r4, r5, pc}
 8015880:	ea5f 0c4c 	movs.w	ip, ip, lsl #1
 8015884:	4140      	adcs	r0, r0
 8015886:	eb41 0101 	adc.w	r1, r1, r1
 801588a:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
 801588e:	f1a4 0401 	sub.w	r4, r4, #1
 8015892:	d1e9      	bne.n	8015868 <__adddf3+0x10c>
 8015894:	f091 0f00 	teq	r1, #0
 8015898:	bf04      	itt	eq
 801589a:	4601      	moveq	r1, r0
 801589c:	2000      	moveq	r0, #0
 801589e:	fab1 f381 	clz	r3, r1
 80158a2:	bf08      	it	eq
 80158a4:	3320      	addeq	r3, #32
 80158a6:	f1a3 030b 	sub.w	r3, r3, #11
 80158aa:	f1b3 0220 	subs.w	r2, r3, #32
 80158ae:	da0c      	bge.n	80158ca <__adddf3+0x16e>
 80158b0:	320c      	adds	r2, #12
 80158b2:	dd08      	ble.n	80158c6 <__adddf3+0x16a>
 80158b4:	f102 0c14 	add.w	ip, r2, #20
 80158b8:	f1c2 020c 	rsb	r2, r2, #12
 80158bc:	fa01 f00c 	lsl.w	r0, r1, ip
 80158c0:	fa21 f102 	lsr.w	r1, r1, r2
 80158c4:	e00c      	b.n	80158e0 <__adddf3+0x184>
 80158c6:	f102 0214 	add.w	r2, r2, #20
 80158ca:	bfd8      	it	le
 80158cc:	f1c2 0c20 	rsble	ip, r2, #32
 80158d0:	fa01 f102 	lsl.w	r1, r1, r2
 80158d4:	fa20 fc0c 	lsr.w	ip, r0, ip
 80158d8:	bfdc      	itt	le
 80158da:	ea41 010c 	orrle.w	r1, r1, ip
 80158de:	4090      	lslle	r0, r2
 80158e0:	1ae4      	subs	r4, r4, r3
 80158e2:	bfa2      	ittt	ge
 80158e4:	eb01 5104 	addge.w	r1, r1, r4, lsl #20
 80158e8:	4329      	orrge	r1, r5
 80158ea:	bd30      	popge	{r4, r5, pc}
 80158ec:	ea6f 0404 	mvn.w	r4, r4
 80158f0:	3c1f      	subs	r4, #31
 80158f2:	da1c      	bge.n	801592e <__adddf3+0x1d2>
 80158f4:	340c      	adds	r4, #12
 80158f6:	dc0e      	bgt.n	8015916 <__adddf3+0x1ba>
 80158f8:	f104 0414 	add.w	r4, r4, #20
 80158fc:	f1c4 0220 	rsb	r2, r4, #32
 8015900:	fa20 f004 	lsr.w	r0, r0, r4
 8015904:	fa01 f302 	lsl.w	r3, r1, r2
 8015908:	ea40 0003 	orr.w	r0, r0, r3
 801590c:	fa21 f304 	lsr.w	r3, r1, r4
 8015910:	ea45 0103 	orr.w	r1, r5, r3
 8015914:	bd30      	pop	{r4, r5, pc}
 8015916:	f1c4 040c 	rsb	r4, r4, #12
 801591a:	f1c4 0220 	rsb	r2, r4, #32
 801591e:	fa20 f002 	lsr.w	r0, r0, r2
 8015922:	fa01 f304 	lsl.w	r3, r1, r4
 8015926:	ea40 0003 	orr.w	r0, r0, r3
 801592a:	4629      	mov	r1, r5
 801592c:	bd30      	pop	{r4, r5, pc}
 801592e:	fa21 f004 	lsr.w	r0, r1, r4
 8015932:	4629      	mov	r1, r5
 8015934:	bd30      	pop	{r4, r5, pc}
 8015936:	f094 0f00 	teq	r4, #0
 801593a:	f483 1380 	eor.w	r3, r3, #1048576	; 0x100000
 801593e:	bf06      	itte	eq
 8015940:	f481 1180 	eoreq.w	r1, r1, #1048576	; 0x100000
 8015944:	3401      	addeq	r4, #1
 8015946:	3d01      	subne	r5, #1
 8015948:	e74e      	b.n	80157e8 <__adddf3+0x8c>
 801594a:	ea7f 5c64 	mvns.w	ip, r4, asr #21
 801594e:	bf18      	it	ne
 8015950:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
 8015954:	d029      	beq.n	80159aa <__adddf3+0x24e>
 8015956:	ea94 0f05 	teq	r4, r5
 801595a:	bf08      	it	eq
 801595c:	ea90 0f02 	teqeq	r0, r2
 8015960:	d005      	beq.n	801596e <__adddf3+0x212>
 8015962:	ea54 0c00 	orrs.w	ip, r4, r0
 8015966:	bf04      	itt	eq
 8015968:	4619      	moveq	r1, r3
 801596a:	4610      	moveq	r0, r2
 801596c:	bd30      	pop	{r4, r5, pc}
 801596e:	ea91 0f03 	teq	r1, r3
 8015972:	bf1e      	ittt	ne
 8015974:	2100      	movne	r1, #0
 8015976:	2000      	movne	r0, #0
 8015978:	bd30      	popne	{r4, r5, pc}
 801597a:	ea5f 5c54 	movs.w	ip, r4, lsr #21
 801597e:	d105      	bne.n	801598c <__adddf3+0x230>
 8015980:	0040      	lsls	r0, r0, #1
 8015982:	4149      	adcs	r1, r1
 8015984:	bf28      	it	cs
 8015986:	f041 4100 	orrcs.w	r1, r1, #2147483648	; 0x80000000
 801598a:	bd30      	pop	{r4, r5, pc}
 801598c:	f514 0480 	adds.w	r4, r4, #4194304	; 0x400000
 8015990:	bf3c      	itt	cc
 8015992:	f501 1180 	addcc.w	r1, r1, #1048576	; 0x100000
 8015996:	bd30      	popcc	{r4, r5, pc}
 8015998:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
 801599c:	f045 41fe 	orr.w	r1, r5, #2130706432	; 0x7f000000
 80159a0:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
 80159a4:	f04f 0000 	mov.w	r0, #0
 80159a8:	bd30      	pop	{r4, r5, pc}
 80159aa:	ea7f 5c64 	mvns.w	ip, r4, asr #21
 80159ae:	bf1a      	itte	ne
 80159b0:	4619      	movne	r1, r3
 80159b2:	4610      	movne	r0, r2
 80159b4:	ea7f 5c65 	mvnseq.w	ip, r5, asr #21
 80159b8:	bf1c      	itt	ne
 80159ba:	460b      	movne	r3, r1
 80159bc:	4602      	movne	r2, r0
 80159be:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
 80159c2:	bf06      	itte	eq
 80159c4:	ea52 3503 	orrseq.w	r5, r2, r3, lsl #12
 80159c8:	ea91 0f03 	teqeq	r1, r3
 80159cc:	f441 2100 	orrne.w	r1, r1, #524288	; 0x80000
 80159d0:	bd30      	pop	{r4, r5, pc}
 80159d2:	bf00      	nop

080159d4 <__aeabi_ui2d>:
 80159d4:	f090 0f00 	teq	r0, #0
 80159d8:	bf04      	itt	eq
 80159da:	2100      	moveq	r1, #0
 80159dc:	4770      	bxeq	lr
 80159de:	b530      	push	{r4, r5, lr}
 80159e0:	f44f 6480 	mov.w	r4, #1024	; 0x400
 80159e4:	f104 0432 	add.w	r4, r4, #50	; 0x32
 80159e8:	f04f 0500 	mov.w	r5, #0
 80159ec:	f04f 0100 	mov.w	r1, #0
 80159f0:	e750      	b.n	8015894 <__adddf3+0x138>
 80159f2:	bf00      	nop

080159f4 <__aeabi_i2d>:
 80159f4:	f090 0f00 	teq	r0, #0
 80159f8:	bf04      	itt	eq
 80159fa:	2100      	moveq	r1, #0
 80159fc:	4770      	bxeq	lr
 80159fe:	b530      	push	{r4, r5, lr}
 8015a00:	f44f 6480 	mov.w	r4, #1024	; 0x400
 8015a04:	f104 0432 	add.w	r4, r4, #50	; 0x32
 8015a08:	f010 4500 	ands.w	r5, r0, #2147483648	; 0x80000000
 8015a0c:	bf48      	it	mi
 8015a0e:	4240      	negmi	r0, r0
 8015a10:	f04f 0100 	mov.w	r1, #0
 8015a14:	e73e      	b.n	8015894 <__adddf3+0x138>
 8015a16:	bf00      	nop

08015a18 <__aeabi_f2d>:
 8015a18:	0042      	lsls	r2, r0, #1
 8015a1a:	ea4f 01e2 	mov.w	r1, r2, asr #3
 8015a1e:	ea4f 0131 	mov.w	r1, r1, rrx
 8015a22:	ea4f 7002 	mov.w	r0, r2, lsl #28
 8015a26:	bf1f      	itttt	ne
 8015a28:	f012 437f 	andsne.w	r3, r2, #4278190080	; 0xff000000
 8015a2c:	f093 4f7f 	teqne	r3, #4278190080	; 0xff000000
 8015a30:	f081 5160 	eorne.w	r1, r1, #939524096	; 0x38000000
 8015a34:	4770      	bxne	lr
 8015a36:	f092 0f00 	teq	r2, #0
 8015a3a:	bf14      	ite	ne
 8015a3c:	f093 4f7f 	teqne	r3, #4278190080	; 0xff000000
 8015a40:	4770      	bxeq	lr
 8015a42:	b530      	push	{r4, r5, lr}
 8015a44:	f44f 7460 	mov.w	r4, #896	; 0x380
 8015a48:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
 8015a4c:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
 8015a50:	e720      	b.n	8015894 <__adddf3+0x138>
 8015a52:	bf00      	nop

08015a54 <__aeabi_ul2d>:
 8015a54:	ea50 0201 	orrs.w	r2, r0, r1
 8015a58:	bf08      	it	eq
 8015a5a:	4770      	bxeq	lr
 8015a5c:	b530      	push	{r4, r5, lr}
 8015a5e:	f04f 0500 	mov.w	r5, #0
 8015a62:	e00a      	b.n	8015a7a <__aeabi_l2d+0x16>

08015a64 <__aeabi_l2d>:
 8015a64:	ea50 0201 	orrs.w	r2, r0, r1
 8015a68:	bf08      	it	eq
 8015a6a:	4770      	bxeq	lr
 8015a6c:	b530      	push	{r4, r5, lr}
 8015a6e:	f011 4500 	ands.w	r5, r1, #2147483648	; 0x80000000
 8015a72:	d502      	bpl.n	8015a7a <__aeabi_l2d+0x16>
 8015a74:	4240      	negs	r0, r0
 8015a76:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 8015a7a:	f44f 6480 	mov.w	r4, #1024	; 0x400
 8015a7e:	f104 0432 	add.w	r4, r4, #50	; 0x32
 8015a82:	ea5f 5c91 	movs.w	ip, r1, lsr #22
 8015a86:	f43f aedc 	beq.w	8015842 <__adddf3+0xe6>
 8015a8a:	f04f 0203 	mov.w	r2, #3
 8015a8e:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
 8015a92:	bf18      	it	ne
 8015a94:	3203      	addne	r2, #3
 8015a96:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
 8015a9a:	bf18      	it	ne
 8015a9c:	3203      	addne	r2, #3
 8015a9e:	eb02 02dc 	add.w	r2, r2, ip, lsr #3
 8015aa2:	f1c2 0320 	rsb	r3, r2, #32
 8015aa6:	fa00 fc03 	lsl.w	ip, r0, r3
 8015aaa:	fa20 f002 	lsr.w	r0, r0, r2
 8015aae:	fa01 fe03 	lsl.w	lr, r1, r3
 8015ab2:	ea40 000e 	orr.w	r0, r0, lr
 8015ab6:	fa21 f102 	lsr.w	r1, r1, r2
 8015aba:	4414      	add	r4, r2
 8015abc:	e6c1      	b.n	8015842 <__adddf3+0xe6>
 8015abe:	bf00      	nop

08015ac0 <__aeabi_dmul>:
 8015ac0:	b570      	push	{r4, r5, r6, lr}
 8015ac2:	f04f 0cff 	mov.w	ip, #255	; 0xff
 8015ac6:	f44c 6ce0 	orr.w	ip, ip, #1792	; 0x700
 8015aca:	ea1c 5411 	ands.w	r4, ip, r1, lsr #20
 8015ace:	bf1d      	ittte	ne
 8015ad0:	ea1c 5513 	andsne.w	r5, ip, r3, lsr #20
 8015ad4:	ea94 0f0c 	teqne	r4, ip
 8015ad8:	ea95 0f0c 	teqne	r5, ip
 8015adc:	f000 f8de 	bleq	8015c9c <__aeabi_dmul+0x1dc>
 8015ae0:	442c      	add	r4, r5
 8015ae2:	ea81 0603 	eor.w	r6, r1, r3
 8015ae6:	ea21 514c 	bic.w	r1, r1, ip, lsl #21
 8015aea:	ea23 534c 	bic.w	r3, r3, ip, lsl #21
 8015aee:	ea50 3501 	orrs.w	r5, r0, r1, lsl #12
 8015af2:	bf18      	it	ne
 8015af4:	ea52 3503 	orrsne.w	r5, r2, r3, lsl #12
 8015af8:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
 8015afc:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
 8015b00:	d038      	beq.n	8015b74 <__aeabi_dmul+0xb4>
 8015b02:	fba0 ce02 	umull	ip, lr, r0, r2
 8015b06:	f04f 0500 	mov.w	r5, #0
 8015b0a:	fbe1 e502 	umlal	lr, r5, r1, r2
 8015b0e:	f006 4200 	and.w	r2, r6, #2147483648	; 0x80000000
 8015b12:	fbe0 e503 	umlal	lr, r5, r0, r3
 8015b16:	f04f 0600 	mov.w	r6, #0
 8015b1a:	fbe1 5603 	umlal	r5, r6, r1, r3
 8015b1e:	f09c 0f00 	teq	ip, #0
 8015b22:	bf18      	it	ne
 8015b24:	f04e 0e01 	orrne.w	lr, lr, #1
 8015b28:	f1a4 04ff 	sub.w	r4, r4, #255	; 0xff
 8015b2c:	f5b6 7f00 	cmp.w	r6, #512	; 0x200
 8015b30:	f564 7440 	sbc.w	r4, r4, #768	; 0x300
 8015b34:	d204      	bcs.n	8015b40 <__aeabi_dmul+0x80>
 8015b36:	ea5f 0e4e 	movs.w	lr, lr, lsl #1
 8015b3a:	416d      	adcs	r5, r5
 8015b3c:	eb46 0606 	adc.w	r6, r6, r6
 8015b40:	ea42 21c6 	orr.w	r1, r2, r6, lsl #11
 8015b44:	ea41 5155 	orr.w	r1, r1, r5, lsr #21
 8015b48:	ea4f 20c5 	mov.w	r0, r5, lsl #11
 8015b4c:	ea40 505e 	orr.w	r0, r0, lr, lsr #21
 8015b50:	ea4f 2ece 	mov.w	lr, lr, lsl #11
 8015b54:	f1b4 0cfd 	subs.w	ip, r4, #253	; 0xfd
 8015b58:	bf88      	it	hi
 8015b5a:	f5bc 6fe0 	cmphi.w	ip, #1792	; 0x700
 8015b5e:	d81e      	bhi.n	8015b9e <__aeabi_dmul+0xde>
 8015b60:	f1be 4f00 	cmp.w	lr, #2147483648	; 0x80000000
 8015b64:	bf08      	it	eq
 8015b66:	ea5f 0e50 	movseq.w	lr, r0, lsr #1
 8015b6a:	f150 0000 	adcs.w	r0, r0, #0
 8015b6e:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
 8015b72:	bd70      	pop	{r4, r5, r6, pc}
 8015b74:	f006 4600 	and.w	r6, r6, #2147483648	; 0x80000000
 8015b78:	ea46 0101 	orr.w	r1, r6, r1
 8015b7c:	ea40 0002 	orr.w	r0, r0, r2
 8015b80:	ea81 0103 	eor.w	r1, r1, r3
 8015b84:	ebb4 045c 	subs.w	r4, r4, ip, lsr #1
 8015b88:	bfc2      	ittt	gt
 8015b8a:	ebd4 050c 	rsbsgt	r5, r4, ip
 8015b8e:	ea41 5104 	orrgt.w	r1, r1, r4, lsl #20
 8015b92:	bd70      	popgt	{r4, r5, r6, pc}
 8015b94:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
 8015b98:	f04f 0e00 	mov.w	lr, #0
 8015b9c:	3c01      	subs	r4, #1
 8015b9e:	f300 80ab 	bgt.w	8015cf8 <__aeabi_dmul+0x238>
 8015ba2:	f114 0f36 	cmn.w	r4, #54	; 0x36
 8015ba6:	bfde      	ittt	le
 8015ba8:	2000      	movle	r0, #0
 8015baa:	f001 4100 	andle.w	r1, r1, #2147483648	; 0x80000000
 8015bae:	bd70      	pople	{r4, r5, r6, pc}
 8015bb0:	f1c4 0400 	rsb	r4, r4, #0
 8015bb4:	3c20      	subs	r4, #32
 8015bb6:	da35      	bge.n	8015c24 <__aeabi_dmul+0x164>
 8015bb8:	340c      	adds	r4, #12
 8015bba:	dc1b      	bgt.n	8015bf4 <__aeabi_dmul+0x134>
 8015bbc:	f104 0414 	add.w	r4, r4, #20
 8015bc0:	f1c4 0520 	rsb	r5, r4, #32
 8015bc4:	fa00 f305 	lsl.w	r3, r0, r5
 8015bc8:	fa20 f004 	lsr.w	r0, r0, r4
 8015bcc:	fa01 f205 	lsl.w	r2, r1, r5
 8015bd0:	ea40 0002 	orr.w	r0, r0, r2
 8015bd4:	f001 4200 	and.w	r2, r1, #2147483648	; 0x80000000
 8015bd8:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
 8015bdc:	eb10 70d3 	adds.w	r0, r0, r3, lsr #31
 8015be0:	fa21 f604 	lsr.w	r6, r1, r4
 8015be4:	eb42 0106 	adc.w	r1, r2, r6
 8015be8:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
 8015bec:	bf08      	it	eq
 8015bee:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
 8015bf2:	bd70      	pop	{r4, r5, r6, pc}
 8015bf4:	f1c4 040c 	rsb	r4, r4, #12
 8015bf8:	f1c4 0520 	rsb	r5, r4, #32
 8015bfc:	fa00 f304 	lsl.w	r3, r0, r4
 8015c00:	fa20 f005 	lsr.w	r0, r0, r5
 8015c04:	fa01 f204 	lsl.w	r2, r1, r4
 8015c08:	ea40 0002 	orr.w	r0, r0, r2
 8015c0c:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 8015c10:	eb10 70d3 	adds.w	r0, r0, r3, lsr #31
 8015c14:	f141 0100 	adc.w	r1, r1, #0
 8015c18:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
 8015c1c:	bf08      	it	eq
 8015c1e:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
 8015c22:	bd70      	pop	{r4, r5, r6, pc}
 8015c24:	f1c4 0520 	rsb	r5, r4, #32
 8015c28:	fa00 f205 	lsl.w	r2, r0, r5
 8015c2c:	ea4e 0e02 	orr.w	lr, lr, r2
 8015c30:	fa20 f304 	lsr.w	r3, r0, r4
 8015c34:	fa01 f205 	lsl.w	r2, r1, r5
 8015c38:	ea43 0302 	orr.w	r3, r3, r2
 8015c3c:	fa21 f004 	lsr.w	r0, r1, r4
 8015c40:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 8015c44:	fa21 f204 	lsr.w	r2, r1, r4
 8015c48:	ea20 0002 	bic.w	r0, r0, r2
 8015c4c:	eb00 70d3 	add.w	r0, r0, r3, lsr #31
 8015c50:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
 8015c54:	bf08      	it	eq
 8015c56:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
 8015c5a:	bd70      	pop	{r4, r5, r6, pc}
 8015c5c:	f094 0f00 	teq	r4, #0
 8015c60:	d10f      	bne.n	8015c82 <__aeabi_dmul+0x1c2>
 8015c62:	f001 4600 	and.w	r6, r1, #2147483648	; 0x80000000
 8015c66:	0040      	lsls	r0, r0, #1
 8015c68:	eb41 0101 	adc.w	r1, r1, r1
 8015c6c:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
 8015c70:	bf08      	it	eq
 8015c72:	3c01      	subeq	r4, #1
 8015c74:	d0f7      	beq.n	8015c66 <__aeabi_dmul+0x1a6>
 8015c76:	ea41 0106 	orr.w	r1, r1, r6
 8015c7a:	f095 0f00 	teq	r5, #0
 8015c7e:	bf18      	it	ne
 8015c80:	4770      	bxne	lr
 8015c82:	f003 4600 	and.w	r6, r3, #2147483648	; 0x80000000
 8015c86:	0052      	lsls	r2, r2, #1
 8015c88:	eb43 0303 	adc.w	r3, r3, r3
 8015c8c:	f413 1f80 	tst.w	r3, #1048576	; 0x100000
 8015c90:	bf08      	it	eq
 8015c92:	3d01      	subeq	r5, #1
 8015c94:	d0f7      	beq.n	8015c86 <__aeabi_dmul+0x1c6>
 8015c96:	ea43 0306 	orr.w	r3, r3, r6
 8015c9a:	4770      	bx	lr
 8015c9c:	ea94 0f0c 	teq	r4, ip
 8015ca0:	ea0c 5513 	and.w	r5, ip, r3, lsr #20
 8015ca4:	bf18      	it	ne
 8015ca6:	ea95 0f0c 	teqne	r5, ip
 8015caa:	d00c      	beq.n	8015cc6 <__aeabi_dmul+0x206>
 8015cac:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
 8015cb0:	bf18      	it	ne
 8015cb2:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
 8015cb6:	d1d1      	bne.n	8015c5c <__aeabi_dmul+0x19c>
 8015cb8:	ea81 0103 	eor.w	r1, r1, r3
 8015cbc:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 8015cc0:	f04f 0000 	mov.w	r0, #0
 8015cc4:	bd70      	pop	{r4, r5, r6, pc}
 8015cc6:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
 8015cca:	bf06      	itte	eq
 8015ccc:	4610      	moveq	r0, r2
 8015cce:	4619      	moveq	r1, r3
 8015cd0:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
 8015cd4:	d019      	beq.n	8015d0a <__aeabi_dmul+0x24a>
 8015cd6:	ea94 0f0c 	teq	r4, ip
 8015cda:	d102      	bne.n	8015ce2 <__aeabi_dmul+0x222>
 8015cdc:	ea50 3601 	orrs.w	r6, r0, r1, lsl #12
 8015ce0:	d113      	bne.n	8015d0a <__aeabi_dmul+0x24a>
 8015ce2:	ea95 0f0c 	teq	r5, ip
 8015ce6:	d105      	bne.n	8015cf4 <__aeabi_dmul+0x234>
 8015ce8:	ea52 3603 	orrs.w	r6, r2, r3, lsl #12
 8015cec:	bf1c      	itt	ne
 8015cee:	4610      	movne	r0, r2
 8015cf0:	4619      	movne	r1, r3
 8015cf2:	d10a      	bne.n	8015d0a <__aeabi_dmul+0x24a>
 8015cf4:	ea81 0103 	eor.w	r1, r1, r3
 8015cf8:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 8015cfc:	f041 41fe 	orr.w	r1, r1, #2130706432	; 0x7f000000
 8015d00:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
 8015d04:	f04f 0000 	mov.w	r0, #0
 8015d08:	bd70      	pop	{r4, r5, r6, pc}
 8015d0a:	f041 41fe 	orr.w	r1, r1, #2130706432	; 0x7f000000
 8015d0e:	f441 0178 	orr.w	r1, r1, #16252928	; 0xf80000
 8015d12:	bd70      	pop	{r4, r5, r6, pc}

08015d14 <__aeabi_ddiv>:
 8015d14:	b570      	push	{r4, r5, r6, lr}
 8015d16:	f04f 0cff 	mov.w	ip, #255	; 0xff
 8015d1a:	f44c 6ce0 	orr.w	ip, ip, #1792	; 0x700
 8015d1e:	ea1c 5411 	ands.w	r4, ip, r1, lsr #20
 8015d22:	bf1d      	ittte	ne
 8015d24:	ea1c 5513 	andsne.w	r5, ip, r3, lsr #20
 8015d28:	ea94 0f0c 	teqne	r4, ip
 8015d2c:	ea95 0f0c 	teqne	r5, ip
 8015d30:	f000 f8a7 	bleq	8015e82 <__aeabi_ddiv+0x16e>
 8015d34:	eba4 0405 	sub.w	r4, r4, r5
 8015d38:	ea81 0e03 	eor.w	lr, r1, r3
 8015d3c:	ea52 3503 	orrs.w	r5, r2, r3, lsl #12
 8015d40:	ea4f 3101 	mov.w	r1, r1, lsl #12
 8015d44:	f000 8088 	beq.w	8015e58 <__aeabi_ddiv+0x144>
 8015d48:	ea4f 3303 	mov.w	r3, r3, lsl #12
 8015d4c:	f04f 5580 	mov.w	r5, #268435456	; 0x10000000
 8015d50:	ea45 1313 	orr.w	r3, r5, r3, lsr #4
 8015d54:	ea43 6312 	orr.w	r3, r3, r2, lsr #24
 8015d58:	ea4f 2202 	mov.w	r2, r2, lsl #8
 8015d5c:	ea45 1511 	orr.w	r5, r5, r1, lsr #4
 8015d60:	ea45 6510 	orr.w	r5, r5, r0, lsr #24
 8015d64:	ea4f 2600 	mov.w	r6, r0, lsl #8
 8015d68:	f00e 4100 	and.w	r1, lr, #2147483648	; 0x80000000
 8015d6c:	429d      	cmp	r5, r3
 8015d6e:	bf08      	it	eq
 8015d70:	4296      	cmpeq	r6, r2
 8015d72:	f144 04fd 	adc.w	r4, r4, #253	; 0xfd
 8015d76:	f504 7440 	add.w	r4, r4, #768	; 0x300
 8015d7a:	d202      	bcs.n	8015d82 <__aeabi_ddiv+0x6e>
 8015d7c:	085b      	lsrs	r3, r3, #1
 8015d7e:	ea4f 0232 	mov.w	r2, r2, rrx
 8015d82:	1ab6      	subs	r6, r6, r2
 8015d84:	eb65 0503 	sbc.w	r5, r5, r3
 8015d88:	085b      	lsrs	r3, r3, #1
 8015d8a:	ea4f 0232 	mov.w	r2, r2, rrx
 8015d8e:	f44f 1080 	mov.w	r0, #1048576	; 0x100000
 8015d92:	f44f 2c00 	mov.w	ip, #524288	; 0x80000
 8015d96:	ebb6 0e02 	subs.w	lr, r6, r2
 8015d9a:	eb75 0e03 	sbcs.w	lr, r5, r3
 8015d9e:	bf22      	ittt	cs
 8015da0:	1ab6      	subcs	r6, r6, r2
 8015da2:	4675      	movcs	r5, lr
 8015da4:	ea40 000c 	orrcs.w	r0, r0, ip
 8015da8:	085b      	lsrs	r3, r3, #1
 8015daa:	ea4f 0232 	mov.w	r2, r2, rrx
 8015dae:	ebb6 0e02 	subs.w	lr, r6, r2
 8015db2:	eb75 0e03 	sbcs.w	lr, r5, r3
 8015db6:	bf22      	ittt	cs
 8015db8:	1ab6      	subcs	r6, r6, r2
 8015dba:	4675      	movcs	r5, lr
 8015dbc:	ea40 005c 	orrcs.w	r0, r0, ip, lsr #1
 8015dc0:	085b      	lsrs	r3, r3, #1
 8015dc2:	ea4f 0232 	mov.w	r2, r2, rrx
 8015dc6:	ebb6 0e02 	subs.w	lr, r6, r2
 8015dca:	eb75 0e03 	sbcs.w	lr, r5, r3
 8015dce:	bf22      	ittt	cs
 8015dd0:	1ab6      	subcs	r6, r6, r2
 8015dd2:	4675      	movcs	r5, lr
 8015dd4:	ea40 009c 	orrcs.w	r0, r0, ip, lsr #2
 8015dd8:	085b      	lsrs	r3, r3, #1
 8015dda:	ea4f 0232 	mov.w	r2, r2, rrx
 8015dde:	ebb6 0e02 	subs.w	lr, r6, r2
 8015de2:	eb75 0e03 	sbcs.w	lr, r5, r3
 8015de6:	bf22      	ittt	cs
 8015de8:	1ab6      	subcs	r6, r6, r2
 8015dea:	4675      	movcs	r5, lr
 8015dec:	ea40 00dc 	orrcs.w	r0, r0, ip, lsr #3
 8015df0:	ea55 0e06 	orrs.w	lr, r5, r6
 8015df4:	d018      	beq.n	8015e28 <__aeabi_ddiv+0x114>
 8015df6:	ea4f 1505 	mov.w	r5, r5, lsl #4
 8015dfa:	ea45 7516 	orr.w	r5, r5, r6, lsr #28
 8015dfe:	ea4f 1606 	mov.w	r6, r6, lsl #4
 8015e02:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 8015e06:	ea43 7352 	orr.w	r3, r3, r2, lsr #29
 8015e0a:	ea4f 02c2 	mov.w	r2, r2, lsl #3
 8015e0e:	ea5f 1c1c 	movs.w	ip, ip, lsr #4
 8015e12:	d1c0      	bne.n	8015d96 <__aeabi_ddiv+0x82>
 8015e14:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
 8015e18:	d10b      	bne.n	8015e32 <__aeabi_ddiv+0x11e>
 8015e1a:	ea41 0100 	orr.w	r1, r1, r0
 8015e1e:	f04f 0000 	mov.w	r0, #0
 8015e22:	f04f 4c00 	mov.w	ip, #2147483648	; 0x80000000
 8015e26:	e7b6      	b.n	8015d96 <__aeabi_ddiv+0x82>
 8015e28:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
 8015e2c:	bf04      	itt	eq
 8015e2e:	4301      	orreq	r1, r0
 8015e30:	2000      	moveq	r0, #0
 8015e32:	f1b4 0cfd 	subs.w	ip, r4, #253	; 0xfd
 8015e36:	bf88      	it	hi
 8015e38:	f5bc 6fe0 	cmphi.w	ip, #1792	; 0x700
 8015e3c:	f63f aeaf 	bhi.w	8015b9e <__aeabi_dmul+0xde>
 8015e40:	ebb5 0c03 	subs.w	ip, r5, r3
 8015e44:	bf04      	itt	eq
 8015e46:	ebb6 0c02 	subseq.w	ip, r6, r2
 8015e4a:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
 8015e4e:	f150 0000 	adcs.w	r0, r0, #0
 8015e52:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
 8015e56:	bd70      	pop	{r4, r5, r6, pc}
 8015e58:	f00e 4e00 	and.w	lr, lr, #2147483648	; 0x80000000
 8015e5c:	ea4e 3111 	orr.w	r1, lr, r1, lsr #12
 8015e60:	eb14 045c 	adds.w	r4, r4, ip, lsr #1
 8015e64:	bfc2      	ittt	gt
 8015e66:	ebd4 050c 	rsbsgt	r5, r4, ip
 8015e6a:	ea41 5104 	orrgt.w	r1, r1, r4, lsl #20
 8015e6e:	bd70      	popgt	{r4, r5, r6, pc}
 8015e70:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
 8015e74:	f04f 0e00 	mov.w	lr, #0
 8015e78:	3c01      	subs	r4, #1
 8015e7a:	e690      	b.n	8015b9e <__aeabi_dmul+0xde>
 8015e7c:	ea45 0e06 	orr.w	lr, r5, r6
 8015e80:	e68d      	b.n	8015b9e <__aeabi_dmul+0xde>
 8015e82:	ea0c 5513 	and.w	r5, ip, r3, lsr #20
 8015e86:	ea94 0f0c 	teq	r4, ip
 8015e8a:	bf08      	it	eq
 8015e8c:	ea95 0f0c 	teqeq	r5, ip
 8015e90:	f43f af3b 	beq.w	8015d0a <__aeabi_dmul+0x24a>
 8015e94:	ea94 0f0c 	teq	r4, ip
 8015e98:	d10a      	bne.n	8015eb0 <__aeabi_ddiv+0x19c>
 8015e9a:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
 8015e9e:	f47f af34 	bne.w	8015d0a <__aeabi_dmul+0x24a>
 8015ea2:	ea95 0f0c 	teq	r5, ip
 8015ea6:	f47f af25 	bne.w	8015cf4 <__aeabi_dmul+0x234>
 8015eaa:	4610      	mov	r0, r2
 8015eac:	4619      	mov	r1, r3
 8015eae:	e72c      	b.n	8015d0a <__aeabi_dmul+0x24a>
 8015eb0:	ea95 0f0c 	teq	r5, ip
 8015eb4:	d106      	bne.n	8015ec4 <__aeabi_ddiv+0x1b0>
 8015eb6:	ea52 3503 	orrs.w	r5, r2, r3, lsl #12
 8015eba:	f43f aefd 	beq.w	8015cb8 <__aeabi_dmul+0x1f8>
 8015ebe:	4610      	mov	r0, r2
 8015ec0:	4619      	mov	r1, r3
 8015ec2:	e722      	b.n	8015d0a <__aeabi_dmul+0x24a>
 8015ec4:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
 8015ec8:	bf18      	it	ne
 8015eca:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
 8015ece:	f47f aec5 	bne.w	8015c5c <__aeabi_dmul+0x19c>
 8015ed2:	ea50 0441 	orrs.w	r4, r0, r1, lsl #1
 8015ed6:	f47f af0d 	bne.w	8015cf4 <__aeabi_dmul+0x234>
 8015eda:	ea52 0543 	orrs.w	r5, r2, r3, lsl #1
 8015ede:	f47f aeeb 	bne.w	8015cb8 <__aeabi_dmul+0x1f8>
 8015ee2:	e712      	b.n	8015d0a <__aeabi_dmul+0x24a>

08015ee4 <__gedf2>:
 8015ee4:	f04f 3cff 	mov.w	ip, #4294967295
 8015ee8:	e006      	b.n	8015ef8 <__cmpdf2+0x4>
 8015eea:	bf00      	nop

08015eec <__ledf2>:
 8015eec:	f04f 0c01 	mov.w	ip, #1
 8015ef0:	e002      	b.n	8015ef8 <__cmpdf2+0x4>
 8015ef2:	bf00      	nop

08015ef4 <__cmpdf2>:
 8015ef4:	f04f 0c01 	mov.w	ip, #1
 8015ef8:	f84d cd04 	str.w	ip, [sp, #-4]!
 8015efc:	ea4f 0c41 	mov.w	ip, r1, lsl #1
 8015f00:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
 8015f04:	ea4f 0c43 	mov.w	ip, r3, lsl #1
 8015f08:	bf18      	it	ne
 8015f0a:	ea7f 5c6c 	mvnsne.w	ip, ip, asr #21
 8015f0e:	d01b      	beq.n	8015f48 <__cmpdf2+0x54>
 8015f10:	b001      	add	sp, #4
 8015f12:	ea50 0c41 	orrs.w	ip, r0, r1, lsl #1
 8015f16:	bf0c      	ite	eq
 8015f18:	ea52 0c43 	orrseq.w	ip, r2, r3, lsl #1
 8015f1c:	ea91 0f03 	teqne	r1, r3
 8015f20:	bf02      	ittt	eq
 8015f22:	ea90 0f02 	teqeq	r0, r2
 8015f26:	2000      	moveq	r0, #0
 8015f28:	4770      	bxeq	lr
 8015f2a:	f110 0f00 	cmn.w	r0, #0
 8015f2e:	ea91 0f03 	teq	r1, r3
 8015f32:	bf58      	it	pl
 8015f34:	4299      	cmppl	r1, r3
 8015f36:	bf08      	it	eq
 8015f38:	4290      	cmpeq	r0, r2
 8015f3a:	bf2c      	ite	cs
 8015f3c:	17d8      	asrcs	r0, r3, #31
 8015f3e:	ea6f 70e3 	mvncc.w	r0, r3, asr #31
 8015f42:	f040 0001 	orr.w	r0, r0, #1
 8015f46:	4770      	bx	lr
 8015f48:	ea4f 0c41 	mov.w	ip, r1, lsl #1
 8015f4c:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
 8015f50:	d102      	bne.n	8015f58 <__cmpdf2+0x64>
 8015f52:	ea50 3c01 	orrs.w	ip, r0, r1, lsl #12
 8015f56:	d107      	bne.n	8015f68 <__cmpdf2+0x74>
 8015f58:	ea4f 0c43 	mov.w	ip, r3, lsl #1
 8015f5c:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
 8015f60:	d1d6      	bne.n	8015f10 <__cmpdf2+0x1c>
 8015f62:	ea52 3c03 	orrs.w	ip, r2, r3, lsl #12
 8015f66:	d0d3      	beq.n	8015f10 <__cmpdf2+0x1c>
 8015f68:	f85d 0b04 	ldr.w	r0, [sp], #4
 8015f6c:	4770      	bx	lr
 8015f6e:	bf00      	nop

08015f70 <__aeabi_cdrcmple>:
 8015f70:	4684      	mov	ip, r0
 8015f72:	4610      	mov	r0, r2
 8015f74:	4662      	mov	r2, ip
 8015f76:	468c      	mov	ip, r1
 8015f78:	4619      	mov	r1, r3
 8015f7a:	4663      	mov	r3, ip
 8015f7c:	e000      	b.n	8015f80 <__aeabi_cdcmpeq>
 8015f7e:	bf00      	nop

08015f80 <__aeabi_cdcmpeq>:
 8015f80:	b501      	push	{r0, lr}
 8015f82:	f7ff ffb7 	bl	8015ef4 <__cmpdf2>
 8015f86:	2800      	cmp	r0, #0
 8015f88:	bf48      	it	mi
 8015f8a:	f110 0f00 	cmnmi.w	r0, #0
 8015f8e:	bd01      	pop	{r0, pc}

08015f90 <__aeabi_dcmpeq>:
 8015f90:	f84d ed08 	str.w	lr, [sp, #-8]!
 8015f94:	f7ff fff4 	bl	8015f80 <__aeabi_cdcmpeq>
 8015f98:	bf0c      	ite	eq
 8015f9a:	2001      	moveq	r0, #1
 8015f9c:	2000      	movne	r0, #0
 8015f9e:	f85d fb08 	ldr.w	pc, [sp], #8
 8015fa2:	bf00      	nop

08015fa4 <__aeabi_dcmplt>:
 8015fa4:	f84d ed08 	str.w	lr, [sp, #-8]!
 8015fa8:	f7ff ffea 	bl	8015f80 <__aeabi_cdcmpeq>
 8015fac:	bf34      	ite	cc
 8015fae:	2001      	movcc	r0, #1
 8015fb0:	2000      	movcs	r0, #0
 8015fb2:	f85d fb08 	ldr.w	pc, [sp], #8
 8015fb6:	bf00      	nop

08015fb8 <__aeabi_dcmple>:
 8015fb8:	f84d ed08 	str.w	lr, [sp, #-8]!
 8015fbc:	f7ff ffe0 	bl	8015f80 <__aeabi_cdcmpeq>
 8015fc0:	bf94      	ite	ls
 8015fc2:	2001      	movls	r0, #1
 8015fc4:	2000      	movhi	r0, #0
 8015fc6:	f85d fb08 	ldr.w	pc, [sp], #8
 8015fca:	bf00      	nop

08015fcc <__aeabi_dcmpge>:
 8015fcc:	f84d ed08 	str.w	lr, [sp, #-8]!
 8015fd0:	f7ff ffce 	bl	8015f70 <__aeabi_cdrcmple>
 8015fd4:	bf94      	ite	ls
 8015fd6:	2001      	movls	r0, #1
 8015fd8:	2000      	movhi	r0, #0
 8015fda:	f85d fb08 	ldr.w	pc, [sp], #8
 8015fde:	bf00      	nop

08015fe0 <__aeabi_dcmpgt>:
 8015fe0:	f84d ed08 	str.w	lr, [sp, #-8]!
 8015fe4:	f7ff ffc4 	bl	8015f70 <__aeabi_cdrcmple>
 8015fe8:	bf34      	ite	cc
 8015fea:	2001      	movcc	r0, #1
 8015fec:	2000      	movcs	r0, #0
 8015fee:	f85d fb08 	ldr.w	pc, [sp], #8
 8015ff2:	bf00      	nop

08015ff4 <__aeabi_d2f>:
 8015ff4:	ea4f 0241 	mov.w	r2, r1, lsl #1
 8015ff8:	f1b2 43e0 	subs.w	r3, r2, #1879048192	; 0x70000000
 8015ffc:	bf24      	itt	cs
 8015ffe:	f5b3 1c00 	subscs.w	ip, r3, #2097152	; 0x200000
 8016002:	f1dc 5cfe 	rsbscs	ip, ip, #532676608	; 0x1fc00000
 8016006:	d90d      	bls.n	8016024 <__aeabi_d2f+0x30>
 8016008:	f001 4c00 	and.w	ip, r1, #2147483648	; 0x80000000
 801600c:	ea4f 02c0 	mov.w	r2, r0, lsl #3
 8016010:	ea4c 7050 	orr.w	r0, ip, r0, lsr #29
 8016014:	f1b2 4f00 	cmp.w	r2, #2147483648	; 0x80000000
 8016018:	eb40 0083 	adc.w	r0, r0, r3, lsl #2
 801601c:	bf08      	it	eq
 801601e:	f020 0001 	biceq.w	r0, r0, #1
 8016022:	4770      	bx	lr
 8016024:	f011 4f80 	tst.w	r1, #1073741824	; 0x40000000
 8016028:	d121      	bne.n	801606e <__aeabi_d2f+0x7a>
 801602a:	f113 7238 	adds.w	r2, r3, #48234496	; 0x2e00000
 801602e:	bfbc      	itt	lt
 8016030:	f001 4000 	andlt.w	r0, r1, #2147483648	; 0x80000000
 8016034:	4770      	bxlt	lr
 8016036:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
 801603a:	ea4f 5252 	mov.w	r2, r2, lsr #21
 801603e:	f1c2 0218 	rsb	r2, r2, #24
 8016042:	f1c2 0c20 	rsb	ip, r2, #32
 8016046:	fa10 f30c 	lsls.w	r3, r0, ip
 801604a:	fa20 f002 	lsr.w	r0, r0, r2
 801604e:	bf18      	it	ne
 8016050:	f040 0001 	orrne.w	r0, r0, #1
 8016054:	ea4f 23c1 	mov.w	r3, r1, lsl #11
 8016058:	ea4f 23d3 	mov.w	r3, r3, lsr #11
 801605c:	fa03 fc0c 	lsl.w	ip, r3, ip
 8016060:	ea40 000c 	orr.w	r0, r0, ip
 8016064:	fa23 f302 	lsr.w	r3, r3, r2
 8016068:	ea4f 0343 	mov.w	r3, r3, lsl #1
 801606c:	e7cc      	b.n	8016008 <__aeabi_d2f+0x14>
 801606e:	ea7f 5362 	mvns.w	r3, r2, asr #21
 8016072:	d107      	bne.n	8016084 <__aeabi_d2f+0x90>
 8016074:	ea50 3301 	orrs.w	r3, r0, r1, lsl #12
 8016078:	bf1e      	ittt	ne
 801607a:	f04f 40fe 	movne.w	r0, #2130706432	; 0x7f000000
 801607e:	f440 0040 	orrne.w	r0, r0, #12582912	; 0xc00000
 8016082:	4770      	bxne	lr
 8016084:	f001 4000 	and.w	r0, r1, #2147483648	; 0x80000000
 8016088:	f040 40fe 	orr.w	r0, r0, #2130706432	; 0x7f000000
 801608c:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
 8016090:	4770      	bx	lr
 8016092:	bf00      	nop

08016094 <Reset_Handler>:
  .weak  Reset_Handler
  .type  Reset_Handler, %function
Reset_Handler:

/* Copy the data segment initializers from flash to SRAM */
  movs  r1, #0
 8016094:	2100      	movs	r1, #0
  b  LoopCopyDataInit
 8016096:	e003      	b.n	80160a0 <LoopCopyDataInit>

08016098 <CopyDataInit>:

CopyDataInit:
  ldr  r3, =_sidata
 8016098:	4b0b      	ldr	r3, [pc, #44]	; (80160c8 <LoopFillZerobss+0x14>)
  ldr  r3, [r3, r1]
 801609a:	585b      	ldr	r3, [r3, r1]
  str  r3, [r0, r1]
 801609c:	5043      	str	r3, [r0, r1]
  adds  r1, r1, #4
 801609e:	3104      	adds	r1, #4

080160a0 <LoopCopyDataInit>:

LoopCopyDataInit:
  ldr  r0, =_sdata
 80160a0:	480a      	ldr	r0, [pc, #40]	; (80160cc <LoopFillZerobss+0x18>)
  ldr  r3, =_edata
 80160a2:	4b0b      	ldr	r3, [pc, #44]	; (80160d0 <LoopFillZerobss+0x1c>)
  adds  r2, r0, r1
 80160a4:	1842      	adds	r2, r0, r1
  cmp  r2, r3
 80160a6:	429a      	cmp	r2, r3
  bcc  CopyDataInit
 80160a8:	d3f6      	bcc.n	8016098 <CopyDataInit>
  ldr  r2, =_sbss
 80160aa:	4a0a      	ldr	r2, [pc, #40]	; (80160d4 <LoopFillZerobss+0x20>)
  b  LoopFillZerobss
 80160ac:	e002      	b.n	80160b4 <LoopFillZerobss>

080160ae <FillZerobss>:
/* Zero fill the bss segment. */
FillZerobss:
  movs  r3, #0
 80160ae:	2300      	movs	r3, #0
  str  r3, [r2], #4
 80160b0:	f842 3b04 	str.w	r3, [r2], #4

080160b4 <LoopFillZerobss>:

LoopFillZerobss:
  ldr  r3, = _ebss
 80160b4:	4b08      	ldr	r3, [pc, #32]	; (80160d8 <LoopFillZerobss+0x24>)
  cmp  r2, r3
 80160b6:	429a      	cmp	r2, r3
  bcc  FillZerobss
 80160b8:	d3f9      	bcc.n	80160ae <FillZerobss>

/* Call the clock system intitialization function.*/
  bl  SystemInit
 80160ba:	f7ff f96d 	bl	8015398 <SystemInit>
/* Call static constructors */
    bl __libc_init_array
 80160be:	f000 fde5 	bl	8016c8c <__libc_init_array>
/* Call the application's entry point.*/
  bl  main
 80160c2:	f7fe ff31 	bl	8014f28 <main>
  bx  lr
 80160c6:	4770      	bx	lr
  ldr  r3, =_sidata
 80160c8:	0806bc90 	.word	0x0806bc90
  ldr  r0, =_sdata
 80160cc:	20000000 	.word	0x20000000
  ldr  r3, =_edata
 80160d0:	20000098 	.word	0x20000098
  ldr  r2, =_sbss
 80160d4:	20000098 	.word	0x20000098
  ldr  r3, = _ebss
 80160d8:	20009e70 	.word	0x20009e70

080160dc <ADC_IRQHandler>:
 * @retval None
*/
    .section  .text.Default_Handler,"ax",%progbits
Default_Handler:
Infinite_Loop:
  b  Infinite_Loop
 80160dc:	e7fe      	b.n	80160dc <ADC_IRQHandler>
	...

080160e0 <floorf>:
 80160e0:	ee10 3a10 	vmov	r3, s0
 80160e4:	f023 4100 	bic.w	r1, r3, #2147483648	; 0x80000000
 80160e8:	0dca      	lsrs	r2, r1, #23
 80160ea:	3a7f      	subs	r2, #127	; 0x7f
 80160ec:	2a16      	cmp	r2, #22
 80160ee:	dc2a      	bgt.n	8016146 <floorf+0x66>
 80160f0:	2a00      	cmp	r2, #0
 80160f2:	da11      	bge.n	8016118 <floorf+0x38>
 80160f4:	eddf 7a18 	vldr	s15, [pc, #96]	; 8016158 <floorf+0x78>
 80160f8:	ee30 0a27 	vadd.f32	s0, s0, s15
 80160fc:	eeb5 0ac0 	vcmpe.f32	s0, #0.0
 8016100:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8016104:	dd05      	ble.n	8016112 <floorf+0x32>
 8016106:	2b00      	cmp	r3, #0
 8016108:	da23      	bge.n	8016152 <floorf+0x72>
 801610a:	4a14      	ldr	r2, [pc, #80]	; (801615c <floorf+0x7c>)
 801610c:	2900      	cmp	r1, #0
 801610e:	bf18      	it	ne
 8016110:	4613      	movne	r3, r2
 8016112:	ee00 3a10 	vmov	s0, r3
 8016116:	4770      	bx	lr
 8016118:	4911      	ldr	r1, [pc, #68]	; (8016160 <floorf+0x80>)
 801611a:	4111      	asrs	r1, r2
 801611c:	420b      	tst	r3, r1
 801611e:	d0fa      	beq.n	8016116 <floorf+0x36>
 8016120:	eddf 7a0d 	vldr	s15, [pc, #52]	; 8016158 <floorf+0x78>
 8016124:	ee30 0a27 	vadd.f32	s0, s0, s15
 8016128:	eeb5 0ac0 	vcmpe.f32	s0, #0.0
 801612c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8016130:	ddef      	ble.n	8016112 <floorf+0x32>
 8016132:	2b00      	cmp	r3, #0
 8016134:	bfbe      	ittt	lt
 8016136:	f44f 0000 	movlt.w	r0, #8388608	; 0x800000
 801613a:	fa40 f202 	asrlt.w	r2, r0, r2
 801613e:	189b      	addlt	r3, r3, r2
 8016140:	ea23 0301 	bic.w	r3, r3, r1
 8016144:	e7e5      	b.n	8016112 <floorf+0x32>
 8016146:	f1b1 4fff 	cmp.w	r1, #2139095040	; 0x7f800000
 801614a:	d3e4      	bcc.n	8016116 <floorf+0x36>
 801614c:	ee30 0a00 	vadd.f32	s0, s0, s0
 8016150:	4770      	bx	lr
 8016152:	2300      	movs	r3, #0
 8016154:	e7dd      	b.n	8016112 <floorf+0x32>
 8016156:	bf00      	nop
 8016158:	7149f2ca 	.word	0x7149f2ca
 801615c:	bf800000 	.word	0xbf800000
 8016160:	007fffff 	.word	0x007fffff

08016164 <powf>:
 8016164:	b570      	push	{r4, r5, r6, lr}
 8016166:	ed2d 8b04 	vpush	{d8-d9}
 801616a:	4cb5      	ldr	r4, [pc, #724]	; (8016440 <powf+0x2dc>)
 801616c:	b08a      	sub	sp, #40	; 0x28
 801616e:	eef0 8a40 	vmov.f32	s17, s0
 8016172:	eeb0 8a60 	vmov.f32	s16, s1
 8016176:	f000 f971 	bl	801645c <__ieee754_powf>
 801617a:	f994 5000 	ldrsb.w	r5, [r4]
 801617e:	1c6b      	adds	r3, r5, #1
 8016180:	eeb0 9a40 	vmov.f32	s18, s0
 8016184:	4626      	mov	r6, r4
 8016186:	d05d      	beq.n	8016244 <powf+0xe0>
 8016188:	eeb4 8a48 	vcmp.f32	s16, s16
 801618c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8016190:	d658      	bvs.n	8016244 <powf+0xe0>
 8016192:	eef4 8a68 	vcmp.f32	s17, s17
 8016196:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801619a:	d721      	bvc.n	80161e0 <powf+0x7c>
 801619c:	eeb5 8a40 	vcmp.f32	s16, #0.0
 80161a0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80161a4:	d14e      	bne.n	8016244 <powf+0xe0>
 80161a6:	2301      	movs	r3, #1
 80161a8:	9300      	str	r3, [sp, #0]
 80161aa:	4ba6      	ldr	r3, [pc, #664]	; (8016444 <powf+0x2e0>)
 80161ac:	9301      	str	r3, [sp, #4]
 80161ae:	ee18 0a90 	vmov	r0, s17
 80161b2:	2300      	movs	r3, #0
 80161b4:	9308      	str	r3, [sp, #32]
 80161b6:	f7ff fc2f 	bl	8015a18 <__aeabi_f2d>
 80161ba:	e9cd 0102 	strd	r0, r1, [sp, #8]
 80161be:	ee18 0a10 	vmov	r0, s16
 80161c2:	f7ff fc29 	bl	8015a18 <__aeabi_f2d>
 80161c6:	4ba0      	ldr	r3, [pc, #640]	; (8016448 <powf+0x2e4>)
 80161c8:	2200      	movs	r2, #0
 80161ca:	2d02      	cmp	r5, #2
 80161cc:	e9cd 0104 	strd	r0, r1, [sp, #16]
 80161d0:	e9cd 2306 	strd	r2, r3, [sp, #24]
 80161d4:	d030      	beq.n	8016238 <powf+0xd4>
 80161d6:	4668      	mov	r0, sp
 80161d8:	f000 fc49 	bl	8016a6e <matherr>
 80161dc:	bb30      	cbnz	r0, 801622c <powf+0xc8>
 80161de:	e062      	b.n	80162a6 <powf+0x142>
 80161e0:	eef5 8a40 	vcmp.f32	s17, #0.0
 80161e4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80161e8:	d162      	bne.n	80162b0 <powf+0x14c>
 80161ea:	eeb5 8a40 	vcmp.f32	s16, #0.0
 80161ee:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80161f2:	d12d      	bne.n	8016250 <powf+0xec>
 80161f4:	2301      	movs	r3, #1
 80161f6:	9300      	str	r3, [sp, #0]
 80161f8:	4b92      	ldr	r3, [pc, #584]	; (8016444 <powf+0x2e0>)
 80161fa:	9301      	str	r3, [sp, #4]
 80161fc:	ee18 0a90 	vmov	r0, s17
 8016200:	2300      	movs	r3, #0
 8016202:	9308      	str	r3, [sp, #32]
 8016204:	f7ff fc08 	bl	8015a18 <__aeabi_f2d>
 8016208:	e9cd 0102 	strd	r0, r1, [sp, #8]
 801620c:	ee18 0a10 	vmov	r0, s16
 8016210:	f7ff fc02 	bl	8015a18 <__aeabi_f2d>
 8016214:	2200      	movs	r2, #0
 8016216:	2300      	movs	r3, #0
 8016218:	e9cd 0104 	strd	r0, r1, [sp, #16]
 801621c:	e9cd 2306 	strd	r2, r3, [sp, #24]
 8016220:	2d00      	cmp	r5, #0
 8016222:	d0d8      	beq.n	80161d6 <powf+0x72>
 8016224:	4b88      	ldr	r3, [pc, #544]	; (8016448 <powf+0x2e4>)
 8016226:	2200      	movs	r2, #0
 8016228:	e9cd 2306 	strd	r2, r3, [sp, #24]
 801622c:	9b08      	ldr	r3, [sp, #32]
 801622e:	b11b      	cbz	r3, 8016238 <powf+0xd4>
 8016230:	f001 fa06 	bl	8017640 <____errno_veneer>
 8016234:	9b08      	ldr	r3, [sp, #32]
 8016236:	6003      	str	r3, [r0, #0]
 8016238:	e9dd 0106 	ldrd	r0, r1, [sp, #24]
 801623c:	f7ff feda 	bl	8015ff4 <__aeabi_d2f>
 8016240:	ee09 0a10 	vmov	s18, r0
 8016244:	eeb0 0a49 	vmov.f32	s0, s18
 8016248:	b00a      	add	sp, #40	; 0x28
 801624a:	ecbd 8b04 	vpop	{d8-d9}
 801624e:	bd70      	pop	{r4, r5, r6, pc}
 8016250:	eeb0 0a48 	vmov.f32	s0, s16
 8016254:	f000 fc9d 	bl	8016b92 <finitef>
 8016258:	2800      	cmp	r0, #0
 801625a:	d0f3      	beq.n	8016244 <powf+0xe0>
 801625c:	eeb5 8ac0 	vcmpe.f32	s16, #0.0
 8016260:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8016264:	d5ee      	bpl.n	8016244 <powf+0xe0>
 8016266:	2301      	movs	r3, #1
 8016268:	9300      	str	r3, [sp, #0]
 801626a:	4b76      	ldr	r3, [pc, #472]	; (8016444 <powf+0x2e0>)
 801626c:	9301      	str	r3, [sp, #4]
 801626e:	ee18 0a90 	vmov	r0, s17
 8016272:	2300      	movs	r3, #0
 8016274:	9308      	str	r3, [sp, #32]
 8016276:	f7ff fbcf 	bl	8015a18 <__aeabi_f2d>
 801627a:	e9cd 0102 	strd	r0, r1, [sp, #8]
 801627e:	ee18 0a10 	vmov	r0, s16
 8016282:	f7ff fbc9 	bl	8015a18 <__aeabi_f2d>
 8016286:	f994 3000 	ldrsb.w	r3, [r4]
 801628a:	e9cd 0104 	strd	r0, r1, [sp, #16]
 801628e:	b923      	cbnz	r3, 801629a <powf+0x136>
 8016290:	2200      	movs	r2, #0
 8016292:	2300      	movs	r3, #0
 8016294:	e9cd 2306 	strd	r2, r3, [sp, #24]
 8016298:	e79d      	b.n	80161d6 <powf+0x72>
 801629a:	496c      	ldr	r1, [pc, #432]	; (801644c <powf+0x2e8>)
 801629c:	2000      	movs	r0, #0
 801629e:	e9cd 0106 	strd	r0, r1, [sp, #24]
 80162a2:	2b02      	cmp	r3, #2
 80162a4:	d197      	bne.n	80161d6 <powf+0x72>
 80162a6:	f001 f9cb 	bl	8017640 <____errno_veneer>
 80162aa:	2321      	movs	r3, #33	; 0x21
 80162ac:	6003      	str	r3, [r0, #0]
 80162ae:	e7bd      	b.n	801622c <powf+0xc8>
 80162b0:	f000 fc6f 	bl	8016b92 <finitef>
 80162b4:	4605      	mov	r5, r0
 80162b6:	2800      	cmp	r0, #0
 80162b8:	f040 8091 	bne.w	80163de <powf+0x27a>
 80162bc:	eeb0 0a68 	vmov.f32	s0, s17
 80162c0:	f000 fc67 	bl	8016b92 <finitef>
 80162c4:	2800      	cmp	r0, #0
 80162c6:	f000 808a 	beq.w	80163de <powf+0x27a>
 80162ca:	eeb0 0a48 	vmov.f32	s0, s16
 80162ce:	f000 fc60 	bl	8016b92 <finitef>
 80162d2:	2800      	cmp	r0, #0
 80162d4:	f000 8083 	beq.w	80163de <powf+0x27a>
 80162d8:	eeb4 9a49 	vcmp.f32	s18, s18
 80162dc:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80162e0:	f994 4000 	ldrsb.w	r4, [r4]
 80162e4:	4b57      	ldr	r3, [pc, #348]	; (8016444 <powf+0x2e0>)
 80162e6:	d71b      	bvc.n	8016320 <powf+0x1bc>
 80162e8:	2201      	movs	r2, #1
 80162ea:	ee18 0a90 	vmov	r0, s17
 80162ee:	e88d 000c 	stmia.w	sp, {r2, r3}
 80162f2:	9508      	str	r5, [sp, #32]
 80162f4:	f7ff fb90 	bl	8015a18 <__aeabi_f2d>
 80162f8:	e9cd 0102 	strd	r0, r1, [sp, #8]
 80162fc:	ee18 0a10 	vmov	r0, s16
 8016300:	f7ff fb8a 	bl	8015a18 <__aeabi_f2d>
 8016304:	2200      	movs	r2, #0
 8016306:	e9cd 0104 	strd	r0, r1, [sp, #16]
 801630a:	2300      	movs	r3, #0
 801630c:	2c00      	cmp	r4, #0
 801630e:	d0c1      	beq.n	8016294 <powf+0x130>
 8016310:	4610      	mov	r0, r2
 8016312:	4619      	mov	r1, r3
 8016314:	f7ff fcfe 	bl	8015d14 <__aeabi_ddiv>
 8016318:	2c02      	cmp	r4, #2
 801631a:	e9cd 0106 	strd	r0, r1, [sp, #24]
 801631e:	e7c1      	b.n	80162a4 <powf+0x140>
 8016320:	2203      	movs	r2, #3
 8016322:	ee18 0a90 	vmov	r0, s17
 8016326:	e88d 000c 	stmia.w	sp, {r2, r3}
 801632a:	9508      	str	r5, [sp, #32]
 801632c:	f7ff fb74 	bl	8015a18 <__aeabi_f2d>
 8016330:	e9cd 0102 	strd	r0, r1, [sp, #8]
 8016334:	ee18 0a10 	vmov	r0, s16
 8016338:	f7ff fb6e 	bl	8015a18 <__aeabi_f2d>
 801633c:	e9cd 0104 	strd	r0, r1, [sp, #16]
 8016340:	bb5c      	cbnz	r4, 801639a <powf+0x236>
 8016342:	4b43      	ldr	r3, [pc, #268]	; (8016450 <powf+0x2ec>)
 8016344:	eef5 8ac0 	vcmpe.f32	s17, #0.0
 8016348:	f04f 4260 	mov.w	r2, #3758096384	; 0xe0000000
 801634c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8016350:	e9cd 2306 	strd	r2, r3, [sp, #24]
 8016354:	d56c      	bpl.n	8016430 <powf+0x2cc>
 8016356:	eef6 7a00 	vmov.f32	s15, #96	; 0x3f000000  0.5
 801635a:	ee68 7a27 	vmul.f32	s15, s16, s15
 801635e:	ee17 0a90 	vmov	r0, s15
 8016362:	f7ff fb59 	bl	8015a18 <__aeabi_f2d>
 8016366:	4604      	mov	r4, r0
 8016368:	460d      	mov	r5, r1
 801636a:	ec45 4b10 	vmov	d0, r4, r5
 801636e:	f000 fb81 	bl	8016a74 <rint>
 8016372:	4620      	mov	r0, r4
 8016374:	ec53 2b10 	vmov	r2, r3, d0
 8016378:	4629      	mov	r1, r5
 801637a:	f7ff fe09 	bl	8015f90 <__aeabi_dcmpeq>
 801637e:	b920      	cbnz	r0, 801638a <powf+0x226>
 8016380:	4b34      	ldr	r3, [pc, #208]	; (8016454 <powf+0x2f0>)
 8016382:	f04f 4260 	mov.w	r2, #3758096384	; 0xe0000000
 8016386:	e9cd 2306 	strd	r2, r3, [sp, #24]
 801638a:	f996 3000 	ldrsb.w	r3, [r6]
 801638e:	2b02      	cmp	r3, #2
 8016390:	d14e      	bne.n	8016430 <powf+0x2cc>
 8016392:	f001 f955 	bl	8017640 <____errno_veneer>
 8016396:	2322      	movs	r3, #34	; 0x22
 8016398:	e788      	b.n	80162ac <powf+0x148>
 801639a:	4b2f      	ldr	r3, [pc, #188]	; (8016458 <powf+0x2f4>)
 801639c:	eef5 8ac0 	vcmpe.f32	s17, #0.0
 80163a0:	2200      	movs	r2, #0
 80163a2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80163a6:	e9cd 2306 	strd	r2, r3, [sp, #24]
 80163aa:	d5ee      	bpl.n	801638a <powf+0x226>
 80163ac:	eef6 7a00 	vmov.f32	s15, #96	; 0x3f000000  0.5
 80163b0:	ee68 7a27 	vmul.f32	s15, s16, s15
 80163b4:	ee17 0a90 	vmov	r0, s15
 80163b8:	f7ff fb2e 	bl	8015a18 <__aeabi_f2d>
 80163bc:	4604      	mov	r4, r0
 80163be:	460d      	mov	r5, r1
 80163c0:	ec45 4b10 	vmov	d0, r4, r5
 80163c4:	f000 fb56 	bl	8016a74 <rint>
 80163c8:	4620      	mov	r0, r4
 80163ca:	ec53 2b10 	vmov	r2, r3, d0
 80163ce:	4629      	mov	r1, r5
 80163d0:	f7ff fdde 	bl	8015f90 <__aeabi_dcmpeq>
 80163d4:	2800      	cmp	r0, #0
 80163d6:	d1d8      	bne.n	801638a <powf+0x226>
 80163d8:	2200      	movs	r2, #0
 80163da:	4b1c      	ldr	r3, [pc, #112]	; (801644c <powf+0x2e8>)
 80163dc:	e7d3      	b.n	8016386 <powf+0x222>
 80163de:	eeb5 9a40 	vcmp.f32	s18, #0.0
 80163e2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80163e6:	f47f af2d 	bne.w	8016244 <powf+0xe0>
 80163ea:	eeb0 0a68 	vmov.f32	s0, s17
 80163ee:	f000 fbd0 	bl	8016b92 <finitef>
 80163f2:	2800      	cmp	r0, #0
 80163f4:	f43f af26 	beq.w	8016244 <powf+0xe0>
 80163f8:	eeb0 0a48 	vmov.f32	s0, s16
 80163fc:	f000 fbc9 	bl	8016b92 <finitef>
 8016400:	2800      	cmp	r0, #0
 8016402:	f43f af1f 	beq.w	8016244 <powf+0xe0>
 8016406:	2304      	movs	r3, #4
 8016408:	9300      	str	r3, [sp, #0]
 801640a:	4b0e      	ldr	r3, [pc, #56]	; (8016444 <powf+0x2e0>)
 801640c:	9301      	str	r3, [sp, #4]
 801640e:	ee18 0a90 	vmov	r0, s17
 8016412:	2300      	movs	r3, #0
 8016414:	9308      	str	r3, [sp, #32]
 8016416:	f7ff faff 	bl	8015a18 <__aeabi_f2d>
 801641a:	e9cd 0102 	strd	r0, r1, [sp, #8]
 801641e:	ee18 0a10 	vmov	r0, s16
 8016422:	f7ff faf9 	bl	8015a18 <__aeabi_f2d>
 8016426:	2200      	movs	r2, #0
 8016428:	e9cd 0104 	strd	r0, r1, [sp, #16]
 801642c:	2300      	movs	r3, #0
 801642e:	e7aa      	b.n	8016386 <powf+0x222>
 8016430:	4668      	mov	r0, sp
 8016432:	f000 fb1c 	bl	8016a6e <matherr>
 8016436:	2800      	cmp	r0, #0
 8016438:	f47f aef8 	bne.w	801622c <powf+0xc8>
 801643c:	e7a9      	b.n	8016392 <powf+0x22e>
 801643e:	bf00      	nop
 8016440:	20000030 	.word	0x20000030
 8016444:	0806bc21 	.word	0x0806bc21
 8016448:	3ff00000 	.word	0x3ff00000
 801644c:	fff00000 	.word	0xfff00000
 8016450:	47efffff 	.word	0x47efffff
 8016454:	c7efffff 	.word	0xc7efffff
 8016458:	7ff00000 	.word	0x7ff00000

0801645c <__ieee754_powf>:
 801645c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8016460:	ee10 5a90 	vmov	r5, s1
 8016464:	f035 4700 	bics.w	r7, r5, #2147483648	; 0x80000000
 8016468:	ed2d 8b02 	vpush	{d8}
 801646c:	eeb0 8a40 	vmov.f32	s16, s0
 8016470:	eef0 8a60 	vmov.f32	s17, s1
 8016474:	f000 8295 	beq.w	80169a2 <__ieee754_powf+0x546>
 8016478:	ee10 8a10 	vmov	r8, s0
 801647c:	f028 4400 	bic.w	r4, r8, #2147483648	; 0x80000000
 8016480:	f1b4 4fff 	cmp.w	r4, #2139095040	; 0x7f800000
 8016484:	dc06      	bgt.n	8016494 <__ieee754_powf+0x38>
 8016486:	f1b7 4fff 	cmp.w	r7, #2139095040	; 0x7f800000
 801648a:	dd0a      	ble.n	80164a2 <__ieee754_powf+0x46>
 801648c:	f1b4 5f7e 	cmp.w	r4, #1065353216	; 0x3f800000
 8016490:	f000 8287 	beq.w	80169a2 <__ieee754_powf+0x546>
 8016494:	ecbd 8b02 	vpop	{d8}
 8016498:	48d9      	ldr	r0, [pc, #868]	; (8016800 <__ieee754_powf+0x3a4>)
 801649a:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
 801649e:	f000 bb83 	b.w	8016ba8 <nanf>
 80164a2:	f1b8 0f00 	cmp.w	r8, #0
 80164a6:	da1d      	bge.n	80164e4 <__ieee754_powf+0x88>
 80164a8:	f1b7 4f97 	cmp.w	r7, #1266679808	; 0x4b800000
 80164ac:	da2c      	bge.n	8016508 <__ieee754_powf+0xac>
 80164ae:	f1b7 5f7e 	cmp.w	r7, #1065353216	; 0x3f800000
 80164b2:	db30      	blt.n	8016516 <__ieee754_powf+0xba>
 80164b4:	15fb      	asrs	r3, r7, #23
 80164b6:	f1c3 0396 	rsb	r3, r3, #150	; 0x96
 80164ba:	fa47 f603 	asr.w	r6, r7, r3
 80164be:	fa06 f303 	lsl.w	r3, r6, r3
 80164c2:	429f      	cmp	r7, r3
 80164c4:	d127      	bne.n	8016516 <__ieee754_powf+0xba>
 80164c6:	f006 0601 	and.w	r6, r6, #1
 80164ca:	f1c6 0602 	rsb	r6, r6, #2
 80164ce:	f1b7 5f7e 	cmp.w	r7, #1065353216	; 0x3f800000
 80164d2:	d122      	bne.n	801651a <__ieee754_powf+0xbe>
 80164d4:	2d00      	cmp	r5, #0
 80164d6:	f280 826a 	bge.w	80169ae <__ieee754_powf+0x552>
 80164da:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
 80164de:	ee87 0a88 	vdiv.f32	s0, s15, s16
 80164e2:	e00d      	b.n	8016500 <__ieee754_powf+0xa4>
 80164e4:	2600      	movs	r6, #0
 80164e6:	f1b7 4fff 	cmp.w	r7, #2139095040	; 0x7f800000
 80164ea:	d1f0      	bne.n	80164ce <__ieee754_powf+0x72>
 80164ec:	f1b4 5f7e 	cmp.w	r4, #1065353216	; 0x3f800000
 80164f0:	f000 8257 	beq.w	80169a2 <__ieee754_powf+0x546>
 80164f4:	dd0a      	ble.n	801650c <__ieee754_powf+0xb0>
 80164f6:	2d00      	cmp	r5, #0
 80164f8:	f280 8256 	bge.w	80169a8 <__ieee754_powf+0x54c>
 80164fc:	ed9f 0ac1 	vldr	s0, [pc, #772]	; 8016804 <__ieee754_powf+0x3a8>
 8016500:	ecbd 8b02 	vpop	{d8}
 8016504:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8016508:	2602      	movs	r6, #2
 801650a:	e7ec      	b.n	80164e6 <__ieee754_powf+0x8a>
 801650c:	2d00      	cmp	r5, #0
 801650e:	daf5      	bge.n	80164fc <__ieee754_powf+0xa0>
 8016510:	eeb1 0a68 	vneg.f32	s0, s17
 8016514:	e7f4      	b.n	8016500 <__ieee754_powf+0xa4>
 8016516:	2600      	movs	r6, #0
 8016518:	e7d9      	b.n	80164ce <__ieee754_powf+0x72>
 801651a:	f1b5 4f80 	cmp.w	r5, #1073741824	; 0x40000000
 801651e:	d102      	bne.n	8016526 <__ieee754_powf+0xca>
 8016520:	ee28 0a08 	vmul.f32	s0, s16, s16
 8016524:	e7ec      	b.n	8016500 <__ieee754_powf+0xa4>
 8016526:	f1b5 5f7c 	cmp.w	r5, #1056964608	; 0x3f000000
 801652a:	eeb0 0a48 	vmov.f32	s0, s16
 801652e:	d108      	bne.n	8016542 <__ieee754_powf+0xe6>
 8016530:	f1b8 0f00 	cmp.w	r8, #0
 8016534:	db05      	blt.n	8016542 <__ieee754_powf+0xe6>
 8016536:	ecbd 8b02 	vpop	{d8}
 801653a:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
 801653e:	f000 ba4f 	b.w	80169e0 <__ieee754_sqrtf>
 8016542:	f000 fb1f 	bl	8016b84 <fabsf>
 8016546:	b124      	cbz	r4, 8016552 <__ieee754_powf+0xf6>
 8016548:	f028 4340 	bic.w	r3, r8, #3221225472	; 0xc0000000
 801654c:	f1b3 5f7e 	cmp.w	r3, #1065353216	; 0x3f800000
 8016550:	d117      	bne.n	8016582 <__ieee754_powf+0x126>
 8016552:	2d00      	cmp	r5, #0
 8016554:	bfbc      	itt	lt
 8016556:	eef7 7a00 	vmovlt.f32	s15, #112	; 0x3f800000  1.0
 801655a:	ee87 0a80 	vdivlt.f32	s0, s15, s0
 801655e:	f1b8 0f00 	cmp.w	r8, #0
 8016562:	dacd      	bge.n	8016500 <__ieee754_powf+0xa4>
 8016564:	f1a4 547e 	sub.w	r4, r4, #1065353216	; 0x3f800000
 8016568:	ea54 0306 	orrs.w	r3, r4, r6
 801656c:	d104      	bne.n	8016578 <__ieee754_powf+0x11c>
 801656e:	ee70 7a40 	vsub.f32	s15, s0, s0
 8016572:	ee87 0aa7 	vdiv.f32	s0, s15, s15
 8016576:	e7c3      	b.n	8016500 <__ieee754_powf+0xa4>
 8016578:	2e01      	cmp	r6, #1
 801657a:	d1c1      	bne.n	8016500 <__ieee754_powf+0xa4>
 801657c:	eeb1 0a40 	vneg.f32	s0, s0
 8016580:	e7be      	b.n	8016500 <__ieee754_powf+0xa4>
 8016582:	ea4f 70d8 	mov.w	r0, r8, lsr #31
 8016586:	3801      	subs	r0, #1
 8016588:	ea56 0300 	orrs.w	r3, r6, r0
 801658c:	d104      	bne.n	8016598 <__ieee754_powf+0x13c>
 801658e:	ee38 8a48 	vsub.f32	s16, s16, s16
 8016592:	ee88 0a08 	vdiv.f32	s0, s16, s16
 8016596:	e7b3      	b.n	8016500 <__ieee754_powf+0xa4>
 8016598:	f1b7 4f9a 	cmp.w	r7, #1291845632	; 0x4d000000
 801659c:	dd6d      	ble.n	801667a <__ieee754_powf+0x21e>
 801659e:	4b9a      	ldr	r3, [pc, #616]	; (8016808 <__ieee754_powf+0x3ac>)
 80165a0:	429c      	cmp	r4, r3
 80165a2:	dc06      	bgt.n	80165b2 <__ieee754_powf+0x156>
 80165a4:	2d00      	cmp	r5, #0
 80165a6:	daa9      	bge.n	80164fc <__ieee754_powf+0xa0>
 80165a8:	ed9f 0a98 	vldr	s0, [pc, #608]	; 801680c <__ieee754_powf+0x3b0>
 80165ac:	ee20 0a00 	vmul.f32	s0, s0, s0
 80165b0:	e7a6      	b.n	8016500 <__ieee754_powf+0xa4>
 80165b2:	4b97      	ldr	r3, [pc, #604]	; (8016810 <__ieee754_powf+0x3b4>)
 80165b4:	429c      	cmp	r4, r3
 80165b6:	dd02      	ble.n	80165be <__ieee754_powf+0x162>
 80165b8:	2d00      	cmp	r5, #0
 80165ba:	dcf5      	bgt.n	80165a8 <__ieee754_powf+0x14c>
 80165bc:	e79e      	b.n	80164fc <__ieee754_powf+0xa0>
 80165be:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
 80165c2:	ee30 0a67 	vsub.f32	s0, s0, s15
 80165c6:	ed9f 7a93 	vldr	s14, [pc, #588]	; 8016814 <__ieee754_powf+0x3b8>
 80165ca:	ed9f 6a93 	vldr	s12, [pc, #588]	; 8016818 <__ieee754_powf+0x3bc>
 80165ce:	eef1 6a40 	vneg.f32	s13, s0
 80165d2:	eef5 7a00 	vmov.f32	s15, #80	; 0x3e800000  0.250
 80165d6:	eea6 7aa7 	vfma.f32	s14, s13, s15
 80165da:	eef6 7a00 	vmov.f32	s15, #96	; 0x3f000000  0.5
 80165de:	eee6 7a87 	vfma.f32	s15, s13, s14
 80165e2:	ee20 7a00 	vmul.f32	s14, s0, s0
 80165e6:	ee27 7a87 	vmul.f32	s14, s15, s14
 80165ea:	eddf 7a8c 	vldr	s15, [pc, #560]	; 801681c <__ieee754_powf+0x3c0>
 80165ee:	ee67 7ac7 	vnmul.f32	s15, s15, s14
 80165f2:	ed9f 7a8b 	vldr	s14, [pc, #556]	; 8016820 <__ieee754_powf+0x3c4>
 80165f6:	eee0 7a07 	vfma.f32	s15, s0, s14
 80165fa:	eeb0 7a67 	vmov.f32	s14, s15
 80165fe:	eea0 7a06 	vfma.f32	s14, s0, s12
 8016602:	ee17 3a10 	vmov	r3, s14
 8016606:	f423 637f 	bic.w	r3, r3, #4080	; 0xff0
 801660a:	f023 030f 	bic.w	r3, r3, #15
 801660e:	ee07 3a10 	vmov	s14, r3
 8016612:	eea6 7a86 	vfma.f32	s14, s13, s12
 8016616:	ee77 7ac7 	vsub.f32	s15, s15, s14
 801661a:	f425 657f 	bic.w	r5, r5, #4080	; 0xff0
 801661e:	f025 050f 	bic.w	r5, r5, #15
 8016622:	ee07 5a10 	vmov	s14, r5
 8016626:	ee67 7aa8 	vmul.f32	s15, s15, s17
 801662a:	ee78 8ac7 	vsub.f32	s17, s17, s14
 801662e:	ee07 3a10 	vmov	s14, r3
 8016632:	ee06 5a90 	vmov	s13, r5
 8016636:	eee7 7a28 	vfma.f32	s15, s14, s17
 801663a:	3e01      	subs	r6, #1
 801663c:	ea56 0200 	orrs.w	r2, r6, r0
 8016640:	ee27 7a26 	vmul.f32	s14, s14, s13
 8016644:	eebf 0a00 	vmov.f32	s0, #240	; 0xbf800000 -1.0
 8016648:	ee77 6a87 	vadd.f32	s13, s15, s14
 801664c:	eeb7 8a00 	vmov.f32	s16, #112	; 0x3f800000  1.0
 8016650:	ee16 4a90 	vmov	r4, s13
 8016654:	bf08      	it	eq
 8016656:	eeb0 8a40 	vmoveq.f32	s16, s0
 801665a:	2c00      	cmp	r4, #0
 801665c:	f024 4300 	bic.w	r3, r4, #2147483648	; 0x80000000
 8016660:	f340 8186 	ble.w	8016970 <__ieee754_powf+0x514>
 8016664:	f1b3 4f86 	cmp.w	r3, #1124073472	; 0x43000000
 8016668:	f340 80fc 	ble.w	8016864 <__ieee754_powf+0x408>
 801666c:	eddf 7a67 	vldr	s15, [pc, #412]	; 801680c <__ieee754_powf+0x3b0>
 8016670:	ee28 0a27 	vmul.f32	s0, s16, s15
 8016674:	ee20 0a27 	vmul.f32	s0, s0, s15
 8016678:	e742      	b.n	8016500 <__ieee754_powf+0xa4>
 801667a:	f5b4 0f00 	cmp.w	r4, #8388608	; 0x800000
 801667e:	bfbf      	itttt	lt
 8016680:	eddf 7a68 	vldrlt	s15, [pc, #416]	; 8016824 <__ieee754_powf+0x3c8>
 8016684:	ee60 7a27 	vmullt.f32	s15, s0, s15
 8016688:	f06f 0217 	mvnlt.w	r2, #23
 801668c:	ee17 4a90 	vmovlt	r4, s15
 8016690:	ea4f 53e4 	mov.w	r3, r4, asr #23
 8016694:	bfa8      	it	ge
 8016696:	2200      	movge	r2, #0
 8016698:	3b7f      	subs	r3, #127	; 0x7f
 801669a:	4413      	add	r3, r2
 801669c:	4a62      	ldr	r2, [pc, #392]	; (8016828 <__ieee754_powf+0x3cc>)
 801669e:	f3c4 0416 	ubfx	r4, r4, #0, #23
 80166a2:	4294      	cmp	r4, r2
 80166a4:	f044 517e 	orr.w	r1, r4, #1065353216	; 0x3f800000
 80166a8:	dd06      	ble.n	80166b8 <__ieee754_powf+0x25c>
 80166aa:	4a60      	ldr	r2, [pc, #384]	; (801682c <__ieee754_powf+0x3d0>)
 80166ac:	4294      	cmp	r4, r2
 80166ae:	f340 80a5 	ble.w	80167fc <__ieee754_powf+0x3a0>
 80166b2:	3301      	adds	r3, #1
 80166b4:	f5a1 0100 	sub.w	r1, r1, #8388608	; 0x800000
 80166b8:	2400      	movs	r4, #0
 80166ba:	4a5d      	ldr	r2, [pc, #372]	; (8016830 <__ieee754_powf+0x3d4>)
 80166bc:	00a7      	lsls	r7, r4, #2
 80166be:	443a      	add	r2, r7
 80166c0:	ee07 1a90 	vmov	s15, r1
 80166c4:	ed92 7a00 	vldr	s14, [r2]
 80166c8:	4a5a      	ldr	r2, [pc, #360]	; (8016834 <__ieee754_powf+0x3d8>)
 80166ca:	ee77 6a87 	vadd.f32	s13, s15, s14
 80166ce:	eef7 5a00 	vmov.f32	s11, #112	; 0x3f800000  1.0
 80166d2:	ee85 5aa6 	vdiv.f32	s10, s11, s13
 80166d6:	1049      	asrs	r1, r1, #1
 80166d8:	f041 5100 	orr.w	r1, r1, #536870912	; 0x20000000
 80166dc:	f501 2180 	add.w	r1, r1, #262144	; 0x40000
 80166e0:	eb01 5144 	add.w	r1, r1, r4, lsl #21
 80166e4:	ee37 6ac7 	vsub.f32	s12, s15, s14
 80166e8:	ee06 1a90 	vmov	s13, r1
 80166ec:	ee66 4a05 	vmul.f32	s9, s12, s10
 80166f0:	ee14 ea90 	vmov	lr, s9
 80166f4:	ea02 0e0e 	and.w	lr, r2, lr
 80166f8:	ee05 ea90 	vmov	s11, lr
 80166fc:	eeb1 4a65 	vneg.f32	s8, s11
 8016700:	eea4 6a26 	vfma.f32	s12, s8, s13
 8016704:	ee76 6ac7 	vsub.f32	s13, s13, s14
 8016708:	ee35 7aa4 	vadd.f32	s14, s11, s9
 801670c:	ee77 6ae6 	vsub.f32	s13, s15, s13
 8016710:	eddf 7a49 	vldr	s15, [pc, #292]	; 8016838 <__ieee754_powf+0x3dc>
 8016714:	eea4 6a26 	vfma.f32	s12, s8, s13
 8016718:	ee66 6a05 	vmul.f32	s13, s12, s10
 801671c:	ee24 6aa4 	vmul.f32	s12, s9, s9
 8016720:	ed9f 5a46 	vldr	s10, [pc, #280]	; 801683c <__ieee754_powf+0x3e0>
 8016724:	eee6 7a05 	vfma.f32	s15, s12, s10
 8016728:	ed9f 5a45 	vldr	s10, [pc, #276]	; 8016840 <__ieee754_powf+0x3e4>
 801672c:	eea6 5a27 	vfma.f32	s10, s12, s15
 8016730:	eddf 7a38 	vldr	s15, [pc, #224]	; 8016814 <__ieee754_powf+0x3b8>
 8016734:	eee6 7a05 	vfma.f32	s15, s12, s10
 8016738:	ed9f 5a42 	vldr	s10, [pc, #264]	; 8016844 <__ieee754_powf+0x3e8>
 801673c:	eea6 5a27 	vfma.f32	s10, s12, s15
 8016740:	eddf 7a41 	vldr	s15, [pc, #260]	; 8016848 <__ieee754_powf+0x3ec>
 8016744:	eee6 7a05 	vfma.f32	s15, s12, s10
 8016748:	ee66 3a06 	vmul.f32	s7, s12, s12
 801674c:	eeb0 5a08 	vmov.f32	s10, #8	; 0x40400000  3.0
 8016750:	ee27 7a26 	vmul.f32	s14, s14, s13
 8016754:	eeb0 6a45 	vmov.f32	s12, s10
 8016758:	eea3 7aa7 	vfma.f32	s14, s7, s15
 801675c:	eea5 6aa5 	vfma.f32	s12, s11, s11
 8016760:	ee36 6a07 	vadd.f32	s12, s12, s14
 8016764:	ee16 1a10 	vmov	r1, s12
 8016768:	4011      	ands	r1, r2
 801676a:	ee06 1a10 	vmov	s12, r1
 801676e:	ee76 7a45 	vsub.f32	s15, s12, s10
 8016772:	ed9f 5a36 	vldr	s10, [pc, #216]	; 801684c <__ieee754_powf+0x3f0>
 8016776:	eee4 7a25 	vfma.f32	s15, s8, s11
 801677a:	ee77 7a67 	vsub.f32	s15, s14, s15
 801677e:	ee67 7aa4 	vmul.f32	s15, s15, s9
 8016782:	eee6 7a26 	vfma.f32	s15, s12, s13
 8016786:	eeb0 7a67 	vmov.f32	s14, s15
 801678a:	eea5 7a86 	vfma.f32	s14, s11, s12
 801678e:	ee17 1a10 	vmov	r1, s14
 8016792:	4011      	ands	r1, r2
 8016794:	ee07 1a10 	vmov	s14, r1
 8016798:	eea4 7a06 	vfma.f32	s14, s8, s12
 801679c:	ee05 1a90 	vmov	s11, r1
 80167a0:	ee77 7ac7 	vsub.f32	s15, s15, s14
 80167a4:	ed9f 7a2a 	vldr	s14, [pc, #168]	; 8016850 <__ieee754_powf+0x3f4>
 80167a8:	492a      	ldr	r1, [pc, #168]	; (8016854 <__ieee754_powf+0x3f8>)
 80167aa:	ee67 7a87 	vmul.f32	s15, s15, s14
 80167ae:	ed9f 7a2a 	vldr	s14, [pc, #168]	; 8016858 <__ieee754_powf+0x3fc>
 80167b2:	eee5 7a87 	vfma.f32	s15, s11, s14
 80167b6:	4439      	add	r1, r7
 80167b8:	ed91 7a00 	vldr	s14, [r1]
 80167bc:	ee37 7a87 	vadd.f32	s14, s15, s14
 80167c0:	ee07 3a90 	vmov	s15, r3
 80167c4:	eeb0 6a47 	vmov.f32	s12, s14
 80167c8:	4b24      	ldr	r3, [pc, #144]	; (801685c <__ieee754_powf+0x400>)
 80167ca:	eea5 6a85 	vfma.f32	s12, s11, s10
 80167ce:	443b      	add	r3, r7
 80167d0:	edd3 4a00 	vldr	s9, [r3]
 80167d4:	eef8 6ae7 	vcvt.f32.s32	s13, s15
 80167d8:	ee36 6a24 	vadd.f32	s12, s12, s9
 80167dc:	ee76 7a26 	vadd.f32	s15, s12, s13
 80167e0:	ee17 3a90 	vmov	r3, s15
 80167e4:	4013      	ands	r3, r2
 80167e6:	ee07 3a90 	vmov	s15, r3
 80167ea:	ee77 7ae6 	vsub.f32	s15, s15, s13
 80167ee:	ee77 7ae4 	vsub.f32	s15, s15, s9
 80167f2:	eee5 7ac5 	vfms.f32	s15, s11, s10
 80167f6:	ee77 7a67 	vsub.f32	s15, s14, s15
 80167fa:	e70e      	b.n	801661a <__ieee754_powf+0x1be>
 80167fc:	2401      	movs	r4, #1
 80167fe:	e75c      	b.n	80166ba <__ieee754_powf+0x25e>
 8016800:	0806bc59 	.word	0x0806bc59
 8016804:	00000000 	.word	0x00000000
 8016808:	3f7ffff7 	.word	0x3f7ffff7
 801680c:	7149f2ca 	.word	0x7149f2ca
 8016810:	3f800007 	.word	0x3f800007
 8016814:	3eaaaaab 	.word	0x3eaaaaab
 8016818:	3fb8aa00 	.word	0x3fb8aa00
 801681c:	3fb8aa3b 	.word	0x3fb8aa3b
 8016820:	36eca570 	.word	0x36eca570
 8016824:	4b800000 	.word	0x4b800000
 8016828:	001cc471 	.word	0x001cc471
 801682c:	005db3d6 	.word	0x005db3d6
 8016830:	0806bc28 	.word	0x0806bc28
 8016834:	fffff000 	.word	0xfffff000
 8016838:	3e6c3255 	.word	0x3e6c3255
 801683c:	3e53f142 	.word	0x3e53f142
 8016840:	3e8ba305 	.word	0x3e8ba305
 8016844:	3edb6db7 	.word	0x3edb6db7
 8016848:	3f19999a 	.word	0x3f19999a
 801684c:	3f763800 	.word	0x3f763800
 8016850:	3f76384f 	.word	0x3f76384f
 8016854:	0806bc38 	.word	0x0806bc38
 8016858:	369dc3a0 	.word	0x369dc3a0
 801685c:	0806bc30 	.word	0x0806bc30
 8016860:	3338aa3c 	.word	0x3338aa3c
 8016864:	f040 8094 	bne.w	8016990 <__ieee754_powf+0x534>
 8016868:	ed1f 6a03 	vldr	s12, [pc, #-12]	; 8016860 <__ieee754_powf+0x404>
 801686c:	ee76 6ac7 	vsub.f32	s13, s13, s14
 8016870:	ee37 6a86 	vadd.f32	s12, s15, s12
 8016874:	eeb4 6ae6 	vcmpe.f32	s12, s13
 8016878:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801687c:	f73f aef6 	bgt.w	801666c <__ieee754_powf+0x210>
 8016880:	15db      	asrs	r3, r3, #23
 8016882:	f1a3 007e 	sub.w	r0, r3, #126	; 0x7e
 8016886:	f44f 0300 	mov.w	r3, #8388608	; 0x800000
 801688a:	4103      	asrs	r3, r0
 801688c:	4423      	add	r3, r4
 801688e:	f3c3 52c7 	ubfx	r2, r3, #23, #8
 8016892:	4948      	ldr	r1, [pc, #288]	; (80169b4 <__ieee754_powf+0x558>)
 8016894:	3a7f      	subs	r2, #127	; 0x7f
 8016896:	4111      	asrs	r1, r2
 8016898:	ea23 0101 	bic.w	r1, r3, r1
 801689c:	f3c3 0016 	ubfx	r0, r3, #0, #23
 80168a0:	ee06 1a90 	vmov	s13, r1
 80168a4:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
 80168a8:	f1c2 0217 	rsb	r2, r2, #23
 80168ac:	4110      	asrs	r0, r2
 80168ae:	2c00      	cmp	r4, #0
 80168b0:	ee37 7a66 	vsub.f32	s14, s14, s13
 80168b4:	bfb8      	it	lt
 80168b6:	4240      	neglt	r0, r0
 80168b8:	ee77 6a27 	vadd.f32	s13, s14, s15
 80168bc:	ed9f 6a3e 	vldr	s12, [pc, #248]	; 80169b8 <__ieee754_powf+0x55c>
 80168c0:	ee16 3a90 	vmov	r3, s13
 80168c4:	f423 637f 	bic.w	r3, r3, #4080	; 0xff0
 80168c8:	f023 030f 	bic.w	r3, r3, #15
 80168cc:	ee06 3a90 	vmov	s13, r3
 80168d0:	ee36 7ac7 	vsub.f32	s14, s13, s14
 80168d4:	ee77 7ac7 	vsub.f32	s15, s15, s14
 80168d8:	ed9f 7a38 	vldr	s14, [pc, #224]	; 80169bc <__ieee754_powf+0x560>
 80168dc:	ee26 7a87 	vmul.f32	s14, s13, s14
 80168e0:	eea7 7a86 	vfma.f32	s14, s15, s12
 80168e4:	eef0 7a47 	vmov.f32	s15, s14
 80168e8:	ed9f 7a35 	vldr	s14, [pc, #212]	; 80169c0 <__ieee754_powf+0x564>
 80168ec:	eeb0 0a67 	vmov.f32	s0, s15
 80168f0:	eea6 0a87 	vfma.f32	s0, s13, s14
 80168f4:	eeb0 6a40 	vmov.f32	s12, s0
 80168f8:	eea6 6ac7 	vfms.f32	s12, s13, s14
 80168fc:	ee20 7a00 	vmul.f32	s14, s0, s0
 8016900:	ee77 7ac6 	vsub.f32	s15, s15, s12
 8016904:	eddf 6a2f 	vldr	s13, [pc, #188]	; 80169c4 <__ieee754_powf+0x568>
 8016908:	ed9f 6a2f 	vldr	s12, [pc, #188]	; 80169c8 <__ieee754_powf+0x56c>
 801690c:	eea7 6a26 	vfma.f32	s12, s14, s13
 8016910:	eddf 6a2e 	vldr	s13, [pc, #184]	; 80169cc <__ieee754_powf+0x570>
 8016914:	eee7 6a06 	vfma.f32	s13, s14, s12
 8016918:	ed9f 6a2d 	vldr	s12, [pc, #180]	; 80169d0 <__ieee754_powf+0x574>
 801691c:	eea7 6a26 	vfma.f32	s12, s14, s13
 8016920:	eddf 6a2c 	vldr	s13, [pc, #176]	; 80169d4 <__ieee754_powf+0x578>
 8016924:	eee7 6a06 	vfma.f32	s13, s14, s12
 8016928:	eeb0 6a40 	vmov.f32	s12, s0
 801692c:	eea7 6a66 	vfms.f32	s12, s14, s13
 8016930:	eef0 6a00 	vmov.f32	s13, #0	; 0x40000000  2.0
 8016934:	eeb0 7a46 	vmov.f32	s14, s12
 8016938:	ee77 6a66 	vsub.f32	s13, s14, s13
 801693c:	ee20 6a06 	vmul.f32	s12, s0, s12
 8016940:	eee0 7a27 	vfma.f32	s15, s0, s15
 8016944:	ee86 7a26 	vdiv.f32	s14, s12, s13
 8016948:	ee77 7a67 	vsub.f32	s15, s14, s15
 801694c:	ee37 0ac0 	vsub.f32	s0, s15, s0
 8016950:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
 8016954:	ee37 0ac0 	vsub.f32	s0, s15, s0
 8016958:	ee10 3a10 	vmov	r3, s0
 801695c:	eb03 53c0 	add.w	r3, r3, r0, lsl #23
 8016960:	f5b3 0f00 	cmp.w	r3, #8388608	; 0x800000
 8016964:	da1a      	bge.n	801699c <__ieee754_powf+0x540>
 8016966:	f000 f925 	bl	8016bb4 <scalbnf>
 801696a:	ee20 0a08 	vmul.f32	s0, s0, s16
 801696e:	e5c7      	b.n	8016500 <__ieee754_powf+0xa4>
 8016970:	4a19      	ldr	r2, [pc, #100]	; (80169d8 <__ieee754_powf+0x57c>)
 8016972:	4293      	cmp	r3, r2
 8016974:	dd02      	ble.n	801697c <__ieee754_powf+0x520>
 8016976:	eddf 7a19 	vldr	s15, [pc, #100]	; 80169dc <__ieee754_powf+0x580>
 801697a:	e679      	b.n	8016670 <__ieee754_powf+0x214>
 801697c:	d108      	bne.n	8016990 <__ieee754_powf+0x534>
 801697e:	ee76 6ac7 	vsub.f32	s13, s13, s14
 8016982:	eef4 7ae6 	vcmpe.f32	s15, s13
 8016986:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801698a:	f63f af79 	bhi.w	8016880 <__ieee754_powf+0x424>
 801698e:	e7f2      	b.n	8016976 <__ieee754_powf+0x51a>
 8016990:	f1b3 5f7c 	cmp.w	r3, #1056964608	; 0x3f000000
 8016994:	f73f af74 	bgt.w	8016880 <__ieee754_powf+0x424>
 8016998:	2000      	movs	r0, #0
 801699a:	e78d      	b.n	80168b8 <__ieee754_powf+0x45c>
 801699c:	ee00 3a10 	vmov	s0, r3
 80169a0:	e7e3      	b.n	801696a <__ieee754_powf+0x50e>
 80169a2:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
 80169a6:	e5ab      	b.n	8016500 <__ieee754_powf+0xa4>
 80169a8:	eeb0 0a68 	vmov.f32	s0, s17
 80169ac:	e5a8      	b.n	8016500 <__ieee754_powf+0xa4>
 80169ae:	eeb0 0a48 	vmov.f32	s0, s16
 80169b2:	e5a5      	b.n	8016500 <__ieee754_powf+0xa4>
 80169b4:	007fffff 	.word	0x007fffff
 80169b8:	3f317218 	.word	0x3f317218
 80169bc:	35bfbe8c 	.word	0x35bfbe8c
 80169c0:	3f317200 	.word	0x3f317200
 80169c4:	3331bb4c 	.word	0x3331bb4c
 80169c8:	b5ddea0e 	.word	0xb5ddea0e
 80169cc:	388ab355 	.word	0x388ab355
 80169d0:	bb360b61 	.word	0xbb360b61
 80169d4:	3e2aaaab 	.word	0x3e2aaaab
 80169d8:	43160000 	.word	0x43160000
 80169dc:	0da24260 	.word	0x0da24260

080169e0 <__ieee754_sqrtf>:
 80169e0:	ee10 2a10 	vmov	r2, s0
 80169e4:	f022 4100 	bic.w	r1, r2, #2147483648	; 0x80000000
 80169e8:	f1b1 4fff 	cmp.w	r1, #2139095040	; 0x7f800000
 80169ec:	b570      	push	{r4, r5, r6, lr}
 80169ee:	d302      	bcc.n	80169f6 <__ieee754_sqrtf+0x16>
 80169f0:	eea0 0a00 	vfma.f32	s0, s0, s0
 80169f4:	bd70      	pop	{r4, r5, r6, pc}
 80169f6:	b3b1      	cbz	r1, 8016a66 <__ieee754_sqrtf+0x86>
 80169f8:	2a00      	cmp	r2, #0
 80169fa:	da04      	bge.n	8016a06 <__ieee754_sqrtf+0x26>
 80169fc:	ee70 7a40 	vsub.f32	s15, s0, s0
 8016a00:	ee87 0aa7 	vdiv.f32	s0, s15, s15
 8016a04:	bd70      	pop	{r4, r5, r6, pc}
 8016a06:	f5b1 0f00 	cmp.w	r1, #8388608	; 0x800000
 8016a0a:	ea4f 53e2 	mov.w	r3, r2, asr #23
 8016a0e:	d204      	bcs.n	8016a1a <__ieee754_sqrtf+0x3a>
 8016a10:	2100      	movs	r1, #0
 8016a12:	0210      	lsls	r0, r2, #8
 8016a14:	d528      	bpl.n	8016a68 <__ieee754_sqrtf+0x88>
 8016a16:	3901      	subs	r1, #1
 8016a18:	1a5b      	subs	r3, r3, r1
 8016a1a:	3b7f      	subs	r3, #127	; 0x7f
 8016a1c:	f3c2 0216 	ubfx	r2, r2, #0, #23
 8016a20:	07d9      	lsls	r1, r3, #31
 8016a22:	f442 0200 	orr.w	r2, r2, #8388608	; 0x800000
 8016a26:	bf48      	it	mi
 8016a28:	0052      	lslmi	r2, r2, #1
 8016a2a:	1059      	asrs	r1, r3, #1
 8016a2c:	2300      	movs	r3, #0
 8016a2e:	0052      	lsls	r2, r2, #1
 8016a30:	2419      	movs	r4, #25
 8016a32:	461e      	mov	r6, r3
 8016a34:	f04f 7080 	mov.w	r0, #16777216	; 0x1000000
 8016a38:	1835      	adds	r5, r6, r0
 8016a3a:	4295      	cmp	r5, r2
 8016a3c:	bfde      	ittt	le
 8016a3e:	182e      	addle	r6, r5, r0
 8016a40:	1b52      	suble	r2, r2, r5
 8016a42:	181b      	addle	r3, r3, r0
 8016a44:	3c01      	subs	r4, #1
 8016a46:	ea4f 0242 	mov.w	r2, r2, lsl #1
 8016a4a:	ea4f 0050 	mov.w	r0, r0, lsr #1
 8016a4e:	d1f3      	bne.n	8016a38 <__ieee754_sqrtf+0x58>
 8016a50:	b112      	cbz	r2, 8016a58 <__ieee754_sqrtf+0x78>
 8016a52:	3301      	adds	r3, #1
 8016a54:	f023 0301 	bic.w	r3, r3, #1
 8016a58:	105b      	asrs	r3, r3, #1
 8016a5a:	f103 537c 	add.w	r3, r3, #1056964608	; 0x3f000000
 8016a5e:	eb03 53c1 	add.w	r3, r3, r1, lsl #23
 8016a62:	ee00 3a10 	vmov	s0, r3
 8016a66:	bd70      	pop	{r4, r5, r6, pc}
 8016a68:	0052      	lsls	r2, r2, #1
 8016a6a:	3101      	adds	r1, #1
 8016a6c:	e7d1      	b.n	8016a12 <__ieee754_sqrtf+0x32>

08016a6e <matherr>:
 8016a6e:	2000      	movs	r0, #0
 8016a70:	4770      	bx	lr
	...

08016a74 <rint>:
 8016a74:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 8016a76:	ec51 0b10 	vmov	r0, r1, d0
 8016a7a:	f3c1 540a 	ubfx	r4, r1, #20, #11
 8016a7e:	f2a4 36ff 	subw	r6, r4, #1023	; 0x3ff
 8016a82:	2e13      	cmp	r6, #19
 8016a84:	ee10 7a10 	vmov	r7, s0
 8016a88:	460b      	mov	r3, r1
 8016a8a:	4602      	mov	r2, r0
 8016a8c:	ea4f 75d1 	mov.w	r5, r1, lsr #31
 8016a90:	dc58      	bgt.n	8016b44 <rint+0xd0>
 8016a92:	2e00      	cmp	r6, #0
 8016a94:	da2b      	bge.n	8016aee <rint+0x7a>
 8016a96:	f021 4200 	bic.w	r2, r1, #2147483648	; 0x80000000
 8016a9a:	4302      	orrs	r2, r0
 8016a9c:	d023      	beq.n	8016ae6 <rint+0x72>
 8016a9e:	f3c1 0213 	ubfx	r2, r1, #0, #20
 8016aa2:	4302      	orrs	r2, r0
 8016aa4:	4251      	negs	r1, r2
 8016aa6:	4311      	orrs	r1, r2
 8016aa8:	0b09      	lsrs	r1, r1, #12
 8016aaa:	0c5b      	lsrs	r3, r3, #17
 8016aac:	f401 2100 	and.w	r1, r1, #524288	; 0x80000
 8016ab0:	045b      	lsls	r3, r3, #17
 8016ab2:	ea41 0703 	orr.w	r7, r1, r3
 8016ab6:	4b31      	ldr	r3, [pc, #196]	; (8016b7c <rint+0x108>)
 8016ab8:	eb03 03c5 	add.w	r3, r3, r5, lsl #3
 8016abc:	4639      	mov	r1, r7
 8016abe:	e9d3 6700 	ldrd	r6, r7, [r3]
 8016ac2:	ee10 0a10 	vmov	r0, s0
 8016ac6:	4632      	mov	r2, r6
 8016ac8:	463b      	mov	r3, r7
 8016aca:	f7fe fe47 	bl	801575c <__adddf3>
 8016ace:	e9cd 0100 	strd	r0, r1, [sp]
 8016ad2:	463b      	mov	r3, r7
 8016ad4:	4632      	mov	r2, r6
 8016ad6:	e9dd 0100 	ldrd	r0, r1, [sp]
 8016ada:	f7fe fe3d 	bl	8015758 <__aeabi_dsub>
 8016ade:	f021 4300 	bic.w	r3, r1, #2147483648	; 0x80000000
 8016ae2:	ea43 71c5 	orr.w	r1, r3, r5, lsl #31
 8016ae6:	ec41 0b10 	vmov	d0, r0, r1
 8016aea:	b003      	add	sp, #12
 8016aec:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8016aee:	4c24      	ldr	r4, [pc, #144]	; (8016b80 <rint+0x10c>)
 8016af0:	4134      	asrs	r4, r6
 8016af2:	ea01 0704 	and.w	r7, r1, r4
 8016af6:	4307      	orrs	r7, r0
 8016af8:	d0f5      	beq.n	8016ae6 <rint+0x72>
 8016afa:	0861      	lsrs	r1, r4, #1
 8016afc:	ea03 0001 	and.w	r0, r3, r1
 8016b00:	4302      	orrs	r2, r0
 8016b02:	d00b      	beq.n	8016b1c <rint+0xa8>
 8016b04:	ea23 0101 	bic.w	r1, r3, r1
 8016b08:	f44f 2380 	mov.w	r3, #262144	; 0x40000
 8016b0c:	2e13      	cmp	r6, #19
 8016b0e:	fa43 f306 	asr.w	r3, r3, r6
 8016b12:	bf0c      	ite	eq
 8016b14:	f04f 4200 	moveq.w	r2, #2147483648	; 0x80000000
 8016b18:	2200      	movne	r2, #0
 8016b1a:	430b      	orrs	r3, r1
 8016b1c:	4619      	mov	r1, r3
 8016b1e:	4b17      	ldr	r3, [pc, #92]	; (8016b7c <rint+0x108>)
 8016b20:	eb03 05c5 	add.w	r5, r3, r5, lsl #3
 8016b24:	e9d5 4500 	ldrd	r4, r5, [r5]
 8016b28:	4610      	mov	r0, r2
 8016b2a:	462b      	mov	r3, r5
 8016b2c:	4622      	mov	r2, r4
 8016b2e:	f7fe fe15 	bl	801575c <__adddf3>
 8016b32:	e9cd 0100 	strd	r0, r1, [sp]
 8016b36:	4622      	mov	r2, r4
 8016b38:	462b      	mov	r3, r5
 8016b3a:	e9dd 0100 	ldrd	r0, r1, [sp]
 8016b3e:	f7fe fe0b 	bl	8015758 <__aeabi_dsub>
 8016b42:	e7d0      	b.n	8016ae6 <rint+0x72>
 8016b44:	2e33      	cmp	r6, #51	; 0x33
 8016b46:	dd08      	ble.n	8016b5a <rint+0xe6>
 8016b48:	f5b6 6f80 	cmp.w	r6, #1024	; 0x400
 8016b4c:	d1cb      	bne.n	8016ae6 <rint+0x72>
 8016b4e:	ee10 2a10 	vmov	r2, s0
 8016b52:	460b      	mov	r3, r1
 8016b54:	f7fe fe02 	bl	801575c <__adddf3>
 8016b58:	e7c5      	b.n	8016ae6 <rint+0x72>
 8016b5a:	f2a4 4613 	subw	r6, r4, #1043	; 0x413
 8016b5e:	f04f 34ff 	mov.w	r4, #4294967295
 8016b62:	40f4      	lsrs	r4, r6
 8016b64:	4220      	tst	r0, r4
 8016b66:	d0be      	beq.n	8016ae6 <rint+0x72>
 8016b68:	0861      	lsrs	r1, r4, #1
 8016b6a:	420f      	tst	r7, r1
 8016b6c:	bf1f      	itttt	ne
 8016b6e:	f04f 4280 	movne.w	r2, #1073741824	; 0x40000000
 8016b72:	ea27 0101 	bicne.w	r1, r7, r1
 8016b76:	4132      	asrne	r2, r6
 8016b78:	430a      	orrne	r2, r1
 8016b7a:	e7cf      	b.n	8016b1c <rint+0xa8>
 8016b7c:	0806bc40 	.word	0x0806bc40
 8016b80:	000fffff 	.word	0x000fffff

08016b84 <fabsf>:
 8016b84:	ee10 3a10 	vmov	r3, s0
 8016b88:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
 8016b8c:	ee00 3a10 	vmov	s0, r3
 8016b90:	4770      	bx	lr

08016b92 <finitef>:
 8016b92:	ee10 3a10 	vmov	r3, s0
 8016b96:	f023 4000 	bic.w	r0, r3, #2147483648	; 0x80000000
 8016b9a:	f1b0 4fff 	cmp.w	r0, #2139095040	; 0x7f800000
 8016b9e:	bfac      	ite	ge
 8016ba0:	2000      	movge	r0, #0
 8016ba2:	2001      	movlt	r0, #1
 8016ba4:	4770      	bx	lr
	...

08016ba8 <nanf>:
 8016ba8:	ed9f 0a01 	vldr	s0, [pc, #4]	; 8016bb0 <nanf+0x8>
 8016bac:	4770      	bx	lr
 8016bae:	bf00      	nop
 8016bb0:	7fc00000 	.word	0x7fc00000

08016bb4 <scalbnf>:
 8016bb4:	b508      	push	{r3, lr}
 8016bb6:	ee10 2a10 	vmov	r2, s0
 8016bba:	f032 4300 	bics.w	r3, r2, #2147483648	; 0x80000000
 8016bbe:	ed2d 8b02 	vpush	{d8}
 8016bc2:	eef0 0a40 	vmov.f32	s1, s0
 8016bc6:	d004      	beq.n	8016bd2 <scalbnf+0x1e>
 8016bc8:	f1b3 4fff 	cmp.w	r3, #2139095040	; 0x7f800000
 8016bcc:	d306      	bcc.n	8016bdc <scalbnf+0x28>
 8016bce:	ee70 0a00 	vadd.f32	s1, s0, s0
 8016bd2:	ecbd 8b02 	vpop	{d8}
 8016bd6:	eeb0 0a60 	vmov.f32	s0, s1
 8016bda:	bd08      	pop	{r3, pc}
 8016bdc:	f5b3 0f00 	cmp.w	r3, #8388608	; 0x800000
 8016be0:	d21c      	bcs.n	8016c1c <scalbnf+0x68>
 8016be2:	4b1f      	ldr	r3, [pc, #124]	; (8016c60 <scalbnf+0xac>)
 8016be4:	eddf 7a1f 	vldr	s15, [pc, #124]	; 8016c64 <scalbnf+0xb0>
 8016be8:	4298      	cmp	r0, r3
 8016bea:	ee60 0a27 	vmul.f32	s1, s0, s15
 8016bee:	db10      	blt.n	8016c12 <scalbnf+0x5e>
 8016bf0:	ee10 2a90 	vmov	r2, s1
 8016bf4:	f3c2 53c7 	ubfx	r3, r2, #23, #8
 8016bf8:	3b19      	subs	r3, #25
 8016bfa:	4403      	add	r3, r0
 8016bfc:	2bfe      	cmp	r3, #254	; 0xfe
 8016bfe:	dd0f      	ble.n	8016c20 <scalbnf+0x6c>
 8016c00:	ed9f 8a19 	vldr	s16, [pc, #100]	; 8016c68 <scalbnf+0xb4>
 8016c04:	eeb0 0a48 	vmov.f32	s0, s16
 8016c08:	f000 f834 	bl	8016c74 <copysignf>
 8016c0c:	ee60 0a08 	vmul.f32	s1, s0, s16
 8016c10:	e7df      	b.n	8016bd2 <scalbnf+0x1e>
 8016c12:	eddf 7a16 	vldr	s15, [pc, #88]	; 8016c6c <scalbnf+0xb8>
 8016c16:	ee60 0aa7 	vmul.f32	s1, s1, s15
 8016c1a:	e7da      	b.n	8016bd2 <scalbnf+0x1e>
 8016c1c:	0ddb      	lsrs	r3, r3, #23
 8016c1e:	e7ec      	b.n	8016bfa <scalbnf+0x46>
 8016c20:	2b00      	cmp	r3, #0
 8016c22:	dd06      	ble.n	8016c32 <scalbnf+0x7e>
 8016c24:	f022 42ff 	bic.w	r2, r2, #2139095040	; 0x7f800000
 8016c28:	ea42 53c3 	orr.w	r3, r2, r3, lsl #23
 8016c2c:	ee00 3a90 	vmov	s1, r3
 8016c30:	e7cf      	b.n	8016bd2 <scalbnf+0x1e>
 8016c32:	f113 0f16 	cmn.w	r3, #22
 8016c36:	da06      	bge.n	8016c46 <scalbnf+0x92>
 8016c38:	f24c 3350 	movw	r3, #50000	; 0xc350
 8016c3c:	4298      	cmp	r0, r3
 8016c3e:	dcdf      	bgt.n	8016c00 <scalbnf+0x4c>
 8016c40:	ed9f 8a0a 	vldr	s16, [pc, #40]	; 8016c6c <scalbnf+0xb8>
 8016c44:	e7de      	b.n	8016c04 <scalbnf+0x50>
 8016c46:	3319      	adds	r3, #25
 8016c48:	f022 42ff 	bic.w	r2, r2, #2139095040	; 0x7f800000
 8016c4c:	ea42 53c3 	orr.w	r3, r2, r3, lsl #23
 8016c50:	eddf 7a07 	vldr	s15, [pc, #28]	; 8016c70 <scalbnf+0xbc>
 8016c54:	ee07 3a10 	vmov	s14, r3
 8016c58:	ee67 0a27 	vmul.f32	s1, s14, s15
 8016c5c:	e7b9      	b.n	8016bd2 <scalbnf+0x1e>
 8016c5e:	bf00      	nop
 8016c60:	ffff3cb0 	.word	0xffff3cb0
 8016c64:	4c000000 	.word	0x4c000000
 8016c68:	7149f2ca 	.word	0x7149f2ca
 8016c6c:	0da24260 	.word	0x0da24260
 8016c70:	33000000 	.word	0x33000000

08016c74 <copysignf>:
 8016c74:	ee10 3a10 	vmov	r3, s0
 8016c78:	ee10 2a90 	vmov	r2, s1
 8016c7c:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
 8016c80:	f002 4200 	and.w	r2, r2, #2147483648	; 0x80000000
 8016c84:	4313      	orrs	r3, r2
 8016c86:	ee00 3a10 	vmov	s0, r3
 8016c8a:	4770      	bx	lr

08016c8c <__libc_init_array>:
 8016c8c:	b570      	push	{r4, r5, r6, lr}
 8016c8e:	4e0d      	ldr	r6, [pc, #52]	; (8016cc4 <__libc_init_array+0x38>)
 8016c90:	4c0d      	ldr	r4, [pc, #52]	; (8016cc8 <__libc_init_array+0x3c>)
 8016c92:	1ba4      	subs	r4, r4, r6
 8016c94:	10a4      	asrs	r4, r4, #2
 8016c96:	2500      	movs	r5, #0
 8016c98:	42a5      	cmp	r5, r4
 8016c9a:	d109      	bne.n	8016cb0 <__libc_init_array+0x24>
 8016c9c:	4e0b      	ldr	r6, [pc, #44]	; (8016ccc <__libc_init_array+0x40>)
 8016c9e:	4c0c      	ldr	r4, [pc, #48]	; (8016cd0 <__libc_init_array+0x44>)
 8016ca0:	f000 fcc2 	bl	8017628 <_init>
 8016ca4:	1ba4      	subs	r4, r4, r6
 8016ca6:	10a4      	asrs	r4, r4, #2
 8016ca8:	2500      	movs	r5, #0
 8016caa:	42a5      	cmp	r5, r4
 8016cac:	d105      	bne.n	8016cba <__libc_init_array+0x2e>
 8016cae:	bd70      	pop	{r4, r5, r6, pc}
 8016cb0:	f856 3025 	ldr.w	r3, [r6, r5, lsl #2]
 8016cb4:	4798      	blx	r3
 8016cb6:	3501      	adds	r5, #1
 8016cb8:	e7ee      	b.n	8016c98 <__libc_init_array+0xc>
 8016cba:	f856 3025 	ldr.w	r3, [r6, r5, lsl #2]
 8016cbe:	4798      	blx	r3
 8016cc0:	3501      	adds	r5, #1
 8016cc2:	e7f2      	b.n	8016caa <__libc_init_array+0x1e>
 8016cc4:	0806bc88 	.word	0x0806bc88
 8016cc8:	0806bc88 	.word	0x0806bc88
 8016ccc:	0806bc88 	.word	0x0806bc88
 8016cd0:	0806bc8c 	.word	0x0806bc8c

08016cd4 <memcpy>:
 8016cd4:	b510      	push	{r4, lr}
 8016cd6:	1e43      	subs	r3, r0, #1
 8016cd8:	440a      	add	r2, r1
 8016cda:	4291      	cmp	r1, r2
 8016cdc:	d100      	bne.n	8016ce0 <memcpy+0xc>
 8016cde:	bd10      	pop	{r4, pc}
 8016ce0:	f811 4b01 	ldrb.w	r4, [r1], #1
 8016ce4:	f803 4f01 	strb.w	r4, [r3, #1]!
 8016ce8:	e7f7      	b.n	8016cda <memcpy+0x6>

08016cea <memmove>:
 8016cea:	4288      	cmp	r0, r1
 8016cec:	b510      	push	{r4, lr}
 8016cee:	eb01 0302 	add.w	r3, r1, r2
 8016cf2:	d803      	bhi.n	8016cfc <memmove+0x12>
 8016cf4:	1e42      	subs	r2, r0, #1
 8016cf6:	4299      	cmp	r1, r3
 8016cf8:	d10c      	bne.n	8016d14 <memmove+0x2a>
 8016cfa:	bd10      	pop	{r4, pc}
 8016cfc:	4298      	cmp	r0, r3
 8016cfe:	d2f9      	bcs.n	8016cf4 <memmove+0xa>
 8016d00:	1881      	adds	r1, r0, r2
 8016d02:	1ad2      	subs	r2, r2, r3
 8016d04:	42d3      	cmn	r3, r2
 8016d06:	d100      	bne.n	8016d0a <memmove+0x20>
 8016d08:	bd10      	pop	{r4, pc}
 8016d0a:	f813 4d01 	ldrb.w	r4, [r3, #-1]!
 8016d0e:	f801 4d01 	strb.w	r4, [r1, #-1]!
 8016d12:	e7f7      	b.n	8016d04 <memmove+0x1a>
 8016d14:	f811 4b01 	ldrb.w	r4, [r1], #1
 8016d18:	f802 4f01 	strb.w	r4, [r2, #1]!
 8016d1c:	e7eb      	b.n	8016cf6 <memmove+0xc>

08016d1e <_siprintf_r>:
 8016d1e:	b40c      	push	{r2, r3}
 8016d20:	b510      	push	{r4, lr}
 8016d22:	b09c      	sub	sp, #112	; 0x70
 8016d24:	ab1e      	add	r3, sp, #120	; 0x78
 8016d26:	9102      	str	r1, [sp, #8]
 8016d28:	9106      	str	r1, [sp, #24]
 8016d2a:	f06f 4100 	mvn.w	r1, #2147483648	; 0x80000000
 8016d2e:	9104      	str	r1, [sp, #16]
 8016d30:	9107      	str	r1, [sp, #28]
 8016d32:	f64f 71ff 	movw	r1, #65535	; 0xffff
 8016d36:	f853 2b04 	ldr.w	r2, [r3], #4
 8016d3a:	f8ad 1016 	strh.w	r1, [sp, #22]
 8016d3e:	f44f 7402 	mov.w	r4, #520	; 0x208
 8016d42:	a902      	add	r1, sp, #8
 8016d44:	9301      	str	r3, [sp, #4]
 8016d46:	f8ad 4014 	strh.w	r4, [sp, #20]
 8016d4a:	f000 f903 	bl	8016f54 <_svfiprintf_r>
 8016d4e:	9b02      	ldr	r3, [sp, #8]
 8016d50:	2200      	movs	r2, #0
 8016d52:	701a      	strb	r2, [r3, #0]
 8016d54:	b01c      	add	sp, #112	; 0x70
 8016d56:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 8016d5a:	b002      	add	sp, #8
 8016d5c:	4770      	bx	lr
	...

08016d60 <siprintf>:
 8016d60:	b40e      	push	{r1, r2, r3}
 8016d62:	b500      	push	{lr}
 8016d64:	b09c      	sub	sp, #112	; 0x70
 8016d66:	f44f 7102 	mov.w	r1, #520	; 0x208
 8016d6a:	ab1d      	add	r3, sp, #116	; 0x74
 8016d6c:	f8ad 1014 	strh.w	r1, [sp, #20]
 8016d70:	9002      	str	r0, [sp, #8]
 8016d72:	9006      	str	r0, [sp, #24]
 8016d74:	f06f 4100 	mvn.w	r1, #2147483648	; 0x80000000
 8016d78:	480a      	ldr	r0, [pc, #40]	; (8016da4 <siprintf+0x44>)
 8016d7a:	9104      	str	r1, [sp, #16]
 8016d7c:	9107      	str	r1, [sp, #28]
 8016d7e:	f64f 71ff 	movw	r1, #65535	; 0xffff
 8016d82:	f853 2b04 	ldr.w	r2, [r3], #4
 8016d86:	f8ad 1016 	strh.w	r1, [sp, #22]
 8016d8a:	6800      	ldr	r0, [r0, #0]
 8016d8c:	9301      	str	r3, [sp, #4]
 8016d8e:	a902      	add	r1, sp, #8
 8016d90:	f000 f8e0 	bl	8016f54 <_svfiprintf_r>
 8016d94:	9b02      	ldr	r3, [sp, #8]
 8016d96:	2200      	movs	r2, #0
 8016d98:	701a      	strb	r2, [r3, #0]
 8016d9a:	b01c      	add	sp, #112	; 0x70
 8016d9c:	f85d eb04 	ldr.w	lr, [sp], #4
 8016da0:	b003      	add	sp, #12
 8016da2:	4770      	bx	lr
 8016da4:	20000034 	.word	0x20000034

08016da8 <__ssputs_r>:
 8016da8:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8016dac:	688e      	ldr	r6, [r1, #8]
 8016dae:	429e      	cmp	r6, r3
 8016db0:	4682      	mov	sl, r0
 8016db2:	460c      	mov	r4, r1
 8016db4:	4691      	mov	r9, r2
 8016db6:	4698      	mov	r8, r3
 8016db8:	d835      	bhi.n	8016e26 <__ssputs_r+0x7e>
 8016dba:	898a      	ldrh	r2, [r1, #12]
 8016dbc:	f412 6f90 	tst.w	r2, #1152	; 0x480
 8016dc0:	d031      	beq.n	8016e26 <__ssputs_r+0x7e>
 8016dc2:	6825      	ldr	r5, [r4, #0]
 8016dc4:	6909      	ldr	r1, [r1, #16]
 8016dc6:	1a6f      	subs	r7, r5, r1
 8016dc8:	6965      	ldr	r5, [r4, #20]
 8016dca:	2302      	movs	r3, #2
 8016dcc:	eb05 0545 	add.w	r5, r5, r5, lsl #1
 8016dd0:	fb95 f5f3 	sdiv	r5, r5, r3
 8016dd4:	f108 0301 	add.w	r3, r8, #1
 8016dd8:	443b      	add	r3, r7
 8016dda:	429d      	cmp	r5, r3
 8016ddc:	bf38      	it	cc
 8016dde:	461d      	movcc	r5, r3
 8016de0:	0553      	lsls	r3, r2, #21
 8016de2:	d531      	bpl.n	8016e48 <__ssputs_r+0xa0>
 8016de4:	4629      	mov	r1, r5
 8016de6:	f000 fb8d 	bl	8017504 <_malloc_r>
 8016dea:	4606      	mov	r6, r0
 8016dec:	b950      	cbnz	r0, 8016e04 <__ssputs_r+0x5c>
 8016dee:	230c      	movs	r3, #12
 8016df0:	f8ca 3000 	str.w	r3, [sl]
 8016df4:	89a3      	ldrh	r3, [r4, #12]
 8016df6:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8016dfa:	81a3      	strh	r3, [r4, #12]
 8016dfc:	f04f 30ff 	mov.w	r0, #4294967295
 8016e00:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8016e04:	463a      	mov	r2, r7
 8016e06:	6921      	ldr	r1, [r4, #16]
 8016e08:	f7ff ff64 	bl	8016cd4 <memcpy>
 8016e0c:	89a3      	ldrh	r3, [r4, #12]
 8016e0e:	f423 6390 	bic.w	r3, r3, #1152	; 0x480
 8016e12:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8016e16:	81a3      	strh	r3, [r4, #12]
 8016e18:	6126      	str	r6, [r4, #16]
 8016e1a:	6165      	str	r5, [r4, #20]
 8016e1c:	443e      	add	r6, r7
 8016e1e:	1bed      	subs	r5, r5, r7
 8016e20:	6026      	str	r6, [r4, #0]
 8016e22:	60a5      	str	r5, [r4, #8]
 8016e24:	4646      	mov	r6, r8
 8016e26:	4546      	cmp	r6, r8
 8016e28:	bf28      	it	cs
 8016e2a:	4646      	movcs	r6, r8
 8016e2c:	4632      	mov	r2, r6
 8016e2e:	4649      	mov	r1, r9
 8016e30:	6820      	ldr	r0, [r4, #0]
 8016e32:	f7ff ff5a 	bl	8016cea <memmove>
 8016e36:	68a3      	ldr	r3, [r4, #8]
 8016e38:	1b9b      	subs	r3, r3, r6
 8016e3a:	60a3      	str	r3, [r4, #8]
 8016e3c:	6823      	ldr	r3, [r4, #0]
 8016e3e:	441e      	add	r6, r3
 8016e40:	6026      	str	r6, [r4, #0]
 8016e42:	2000      	movs	r0, #0
 8016e44:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8016e48:	462a      	mov	r2, r5
 8016e4a:	f000 fbb9 	bl	80175c0 <_realloc_r>
 8016e4e:	4606      	mov	r6, r0
 8016e50:	2800      	cmp	r0, #0
 8016e52:	d1e1      	bne.n	8016e18 <__ssputs_r+0x70>
 8016e54:	6921      	ldr	r1, [r4, #16]
 8016e56:	4650      	mov	r0, sl
 8016e58:	f000 fb06 	bl	8017468 <_free_r>
 8016e5c:	e7c7      	b.n	8016dee <__ssputs_r+0x46>

08016e5e <__ssprint_r>:
 8016e5e:	6893      	ldr	r3, [r2, #8]
 8016e60:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8016e64:	4681      	mov	r9, r0
 8016e66:	460c      	mov	r4, r1
 8016e68:	4617      	mov	r7, r2
 8016e6a:	2b00      	cmp	r3, #0
 8016e6c:	d060      	beq.n	8016f30 <__ssprint_r+0xd2>
 8016e6e:	f04f 0b00 	mov.w	fp, #0
 8016e72:	f8d2 a000 	ldr.w	sl, [r2]
 8016e76:	465e      	mov	r6, fp
 8016e78:	b356      	cbz	r6, 8016ed0 <__ssprint_r+0x72>
 8016e7a:	68a3      	ldr	r3, [r4, #8]
 8016e7c:	429e      	cmp	r6, r3
 8016e7e:	d344      	bcc.n	8016f0a <__ssprint_r+0xac>
 8016e80:	89a2      	ldrh	r2, [r4, #12]
 8016e82:	f412 6f90 	tst.w	r2, #1152	; 0x480
 8016e86:	d03e      	beq.n	8016f06 <__ssprint_r+0xa8>
 8016e88:	6825      	ldr	r5, [r4, #0]
 8016e8a:	6921      	ldr	r1, [r4, #16]
 8016e8c:	eba5 0801 	sub.w	r8, r5, r1
 8016e90:	6965      	ldr	r5, [r4, #20]
 8016e92:	2302      	movs	r3, #2
 8016e94:	eb05 0545 	add.w	r5, r5, r5, lsl #1
 8016e98:	fb95 f5f3 	sdiv	r5, r5, r3
 8016e9c:	f108 0301 	add.w	r3, r8, #1
 8016ea0:	4433      	add	r3, r6
 8016ea2:	429d      	cmp	r5, r3
 8016ea4:	bf38      	it	cc
 8016ea6:	461d      	movcc	r5, r3
 8016ea8:	0553      	lsls	r3, r2, #21
 8016eaa:	d546      	bpl.n	8016f3a <__ssprint_r+0xdc>
 8016eac:	4629      	mov	r1, r5
 8016eae:	4648      	mov	r0, r9
 8016eb0:	f000 fb28 	bl	8017504 <_malloc_r>
 8016eb4:	b998      	cbnz	r0, 8016ede <__ssprint_r+0x80>
 8016eb6:	230c      	movs	r3, #12
 8016eb8:	f8c9 3000 	str.w	r3, [r9]
 8016ebc:	89a3      	ldrh	r3, [r4, #12]
 8016ebe:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8016ec2:	81a3      	strh	r3, [r4, #12]
 8016ec4:	2300      	movs	r3, #0
 8016ec6:	60bb      	str	r3, [r7, #8]
 8016ec8:	607b      	str	r3, [r7, #4]
 8016eca:	f04f 30ff 	mov.w	r0, #4294967295
 8016ece:	e031      	b.n	8016f34 <__ssprint_r+0xd6>
 8016ed0:	f8da b000 	ldr.w	fp, [sl]
 8016ed4:	f8da 6004 	ldr.w	r6, [sl, #4]
 8016ed8:	f10a 0a08 	add.w	sl, sl, #8
 8016edc:	e7cc      	b.n	8016e78 <__ssprint_r+0x1a>
 8016ede:	4642      	mov	r2, r8
 8016ee0:	6921      	ldr	r1, [r4, #16]
 8016ee2:	9001      	str	r0, [sp, #4]
 8016ee4:	f7ff fef6 	bl	8016cd4 <memcpy>
 8016ee8:	89a2      	ldrh	r2, [r4, #12]
 8016eea:	9b01      	ldr	r3, [sp, #4]
 8016eec:	f422 6290 	bic.w	r2, r2, #1152	; 0x480
 8016ef0:	f042 0280 	orr.w	r2, r2, #128	; 0x80
 8016ef4:	81a2      	strh	r2, [r4, #12]
 8016ef6:	6123      	str	r3, [r4, #16]
 8016ef8:	6165      	str	r5, [r4, #20]
 8016efa:	4443      	add	r3, r8
 8016efc:	eba5 0508 	sub.w	r5, r5, r8
 8016f00:	6023      	str	r3, [r4, #0]
 8016f02:	60a5      	str	r5, [r4, #8]
 8016f04:	4633      	mov	r3, r6
 8016f06:	429e      	cmp	r6, r3
 8016f08:	d200      	bcs.n	8016f0c <__ssprint_r+0xae>
 8016f0a:	4633      	mov	r3, r6
 8016f0c:	461a      	mov	r2, r3
 8016f0e:	4659      	mov	r1, fp
 8016f10:	6820      	ldr	r0, [r4, #0]
 8016f12:	9301      	str	r3, [sp, #4]
 8016f14:	f7ff fee9 	bl	8016cea <memmove>
 8016f18:	68a2      	ldr	r2, [r4, #8]
 8016f1a:	9b01      	ldr	r3, [sp, #4]
 8016f1c:	1ad2      	subs	r2, r2, r3
 8016f1e:	60a2      	str	r2, [r4, #8]
 8016f20:	6822      	ldr	r2, [r4, #0]
 8016f22:	4413      	add	r3, r2
 8016f24:	6023      	str	r3, [r4, #0]
 8016f26:	68bb      	ldr	r3, [r7, #8]
 8016f28:	1b9e      	subs	r6, r3, r6
 8016f2a:	60be      	str	r6, [r7, #8]
 8016f2c:	2e00      	cmp	r6, #0
 8016f2e:	d1cf      	bne.n	8016ed0 <__ssprint_r+0x72>
 8016f30:	2000      	movs	r0, #0
 8016f32:	6078      	str	r0, [r7, #4]
 8016f34:	b003      	add	sp, #12
 8016f36:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8016f3a:	462a      	mov	r2, r5
 8016f3c:	4648      	mov	r0, r9
 8016f3e:	f000 fb3f 	bl	80175c0 <_realloc_r>
 8016f42:	4603      	mov	r3, r0
 8016f44:	2800      	cmp	r0, #0
 8016f46:	d1d6      	bne.n	8016ef6 <__ssprint_r+0x98>
 8016f48:	6921      	ldr	r1, [r4, #16]
 8016f4a:	4648      	mov	r0, r9
 8016f4c:	f000 fa8c 	bl	8017468 <_free_r>
 8016f50:	e7b1      	b.n	8016eb6 <__ssprint_r+0x58>
	...

08016f54 <_svfiprintf_r>:
 8016f54:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8016f58:	b09d      	sub	sp, #116	; 0x74
 8016f5a:	4680      	mov	r8, r0
 8016f5c:	9303      	str	r3, [sp, #12]
 8016f5e:	898b      	ldrh	r3, [r1, #12]
 8016f60:	061c      	lsls	r4, r3, #24
 8016f62:	460d      	mov	r5, r1
 8016f64:	4616      	mov	r6, r2
 8016f66:	d50f      	bpl.n	8016f88 <_svfiprintf_r+0x34>
 8016f68:	690b      	ldr	r3, [r1, #16]
 8016f6a:	b96b      	cbnz	r3, 8016f88 <_svfiprintf_r+0x34>
 8016f6c:	2140      	movs	r1, #64	; 0x40
 8016f6e:	f000 fac9 	bl	8017504 <_malloc_r>
 8016f72:	6028      	str	r0, [r5, #0]
 8016f74:	6128      	str	r0, [r5, #16]
 8016f76:	b928      	cbnz	r0, 8016f84 <_svfiprintf_r+0x30>
 8016f78:	230c      	movs	r3, #12
 8016f7a:	f8c8 3000 	str.w	r3, [r8]
 8016f7e:	f04f 30ff 	mov.w	r0, #4294967295
 8016f82:	e0c5      	b.n	8017110 <_svfiprintf_r+0x1bc>
 8016f84:	2340      	movs	r3, #64	; 0x40
 8016f86:	616b      	str	r3, [r5, #20]
 8016f88:	2300      	movs	r3, #0
 8016f8a:	9309      	str	r3, [sp, #36]	; 0x24
 8016f8c:	2320      	movs	r3, #32
 8016f8e:	f88d 3029 	strb.w	r3, [sp, #41]	; 0x29
 8016f92:	2330      	movs	r3, #48	; 0x30
 8016f94:	f88d 302a 	strb.w	r3, [sp, #42]	; 0x2a
 8016f98:	f04f 0b01 	mov.w	fp, #1
 8016f9c:	4637      	mov	r7, r6
 8016f9e:	463c      	mov	r4, r7
 8016fa0:	f814 3b01 	ldrb.w	r3, [r4], #1
 8016fa4:	2b00      	cmp	r3, #0
 8016fa6:	d13c      	bne.n	8017022 <_svfiprintf_r+0xce>
 8016fa8:	ebb7 0a06 	subs.w	sl, r7, r6
 8016fac:	d00b      	beq.n	8016fc6 <_svfiprintf_r+0x72>
 8016fae:	4653      	mov	r3, sl
 8016fb0:	4632      	mov	r2, r6
 8016fb2:	4629      	mov	r1, r5
 8016fb4:	4640      	mov	r0, r8
 8016fb6:	f7ff fef7 	bl	8016da8 <__ssputs_r>
 8016fba:	3001      	adds	r0, #1
 8016fbc:	f000 80a3 	beq.w	8017106 <_svfiprintf_r+0x1b2>
 8016fc0:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8016fc2:	4453      	add	r3, sl
 8016fc4:	9309      	str	r3, [sp, #36]	; 0x24
 8016fc6:	783b      	ldrb	r3, [r7, #0]
 8016fc8:	2b00      	cmp	r3, #0
 8016fca:	f000 809c 	beq.w	8017106 <_svfiprintf_r+0x1b2>
 8016fce:	2300      	movs	r3, #0
 8016fd0:	f04f 32ff 	mov.w	r2, #4294967295
 8016fd4:	9304      	str	r3, [sp, #16]
 8016fd6:	9307      	str	r3, [sp, #28]
 8016fd8:	9205      	str	r2, [sp, #20]
 8016fda:	9306      	str	r3, [sp, #24]
 8016fdc:	f88d 3053 	strb.w	r3, [sp, #83]	; 0x53
 8016fe0:	931a      	str	r3, [sp, #104]	; 0x68
 8016fe2:	2205      	movs	r2, #5
 8016fe4:	7821      	ldrb	r1, [r4, #0]
 8016fe6:	4850      	ldr	r0, [pc, #320]	; (8017128 <_svfiprintf_r+0x1d4>)
 8016fe8:	f7fe fb62 	bl	80156b0 <memchr>
 8016fec:	1c67      	adds	r7, r4, #1
 8016fee:	9b04      	ldr	r3, [sp, #16]
 8016ff0:	b9d8      	cbnz	r0, 801702a <_svfiprintf_r+0xd6>
 8016ff2:	06d9      	lsls	r1, r3, #27
 8016ff4:	bf44      	itt	mi
 8016ff6:	2220      	movmi	r2, #32
 8016ff8:	f88d 2053 	strbmi.w	r2, [sp, #83]	; 0x53
 8016ffc:	071a      	lsls	r2, r3, #28
 8016ffe:	bf44      	itt	mi
 8017000:	222b      	movmi	r2, #43	; 0x2b
 8017002:	f88d 2053 	strbmi.w	r2, [sp, #83]	; 0x53
 8017006:	7822      	ldrb	r2, [r4, #0]
 8017008:	2a2a      	cmp	r2, #42	; 0x2a
 801700a:	d016      	beq.n	801703a <_svfiprintf_r+0xe6>
 801700c:	9a07      	ldr	r2, [sp, #28]
 801700e:	2100      	movs	r1, #0
 8017010:	200a      	movs	r0, #10
 8017012:	4627      	mov	r7, r4
 8017014:	3401      	adds	r4, #1
 8017016:	783b      	ldrb	r3, [r7, #0]
 8017018:	3b30      	subs	r3, #48	; 0x30
 801701a:	2b09      	cmp	r3, #9
 801701c:	d951      	bls.n	80170c2 <_svfiprintf_r+0x16e>
 801701e:	b1c9      	cbz	r1, 8017054 <_svfiprintf_r+0x100>
 8017020:	e011      	b.n	8017046 <_svfiprintf_r+0xf2>
 8017022:	2b25      	cmp	r3, #37	; 0x25
 8017024:	d0c0      	beq.n	8016fa8 <_svfiprintf_r+0x54>
 8017026:	4627      	mov	r7, r4
 8017028:	e7b9      	b.n	8016f9e <_svfiprintf_r+0x4a>
 801702a:	4a3f      	ldr	r2, [pc, #252]	; (8017128 <_svfiprintf_r+0x1d4>)
 801702c:	1a80      	subs	r0, r0, r2
 801702e:	fa0b f000 	lsl.w	r0, fp, r0
 8017032:	4318      	orrs	r0, r3
 8017034:	9004      	str	r0, [sp, #16]
 8017036:	463c      	mov	r4, r7
 8017038:	e7d3      	b.n	8016fe2 <_svfiprintf_r+0x8e>
 801703a:	9a03      	ldr	r2, [sp, #12]
 801703c:	1d11      	adds	r1, r2, #4
 801703e:	6812      	ldr	r2, [r2, #0]
 8017040:	9103      	str	r1, [sp, #12]
 8017042:	2a00      	cmp	r2, #0
 8017044:	db01      	blt.n	801704a <_svfiprintf_r+0xf6>
 8017046:	9207      	str	r2, [sp, #28]
 8017048:	e004      	b.n	8017054 <_svfiprintf_r+0x100>
 801704a:	4252      	negs	r2, r2
 801704c:	f043 0302 	orr.w	r3, r3, #2
 8017050:	9207      	str	r2, [sp, #28]
 8017052:	9304      	str	r3, [sp, #16]
 8017054:	783b      	ldrb	r3, [r7, #0]
 8017056:	2b2e      	cmp	r3, #46	; 0x2e
 8017058:	d10e      	bne.n	8017078 <_svfiprintf_r+0x124>
 801705a:	787b      	ldrb	r3, [r7, #1]
 801705c:	2b2a      	cmp	r3, #42	; 0x2a
 801705e:	f107 0101 	add.w	r1, r7, #1
 8017062:	d132      	bne.n	80170ca <_svfiprintf_r+0x176>
 8017064:	9b03      	ldr	r3, [sp, #12]
 8017066:	1d1a      	adds	r2, r3, #4
 8017068:	681b      	ldr	r3, [r3, #0]
 801706a:	9203      	str	r2, [sp, #12]
 801706c:	2b00      	cmp	r3, #0
 801706e:	bfb8      	it	lt
 8017070:	f04f 33ff 	movlt.w	r3, #4294967295
 8017074:	3702      	adds	r7, #2
 8017076:	9305      	str	r3, [sp, #20]
 8017078:	4c2c      	ldr	r4, [pc, #176]	; (801712c <_svfiprintf_r+0x1d8>)
 801707a:	7839      	ldrb	r1, [r7, #0]
 801707c:	2203      	movs	r2, #3
 801707e:	4620      	mov	r0, r4
 8017080:	f7fe fb16 	bl	80156b0 <memchr>
 8017084:	b138      	cbz	r0, 8017096 <_svfiprintf_r+0x142>
 8017086:	2340      	movs	r3, #64	; 0x40
 8017088:	1b00      	subs	r0, r0, r4
 801708a:	fa03 f000 	lsl.w	r0, r3, r0
 801708e:	9b04      	ldr	r3, [sp, #16]
 8017090:	4303      	orrs	r3, r0
 8017092:	9304      	str	r3, [sp, #16]
 8017094:	3701      	adds	r7, #1
 8017096:	7839      	ldrb	r1, [r7, #0]
 8017098:	4825      	ldr	r0, [pc, #148]	; (8017130 <_svfiprintf_r+0x1dc>)
 801709a:	f88d 1028 	strb.w	r1, [sp, #40]	; 0x28
 801709e:	2206      	movs	r2, #6
 80170a0:	1c7e      	adds	r6, r7, #1
 80170a2:	f7fe fb05 	bl	80156b0 <memchr>
 80170a6:	2800      	cmp	r0, #0
 80170a8:	d035      	beq.n	8017116 <_svfiprintf_r+0x1c2>
 80170aa:	4b22      	ldr	r3, [pc, #136]	; (8017134 <_svfiprintf_r+0x1e0>)
 80170ac:	b9fb      	cbnz	r3, 80170ee <_svfiprintf_r+0x19a>
 80170ae:	9b03      	ldr	r3, [sp, #12]
 80170b0:	3307      	adds	r3, #7
 80170b2:	f023 0307 	bic.w	r3, r3, #7
 80170b6:	3308      	adds	r3, #8
 80170b8:	9303      	str	r3, [sp, #12]
 80170ba:	9b09      	ldr	r3, [sp, #36]	; 0x24
 80170bc:	444b      	add	r3, r9
 80170be:	9309      	str	r3, [sp, #36]	; 0x24
 80170c0:	e76c      	b.n	8016f9c <_svfiprintf_r+0x48>
 80170c2:	fb00 3202 	mla	r2, r0, r2, r3
 80170c6:	2101      	movs	r1, #1
 80170c8:	e7a3      	b.n	8017012 <_svfiprintf_r+0xbe>
 80170ca:	2300      	movs	r3, #0
 80170cc:	9305      	str	r3, [sp, #20]
 80170ce:	4618      	mov	r0, r3
 80170d0:	240a      	movs	r4, #10
 80170d2:	460f      	mov	r7, r1
 80170d4:	3101      	adds	r1, #1
 80170d6:	783a      	ldrb	r2, [r7, #0]
 80170d8:	3a30      	subs	r2, #48	; 0x30
 80170da:	2a09      	cmp	r2, #9
 80170dc:	d903      	bls.n	80170e6 <_svfiprintf_r+0x192>
 80170de:	2b00      	cmp	r3, #0
 80170e0:	d0ca      	beq.n	8017078 <_svfiprintf_r+0x124>
 80170e2:	9005      	str	r0, [sp, #20]
 80170e4:	e7c8      	b.n	8017078 <_svfiprintf_r+0x124>
 80170e6:	fb04 2000 	mla	r0, r4, r0, r2
 80170ea:	2301      	movs	r3, #1
 80170ec:	e7f1      	b.n	80170d2 <_svfiprintf_r+0x17e>
 80170ee:	ab03      	add	r3, sp, #12
 80170f0:	9300      	str	r3, [sp, #0]
 80170f2:	462a      	mov	r2, r5
 80170f4:	4b10      	ldr	r3, [pc, #64]	; (8017138 <_svfiprintf_r+0x1e4>)
 80170f6:	a904      	add	r1, sp, #16
 80170f8:	4640      	mov	r0, r8
 80170fa:	f3af 8000 	nop.w
 80170fe:	f1b0 3fff 	cmp.w	r0, #4294967295
 8017102:	4681      	mov	r9, r0
 8017104:	d1d9      	bne.n	80170ba <_svfiprintf_r+0x166>
 8017106:	89ab      	ldrh	r3, [r5, #12]
 8017108:	065b      	lsls	r3, r3, #25
 801710a:	f53f af38 	bmi.w	8016f7e <_svfiprintf_r+0x2a>
 801710e:	9809      	ldr	r0, [sp, #36]	; 0x24
 8017110:	b01d      	add	sp, #116	; 0x74
 8017112:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8017116:	ab03      	add	r3, sp, #12
 8017118:	9300      	str	r3, [sp, #0]
 801711a:	462a      	mov	r2, r5
 801711c:	4b06      	ldr	r3, [pc, #24]	; (8017138 <_svfiprintf_r+0x1e4>)
 801711e:	a904      	add	r1, sp, #16
 8017120:	4640      	mov	r0, r8
 8017122:	f000 f881 	bl	8017228 <_printf_i>
 8017126:	e7ea      	b.n	80170fe <_svfiprintf_r+0x1aa>
 8017128:	0806bc54 	.word	0x0806bc54
 801712c:	0806bc5a 	.word	0x0806bc5a
 8017130:	0806bc5e 	.word	0x0806bc5e
 8017134:	00000000 	.word	0x00000000
 8017138:	08016da9 	.word	0x08016da9

0801713c <_printf_common>:
 801713c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8017140:	4691      	mov	r9, r2
 8017142:	461f      	mov	r7, r3
 8017144:	688a      	ldr	r2, [r1, #8]
 8017146:	690b      	ldr	r3, [r1, #16]
 8017148:	f8dd 8020 	ldr.w	r8, [sp, #32]
 801714c:	4293      	cmp	r3, r2
 801714e:	bfb8      	it	lt
 8017150:	4613      	movlt	r3, r2
 8017152:	f8c9 3000 	str.w	r3, [r9]
 8017156:	f891 2043 	ldrb.w	r2, [r1, #67]	; 0x43
 801715a:	4606      	mov	r6, r0
 801715c:	460c      	mov	r4, r1
 801715e:	b112      	cbz	r2, 8017166 <_printf_common+0x2a>
 8017160:	3301      	adds	r3, #1
 8017162:	f8c9 3000 	str.w	r3, [r9]
 8017166:	6823      	ldr	r3, [r4, #0]
 8017168:	0699      	lsls	r1, r3, #26
 801716a:	bf42      	ittt	mi
 801716c:	f8d9 3000 	ldrmi.w	r3, [r9]
 8017170:	3302      	addmi	r3, #2
 8017172:	f8c9 3000 	strmi.w	r3, [r9]
 8017176:	6825      	ldr	r5, [r4, #0]
 8017178:	f015 0506 	ands.w	r5, r5, #6
 801717c:	d107      	bne.n	801718e <_printf_common+0x52>
 801717e:	f104 0a19 	add.w	sl, r4, #25
 8017182:	68e3      	ldr	r3, [r4, #12]
 8017184:	f8d9 2000 	ldr.w	r2, [r9]
 8017188:	1a9b      	subs	r3, r3, r2
 801718a:	429d      	cmp	r5, r3
 801718c:	db29      	blt.n	80171e2 <_printf_common+0xa6>
 801718e:	f894 3043 	ldrb.w	r3, [r4, #67]	; 0x43
 8017192:	6822      	ldr	r2, [r4, #0]
 8017194:	3300      	adds	r3, #0
 8017196:	bf18      	it	ne
 8017198:	2301      	movne	r3, #1
 801719a:	0692      	lsls	r2, r2, #26
 801719c:	d42e      	bmi.n	80171fc <_printf_common+0xc0>
 801719e:	f104 0243 	add.w	r2, r4, #67	; 0x43
 80171a2:	4639      	mov	r1, r7
 80171a4:	4630      	mov	r0, r6
 80171a6:	47c0      	blx	r8
 80171a8:	3001      	adds	r0, #1
 80171aa:	d021      	beq.n	80171f0 <_printf_common+0xb4>
 80171ac:	6823      	ldr	r3, [r4, #0]
 80171ae:	68e5      	ldr	r5, [r4, #12]
 80171b0:	f8d9 2000 	ldr.w	r2, [r9]
 80171b4:	f003 0306 	and.w	r3, r3, #6
 80171b8:	2b04      	cmp	r3, #4
 80171ba:	bf08      	it	eq
 80171bc:	1aad      	subeq	r5, r5, r2
 80171be:	68a3      	ldr	r3, [r4, #8]
 80171c0:	6922      	ldr	r2, [r4, #16]
 80171c2:	bf0c      	ite	eq
 80171c4:	ea25 75e5 	biceq.w	r5, r5, r5, asr #31
 80171c8:	2500      	movne	r5, #0
 80171ca:	4293      	cmp	r3, r2
 80171cc:	bfc4      	itt	gt
 80171ce:	1a9b      	subgt	r3, r3, r2
 80171d0:	18ed      	addgt	r5, r5, r3
 80171d2:	f04f 0900 	mov.w	r9, #0
 80171d6:	341a      	adds	r4, #26
 80171d8:	454d      	cmp	r5, r9
 80171da:	d11b      	bne.n	8017214 <_printf_common+0xd8>
 80171dc:	2000      	movs	r0, #0
 80171de:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 80171e2:	2301      	movs	r3, #1
 80171e4:	4652      	mov	r2, sl
 80171e6:	4639      	mov	r1, r7
 80171e8:	4630      	mov	r0, r6
 80171ea:	47c0      	blx	r8
 80171ec:	3001      	adds	r0, #1
 80171ee:	d103      	bne.n	80171f8 <_printf_common+0xbc>
 80171f0:	f04f 30ff 	mov.w	r0, #4294967295
 80171f4:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 80171f8:	3501      	adds	r5, #1
 80171fa:	e7c2      	b.n	8017182 <_printf_common+0x46>
 80171fc:	18e1      	adds	r1, r4, r3
 80171fe:	1c5a      	adds	r2, r3, #1
 8017200:	2030      	movs	r0, #48	; 0x30
 8017202:	f881 0043 	strb.w	r0, [r1, #67]	; 0x43
 8017206:	4422      	add	r2, r4
 8017208:	f894 1045 	ldrb.w	r1, [r4, #69]	; 0x45
 801720c:	f882 1043 	strb.w	r1, [r2, #67]	; 0x43
 8017210:	3302      	adds	r3, #2
 8017212:	e7c4      	b.n	801719e <_printf_common+0x62>
 8017214:	2301      	movs	r3, #1
 8017216:	4622      	mov	r2, r4
 8017218:	4639      	mov	r1, r7
 801721a:	4630      	mov	r0, r6
 801721c:	47c0      	blx	r8
 801721e:	3001      	adds	r0, #1
 8017220:	d0e6      	beq.n	80171f0 <_printf_common+0xb4>
 8017222:	f109 0901 	add.w	r9, r9, #1
 8017226:	e7d7      	b.n	80171d8 <_printf_common+0x9c>

08017228 <_printf_i>:
 8017228:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 801722c:	4617      	mov	r7, r2
 801722e:	7e0a      	ldrb	r2, [r1, #24]
 8017230:	b085      	sub	sp, #20
 8017232:	2a6e      	cmp	r2, #110	; 0x6e
 8017234:	4698      	mov	r8, r3
 8017236:	4606      	mov	r6, r0
 8017238:	460c      	mov	r4, r1
 801723a:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 801723c:	f101 0e43 	add.w	lr, r1, #67	; 0x43
 8017240:	f000 80bc 	beq.w	80173bc <_printf_i+0x194>
 8017244:	d81a      	bhi.n	801727c <_printf_i+0x54>
 8017246:	2a63      	cmp	r2, #99	; 0x63
 8017248:	d02e      	beq.n	80172a8 <_printf_i+0x80>
 801724a:	d80a      	bhi.n	8017262 <_printf_i+0x3a>
 801724c:	2a00      	cmp	r2, #0
 801724e:	f000 80c8 	beq.w	80173e2 <_printf_i+0x1ba>
 8017252:	2a58      	cmp	r2, #88	; 0x58
 8017254:	f000 808a 	beq.w	801736c <_printf_i+0x144>
 8017258:	f104 0542 	add.w	r5, r4, #66	; 0x42
 801725c:	f884 2042 	strb.w	r2, [r4, #66]	; 0x42
 8017260:	e02a      	b.n	80172b8 <_printf_i+0x90>
 8017262:	2a64      	cmp	r2, #100	; 0x64
 8017264:	d001      	beq.n	801726a <_printf_i+0x42>
 8017266:	2a69      	cmp	r2, #105	; 0x69
 8017268:	d1f6      	bne.n	8017258 <_printf_i+0x30>
 801726a:	6821      	ldr	r1, [r4, #0]
 801726c:	681a      	ldr	r2, [r3, #0]
 801726e:	f011 0f80 	tst.w	r1, #128	; 0x80
 8017272:	d023      	beq.n	80172bc <_printf_i+0x94>
 8017274:	1d11      	adds	r1, r2, #4
 8017276:	6019      	str	r1, [r3, #0]
 8017278:	6813      	ldr	r3, [r2, #0]
 801727a:	e027      	b.n	80172cc <_printf_i+0xa4>
 801727c:	2a73      	cmp	r2, #115	; 0x73
 801727e:	f000 80b4 	beq.w	80173ea <_printf_i+0x1c2>
 8017282:	d808      	bhi.n	8017296 <_printf_i+0x6e>
 8017284:	2a6f      	cmp	r2, #111	; 0x6f
 8017286:	d02a      	beq.n	80172de <_printf_i+0xb6>
 8017288:	2a70      	cmp	r2, #112	; 0x70
 801728a:	d1e5      	bne.n	8017258 <_printf_i+0x30>
 801728c:	680a      	ldr	r2, [r1, #0]
 801728e:	f042 0220 	orr.w	r2, r2, #32
 8017292:	600a      	str	r2, [r1, #0]
 8017294:	e003      	b.n	801729e <_printf_i+0x76>
 8017296:	2a75      	cmp	r2, #117	; 0x75
 8017298:	d021      	beq.n	80172de <_printf_i+0xb6>
 801729a:	2a78      	cmp	r2, #120	; 0x78
 801729c:	d1dc      	bne.n	8017258 <_printf_i+0x30>
 801729e:	2278      	movs	r2, #120	; 0x78
 80172a0:	f884 2045 	strb.w	r2, [r4, #69]	; 0x45
 80172a4:	496e      	ldr	r1, [pc, #440]	; (8017460 <_printf_i+0x238>)
 80172a6:	e064      	b.n	8017372 <_printf_i+0x14a>
 80172a8:	681a      	ldr	r2, [r3, #0]
 80172aa:	f101 0542 	add.w	r5, r1, #66	; 0x42
 80172ae:	1d11      	adds	r1, r2, #4
 80172b0:	6019      	str	r1, [r3, #0]
 80172b2:	6813      	ldr	r3, [r2, #0]
 80172b4:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
 80172b8:	2301      	movs	r3, #1
 80172ba:	e0a3      	b.n	8017404 <_printf_i+0x1dc>
 80172bc:	f011 0f40 	tst.w	r1, #64	; 0x40
 80172c0:	f102 0104 	add.w	r1, r2, #4
 80172c4:	6019      	str	r1, [r3, #0]
 80172c6:	d0d7      	beq.n	8017278 <_printf_i+0x50>
 80172c8:	f9b2 3000 	ldrsh.w	r3, [r2]
 80172cc:	2b00      	cmp	r3, #0
 80172ce:	da03      	bge.n	80172d8 <_printf_i+0xb0>
 80172d0:	222d      	movs	r2, #45	; 0x2d
 80172d2:	425b      	negs	r3, r3
 80172d4:	f884 2043 	strb.w	r2, [r4, #67]	; 0x43
 80172d8:	4962      	ldr	r1, [pc, #392]	; (8017464 <_printf_i+0x23c>)
 80172da:	220a      	movs	r2, #10
 80172dc:	e017      	b.n	801730e <_printf_i+0xe6>
 80172de:	6820      	ldr	r0, [r4, #0]
 80172e0:	6819      	ldr	r1, [r3, #0]
 80172e2:	f010 0f80 	tst.w	r0, #128	; 0x80
 80172e6:	d003      	beq.n	80172f0 <_printf_i+0xc8>
 80172e8:	1d08      	adds	r0, r1, #4
 80172ea:	6018      	str	r0, [r3, #0]
 80172ec:	680b      	ldr	r3, [r1, #0]
 80172ee:	e006      	b.n	80172fe <_printf_i+0xd6>
 80172f0:	f010 0f40 	tst.w	r0, #64	; 0x40
 80172f4:	f101 0004 	add.w	r0, r1, #4
 80172f8:	6018      	str	r0, [r3, #0]
 80172fa:	d0f7      	beq.n	80172ec <_printf_i+0xc4>
 80172fc:	880b      	ldrh	r3, [r1, #0]
 80172fe:	4959      	ldr	r1, [pc, #356]	; (8017464 <_printf_i+0x23c>)
 8017300:	2a6f      	cmp	r2, #111	; 0x6f
 8017302:	bf14      	ite	ne
 8017304:	220a      	movne	r2, #10
 8017306:	2208      	moveq	r2, #8
 8017308:	2000      	movs	r0, #0
 801730a:	f884 0043 	strb.w	r0, [r4, #67]	; 0x43
 801730e:	6865      	ldr	r5, [r4, #4]
 8017310:	60a5      	str	r5, [r4, #8]
 8017312:	2d00      	cmp	r5, #0
 8017314:	f2c0 809c 	blt.w	8017450 <_printf_i+0x228>
 8017318:	6820      	ldr	r0, [r4, #0]
 801731a:	f020 0004 	bic.w	r0, r0, #4
 801731e:	6020      	str	r0, [r4, #0]
 8017320:	2b00      	cmp	r3, #0
 8017322:	d13f      	bne.n	80173a4 <_printf_i+0x17c>
 8017324:	2d00      	cmp	r5, #0
 8017326:	f040 8095 	bne.w	8017454 <_printf_i+0x22c>
 801732a:	4675      	mov	r5, lr
 801732c:	2a08      	cmp	r2, #8
 801732e:	d10b      	bne.n	8017348 <_printf_i+0x120>
 8017330:	6823      	ldr	r3, [r4, #0]
 8017332:	07da      	lsls	r2, r3, #31
 8017334:	d508      	bpl.n	8017348 <_printf_i+0x120>
 8017336:	6923      	ldr	r3, [r4, #16]
 8017338:	6862      	ldr	r2, [r4, #4]
 801733a:	429a      	cmp	r2, r3
 801733c:	bfde      	ittt	le
 801733e:	2330      	movle	r3, #48	; 0x30
 8017340:	f805 3c01 	strble.w	r3, [r5, #-1]
 8017344:	f105 35ff 	addle.w	r5, r5, #4294967295
 8017348:	ebae 0305 	sub.w	r3, lr, r5
 801734c:	6123      	str	r3, [r4, #16]
 801734e:	f8cd 8000 	str.w	r8, [sp]
 8017352:	463b      	mov	r3, r7
 8017354:	aa03      	add	r2, sp, #12
 8017356:	4621      	mov	r1, r4
 8017358:	4630      	mov	r0, r6
 801735a:	f7ff feef 	bl	801713c <_printf_common>
 801735e:	3001      	adds	r0, #1
 8017360:	d155      	bne.n	801740e <_printf_i+0x1e6>
 8017362:	f04f 30ff 	mov.w	r0, #4294967295
 8017366:	b005      	add	sp, #20
 8017368:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 801736c:	f881 2045 	strb.w	r2, [r1, #69]	; 0x45
 8017370:	493c      	ldr	r1, [pc, #240]	; (8017464 <_printf_i+0x23c>)
 8017372:	6822      	ldr	r2, [r4, #0]
 8017374:	6818      	ldr	r0, [r3, #0]
 8017376:	f012 0f80 	tst.w	r2, #128	; 0x80
 801737a:	f100 0504 	add.w	r5, r0, #4
 801737e:	601d      	str	r5, [r3, #0]
 8017380:	d001      	beq.n	8017386 <_printf_i+0x15e>
 8017382:	6803      	ldr	r3, [r0, #0]
 8017384:	e002      	b.n	801738c <_printf_i+0x164>
 8017386:	0655      	lsls	r5, r2, #25
 8017388:	d5fb      	bpl.n	8017382 <_printf_i+0x15a>
 801738a:	8803      	ldrh	r3, [r0, #0]
 801738c:	07d0      	lsls	r0, r2, #31
 801738e:	bf44      	itt	mi
 8017390:	f042 0220 	orrmi.w	r2, r2, #32
 8017394:	6022      	strmi	r2, [r4, #0]
 8017396:	b91b      	cbnz	r3, 80173a0 <_printf_i+0x178>
 8017398:	6822      	ldr	r2, [r4, #0]
 801739a:	f022 0220 	bic.w	r2, r2, #32
 801739e:	6022      	str	r2, [r4, #0]
 80173a0:	2210      	movs	r2, #16
 80173a2:	e7b1      	b.n	8017308 <_printf_i+0xe0>
 80173a4:	4675      	mov	r5, lr
 80173a6:	fbb3 f0f2 	udiv	r0, r3, r2
 80173aa:	fb02 3310 	mls	r3, r2, r0, r3
 80173ae:	5ccb      	ldrb	r3, [r1, r3]
 80173b0:	f805 3d01 	strb.w	r3, [r5, #-1]!
 80173b4:	4603      	mov	r3, r0
 80173b6:	2800      	cmp	r0, #0
 80173b8:	d1f5      	bne.n	80173a6 <_printf_i+0x17e>
 80173ba:	e7b7      	b.n	801732c <_printf_i+0x104>
 80173bc:	6808      	ldr	r0, [r1, #0]
 80173be:	681a      	ldr	r2, [r3, #0]
 80173c0:	6949      	ldr	r1, [r1, #20]
 80173c2:	f010 0f80 	tst.w	r0, #128	; 0x80
 80173c6:	d004      	beq.n	80173d2 <_printf_i+0x1aa>
 80173c8:	1d10      	adds	r0, r2, #4
 80173ca:	6018      	str	r0, [r3, #0]
 80173cc:	6813      	ldr	r3, [r2, #0]
 80173ce:	6019      	str	r1, [r3, #0]
 80173d0:	e007      	b.n	80173e2 <_printf_i+0x1ba>
 80173d2:	f010 0f40 	tst.w	r0, #64	; 0x40
 80173d6:	f102 0004 	add.w	r0, r2, #4
 80173da:	6018      	str	r0, [r3, #0]
 80173dc:	6813      	ldr	r3, [r2, #0]
 80173de:	d0f6      	beq.n	80173ce <_printf_i+0x1a6>
 80173e0:	8019      	strh	r1, [r3, #0]
 80173e2:	2300      	movs	r3, #0
 80173e4:	6123      	str	r3, [r4, #16]
 80173e6:	4675      	mov	r5, lr
 80173e8:	e7b1      	b.n	801734e <_printf_i+0x126>
 80173ea:	681a      	ldr	r2, [r3, #0]
 80173ec:	1d11      	adds	r1, r2, #4
 80173ee:	6019      	str	r1, [r3, #0]
 80173f0:	6815      	ldr	r5, [r2, #0]
 80173f2:	6862      	ldr	r2, [r4, #4]
 80173f4:	2100      	movs	r1, #0
 80173f6:	4628      	mov	r0, r5
 80173f8:	f7fe f95a 	bl	80156b0 <memchr>
 80173fc:	b108      	cbz	r0, 8017402 <_printf_i+0x1da>
 80173fe:	1b40      	subs	r0, r0, r5
 8017400:	6060      	str	r0, [r4, #4]
 8017402:	6863      	ldr	r3, [r4, #4]
 8017404:	6123      	str	r3, [r4, #16]
 8017406:	2300      	movs	r3, #0
 8017408:	f884 3043 	strb.w	r3, [r4, #67]	; 0x43
 801740c:	e79f      	b.n	801734e <_printf_i+0x126>
 801740e:	6923      	ldr	r3, [r4, #16]
 8017410:	462a      	mov	r2, r5
 8017412:	4639      	mov	r1, r7
 8017414:	4630      	mov	r0, r6
 8017416:	47c0      	blx	r8
 8017418:	3001      	adds	r0, #1
 801741a:	d0a2      	beq.n	8017362 <_printf_i+0x13a>
 801741c:	6823      	ldr	r3, [r4, #0]
 801741e:	079b      	lsls	r3, r3, #30
 8017420:	d507      	bpl.n	8017432 <_printf_i+0x20a>
 8017422:	2500      	movs	r5, #0
 8017424:	f104 0919 	add.w	r9, r4, #25
 8017428:	68e3      	ldr	r3, [r4, #12]
 801742a:	9a03      	ldr	r2, [sp, #12]
 801742c:	1a9b      	subs	r3, r3, r2
 801742e:	429d      	cmp	r5, r3
 8017430:	db05      	blt.n	801743e <_printf_i+0x216>
 8017432:	68e0      	ldr	r0, [r4, #12]
 8017434:	9b03      	ldr	r3, [sp, #12]
 8017436:	4298      	cmp	r0, r3
 8017438:	bfb8      	it	lt
 801743a:	4618      	movlt	r0, r3
 801743c:	e793      	b.n	8017366 <_printf_i+0x13e>
 801743e:	2301      	movs	r3, #1
 8017440:	464a      	mov	r2, r9
 8017442:	4639      	mov	r1, r7
 8017444:	4630      	mov	r0, r6
 8017446:	47c0      	blx	r8
 8017448:	3001      	adds	r0, #1
 801744a:	d08a      	beq.n	8017362 <_printf_i+0x13a>
 801744c:	3501      	adds	r5, #1
 801744e:	e7eb      	b.n	8017428 <_printf_i+0x200>
 8017450:	2b00      	cmp	r3, #0
 8017452:	d1a7      	bne.n	80173a4 <_printf_i+0x17c>
 8017454:	780b      	ldrb	r3, [r1, #0]
 8017456:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
 801745a:	f104 0542 	add.w	r5, r4, #66	; 0x42
 801745e:	e765      	b.n	801732c <_printf_i+0x104>
 8017460:	0806bc76 	.word	0x0806bc76
 8017464:	0806bc65 	.word	0x0806bc65

08017468 <_free_r>:
 8017468:	b538      	push	{r3, r4, r5, lr}
 801746a:	4605      	mov	r5, r0
 801746c:	2900      	cmp	r1, #0
 801746e:	d045      	beq.n	80174fc <_free_r+0x94>
 8017470:	f851 3c04 	ldr.w	r3, [r1, #-4]
 8017474:	1f0c      	subs	r4, r1, #4
 8017476:	2b00      	cmp	r3, #0
 8017478:	bfb8      	it	lt
 801747a:	18e4      	addlt	r4, r4, r3
 801747c:	f000 f8c6 	bl	801760c <__malloc_lock>
 8017480:	4a1f      	ldr	r2, [pc, #124]	; (8017500 <_free_r+0x98>)
 8017482:	6813      	ldr	r3, [r2, #0]
 8017484:	4610      	mov	r0, r2
 8017486:	b933      	cbnz	r3, 8017496 <_free_r+0x2e>
 8017488:	6063      	str	r3, [r4, #4]
 801748a:	6014      	str	r4, [r2, #0]
 801748c:	4628      	mov	r0, r5
 801748e:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
 8017492:	f000 b8bc 	b.w	801760e <__malloc_unlock>
 8017496:	42a3      	cmp	r3, r4
 8017498:	d90c      	bls.n	80174b4 <_free_r+0x4c>
 801749a:	6821      	ldr	r1, [r4, #0]
 801749c:	1862      	adds	r2, r4, r1
 801749e:	4293      	cmp	r3, r2
 80174a0:	bf04      	itt	eq
 80174a2:	681a      	ldreq	r2, [r3, #0]
 80174a4:	685b      	ldreq	r3, [r3, #4]
 80174a6:	6063      	str	r3, [r4, #4]
 80174a8:	bf04      	itt	eq
 80174aa:	1852      	addeq	r2, r2, r1
 80174ac:	6022      	streq	r2, [r4, #0]
 80174ae:	6004      	str	r4, [r0, #0]
 80174b0:	e7ec      	b.n	801748c <_free_r+0x24>
 80174b2:	4613      	mov	r3, r2
 80174b4:	685a      	ldr	r2, [r3, #4]
 80174b6:	b10a      	cbz	r2, 80174bc <_free_r+0x54>
 80174b8:	42a2      	cmp	r2, r4
 80174ba:	d9fa      	bls.n	80174b2 <_free_r+0x4a>
 80174bc:	6819      	ldr	r1, [r3, #0]
 80174be:	1858      	adds	r0, r3, r1
 80174c0:	42a0      	cmp	r0, r4
 80174c2:	d10b      	bne.n	80174dc <_free_r+0x74>
 80174c4:	6820      	ldr	r0, [r4, #0]
 80174c6:	4401      	add	r1, r0
 80174c8:	1858      	adds	r0, r3, r1
 80174ca:	4282      	cmp	r2, r0
 80174cc:	6019      	str	r1, [r3, #0]
 80174ce:	d1dd      	bne.n	801748c <_free_r+0x24>
 80174d0:	6810      	ldr	r0, [r2, #0]
 80174d2:	6852      	ldr	r2, [r2, #4]
 80174d4:	605a      	str	r2, [r3, #4]
 80174d6:	4401      	add	r1, r0
 80174d8:	6019      	str	r1, [r3, #0]
 80174da:	e7d7      	b.n	801748c <_free_r+0x24>
 80174dc:	d902      	bls.n	80174e4 <_free_r+0x7c>
 80174de:	230c      	movs	r3, #12
 80174e0:	602b      	str	r3, [r5, #0]
 80174e2:	e7d3      	b.n	801748c <_free_r+0x24>
 80174e4:	6820      	ldr	r0, [r4, #0]
 80174e6:	1821      	adds	r1, r4, r0
 80174e8:	428a      	cmp	r2, r1
 80174ea:	bf04      	itt	eq
 80174ec:	6811      	ldreq	r1, [r2, #0]
 80174ee:	6852      	ldreq	r2, [r2, #4]
 80174f0:	6062      	str	r2, [r4, #4]
 80174f2:	bf04      	itt	eq
 80174f4:	1809      	addeq	r1, r1, r0
 80174f6:	6021      	streq	r1, [r4, #0]
 80174f8:	605c      	str	r4, [r3, #4]
 80174fa:	e7c7      	b.n	801748c <_free_r+0x24>
 80174fc:	bd38      	pop	{r3, r4, r5, pc}
 80174fe:	bf00      	nop
 8017500:	20009e3c 	.word	0x20009e3c

08017504 <_malloc_r>:
 8017504:	b570      	push	{r4, r5, r6, lr}
 8017506:	1ccd      	adds	r5, r1, #3
 8017508:	f025 0503 	bic.w	r5, r5, #3
 801750c:	3508      	adds	r5, #8
 801750e:	2d0c      	cmp	r5, #12
 8017510:	bf38      	it	cc
 8017512:	250c      	movcc	r5, #12
 8017514:	2d00      	cmp	r5, #0
 8017516:	4606      	mov	r6, r0
 8017518:	db01      	blt.n	801751e <_malloc_r+0x1a>
 801751a:	42a9      	cmp	r1, r5
 801751c:	d903      	bls.n	8017526 <_malloc_r+0x22>
 801751e:	230c      	movs	r3, #12
 8017520:	6033      	str	r3, [r6, #0]
 8017522:	2000      	movs	r0, #0
 8017524:	bd70      	pop	{r4, r5, r6, pc}
 8017526:	f000 f871 	bl	801760c <__malloc_lock>
 801752a:	4a23      	ldr	r2, [pc, #140]	; (80175b8 <_malloc_r+0xb4>)
 801752c:	6814      	ldr	r4, [r2, #0]
 801752e:	4621      	mov	r1, r4
 8017530:	b991      	cbnz	r1, 8017558 <_malloc_r+0x54>
 8017532:	4c22      	ldr	r4, [pc, #136]	; (80175bc <_malloc_r+0xb8>)
 8017534:	6823      	ldr	r3, [r4, #0]
 8017536:	b91b      	cbnz	r3, 8017540 <_malloc_r+0x3c>
 8017538:	4630      	mov	r0, r6
 801753a:	f7fd fedb 	bl	80152f4 <_sbrk_r>
 801753e:	6020      	str	r0, [r4, #0]
 8017540:	4629      	mov	r1, r5
 8017542:	4630      	mov	r0, r6
 8017544:	f7fd fed6 	bl	80152f4 <_sbrk_r>
 8017548:	1c43      	adds	r3, r0, #1
 801754a:	d126      	bne.n	801759a <_malloc_r+0x96>
 801754c:	230c      	movs	r3, #12
 801754e:	6033      	str	r3, [r6, #0]
 8017550:	4630      	mov	r0, r6
 8017552:	f000 f85c 	bl	801760e <__malloc_unlock>
 8017556:	e7e4      	b.n	8017522 <_malloc_r+0x1e>
 8017558:	680b      	ldr	r3, [r1, #0]
 801755a:	1b5b      	subs	r3, r3, r5
 801755c:	d41a      	bmi.n	8017594 <_malloc_r+0x90>
 801755e:	2b0b      	cmp	r3, #11
 8017560:	d90f      	bls.n	8017582 <_malloc_r+0x7e>
 8017562:	600b      	str	r3, [r1, #0]
 8017564:	50cd      	str	r5, [r1, r3]
 8017566:	18cc      	adds	r4, r1, r3
 8017568:	4630      	mov	r0, r6
 801756a:	f000 f850 	bl	801760e <__malloc_unlock>
 801756e:	f104 000b 	add.w	r0, r4, #11
 8017572:	1d23      	adds	r3, r4, #4
 8017574:	f020 0007 	bic.w	r0, r0, #7
 8017578:	1ac3      	subs	r3, r0, r3
 801757a:	d01b      	beq.n	80175b4 <_malloc_r+0xb0>
 801757c:	425a      	negs	r2, r3
 801757e:	50e2      	str	r2, [r4, r3]
 8017580:	bd70      	pop	{r4, r5, r6, pc}
 8017582:	428c      	cmp	r4, r1
 8017584:	bf0d      	iteet	eq
 8017586:	6863      	ldreq	r3, [r4, #4]
 8017588:	684b      	ldrne	r3, [r1, #4]
 801758a:	6063      	strne	r3, [r4, #4]
 801758c:	6013      	streq	r3, [r2, #0]
 801758e:	bf18      	it	ne
 8017590:	460c      	movne	r4, r1
 8017592:	e7e9      	b.n	8017568 <_malloc_r+0x64>
 8017594:	460c      	mov	r4, r1
 8017596:	6849      	ldr	r1, [r1, #4]
 8017598:	e7ca      	b.n	8017530 <_malloc_r+0x2c>
 801759a:	1cc4      	adds	r4, r0, #3
 801759c:	f024 0403 	bic.w	r4, r4, #3
 80175a0:	42a0      	cmp	r0, r4
 80175a2:	d005      	beq.n	80175b0 <_malloc_r+0xac>
 80175a4:	1a21      	subs	r1, r4, r0
 80175a6:	4630      	mov	r0, r6
 80175a8:	f7fd fea4 	bl	80152f4 <_sbrk_r>
 80175ac:	3001      	adds	r0, #1
 80175ae:	d0cd      	beq.n	801754c <_malloc_r+0x48>
 80175b0:	6025      	str	r5, [r4, #0]
 80175b2:	e7d9      	b.n	8017568 <_malloc_r+0x64>
 80175b4:	bd70      	pop	{r4, r5, r6, pc}
 80175b6:	bf00      	nop
 80175b8:	20009e3c 	.word	0x20009e3c
 80175bc:	20009e40 	.word	0x20009e40

080175c0 <_realloc_r>:
 80175c0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80175c2:	4607      	mov	r7, r0
 80175c4:	4614      	mov	r4, r2
 80175c6:	460e      	mov	r6, r1
 80175c8:	b921      	cbnz	r1, 80175d4 <_realloc_r+0x14>
 80175ca:	4611      	mov	r1, r2
 80175cc:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
 80175d0:	f7ff bf98 	b.w	8017504 <_malloc_r>
 80175d4:	b922      	cbnz	r2, 80175e0 <_realloc_r+0x20>
 80175d6:	f7ff ff47 	bl	8017468 <_free_r>
 80175da:	4625      	mov	r5, r4
 80175dc:	4628      	mov	r0, r5
 80175de:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 80175e0:	f000 f816 	bl	8017610 <_malloc_usable_size_r>
 80175e4:	4284      	cmp	r4, r0
 80175e6:	d90f      	bls.n	8017608 <_realloc_r+0x48>
 80175e8:	4621      	mov	r1, r4
 80175ea:	4638      	mov	r0, r7
 80175ec:	f7ff ff8a 	bl	8017504 <_malloc_r>
 80175f0:	4605      	mov	r5, r0
 80175f2:	2800      	cmp	r0, #0
 80175f4:	d0f2      	beq.n	80175dc <_realloc_r+0x1c>
 80175f6:	4631      	mov	r1, r6
 80175f8:	4622      	mov	r2, r4
 80175fa:	f7ff fb6b 	bl	8016cd4 <memcpy>
 80175fe:	4631      	mov	r1, r6
 8017600:	4638      	mov	r0, r7
 8017602:	f7ff ff31 	bl	8017468 <_free_r>
 8017606:	e7e9      	b.n	80175dc <_realloc_r+0x1c>
 8017608:	4635      	mov	r5, r6
 801760a:	e7e7      	b.n	80175dc <_realloc_r+0x1c>

0801760c <__malloc_lock>:
 801760c:	4770      	bx	lr

0801760e <__malloc_unlock>:
 801760e:	4770      	bx	lr

08017610 <_malloc_usable_size_r>:
 8017610:	f851 0c04 	ldr.w	r0, [r1, #-4]
 8017614:	2800      	cmp	r0, #0
 8017616:	f1a0 0004 	sub.w	r0, r0, #4
 801761a:	bfbc      	itt	lt
 801761c:	580b      	ldrlt	r3, [r1, r0]
 801761e:	18c0      	addlt	r0, r0, r3
 8017620:	4770      	bx	lr
	...

08017624 <__EH_FRAME_BEGIN__>:
 8017624:	0000 0000                                   ....

08017628 <_init>:
 8017628:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 801762a:	bf00      	nop
 801762c:	bcf8      	pop	{r3, r4, r5, r6, r7}
 801762e:	bc08      	pop	{r3}
 8017630:	469e      	mov	lr, r3
 8017632:	4770      	bx	lr

08017634 <_fini>:
 8017634:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8017636:	bf00      	nop
 8017638:	bcf8      	pop	{r3, r4, r5, r6, r7}
 801763a:	bc08      	pop	{r3}
 801763c:	469e      	mov	lr, r3
 801763e:	4770      	bx	lr

08017640 <____errno_veneer>:
 8017640:	f85f f000 	ldr.w	pc, [pc]	; 8017644 <____errno_veneer+0x4>
 8017644:	20009e6d 	.word	0x20009e6d
